/*! For license information please see main.05eba9bf.js.LICENSE.txt */
(()=>{var t={2028:(t,e,n)=>{"use strict";var r=n(2),a=n(1712),s=a(r("String.prototype.indexOf"));t.exports=function(t,e){var n=r(t,!!e);return"function"===typeof n&&s(t,".prototype.")>-1?a(n):n}},1712:(t,e,n)=>{"use strict";var r=n(3864),a=n(2),s=n(5438),o=n(4902),i=a("%Function.prototype.apply%"),l=a("%Function.prototype.call%"),c=a("%Reflect.apply%",!0)||r.call(l,i),u=n(2090),h=a("%Math.max%");t.exports=function(t){if("function"!==typeof t)throw new o("a function is required");var e=c(r,l,arguments);return s(e,1+h(0,t.length-(arguments.length-1)),!0)};var d=function(){return c(r,i,arguments)};u?u(t.exports,"apply",{value:d}):t.exports.apply=d},4992:(t,e,n)=>{"use strict";var r=n(2090),a=n(2557),s=n(4902),o=n(5558);t.exports=function(t,e,n){if(!t||"object"!==typeof t&&"function"!==typeof t)throw new s("`obj` must be an object or a function`");if("string"!==typeof e&&"symbol"!==typeof e)throw new s("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!==typeof arguments[3]&&null!==arguments[3])throw new s("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!==typeof arguments[4]&&null!==arguments[4])throw new s("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!==typeof arguments[5]&&null!==arguments[5])throw new s("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!==typeof arguments[6])throw new s("`loose`, if provided, must be a boolean");var i=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,u=arguments.length>6&&arguments[6],h=!!o&&o(t,e);if(r)r(t,e,{configurable:null===c&&h?h.configurable:!c,enumerable:null===i&&h?h.enumerable:!i,value:n,writable:null===l&&h?h.writable:!l});else{if(!u&&(i||l||c))throw new a("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");t[e]=n}}},2090:(t,e,n)=>{"use strict";var r=n(2)("%Object.defineProperty%",!0)||!1;if(r)try{r({},"a",{value:1})}catch(a){r=!1}t.exports=r},9820:t=>{"use strict";t.exports=EvalError},9304:t=>{"use strict";t.exports=Error},1725:t=>{"use strict";t.exports=RangeError},5077:t=>{"use strict";t.exports=ReferenceError},2557:t=>{"use strict";t.exports=SyntaxError},4902:t=>{"use strict";t.exports=TypeError},3094:t=>{"use strict";t.exports=URIError},1903:(t,e,n)=>{"use strict";var r=n(8799),a=Object.prototype.toString,s=Object.prototype.hasOwnProperty;t.exports=function(t,e,n){if(!r(e))throw new TypeError("iterator must be a function");var o;arguments.length>=3&&(o=n),"[object Array]"===a.call(t)?function(t,e,n){for(var r=0,a=t.length;r<a;r++)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o):"string"===typeof t?function(t,e,n){for(var r=0,a=t.length;r<a;r++)null==n?e(t.charAt(r),r,t):e.call(n,t.charAt(r),r,t)}(t,e,o):function(t,e,n){for(var r in t)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o)}},7724:t=>{"use strict";var e=Object.prototype.toString,n=Math.max,r=function(t,e){for(var n=[],r=0;r<t.length;r+=1)n[r]=t[r];for(var a=0;a<e.length;a+=1)n[a+t.length]=e[a];return n};t.exports=function(t){var a=this;if("function"!==typeof a||"[object Function]"!==e.apply(a))throw new TypeError("Function.prototype.bind called on incompatible "+a);for(var s,o=function(t,e){for(var n=[],r=e||0,a=0;r<t.length;r+=1,a+=1)n[a]=t[r];return n}(arguments,1),i=n(0,a.length-o.length),l=[],c=0;c<i;c++)l[c]="$"+c;if(s=Function("binder","return function ("+function(t,e){for(var n="",r=0;r<t.length;r+=1)n+=t[r],r+1<t.length&&(n+=e);return n}(l,",")+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof s){var e=a.apply(this,r(o,arguments));return Object(e)===e?e:this}return a.apply(t,r(o,arguments))})),a.prototype){var u=function(){};u.prototype=a.prototype,s.prototype=new u,u.prototype=null}return s}},3864:(t,e,n)=>{"use strict";var r=n(7724);t.exports=Function.prototype.bind||r},2:(t,e,n)=>{"use strict";var r,a=n(9304),s=n(9820),o=n(1725),i=n(5077),l=n(2557),c=n(4902),u=n(3094),h=Function,d=function(t){try{return h('"use strict"; return ('+t+").constructor;")()}catch(e){}},p=Object.getOwnPropertyDescriptor;if(p)try{p({},"")}catch(z){p=null}var f=function(){throw new c},g=p?function(){try{return f}catch(t){try{return p(arguments,"callee").get}catch(e){return f}}}():f,m=n(2108)(),b=n(951)(),y=Object.getPrototypeOf||(b?function(t){return t.__proto__}:null),v={},w="undefined"!==typeof Uint8Array&&y?y(Uint8Array):r,x={__proto__:null,"%AggregateError%":"undefined"===typeof AggregateError?r:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"===typeof ArrayBuffer?r:ArrayBuffer,"%ArrayIteratorPrototype%":m&&y?y([][Symbol.iterator]()):r,"%AsyncFromSyncIteratorPrototype%":r,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"===typeof Atomics?r:Atomics,"%BigInt%":"undefined"===typeof BigInt?r:BigInt,"%BigInt64Array%":"undefined"===typeof BigInt64Array?r:BigInt64Array,"%BigUint64Array%":"undefined"===typeof BigUint64Array?r:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"===typeof DataView?r:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":a,"%eval%":eval,"%EvalError%":s,"%Float32Array%":"undefined"===typeof Float32Array?r:Float32Array,"%Float64Array%":"undefined"===typeof Float64Array?r:Float64Array,"%FinalizationRegistry%":"undefined"===typeof FinalizationRegistry?r:FinalizationRegistry,"%Function%":h,"%GeneratorFunction%":v,"%Int8Array%":"undefined"===typeof Int8Array?r:Int8Array,"%Int16Array%":"undefined"===typeof Int16Array?r:Int16Array,"%Int32Array%":"undefined"===typeof Int32Array?r:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":m&&y?y(y([][Symbol.iterator]())):r,"%JSON%":"object"===typeof JSON?JSON:r,"%Map%":"undefined"===typeof Map?r:Map,"%MapIteratorPrototype%":"undefined"!==typeof Map&&m&&y?y((new Map)[Symbol.iterator]()):r,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"===typeof Promise?r:Promise,"%Proxy%":"undefined"===typeof Proxy?r:Proxy,"%RangeError%":o,"%ReferenceError%":i,"%Reflect%":"undefined"===typeof Reflect?r:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"===typeof Set?r:Set,"%SetIteratorPrototype%":"undefined"!==typeof Set&&m&&y?y((new Set)[Symbol.iterator]()):r,"%SharedArrayBuffer%":"undefined"===typeof SharedArrayBuffer?r:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":m&&y?y(""[Symbol.iterator]()):r,"%Symbol%":m?Symbol:r,"%SyntaxError%":l,"%ThrowTypeError%":g,"%TypedArray%":w,"%TypeError%":c,"%Uint8Array%":"undefined"===typeof Uint8Array?r:Uint8Array,"%Uint8ClampedArray%":"undefined"===typeof Uint8ClampedArray?r:Uint8ClampedArray,"%Uint16Array%":"undefined"===typeof Uint16Array?r:Uint16Array,"%Uint32Array%":"undefined"===typeof Uint32Array?r:Uint32Array,"%URIError%":u,"%WeakMap%":"undefined"===typeof WeakMap?r:WeakMap,"%WeakRef%":"undefined"===typeof WeakRef?r:WeakRef,"%WeakSet%":"undefined"===typeof WeakSet?r:WeakSet};if(y)try{null.error}catch(z){var k=y(y(z));x["%Error.prototype%"]=k}var S=function t(e){var n;if("%AsyncFunction%"===e)n=d("async function () {}");else if("%GeneratorFunction%"===e)n=d("function* () {}");else if("%AsyncGeneratorFunction%"===e)n=d("async function* () {}");else if("%AsyncGenerator%"===e){var r=t("%AsyncGeneratorFunction%");r&&(n=r.prototype)}else if("%AsyncIteratorPrototype%"===e){var a=t("%AsyncGenerator%");a&&y&&(n=y(a.prototype))}return x[e]=n,n},I={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},N=n(3864),E=n(4384),C=N.call(Function.call,Array.prototype.concat),T=N.call(Function.apply,Array.prototype.splice),A=N.call(Function.call,String.prototype.replace),R=N.call(Function.call,String.prototype.slice),F=N.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,D=/\\(\\)?/g,O=function(t,e){var n,r=t;if(E(I,r)&&(r="%"+(n=I[r])[0]+"%"),E(x,r)){var a=x[r];if(a===v&&(a=S(r)),"undefined"===typeof a&&!e)throw new c("intrinsic "+t+" exists, but is not available. Please file an issue!");return{alias:n,name:r,value:a}}throw new l("intrinsic "+t+" does not exist!")};t.exports=function(t,e){if("string"!==typeof t||0===t.length)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!==typeof e)throw new c('"allowMissing" argument must be a boolean');if(null===F(/^%?[^%]*%?$/,t))throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var n=function(t){var e=R(t,0,1),n=R(t,-1);if("%"===e&&"%"!==n)throw new l("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==e)throw new l("invalid intrinsic syntax, expected opening `%`");var r=[];return A(t,_,(function(t,e,n,a){r[r.length]=n?A(a,D,"$1"):e||t})),r}(t),r=n.length>0?n[0]:"",a=O("%"+r+"%",e),s=a.name,o=a.value,i=!1,u=a.alias;u&&(r=u[0],T(n,C([0,1],u)));for(var h=1,d=!0;h<n.length;h+=1){var f=n[h],g=R(f,0,1),m=R(f,-1);if(('"'===g||"'"===g||"`"===g||'"'===m||"'"===m||"`"===m)&&g!==m)throw new l("property names with quotes must have matching quotes");if("constructor"!==f&&d||(i=!0),E(x,s="%"+(r+="."+f)+"%"))o=x[s];else if(null!=o){if(!(f in o)){if(!e)throw new c("base intrinsic for "+t+" exists, but the property is not available.");return}if(p&&h+1>=n.length){var b=p(o,f);o=(d=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:o[f]}else d=E(o,f),o=o[f];d&&!i&&(x[s]=o)}}return o}},5558:(t,e,n)=>{"use strict";var r=n(2)("%Object.getOwnPropertyDescriptor%",!0);if(r)try{r([],"length")}catch(a){r=null}t.exports=r},2101:(t,e,n)=>{"use strict";var r=n(2090),a=function(){return!!r};a.hasArrayLengthDefineBug=function(){if(!r)return null;try{return 1!==r([],"length",{value:1}).length}catch(t){return!0}},t.exports=a},951:t=>{"use strict";var e={__proto__:null,foo:{}},n=Object;t.exports=function(){return{__proto__:e}.foo===e.foo&&!(e instanceof n)}},2108:(t,e,n)=>{"use strict";var r="undefined"!==typeof Symbol&&Symbol,a=n(9534);t.exports=function(){return"function"===typeof r&&("function"===typeof Symbol&&("symbol"===typeof r("foo")&&("symbol"===typeof Symbol("bar")&&a())))}},9534:t=>{"use strict";t.exports=function(){if("function"!==typeof Symbol||"function"!==typeof Object.getOwnPropertySymbols)return!1;if("symbol"===typeof Symbol.iterator)return!0;var t={},e=Symbol("test"),n=Object(e);if("string"===typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(e in t[e]=42,t)return!1;if("function"===typeof Object.keys&&0!==Object.keys(t).length)return!1;if("function"===typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(t).length)return!1;var r=Object.getOwnPropertySymbols(t);if(1!==r.length||r[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(t,e))return!1;if("function"===typeof Object.getOwnPropertyDescriptor){var a=Object.getOwnPropertyDescriptor(t,e);if(42!==a.value||!0!==a.enumerable)return!1}return!0}},4635:(t,e,n)=>{"use strict";var r=n(9534);t.exports=function(){return r()&&!!Symbol.toStringTag}},4384:(t,e,n)=>{"use strict";var r=Function.prototype.call,a=Object.prototype.hasOwnProperty,s=n(3864);t.exports=s.call(r,a)},6329:t=>{"function"===typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}}},8317:(t,e,n)=>{"use strict";var r=n(4635)(),a=n(2028)("Object.prototype.toString"),s=function(t){return!(r&&t&&"object"===typeof t&&Symbol.toStringTag in t)&&"[object Arguments]"===a(t)},o=function(t){return!!s(t)||null!==t&&"object"===typeof t&&"number"===typeof t.length&&t.length>=0&&"[object Array]"!==a(t)&&"[object Function]"===a(t.callee)},i=function(){return s(arguments)}();s.isLegacyArguments=o,t.exports=i?s:o},8799:t=>{"use strict";var e,n,r=Function.prototype.toString,a="object"===typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"===typeof a&&"function"===typeof Object.defineProperty)try{e=Object.defineProperty({},"length",{get:function(){throw n}}),n={},a((function(){throw 42}),null,e)}catch(p){p!==n&&(a=null)}else a=null;var s=/^\s*class\b/,o=function(t){try{var e=r.call(t);return s.test(e)}catch(n){return!1}},i=function(t){try{return!o(t)&&(r.call(t),!0)}catch(e){return!1}},l=Object.prototype.toString,c="function"===typeof Symbol&&!!Symbol.toStringTag,u=!(0 in[,]),h=function(){return!1};if("object"===typeof document){var d=document.all;l.call(d)===l.call(document.all)&&(h=function(t){if((u||!t)&&("undefined"===typeof t||"object"===typeof t))try{var e=l.call(t);return("[object HTMLAllCollection]"===e||"[object HTML document.all class]"===e||"[object HTMLCollection]"===e||"[object Object]"===e)&&null==t("")}catch(n){}return!1})}t.exports=a?function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;try{a(t,null,e)}catch(r){if(r!==n)return!1}return!o(t)&&i(t)}:function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;if(c)return i(t);if(o(t))return!1;var e=l.call(t);return!("[object Function]"!==e&&"[object GeneratorFunction]"!==e&&!/^\[object HTML/.test(e))&&i(t)}},1583:(t,e,n)=>{"use strict";var r,a=Object.prototype.toString,s=Function.prototype.toString,o=/^\s*(?:function)?\*/,i=n(4635)(),l=Object.getPrototypeOf;t.exports=function(t){if("function"!==typeof t)return!1;if(o.test(s.call(t)))return!0;if(!i)return"[object GeneratorFunction]"===a.call(t);if(!l)return!1;if("undefined"===typeof r){var e=function(){if(!i)return!1;try{return Function("return function*() {}")()}catch(t){}}();r=!!e&&l(e)}return l(t)===r}},9849:(t,e,n)=>{"use strict";var r=n(8004);t.exports=function(t){return!!r(t)}},7353:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function o(t,e){var n,r,o;return e?(o=0<=(t>>>=0)&&t<256)&&(r=s[t])?r:(n=l(t,(0|t)<0?-1:0,!0),o&&(s[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(r=a[t])?r:(n=l(t,t<0?-1:0,!1),o&&(a[t]=n),n)}function i(t,e){if(isNaN(t))return e?b:m;if(e){if(t<0)return b;if(t>=p)return k}else{if(t<=-f)return S;if(t+1>=f)return x}return t<0?i(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=o,n.fromNumber=i,n.fromBits=l;var c=Math.pow;function u(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return m;if("number"===typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(t.substring(1),e,n).neg();for(var a=i(c(n,8)),s=m,o=0;o<t.length;o+=8){var l=Math.min(8,t.length-o),h=parseInt(t.substring(o,o+l),n);if(l<8){var d=i(c(n,l));s=s.mul(d).add(i(h))}else s=(s=s.mul(a)).add(i(h))}return s.unsigned=e,s}function h(t,e){return"number"===typeof t?i(t,e):"string"===typeof t?u(t,e):l(t.low,t.high,"boolean"===typeof e?e:t.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=o(1<<24),m=o(0);n.ZERO=m;var b=o(0,!0);n.UZERO=b;var y=o(1);n.ONE=y;var v=o(1,!0);n.UONE=v;var w=o(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var e=i(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var a=i(c(t,6),this.unsigned),s=this,o="";;){var l=s.div(a),u=(s.sub(l.mul(a)).toInt()>>>0).toString(t);if((s=l).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!==1||t.high>>>31!==1)&&(this.high===t.high&&this.low===t.low)},I.eq=I.equals,I.notEquals=function(t){return!this.eq(t)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(t){return this.comp(t)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(t){return this.comp(t)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(t){return this.comp(t)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(t){return this.comp(t)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(y)},I.neg=I.negate,I.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,c=t.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&t.low))>>>16,d+=(p+=a+c)>>>16,u+=(d+=n+i)>>>16,u+=e+o,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},I.sub=I.subtract,I.multiply=function(t){if(this.isZero())return m;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return m;if(this.eq(S))return t.isOdd()?S:m;if(t.eq(S))return this.isOdd()?S:m;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return i(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,c=t.high>>>16,u=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,b=0,y=0,v=0;return y+=(v+=o*p)>>>16,b+=(y+=s*p)>>>16,y&=65535,b+=(y+=o*d)>>>16,f+=(b+=a*p)>>>16,b&=65535,f+=(b+=s*d)>>>16,b&=65535,f+=(b+=o*u)>>>16,f+=n*p+a*d+s*u+o*c,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,a,s;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return b;if(t.gt(this.shru(1)))return v;s=b}else{if(this.eq(S))return t.eq(y)||t.eq(w)?S:t.eq(S)?y:(n=this.shr(1).div(t).shl(1)).eq(m)?t.isNegative()?y:w:(a=this.sub(t.mul(n)),s=n.add(a.div(t)));if(t.eq(S))return this.unsigned?b:m;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=m}for(a=this;a.gte(t);){n=Math.max(1,Math.floor(a.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),u=o<=48?1:c(2,o-48),d=i(n),p=d.mul(t);p.isNegative()||p.gt(a);)p=(d=i(n-=u,this.unsigned)).mul(t);d.isZero()&&(d=y),s=s.add(d),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},I.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},I.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},I.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0===(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},I.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},7163:t=>{"use strict";t.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},2730:(t,e,n)=>{"use strict";var r=n(5043),a=n(8853);function s(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=new Set,i={};function l(t,e){c(t,e),c(t+"Capture",e)}function c(t,e){for(i[t]=e,t=0;t<e.length;t++)o.add(e[t])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function g(t,e,n,r,a,s,o){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t){m[t]=new g(t,0,!1,t,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(t){var e=t[0];m[e]=new g(e,1,!1,t[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(t){m[t]=new g(t,2,!1,t.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(t){m[t]=new g(t,2,!1,t,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t){m[t]=new g(t,3,!1,t.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(t){m[t]=new g(t,3,!0,t,null,!1,!1)})),["capture","download"].forEach((function(t){m[t]=new g(t,4,!1,t,null,!1,!1)})),["cols","rows","size","span"].forEach((function(t){m[t]=new g(t,6,!1,t,null,!1,!1)})),["rowSpan","start"].forEach((function(t){m[t]=new g(t,5,!1,t.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(t){return t[1].toUpperCase()}function v(t,e,n,r){var a=m.hasOwnProperty(e)?m[e]:null;(null!==a?0!==a.type:r||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(t,e,n,r){if(null===e||"undefined"===typeof e||function(t,e,n,r){if(null!==n&&0===n.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(t=t.toLowerCase().slice(0,5))&&"aria-"!==t);default:return!1}}(t,e,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,n,a,r)&&(n=null),r||null===a?function(t){return!!h.call(f,t)||!h.call(p,t)&&(d.test(t)?f[t]=!0:(p[t]=!0,!1))}(e)&&(null===n?t.removeAttribute(e):t.setAttribute(e,""+n)):a.mustUseProperty?t[a.propertyName]=null===n?3!==a.type&&"":n:(e=a.attributeName,r=a.attributeNamespace,null===n?t.removeAttribute(e):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!1,!1)})),m.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!0,!0)}));var w=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),E=Symbol.for("react.provider"),C=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),_=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function z(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=O&&t[O]||t["@@iterator"])?t:null}var L,M=Object.assign;function P(t){if(void 0===L)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);L=e&&e[1]||""}return"\n"+L+t}var B=!1;function W(t,e){if(!t||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var r=c}Reflect.construct(t,[],e)}else{try{e.call()}catch(c){r=c}t.call(e.prototype)}else{try{throw Error()}catch(c){r=c}t()}}catch(c){if(c&&r&&"string"===typeof c.stack){for(var a=c.stack.split("\n"),s=r.stack.split("\n"),o=a.length-1,i=s.length-1;1<=o&&0<=i&&a[o]!==s[i];)i--;for(;1<=o&&0<=i;o--,i--)if(a[o]!==s[i]){if(1!==o||1!==i)do{if(o--,0>--i||a[o]!==s[i]){var l="\n"+a[o].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}}while(1<=o&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?P(t):""}function U(t){switch(t.tag){case 5:return P(t.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return t=W(t.type,!1);case 11:return t=W(t.type.render,!1);case 1:return t=W(t.type,!0);default:return""}}function V(t){if(null==t)return null;if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t;switch(t){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case A:return"Suspense";case R:return"SuspenseList"}if("object"===typeof t)switch(t.$$typeof){case C:return(t.displayName||"Context")+".Consumer";case E:return(t._context.displayName||"Context")+".Provider";case T:var e=t.render;return(t=t.displayName)||(t=""!==(t=e.displayName||e.name||"")?"ForwardRef("+t+")":"ForwardRef"),t;case F:return null!==(e=t.displayName||null)?e:V(t.type)||"Memo";case _:e=t._payload,t=t._init;try{return V(t(e))}catch(n){}}return null}function G(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=(t=e.render).displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(e);case 8:return e===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function j(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":case"object":return t;default:return""}}function H(t){var e=t.type;return(t=t.nodeName)&&"input"===t.toLowerCase()&&("checkbox"===e||"radio"===e)}function K(t){t._valueTracker||(t._valueTracker=function(t){var e=H(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return a.call(this)},set:function(t){r=""+t,s.call(this,t)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(t){r=""+t},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}(t))}function q(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=H(t)?t.checked?"true":"false":t.value),(t=r)!==n&&(e.setValue(t),!0)}function X(t){if("undefined"===typeof(t=t||("undefined"!==typeof document?document:void 0)))return null;try{return t.activeElement||t.body}catch(e){return t.body}}function J(t,e){var n=e.checked;return M({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:t._wrapperState.initialChecked})}function Y(t,e){var n=null==e.defaultValue?"":e.defaultValue,r=null!=e.checked?e.checked:e.defaultChecked;n=j(null!=e.value?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function Z(t,e){null!=(e=e.checked)&&v(t,"checked",e,!1)}function Q(t,e){Z(t,e);var n=j(e.value),r=e.type;if(null!=n)"number"===r?(0===n&&""===t.value||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if("submit"===r||"reset"===r)return void t.removeAttribute("value");e.hasOwnProperty("value")?tt(t,e.type,n):e.hasOwnProperty("defaultValue")&&tt(t,e.type,j(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(t.defaultChecked=!!e.defaultChecked)}function $(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!("submit"!==r&&"reset"!==r||void 0!==e.value&&null!==e.value))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}""!==(n=t.name)&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,""!==n&&(t.name=n)}function tt(t,e,n){"number"===e&&X(t.ownerDocument)===t||(null==n?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var et=Array.isArray;function nt(t,e,n,r){if(t=t.options,e){e={};for(var a=0;a<n.length;a++)e["$"+n[a]]=!0;for(n=0;n<t.length;n++)a=e.hasOwnProperty("$"+t[n].value),t[n].selected!==a&&(t[n].selected=a),a&&r&&(t[n].defaultSelected=!0)}else{for(n=""+j(n),e=null,a=0;a<t.length;a++){if(t[a].value===n)return t[a].selected=!0,void(r&&(t[a].defaultSelected=!0));null!==e||t[a].disabled||(e=t[a])}null!==e&&(e.selected=!0)}}function rt(t,e){if(null!=e.dangerouslySetInnerHTML)throw Error(s(91));return M({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function at(t,e){var n=e.value;if(null==n){if(n=e.children,e=e.defaultValue,null!=n){if(null!=e)throw Error(s(92));if(et(n)){if(1<n.length)throw Error(s(93));n=n[0]}e=n}null==e&&(e=""),n=e}t._wrapperState={initialValue:j(n)}}function st(t,e){var n=j(e.value),r=j(e.defaultValue);null!=n&&((n=""+n)!==t.value&&(t.value=n),null==e.defaultValue&&t.defaultValue!==n&&(t.defaultValue=n)),null!=r&&(t.defaultValue=""+r)}function ot(t){var e=t.textContent;e===t._wrapperState.initialValue&&""!==e&&null!==e&&(t.value=e)}function it(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lt(t,e){return null==t||"http://www.w3.org/1999/xhtml"===t?it(e):"http://www.w3.org/2000/svg"===t&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":t}var ct,ut,ht=(ut=function(t,e){if("http://www.w3.org/2000/svg"!==t.namespaceURI||"innerHTML"in t)t.innerHTML=e;else{for((ct=ct||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ct.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(t,e,n,r){MSApp.execUnsafeLocalFunction((function(){return ut(t,e)}))}:ut);function dt(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&3===n.nodeType)return void(n.nodeValue=e)}t.textContent=e}var pt={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ft=["Webkit","ms","Moz","O"];function gt(t,e,n){return null==e||"boolean"===typeof e||""===e?"":n||"number"!==typeof e||0===e||pt.hasOwnProperty(t)&&pt[t]?(""+e).trim():e+"px"}function mt(t,e){for(var n in t=t.style,e)if(e.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=gt(n,e[n],r);"float"===n&&(n="cssFloat"),r?t.setProperty(n,a):t[n]=a}}Object.keys(pt).forEach((function(t){ft.forEach((function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),pt[e]=pt[t]}))}));var bt=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function yt(t,e){if(e){if(bt[t]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(s(137,t));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(s(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(s(62))}}function vt(t,e){if(-1===t.indexOf("-"))return"string"===typeof e.is;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wt=null;function xt(t){return(t=t.target||t.srcElement||window).correspondingUseElement&&(t=t.correspondingUseElement),3===t.nodeType?t.parentNode:t}var kt=null,St=null,It=null;function Nt(t){if(t=va(t)){if("function"!==typeof kt)throw Error(s(280));var e=t.stateNode;e&&(e=xa(e),kt(t.stateNode,t.type,e))}}function Et(t){St?It?It.push(t):It=[t]:St=t}function Ct(){if(St){var t=St,e=It;if(It=St=null,Nt(t),e)for(t=0;t<e.length;t++)Nt(e[t])}}function Tt(t,e){return t(e)}function At(){}var Rt=!1;function Ft(t,e,n){if(Rt)return t(e,n);Rt=!0;try{return Tt(t,e,n)}finally{Rt=!1,(null!==St||null!==It)&&(At(),Ct())}}function _t(t,e){var n=t.stateNode;if(null===n)return null;var r=xa(n);if(null===r)return null;n=r[e];t:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(t=t.type)||"input"===t||"select"===t||"textarea"===t)),t=!r;break t;default:t=!1}if(t)return null;if(n&&"function"!==typeof n)throw Error(s(231,e,typeof n));return n}var Dt=!1;if(u)try{var Ot={};Object.defineProperty(Ot,"passive",{get:function(){Dt=!0}}),window.addEventListener("test",Ot,Ot),window.removeEventListener("test",Ot,Ot)}catch(ut){Dt=!1}function zt(t,e,n,r,a,s,o,i,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var Lt=!1,Mt=null,Pt=!1,Bt=null,Wt={onError:function(t){Lt=!0,Mt=t}};function Ut(t,e,n,r,a,s,o,i,l){Lt=!1,Mt=null,zt.apply(Wt,arguments)}function Vt(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do{0!==(4098&(e=t).flags)&&(n=e.return),t=e.return}while(t)}return 3===e.tag?n:null}function Gt(t){if(13===t.tag){var e=t.memoizedState;if(null===e&&(null!==(t=t.alternate)&&(e=t.memoizedState)),null!==e)return e.dehydrated}return null}function jt(t){if(Vt(t)!==t)throw Error(s(188))}function Ht(t){return null!==(t=function(t){var e=t.alternate;if(!e){if(null===(e=Vt(t)))throw Error(s(188));return e!==t?null:t}for(var n=t,r=e;;){var a=n.return;if(null===a)break;var o=a.alternate;if(null===o){if(null!==(r=a.return)){n=r;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===n)return jt(a),t;if(o===r)return jt(a),e;o=o.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=o;else{for(var i=!1,l=a.child;l;){if(l===n){i=!0,n=a,r=o;break}if(l===r){i=!0,r=a,n=o;break}l=l.sibling}if(!i){for(l=o.child;l;){if(l===n){i=!0,n=o,r=a;break}if(l===r){i=!0,r=o,n=a;break}l=l.sibling}if(!i)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?t:e}(t))?Kt(t):null}function Kt(t){if(5===t.tag||6===t.tag)return t;for(t=t.child;null!==t;){var e=Kt(t);if(null!==e)return e;t=t.sibling}return null}var qt=a.unstable_scheduleCallback,Xt=a.unstable_cancelCallback,Jt=a.unstable_shouldYield,Yt=a.unstable_requestPaint,Zt=a.unstable_now,Qt=a.unstable_getCurrentPriorityLevel,$t=a.unstable_ImmediatePriority,te=a.unstable_UserBlockingPriority,ee=a.unstable_NormalPriority,ne=a.unstable_LowPriority,re=a.unstable_IdlePriority,ae=null,se=null;var oe=Math.clz32?Math.clz32:function(t){return t>>>=0,0===t?32:31-(ie(t)/le|0)|0},ie=Math.log,le=Math.LN2;var ce=64,ue=4194304;function he(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&t;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&t;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function de(t,e){var n=t.pendingLanes;if(0===n)return 0;var r=0,a=t.suspendedLanes,s=t.pingedLanes,o=268435455&n;if(0!==o){var i=o&~a;0!==i?r=he(i):0!==(s&=o)&&(r=he(s))}else 0!==(o=n&~a)?r=he(o):0!==s&&(r=he(s));if(0===r)return 0;if(0!==e&&e!==r&&0===(e&a)&&((a=r&-r)>=(s=e&-e)||16===a&&0!==(4194240&s)))return e;if(0!==(4&r)&&(r|=16&n),0!==(e=t.entangledLanes))for(t=t.entanglements,e&=r;0<e;)a=1<<(n=31-oe(e)),r|=t[n],e&=~a;return r}function pe(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function fe(t){return 0!==(t=-1073741825&t.pendingLanes)?t:1073741824&t?1073741824:0}function ge(){var t=ce;return 0===(4194240&(ce<<=1))&&(ce=64),t}function me(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function be(t,e,n){t.pendingLanes|=e,536870912!==e&&(t.suspendedLanes=0,t.pingedLanes=0),(t=t.eventTimes)[e=31-oe(e)]=n}function ye(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-oe(n),a=1<<r;a&e|t[r]&e&&(t[r]|=e),n&=~a}}var ve=0;function we(t){return 1<(t&=-t)?4<t?0!==(268435455&t)?16:536870912:4:1}var xe,ke,Se,Ie,Ne,Ee=!1,Ce=[],Te=null,Ae=null,Re=null,Fe=new Map,_e=new Map,De=[],Oe="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ze(t,e){switch(t){case"focusin":case"focusout":Te=null;break;case"dragenter":case"dragleave":Ae=null;break;case"mouseover":case"mouseout":Re=null;break;case"pointerover":case"pointerout":Fe.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":_e.delete(e.pointerId)}}function Le(t,e,n,r,a,s){return null===t||t.nativeEvent!==s?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==e&&(null!==(e=va(e))&&ke(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,null!==a&&-1===e.indexOf(a)&&e.push(a),t)}function Me(t){var e=ya(t.target);if(null!==e){var n=Vt(e);if(null!==n)if(13===(e=n.tag)){if(null!==(e=Gt(n)))return t.blockedOn=e,void Ne(t.priority,(function(){Se(n)}))}else if(3===e&&n.stateNode.current.memoizedState.isDehydrated)return void(t.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}t.blockedOn=null}function Pe(t){if(null!==t.blockedOn)return!1;for(var e=t.targetContainers;0<e.length;){var n=Je(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(null!==n)return null!==(e=va(n))&&ke(e),t.blockedOn=n,!1;var r=new(n=t.nativeEvent).constructor(n.type,n);wt=r,n.target.dispatchEvent(r),wt=null,e.shift()}return!0}function Be(t,e,n){Pe(t)&&n.delete(e)}function We(){Ee=!1,null!==Te&&Pe(Te)&&(Te=null),null!==Ae&&Pe(Ae)&&(Ae=null),null!==Re&&Pe(Re)&&(Re=null),Fe.forEach(Be),_e.forEach(Be)}function Ue(t,e){t.blockedOn===e&&(t.blockedOn=null,Ee||(Ee=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,We)))}function Ve(t){function e(e){return Ue(e,t)}if(0<Ce.length){Ue(Ce[0],t);for(var n=1;n<Ce.length;n++){var r=Ce[n];r.blockedOn===t&&(r.blockedOn=null)}}for(null!==Te&&Ue(Te,t),null!==Ae&&Ue(Ae,t),null!==Re&&Ue(Re,t),Fe.forEach(e),_e.forEach(e),n=0;n<De.length;n++)(r=De[n]).blockedOn===t&&(r.blockedOn=null);for(;0<De.length&&null===(n=De[0]).blockedOn;)Me(n),null===n.blockedOn&&De.shift()}var Ge=w.ReactCurrentBatchConfig,je=!0;function He(t,e,n,r){var a=ve,s=Ge.transition;Ge.transition=null;try{ve=1,qe(t,e,n,r)}finally{ve=a,Ge.transition=s}}function Ke(t,e,n,r){var a=ve,s=Ge.transition;Ge.transition=null;try{ve=4,qe(t,e,n,r)}finally{ve=a,Ge.transition=s}}function qe(t,e,n,r){if(je){var a=Je(t,e,n,r);if(null===a)jr(t,e,r,Xe,n),ze(t,r);else if(function(t,e,n,r,a){switch(e){case"focusin":return Te=Le(Te,t,e,n,r,a),!0;case"dragenter":return Ae=Le(Ae,t,e,n,r,a),!0;case"mouseover":return Re=Le(Re,t,e,n,r,a),!0;case"pointerover":var s=a.pointerId;return Fe.set(s,Le(Fe.get(s)||null,t,e,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,_e.set(s,Le(_e.get(s)||null,t,e,n,r,a)),!0}return!1}(a,t,e,n,r))r.stopPropagation();else if(ze(t,r),4&e&&-1<Oe.indexOf(t)){for(;null!==a;){var s=va(a);if(null!==s&&xe(s),null===(s=Je(t,e,n,r))&&jr(t,e,r,Xe,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else jr(t,e,r,null,n)}}var Xe=null;function Je(t,e,n,r){if(Xe=null,null!==(t=ya(t=xt(r))))if(null===(e=Vt(t)))t=null;else if(13===(n=e.tag)){if(null!==(t=Gt(e)))return t;t=null}else if(3===n){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return Xe=t,null}function Ye(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qt()){case $t:return 1;case te:return 4;case ee:case ne:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ze=null,Qe=null,$e=null;function tn(){if($e)return $e;var t,e,n=Qe,r=n.length,a="value"in Ze?Ze.value:Ze.textContent,s=a.length;for(t=0;t<r&&n[t]===a[t];t++);var o=r-t;for(e=1;e<=o&&n[r-e]===a[s-e];e++);return $e=a.slice(t,1<e?1-e:void 0)}function en(t){var e=t.keyCode;return"charCode"in t?0===(t=t.charCode)&&13===e&&(t=13):t=e,10===t&&(t=13),32<=t||13===t?t:0}function nn(){return!0}function rn(){return!1}function an(t){function e(e,n,r,a,s){for(var o in this._reactName=e,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,t)t.hasOwnProperty(o)&&(e=t[o],this[o]=e?e(a):a[o]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return M(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():"unknown"!==typeof t.returnValue&&(t.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():"unknown"!==typeof t.cancelBubble&&(t.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),e}var sn,on,ln,cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=an(cn),hn=M({},cn,{view:0,detail:0}),dn=an(hn),pn=M({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(t){return void 0===t.relatedTarget?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==ln&&(ln&&"mousemove"===t.type?(sn=t.screenX-ln.screenX,on=t.screenY-ln.screenY):on=sn=0,ln=t),sn)},movementY:function(t){return"movementY"in t?t.movementY:on}}),fn=an(pn),gn=an(M({},pn,{dataTransfer:0})),mn=an(M({},hn,{relatedTarget:0})),bn=an(M({},cn,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=M({},cn,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),vn=an(yn),wn=an(M({},cn,{data:0})),xn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):!!(t=Sn[t])&&!!e[t]}function Nn(){return In}var En=M({},hn,{key:function(t){if(t.key){var e=xn[t.key]||t.key;if("Unidentified"!==e)return e}return"keypress"===t.type?13===(t=en(t))?"Enter":String.fromCharCode(t):"keydown"===t.type||"keyup"===t.type?kn[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(t){return"keypress"===t.type?en(t):0},keyCode:function(t){return"keydown"===t.type||"keyup"===t.type?t.keyCode:0},which:function(t){return"keypress"===t.type?en(t):"keydown"===t.type||"keyup"===t.type?t.keyCode:0}}),Cn=an(En),Tn=an(M({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),An=an(M({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),Rn=an(M({},cn,{propertyName:0,elapsedTime:0,pseudoElement:0})),Fn=M({},pn,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),_n=an(Fn),Dn=[9,13,27,32],On=u&&"CompositionEvent"in window,zn=null;u&&"documentMode"in document&&(zn=document.documentMode);var Ln=u&&"TextEvent"in window&&!zn,Mn=u&&(!On||zn&&8<zn&&11>=zn),Pn=String.fromCharCode(32),Bn=!1;function Wn(t,e){switch(t){case"keyup":return-1!==Dn.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(t){return"object"===typeof(t=t.detail)&&"data"in t?t.data:null}var Vn=!1;var Gn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jn(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return"input"===e?!!Gn[t.type]:"textarea"===e}function Hn(t,e,n,r){Et(r),0<(e=Kr(e,"onChange")).length&&(n=new un("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var Kn=null,qn=null;function Xn(t){Pr(t,0)}function Jn(t){if(q(wa(t)))return t}function Yn(t,e){if("change"===t)return e}var Zn=!1;if(u){var Qn;if(u){var $n="oninput"in document;if(!$n){var tr=document.createElement("div");tr.setAttribute("oninput","return;"),$n="function"===typeof tr.oninput}Qn=$n}else Qn=!1;Zn=Qn&&(!document.documentMode||9<document.documentMode)}function er(){Kn&&(Kn.detachEvent("onpropertychange",nr),qn=Kn=null)}function nr(t){if("value"===t.propertyName&&Jn(qn)){var e=[];Hn(e,qn,t,xt(t)),Ft(Xn,e)}}function rr(t,e,n){"focusin"===t?(er(),qn=n,(Kn=e).attachEvent("onpropertychange",nr)):"focusout"===t&&er()}function ar(t){if("selectionchange"===t||"keyup"===t||"keydown"===t)return Jn(qn)}function sr(t,e){if("click"===t)return Jn(e)}function or(t,e){if("input"===t||"change"===t)return Jn(e)}var ir="function"===typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t===1/e)||t!==t&&e!==e};function lr(t,e){if(ir(t,e))return!0;if("object"!==typeof t||null===t||"object"!==typeof e||null===e)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!h.call(e,a)||!ir(t[a],e[a]))return!1}return!0}function cr(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function ur(t,e){var n,r=cr(t);for(t=0;r;){if(3===r.nodeType){if(n=t+r.textContent.length,t<=e&&n>=e)return{node:r,offset:e-t};t=n}t:{for(;r;){if(r.nextSibling){r=r.nextSibling;break t}r=r.parentNode}r=void 0}r=cr(r)}}function hr(t,e){return!(!t||!e)&&(t===e||(!t||3!==t.nodeType)&&(e&&3===e.nodeType?hr(t,e.parentNode):"contains"in t?t.contains(e):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(e))))}function dr(){for(var t=window,e=X();e instanceof t.HTMLIFrameElement;){try{var n="string"===typeof e.contentWindow.location.href}catch(r){n=!1}if(!n)break;e=X((t=e.contentWindow).document)}return e}function pr(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&("input"===e&&("text"===t.type||"search"===t.type||"tel"===t.type||"url"===t.type||"password"===t.type)||"textarea"===e||"true"===t.contentEditable)}function fr(t){var e=dr(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&hr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(e=r.start,void 0===(t=r.end)&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if((t=(e=n.ownerDocument||document)&&e.defaultView||window).getSelection){t=t.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!t.extend&&s>r&&(a=r,r=s,s=a),a=ur(n,s);var o=ur(n,r);a&&o&&(1!==t.rangeCount||t.anchorNode!==a.node||t.anchorOffset!==a.offset||t.focusNode!==o.node||t.focusOffset!==o.offset)&&((e=e.createRange()).setStart(a.node,a.offset),t.removeAllRanges(),s>r?(t.addRange(e),t.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),t.addRange(e)))}for(e=[],t=n;t=t.parentNode;)1===t.nodeType&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<e.length;n++)(t=e[n]).element.scrollLeft=t.left,t.element.scrollTop=t.top}}var gr=u&&"documentMode"in document&&11>=document.documentMode,mr=null,br=null,yr=null,vr=!1;function wr(t,e,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==mr||mr!==X(r)||("selectionStart"in(r=mr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},yr&&lr(yr,r)||(yr=r,0<(r=Kr(br,"onSelect")).length&&(e=new un("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=mr)))}function xr(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var kr={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},Sr={},Ir={};function Nr(t){if(Sr[t])return Sr[t];if(!kr[t])return t;var e,n=kr[t];for(e in n)if(n.hasOwnProperty(e)&&e in Ir)return Sr[t]=n[e];return t}u&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Er=Nr("animationend"),Cr=Nr("animationiteration"),Tr=Nr("animationstart"),Ar=Nr("transitionend"),Rr=new Map,Fr="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function _r(t,e){Rr.set(t,e),l(e,[t])}for(var Dr=0;Dr<Fr.length;Dr++){var Or=Fr[Dr];_r(Or.toLowerCase(),"on"+(Or[0].toUpperCase()+Or.slice(1)))}_r(Er,"onAnimationEnd"),_r(Cr,"onAnimationIteration"),_r(Tr,"onAnimationStart"),_r("dblclick","onDoubleClick"),_r("focusin","onFocus"),_r("focusout","onBlur"),_r(Ar,"onTransitionEnd"),c("onMouseEnter",["mouseout","mouseover"]),c("onMouseLeave",["mouseout","mouseover"]),c("onPointerEnter",["pointerout","pointerover"]),c("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var zr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Lr=new Set("cancel close invalid load scroll toggle".split(" ").concat(zr));function Mr(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,function(t,e,n,r,a,o,i,l,c){if(Ut.apply(this,arguments),Lt){if(!Lt)throw Error(s(198));var u=Mt;Lt=!1,Mt=null,Pt||(Pt=!0,Bt=u)}}(r,e,void 0,t),t.currentTarget=null}function Pr(t,e){e=0!==(4&e);for(var n=0;n<t.length;n++){var r=t[n],a=r.event;r=r.listeners;t:{var s=void 0;if(e)for(var o=r.length-1;0<=o;o--){var i=r[o],l=i.instance,c=i.currentTarget;if(i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}else for(o=0;o<r.length;o++){if(l=(i=r[o]).instance,c=i.currentTarget,i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}}}if(Pt)throw t=Bt,Pt=!1,Bt=null,t}function Br(t,e){var n=e[ga];void 0===n&&(n=e[ga]=new Set);var r=t+"__bubble";n.has(r)||(Gr(e,t,2,!1),n.add(r))}function Wr(t,e,n){var r=0;e&&(r|=4),Gr(n,t,r,e)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function Vr(t){if(!t[Ur]){t[Ur]=!0,o.forEach((function(e){"selectionchange"!==e&&(Lr.has(e)||Wr(e,!1,t),Wr(e,!0,t))}));var e=9===t.nodeType?t:t.ownerDocument;null===e||e[Ur]||(e[Ur]=!0,Wr("selectionchange",!1,e))}}function Gr(t,e,n,r){switch(Ye(e)){case 1:var a=He;break;case 4:a=Ke;break;default:a=qe}n=a.bind(null,e,n,t),a=void 0,!Dt||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(a=!0),r?void 0!==a?t.addEventListener(e,n,{capture:!0,passive:a}):t.addEventListener(e,n,!0):void 0!==a?t.addEventListener(e,n,{passive:a}):t.addEventListener(e,n,!1)}function jr(t,e,n,r,a){var s=r;if(0===(1&e)&&0===(2&e)&&null!==r)t:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var i=r.stateNode.containerInfo;if(i===a||8===i.nodeType&&i.parentNode===a)break;if(4===o)for(o=r.return;null!==o;){var l=o.tag;if((3===l||4===l)&&((l=o.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;o=o.return}for(;null!==i;){if(null===(o=ya(i)))return;if(5===(l=o.tag)||6===l){r=s=o;continue t}i=i.parentNode}}r=r.return}Ft((function(){var r=s,a=xt(n),o=[];t:{var i=Rr.get(t);if(void 0!==i){var l=un,c=t;switch(t){case"keypress":if(0===en(n))break t;case"keydown":case"keyup":l=Cn;break;case"focusin":c="focus",l=mn;break;case"focusout":c="blur",l=mn;break;case"beforeblur":case"afterblur":l=mn;break;case"click":if(2===n.button)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=gn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=An;break;case Er:case Cr:case Tr:l=bn;break;case Ar:l=Rn;break;case"scroll":l=dn;break;case"wheel":l=_n;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Tn}var u=0!==(4&e),h=!u&&"scroll"===t,d=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=r;null!==f;){var g=(p=f).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==d&&(null!=(g=_t(f,d))&&u.push(Hr(f,g,p)))),h)break;f=f.return}0<u.length&&(i=new l(i,c,null,n,a),o.push({event:i,listeners:u}))}}if(0===(7&e)){if(l="mouseout"===t||"pointerout"===t,(!(i="mouseover"===t||"pointerover"===t)||n===wt||!(c=n.relatedTarget||n.fromElement)||!ya(c)&&!c[fa])&&(l||i)&&(i=a.window===a?a:(i=a.ownerDocument)?i.defaultView||i.parentWindow:window,l?(l=r,null!==(c=(c=n.relatedTarget||n.toElement)?ya(c):null)&&(c!==(h=Vt(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=r),l!==c)){if(u=fn,g="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==t&&"pointerover"!==t||(u=Tn,g="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==l?i:wa(l),p=null==c?i:wa(c),(i=new u(g,f+"leave",l,n,a)).target=h,i.relatedTarget=p,g=null,ya(a)===r&&((u=new u(d,f+"enter",c,n,a)).target=p,u.relatedTarget=h,g=u),h=g,l&&c)t:{for(d=c,f=0,p=u=l;p;p=qr(p))f++;for(p=0,g=d;g;g=qr(g))p++;for(;0<f-p;)u=qr(u),f--;for(;0<p-f;)d=qr(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break t;u=qr(u),d=qr(d)}u=null}else u=null;null!==l&&Xr(o,i,l,u,!1),null!==c&&null!==h&&Xr(o,h,c,u,!0)}if("select"===(l=(i=r?wa(r):window).nodeName&&i.nodeName.toLowerCase())||"input"===l&&"file"===i.type)var m=Yn;else if(jn(i))if(Zn)m=or;else{m=ar;var b=rr}else(l=i.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(m=sr);switch(m&&(m=m(t,r))?Hn(o,m,n,a):(b&&b(t,i,r),"focusout"===t&&(b=i._wrapperState)&&b.controlled&&"number"===i.type&&tt(i,"number",i.value)),b=r?wa(r):window,t){case"focusin":(jn(b)||"true"===b.contentEditable)&&(mr=b,br=r,yr=null);break;case"focusout":yr=br=mr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,wr(o,n,a);break;case"selectionchange":if(gr)break;case"keydown":case"keyup":wr(o,n,a)}var y;if(On)t:{switch(t){case"compositionstart":var v="onCompositionStart";break t;case"compositionend":v="onCompositionEnd";break t;case"compositionupdate":v="onCompositionUpdate";break t}v=void 0}else Vn?Wn(t,n)&&(v="onCompositionEnd"):"keydown"===t&&229===n.keyCode&&(v="onCompositionStart");v&&(Mn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(y=tn()):(Qe="value"in(Ze=a)?Ze.value:Ze.textContent,Vn=!0)),0<(b=Kr(r,v)).length&&(v=new wn(v,t,null,n,a),o.push({event:v,listeners:b}),y?v.data=y:null!==(y=Un(n))&&(v.data=y))),(y=Ln?function(t,e){switch(t){case"compositionend":return Un(e);case"keypress":return 32!==e.which?null:(Bn=!0,Pn);case"textInput":return(t=e.data)===Pn&&Bn?null:t;default:return null}}(t,n):function(t,e){if(Vn)return"compositionend"===t||!On&&Wn(t,e)?(t=tn(),$e=Qe=Ze=null,Vn=!1,t):null;switch(t){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Mn&&"ko"!==e.locale?null:e.data}}(t,n))&&(0<(r=Kr(r,"onBeforeInput")).length&&(a=new wn("onBeforeInput","beforeinput",null,n,a),o.push({event:a,listeners:r}),a.data=y))}Pr(o,e)}))}function Hr(t,e,n){return{instance:t,listener:e,currentTarget:n}}function Kr(t,e){for(var n=e+"Capture",r=[];null!==t;){var a=t,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=_t(t,n))&&r.unshift(Hr(t,s,a)),null!=(s=_t(t,e))&&r.push(Hr(t,s,a))),t=t.return}return r}function qr(t){if(null===t)return null;do{t=t.return}while(t&&5!==t.tag);return t||null}function Xr(t,e,n,r,a){for(var s=e._reactName,o=[];null!==n&&n!==r;){var i=n,l=i.alternate,c=i.stateNode;if(null!==l&&l===r)break;5===i.tag&&null!==c&&(i=c,a?null!=(l=_t(n,s))&&o.unshift(Hr(n,l,i)):a||null!=(l=_t(n,s))&&o.push(Hr(n,l,i))),n=n.return}0!==o.length&&t.push({event:e,listeners:o})}var Jr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Zr(t){return("string"===typeof t?t:""+t).replace(Jr,"\n").replace(Yr,"")}function Qr(t,e,n){if(e=Zr(e),Zr(t)!==e&&n)throw Error(s(425))}function $r(){}var ta=null,ea=null;function na(t,e){return"textarea"===t||"noscript"===t||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,oa="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(t){return sa.resolve(null).then(t).catch(ia)}:ra;function ia(t){setTimeout((function(){throw t}))}function la(t,e){var n=e,r=0;do{var a=n.nextSibling;if(t.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return t.removeChild(a),void Ve(e);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Ve(e)}function ca(t){for(;null!=t;t=t.nextSibling){var e=t.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=t.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return t}function ua(t){t=t.previousSibling;for(var e=0;t;){if(8===t.nodeType){var n=t.data;if("$"===n||"$!"===n||"$?"===n){if(0===e)return t;e--}else"/$"===n&&e++}t=t.previousSibling}return null}var ha=Math.random().toString(36).slice(2),da="__reactFiber$"+ha,pa="__reactProps$"+ha,fa="__reactContainer$"+ha,ga="__reactEvents$"+ha,ma="__reactListeners$"+ha,ba="__reactHandles$"+ha;function ya(t){var e=t[da];if(e)return e;for(var n=t.parentNode;n;){if(e=n[fa]||n[da]){if(n=e.alternate,null!==e.child||null!==n&&null!==n.child)for(t=ua(t);null!==t;){if(n=t[da])return n;t=ua(t)}return e}n=(t=n).parentNode}return null}function va(t){return!(t=t[da]||t[fa])||5!==t.tag&&6!==t.tag&&13!==t.tag&&3!==t.tag?null:t}function wa(t){if(5===t.tag||6===t.tag)return t.stateNode;throw Error(s(33))}function xa(t){return t[pa]||null}var ka=[],Sa=-1;function Ia(t){return{current:t}}function Na(t){0>Sa||(t.current=ka[Sa],ka[Sa]=null,Sa--)}function Ea(t,e){Sa++,ka[Sa]=t.current,t.current=e}var Ca={},Ta=Ia(Ca),Aa=Ia(!1),Ra=Ca;function Fa(t,e){var n=t.type.contextTypes;if(!n)return Ca;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=e[a];return r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=s),s}function _a(t){return null!==(t=t.childContextTypes)&&void 0!==t}function Da(){Na(Aa),Na(Ta)}function Oa(t,e,n){if(Ta.current!==Ca)throw Error(s(168));Ea(Ta,e),Ea(Aa,n)}function za(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in e))throw Error(s(108,G(t)||"Unknown",a));return M({},n,r)}function La(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Ca,Ra=Ta.current,Ea(Ta,t),Ea(Aa,Aa.current),!0}function Ma(t,e,n){var r=t.stateNode;if(!r)throw Error(s(169));n?(t=za(t,e,Ra),r.__reactInternalMemoizedMergedChildContext=t,Na(Aa),Na(Ta),Ea(Ta,t)):Na(Aa),Ea(Aa,n)}var Pa=null,Ba=!1,Wa=!1;function Ua(t){null===Pa?Pa=[t]:Pa.push(t)}function Va(){if(!Wa&&null!==Pa){Wa=!0;var t=0,e=ve;try{var n=Pa;for(ve=1;t<n.length;t++){var r=n[t];do{r=r(!0)}while(null!==r)}Pa=null,Ba=!1}catch(a){throw null!==Pa&&(Pa=Pa.slice(t+1)),qt($t,Va),a}finally{ve=e,Wa=!1}}return null}var Ga=[],ja=0,Ha=null,Ka=0,qa=[],Xa=0,Ja=null,Ya=1,Za="";function Qa(t,e){Ga[ja++]=Ka,Ga[ja++]=Ha,Ha=t,Ka=e}function $a(t,e,n){qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ja=t;var r=Ya;t=Za;var a=32-oe(r)-1;r&=~(1<<a),n+=1;var s=32-oe(e)+a;if(30<s){var o=a-a%5;s=(r&(1<<o)-1).toString(32),r>>=o,a-=o,Ya=1<<32-oe(e)+a|n<<a|r,Za=s+t}else Ya=1<<s|n<<a|r,Za=t}function ts(t){null!==t.return&&(Qa(t,1),$a(t,1,0))}function es(t){for(;t===Ha;)Ha=Ga[--ja],Ga[ja]=null,Ka=Ga[--ja],Ga[ja]=null;for(;t===Ja;)Ja=qa[--Xa],qa[Xa]=null,Za=qa[--Xa],qa[Xa]=null,Ya=qa[--Xa],qa[Xa]=null}var ns=null,rs=null,as=!1,ss=null;function os(t,e){var n=_c(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,null===(e=t.deletions)?(t.deletions=[n],t.flags|=16):e.push(n)}function is(t,e){switch(t.tag){case 5:var n=t.type;return null!==(e=1!==e.nodeType||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(t.stateNode=e,ns=t,rs=ca(e.firstChild),!0);case 6:return null!==(e=""===t.pendingProps||3!==e.nodeType?null:e)&&(t.stateNode=e,ns=t,rs=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(n=null!==Ja?{id:Ya,overflow:Za}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},(n=_c(18,null,null,0)).stateNode=e,n.return=t,t.child=n,ns=t,rs=null,!0);default:return!1}}function ls(t){return 0!==(1&t.mode)&&0===(128&t.flags)}function cs(t){if(as){var e=rs;if(e){var n=e;if(!is(t,e)){if(ls(t))throw Error(s(418));e=ca(n.nextSibling);var r=ns;e&&is(t,e)?os(r,n):(t.flags=-4097&t.flags|2,as=!1,ns=t)}}else{if(ls(t))throw Error(s(418));t.flags=-4097&t.flags|2,as=!1,ns=t}}}function us(t){for(t=t.return;null!==t&&5!==t.tag&&3!==t.tag&&13!==t.tag;)t=t.return;ns=t}function hs(t){if(t!==ns)return!1;if(!as)return us(t),as=!0,!1;var e;if((e=3!==t.tag)&&!(e=5!==t.tag)&&(e="head"!==(e=t.type)&&"body"!==e&&!na(t.type,t.memoizedProps)),e&&(e=rs)){if(ls(t))throw ds(),Error(s(418));for(;e;)os(t,e),e=ca(e.nextSibling)}if(us(t),13===t.tag){if(!(t=null!==(t=t.memoizedState)?t.dehydrated:null))throw Error(s(317));t:{for(t=t.nextSibling,e=0;t;){if(8===t.nodeType){var n=t.data;if("/$"===n){if(0===e){rs=ca(t.nextSibling);break t}e--}else"$"!==n&&"$!"!==n&&"$?"!==n||e++}t=t.nextSibling}rs=null}}else rs=ns?ca(t.stateNode.nextSibling):null;return!0}function ds(){for(var t=rs;t;)t=ca(t.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(t){null===ss?ss=[t]:ss.push(t)}var gs=w.ReactCurrentBatchConfig;function ms(t,e){if(t&&t.defaultProps){for(var n in e=M({},e),t=t.defaultProps)void 0===e[n]&&(e[n]=t[n]);return e}return e}var bs=Ia(null),ys=null,vs=null,ws=null;function xs(){ws=vs=ys=null}function ks(t){var e=bs.current;Na(bs),t._currentValue=e}function Ss(t,e,n){for(;null!==t;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,null!==r&&(r.childLanes|=e)):null!==r&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function Is(t,e){ys=t,ws=vs=null,null!==(t=t.dependencies)&&null!==t.firstContext&&(0!==(t.lanes&e)&&(wi=!0),t.firstContext=null)}function Ns(t){var e=t._currentValue;if(ws!==t)if(t={context:t,memoizedValue:e,next:null},null===vs){if(null===ys)throw Error(s(308));vs=t,ys.dependencies={lanes:0,firstContext:t}}else vs=vs.next=t;return e}var Es=null;function Cs(t){null===Es?Es=[t]:Es.push(t)}function Ts(t,e,n,r){var a=e.interleaved;return null===a?(n.next=n,Cs(e)):(n.next=a.next,a.next=n),e.interleaved=n,As(t,r)}function As(t,e){t.lanes|=e;var n=t.alternate;for(null!==n&&(n.lanes|=e),n=t,t=t.return;null!==t;)t.childLanes|=e,null!==(n=t.alternate)&&(n.childLanes|=e),n=t,t=t.return;return 3===n.tag?n.stateNode:null}var Rs=!1;function Fs(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function _s(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function Ds(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Os(t,e,n){var r=t.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Al)){var a=r.pending;return null===a?e.next=e:(e.next=a.next,a.next=e),r.pending=e,As(t,n)}return null===(a=r.interleaved)?(e.next=e,Cs(r)):(e.next=a.next,a.next=e),r.interleaved=e,As(t,n)}function zs(t,e,n){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&n))){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}function Ls(t,e){var n=t.updateQueue,r=t.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=o:s=s.next=o,n=n.next}while(null!==n);null===s?a=s=e:s=s.next=e}else a=s=e;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(t.updateQueue=n)}null===(t=n.lastBaseUpdate)?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Ms(t,e,n,r){var a=t.updateQueue;Rs=!1;var s=a.firstBaseUpdate,o=a.lastBaseUpdate,i=a.shared.pending;if(null!==i){a.shared.pending=null;var l=i,c=l.next;l.next=null,null===o?s=c:o.next=c,o=l;var u=t.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==o&&(null===i?u.firstBaseUpdate=c:i.next=c,u.lastBaseUpdate=l))}if(null!==s){var h=a.baseState;for(o=0,u=c=l=null,i=s;;){var d=i.lane,p=i.eventTime;if((r&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});t:{var f=t,g=i;switch(d=e,p=n,g.tag){case 1:if("function"===typeof(f=g.payload)){h=f.call(p,h,d);break t}h=f;break t;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=g.payload)?f.call(p,h,d):f)||void 0===d)break t;h=M({},h,d);break t;case 2:Rs=!0}}null!==i.callback&&0!==i.lane&&(t.flags|=64,null===(d=a.effects)?a.effects=[i]:d.push(i))}else p={eventTime:p,lane:d,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(c=u=p,l=h):u=u.next=p,o|=d;if(null===(i=i.next)){if(null===(i=a.shared.pending))break;i=(d=i).next,d.next=null,a.lastBaseUpdate=d,a.shared.pending=null}}if(null===u&&(l=h),a.baseState=l,a.firstBaseUpdate=c,a.lastBaseUpdate=u,null!==(e=a.shared.interleaved)){a=e;do{o|=a.lane,a=a.next}while(a!==e)}else null===s&&(a.shared.lanes=0);Ml|=o,t.lanes=o,t.memoizedState=h}}function Ps(t,e,n){if(t=e.effects,e.effects=null,null!==t)for(e=0;e<t.length;e++){var r=t[e],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var Bs=(new r.Component).refs;function Ws(t,e,n,r){n=null===(n=n(r,e=t.memoizedState))||void 0===n?e:M({},e,n),t.memoizedState=n,0===t.lanes&&(t.updateQueue.baseState=n)}var Us={isMounted:function(t){return!!(t=t._reactInternals)&&Vt(t)===t},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.tag=1,s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=ec(),r=nc(t),a=Ds(n,r);a.tag=2,void 0!==e&&null!==e&&(a.callback=e),null!==(e=Os(t,a,r))&&(rc(e,t,r,n),zs(e,t,r))}};function Vs(t,e,n,r,a,s,o){return"function"===typeof(t=t.stateNode).shouldComponentUpdate?t.shouldComponentUpdate(r,s,o):!e.prototype||!e.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function Gs(t,e,n){var r=!1,a=Ca,s=e.contextType;return"object"===typeof s&&null!==s?s=Ns(s):(a=_a(e)?Ra:Ta.current,s=(r=null!==(r=e.contextTypes)&&void 0!==r)?Fa(t,a):Ca),e=new e(n,s),t.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=Us,t.stateNode=e,e._reactInternals=t,r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,t.__reactInternalMemoizedMaskedChildContext=s),e}function js(t,e,n,r){t=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(n,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&Us.enqueueReplaceState(e,e.state,null)}function Hs(t,e,n,r){var a=t.stateNode;a.props=n,a.state=t.memoizedState,a.refs=Bs,Fs(t);var s=e.contextType;"object"===typeof s&&null!==s?a.context=Ns(s):(s=_a(e)?Ra:Ta.current,a.context=Fa(t,s)),a.state=t.memoizedState,"function"===typeof(s=e.getDerivedStateFromProps)&&(Ws(t,e,s,n),a.state=t.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(e=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),e!==a.state&&Us.enqueueReplaceState(a,a.state,null),Ms(t,n,a,r),a.state=t.memoizedState),"function"===typeof a.componentDidMount&&(t.flags|=4194308)}function Ks(t,e,n){if(null!==(t=n.ref)&&"function"!==typeof t&&"object"!==typeof t){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,t));var a=r,o=""+t;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===o?e.ref:(e=function(t){var e=a.refs;e===Bs&&(e=a.refs={}),null===t?delete e[o]:e[o]=t},e._stringRef=o,e)}if("string"!==typeof t)throw Error(s(284));if(!n._owner)throw Error(s(290,t))}return t}function qs(t,e){throw t=Object.prototype.toString.call(e),Error(s(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function Xs(t){return(0,t._init)(t._payload)}function Js(t){function e(e,n){if(t){var r=e.deletions;null===r?(e.deletions=[n],e.flags|=16):r.push(n)}}function n(n,r){if(!t)return null;for(;null!==r;)e(n,r),r=r.sibling;return null}function r(t,e){for(t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(t,e){return(t=Oc(t,e)).index=0,t.sibling=null,t}function o(e,n,r){return e.index=r,t?null!==(r=e.alternate)?(r=r.index)<n?(e.flags|=2,n):r:(e.flags|=2,n):(e.flags|=1048576,n)}function i(e){return t&&null===e.alternate&&(e.flags|=2),e}function l(t,e,n,r){return null===e||6!==e.tag?((e=Pc(n,t.mode,r)).return=t,e):((e=a(e,n)).return=t,e)}function c(t,e,n,r){var s=n.type;return s===S?h(t,e,n.props.children,r,n.key):null!==e&&(e.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===_&&Xs(s)===e.type)?((r=a(e,n.props)).ref=Ks(t,e,n),r.return=t,r):((r=zc(n.type,n.key,n.props,null,t.mode,r)).ref=Ks(t,e,n),r.return=t,r)}function u(t,e,n,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==n.containerInfo||e.stateNode.implementation!==n.implementation?((e=Bc(n,t.mode,r)).return=t,e):((e=a(e,n.children||[])).return=t,e)}function h(t,e,n,r,s){return null===e||7!==e.tag?((e=Lc(n,t.mode,r,s)).return=t,e):((e=a(e,n)).return=t,e)}function d(t,e,n){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=Pc(""+e,t.mode,n)).return=t,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case x:return(n=zc(e.type,e.key,e.props,null,t.mode,n)).ref=Ks(t,null,e),n.return=t,n;case k:return(e=Bc(e,t.mode,n)).return=t,e;case _:return d(t,(0,e._init)(e._payload),n)}if(et(e)||z(e))return(e=Lc(e,t.mode,n,null)).return=t,e;qs(t,e)}return null}function p(t,e,n,r){var a=null!==e?e.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(t,e,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===a?c(t,e,n,r):null;case k:return n.key===a?u(t,e,n,r):null;case _:return p(t,e,(a=n._init)(n._payload),r)}if(et(n)||z(n))return null!==a?null:h(t,e,n,r,null);qs(t,n)}return null}function f(t,e,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(e,t=t.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case x:return c(e,t=t.get(null===r.key?n:r.key)||null,r,a);case k:return u(e,t=t.get(null===r.key?n:r.key)||null,r,a);case _:return f(t,e,n,(0,r._init)(r._payload),a)}if(et(r)||z(r))return h(e,t=t.get(n)||null,r,a,null);qs(e,r)}return null}function g(a,s,i,l){for(var c=null,u=null,h=s,g=s=0,m=null;null!==h&&g<i.length;g++){h.index>g?(m=h,h=null):m=h.sibling;var b=p(a,h,i[g],l);if(null===b){null===h&&(h=m);break}t&&h&&null===b.alternate&&e(a,h),s=o(b,s,g),null===u?c=b:u.sibling=b,u=b,h=m}if(g===i.length)return n(a,h),as&&Qa(a,g),c;if(null===h){for(;g<i.length;g++)null!==(h=d(a,i[g],l))&&(s=o(h,s,g),null===u?c=h:u.sibling=h,u=h);return as&&Qa(a,g),c}for(h=r(a,h);g<i.length;g++)null!==(m=f(h,a,g,i[g],l))&&(t&&null!==m.alternate&&h.delete(null===m.key?g:m.key),s=o(m,s,g),null===u?c=m:u.sibling=m,u=m);return t&&h.forEach((function(t){return e(a,t)})),as&&Qa(a,g),c}function m(a,i,l,c){var u=z(l);if("function"!==typeof u)throw Error(s(150));if(null==(l=u.call(l)))throw Error(s(151));for(var h=u=null,g=i,m=i=0,b=null,y=l.next();null!==g&&!y.done;m++,y=l.next()){g.index>m?(b=g,g=null):b=g.sibling;var v=p(a,g,y.value,c);if(null===v){null===g&&(g=b);break}t&&g&&null===v.alternate&&e(a,g),i=o(v,i,m),null===h?u=v:h.sibling=v,h=v,g=b}if(y.done)return n(a,g),as&&Qa(a,m),u;if(null===g){for(;!y.done;m++,y=l.next())null!==(y=d(a,y.value,c))&&(i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return as&&Qa(a,m),u}for(g=r(a,g);!y.done;m++,y=l.next())null!==(y=f(g,a,m,y.value,c))&&(t&&null!==y.alternate&&g.delete(null===y.key?m:y.key),i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return t&&g.forEach((function(t){return e(a,t)})),as&&Qa(a,m),u}return function t(r,s,o,l){if("object"===typeof o&&null!==o&&o.type===S&&null===o.key&&(o=o.props.children),"object"===typeof o&&null!==o){switch(o.$$typeof){case x:t:{for(var c=o.key,u=s;null!==u;){if(u.key===c){if((c=o.type)===S){if(7===u.tag){n(r,u.sibling),(s=a(u,o.props.children)).return=r,r=s;break t}}else if(u.elementType===c||"object"===typeof c&&null!==c&&c.$$typeof===_&&Xs(c)===u.type){n(r,u.sibling),(s=a(u,o.props)).ref=Ks(r,u,o),s.return=r,r=s;break t}n(r,u);break}e(r,u),u=u.sibling}o.type===S?((s=Lc(o.props.children,r.mode,l,o.key)).return=r,r=s):((l=zc(o.type,o.key,o.props,null,r.mode,l)).ref=Ks(r,s,o),l.return=r,r=l)}return i(r);case k:t:{for(u=o.key;null!==s;){if(s.key===u){if(4===s.tag&&s.stateNode.containerInfo===o.containerInfo&&s.stateNode.implementation===o.implementation){n(r,s.sibling),(s=a(s,o.children||[])).return=r,r=s;break t}n(r,s);break}e(r,s),s=s.sibling}(s=Bc(o,r.mode,l)).return=r,r=s}return i(r);case _:return t(r,s,(u=o._init)(o._payload),l)}if(et(o))return g(r,s,o,l);if(z(o))return m(r,s,o,l);qs(r,o)}return"string"===typeof o&&""!==o||"number"===typeof o?(o=""+o,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,o)).return=r,r=s):(n(r,s),(s=Pc(o,r.mode,l)).return=r,r=s),i(r)):n(r,s)}}var Ys=Js(!0),Zs=Js(!1),Qs={},$s=Ia(Qs),to=Ia(Qs),eo=Ia(Qs);function no(t){if(t===Qs)throw Error(s(174));return t}function ro(t,e){switch(Ea(eo,e),Ea(to,t),Ea($s,Qs),t=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lt(null,"");break;default:e=lt(e=(t=8===t?e.parentNode:e).namespaceURI||null,t=t.tagName)}Na($s),Ea($s,e)}function ao(){Na($s),Na(to),Na(eo)}function so(t){no(eo.current);var e=no($s.current),n=lt(e,t.type);e!==n&&(Ea(to,t),Ea($s,n))}function oo(t){to.current===t&&(Na($s),Na(to))}var io=Ia(0);function lo(t){for(var e=t;null!==e;){if(13===e.tag){var n=e.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var co=[];function uo(){for(var t=0;t<co.length;t++)co[t]._workInProgressVersionPrimary=null;co.length=0}var ho=w.ReactCurrentDispatcher,po=w.ReactCurrentBatchConfig,fo=0,go=null,mo=null,bo=null,yo=!1,vo=!1,wo=0,xo=0;function ko(){throw Error(s(321))}function So(t,e){if(null===e)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!ir(t[n],e[n]))return!1;return!0}function Io(t,e,n,r,a,o){if(fo=o,go=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ho.current=null===t||null===t.memoizedState?ii:li,t=n(r,a),vo){o=0;do{if(vo=!1,wo=0,25<=o)throw Error(s(301));o+=1,bo=mo=null,e.updateQueue=null,ho.current=ci,t=n(r,a)}while(vo)}if(ho.current=oi,e=null!==mo&&null!==mo.next,fo=0,bo=mo=go=null,yo=!1,e)throw Error(s(300));return t}function No(){var t=0!==wo;return wo=0,t}function Eo(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===bo?go.memoizedState=bo=t:bo=bo.next=t,bo}function Co(){if(null===mo){var t=go.alternate;t=null!==t?t.memoizedState:null}else t=mo.next;var e=null===bo?go.memoizedState:bo.next;if(null!==e)bo=e,mo=t;else{if(null===t)throw Error(s(310));t={memoizedState:(mo=t).memoizedState,baseState:mo.baseState,baseQueue:mo.baseQueue,queue:mo.queue,next:null},null===bo?go.memoizedState=bo=t:bo=bo.next=t}return bo}function To(t,e){return"function"===typeof e?e(t):e}function Ao(t){var e=Co(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=mo,a=r.baseQueue,o=n.pending;if(null!==o){if(null!==a){var i=a.next;a.next=o.next,o.next=i}r.baseQueue=a=o,n.pending=null}if(null!==a){o=a.next,r=r.baseState;var l=i=null,c=null,u=o;do{var h=u.lane;if((fo&h)===h)null!==c&&(c=c.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:t(r,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===c?(l=c=d,i=r):c=c.next=d,go.lanes|=h,Ml|=h}u=u.next}while(null!==u&&u!==o);null===c?i=r:c.next=l,ir(r,e.memoizedState)||(wi=!0),e.memoizedState=r,e.baseState=i,e.baseQueue=c,n.lastRenderedState=r}if(null!==(t=n.interleaved)){a=t;do{o=a.lane,go.lanes|=o,Ml|=o,a=a.next}while(a!==t)}else null===a&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function Ro(t){var e=Co(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=n.dispatch,a=n.pending,o=e.memoizedState;if(null!==a){n.pending=null;var i=a=a.next;do{o=t(o,i.action),i=i.next}while(i!==a);ir(o,e.memoizedState)||(wi=!0),e.memoizedState=o,null===e.baseQueue&&(e.baseState=o),n.lastRenderedState=o}return[o,r]}function Fo(){}function _o(t,e){var n=go,r=Co(),a=e(),o=!ir(r.memoizedState,a);if(o&&(r.memoizedState=a,wi=!0),r=r.queue,jo(zo.bind(null,n,r,t),[t]),r.getSnapshot!==e||o||null!==bo&&1&bo.memoizedState.tag){if(n.flags|=2048,Bo(9,Oo.bind(null,n,r,a,e),void 0,null),null===Rl)throw Error(s(349));0!==(30&fo)||Do(n,e,a)}return a}function Do(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.stores=[t]):null===(n=e.stores)?e.stores=[t]:n.push(t)}function Oo(t,e,n,r){e.value=n,e.getSnapshot=r,Lo(e)&&Mo(t)}function zo(t,e,n){return n((function(){Lo(e)&&Mo(t)}))}function Lo(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ir(t,n)}catch(r){return!0}}function Mo(t){var e=As(t,1);null!==e&&rc(e,t,1,-1)}function Po(t){var e=Eo();return"function"===typeof t&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:To,lastRenderedState:t},e.queue=t,t=t.dispatch=ni.bind(null,go,t),[e.memoizedState,t]}function Bo(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.lastEffect=t.next=t):null===(n=e.lastEffect)?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t),t}function Wo(){return Co().memoizedState}function Uo(t,e,n,r){var a=Eo();go.flags|=t,a.memoizedState=Bo(1|e,n,void 0,void 0===r?null:r)}function Vo(t,e,n,r){var a=Co();r=void 0===r?null:r;var s=void 0;if(null!==mo){var o=mo.memoizedState;if(s=o.destroy,null!==r&&So(r,o.deps))return void(a.memoizedState=Bo(e,n,s,r))}go.flags|=t,a.memoizedState=Bo(1|e,n,s,r)}function Go(t,e){return Uo(8390656,8,t,e)}function jo(t,e){return Vo(2048,8,t,e)}function Ho(t,e){return Vo(4,2,t,e)}function Ko(t,e){return Vo(4,4,t,e)}function qo(t,e){return"function"===typeof e?(t=t(),e(t),function(){e(null)}):null!==e&&void 0!==e?(t=t(),e.current=t,function(){e.current=null}):void 0}function Xo(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Vo(4,4,qo.bind(null,e,t),n)}function Jo(){}function Yo(t,e){var n=Co();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function Zo(t,e){var n=Co();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function Qo(t,e,n){return 0===(21&fo)?(t.baseState&&(t.baseState=!1,wi=!0),t.memoizedState=n):(ir(n,e)||(n=ge(),go.lanes|=n,Ml|=n,t.baseState=!0),e)}function $o(t,e){var n=ve;ve=0!==n&&4>n?n:4,t(!0);var r=po.transition;po.transition={};try{t(!1),e()}finally{ve=n,po.transition=r}}function ti(){return Co().memoizedState}function ei(t,e,n){var r=nc(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},ri(t))ai(e,n);else if(null!==(n=Ts(t,e,n,r))){rc(n,t,r,ec()),si(n,e,r)}}function ni(t,e,n){var r=nc(t),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(ri(t))ai(e,a);else{var s=t.alternate;if(0===t.lanes&&(null===s||0===s.lanes)&&null!==(s=e.lastRenderedReducer))try{var o=e.lastRenderedState,i=s(o,n);if(a.hasEagerState=!0,a.eagerState=i,ir(i,o)){var l=e.interleaved;return null===l?(a.next=a,Cs(e)):(a.next=l.next,l.next=a),void(e.interleaved=a)}}catch(c){}null!==(n=Ts(t,e,a,r))&&(rc(n,t,r,a=ec()),si(n,e,r))}}function ri(t){var e=t.alternate;return t===go||null!==e&&e===go}function ai(t,e){vo=yo=!0;var n=t.pending;null===n?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function si(t,e,n){if(0!==(4194240&n)){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}var oi={readContext:Ns,useCallback:ko,useContext:ko,useEffect:ko,useImperativeHandle:ko,useInsertionEffect:ko,useLayoutEffect:ko,useMemo:ko,useReducer:ko,useRef:ko,useState:ko,useDebugValue:ko,useDeferredValue:ko,useTransition:ko,useMutableSource:ko,useSyncExternalStore:ko,useId:ko,unstable_isNewReconciler:!1},ii={readContext:Ns,useCallback:function(t,e){return Eo().memoizedState=[t,void 0===e?null:e],t},useContext:Ns,useEffect:Go,useImperativeHandle:function(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Uo(4194308,4,qo.bind(null,e,t),n)},useLayoutEffect:function(t,e){return Uo(4194308,4,t,e)},useInsertionEffect:function(t,e){return Uo(4,2,t,e)},useMemo:function(t,e){var n=Eo();return e=void 0===e?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=Eo();return e=void 0!==n?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=ei.bind(null,go,t),[r.memoizedState,t]},useRef:function(t){return t={current:t},Eo().memoizedState=t},useState:Po,useDebugValue:Jo,useDeferredValue:function(t){return Eo().memoizedState=t},useTransition:function(){var t=Po(!1),e=t[0];return t=$o.bind(null,t[1]),Eo().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=go,a=Eo();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=e(),null===Rl)throw Error(s(349));0!==(30&fo)||Do(r,e,n)}a.memoizedState=n;var o={value:n,getSnapshot:e};return a.queue=o,Go(zo.bind(null,r,o,t),[t]),r.flags|=2048,Bo(9,Oo.bind(null,r,o,n,e),void 0,null),n},useId:function(){var t=Eo(),e=Rl.identifierPrefix;if(as){var n=Za;e=":"+e+"R"+(n=(Ya&~(1<<32-oe(Ya)-1)).toString(32)+n),0<(n=wo++)&&(e+="H"+n.toString(32)),e+=":"}else e=":"+e+"r"+(n=xo++).toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},li={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:jo,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ao,useRef:Wo,useState:function(){return Ao(To)},useDebugValue:Jo,useDeferredValue:function(t){return Qo(Co(),mo.memoizedState,t)},useTransition:function(){return[Ao(To)[0],Co().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1},ci={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:jo,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ro,useRef:Wo,useState:function(){return Ro(To)},useDebugValue:Jo,useDeferredValue:function(t){var e=Co();return null===mo?e.memoizedState=t:Qo(e,mo.memoizedState,t)},useTransition:function(){return[Ro(To)[0],Co().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1};function ui(t,e){try{var n="",r=e;do{n+=U(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:t,source:e,stack:a,digest:null}}function hi(t,e,n){return{value:t,source:null,stack:null!=n?n:null,digest:null!=e?e:null}}function di(t,e){try{console.error(e.value)}catch(n){setTimeout((function(){throw n}))}}var pi="function"===typeof WeakMap?WeakMap:Map;function fi(t,e,n){(n=Ds(-1,n)).tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){Hl||(Hl=!0,Kl=r),di(0,e)},n}function gi(t,e,n){(n=Ds(-1,n)).tag=3;var r=t.type.getDerivedStateFromError;if("function"===typeof r){var a=e.value;n.payload=function(){return r(a)},n.callback=function(){di(0,e)}}var s=t.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){di(0,e),"function"!==typeof r&&(null===ql?ql=new Set([this]):ql.add(this));var t=e.stack;this.componentDidCatch(e.value,{componentStack:null!==t?t:""})}),n}function mi(t,e,n){var r=t.pingCache;if(null===r){r=t.pingCache=new pi;var a=new Set;r.set(e,a)}else void 0===(a=r.get(e))&&(a=new Set,r.set(e,a));a.has(n)||(a.add(n),t=Ec.bind(null,t,e,n),e.then(t,t))}function bi(t){do{var e;if((e=13===t.tag)&&(e=null===(e=t.memoizedState)||null!==e.dehydrated),e)return t;t=t.return}while(null!==t);return null}function yi(t,e,n,r,a){return 0===(1&t.mode)?(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((e=Ds(-1,1)).tag=2,Os(n,e,1))),n.lanes|=1),t):(t.flags|=65536,t.lanes=a,t)}var vi=w.ReactCurrentOwner,wi=!1;function xi(t,e,n,r){e.child=null===t?Zs(e,null,n,r):Ys(e,t.child,n,r)}function ki(t,e,n,r,a){n=n.render;var s=e.ref;return Is(e,a),r=Io(t,e,n,r,s,a),n=No(),null===t||wi?(as&&n&&ts(e),e.flags|=1,xi(t,e,r,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Si(t,e,n,r,a){if(null===t){var s=n.type;return"function"!==typeof s||Dc(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((t=zc(n.type,null,r,e,e.mode,a)).ref=e.ref,t.return=e,e.child=t):(e.tag=15,e.type=s,Ii(t,e,s,r,a))}if(s=t.child,0===(t.lanes&a)){var o=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(o,r)&&t.ref===e.ref)return Hi(t,e,a)}return e.flags|=1,(t=Oc(s,r)).ref=e.ref,t.return=e,e.child=t}function Ii(t,e,n,r,a){if(null!==t){var s=t.memoizedProps;if(lr(s,r)&&t.ref===e.ref){if(wi=!1,e.pendingProps=r=s,0===(t.lanes&a))return e.lanes=t.lanes,Hi(t,e,a);0!==(131072&t.flags)&&(wi=!0)}}return Ci(t,e,n,r,a)}function Ni(t,e,n){var r=e.pendingProps,a=r.children,s=null!==t?t.memoizedState:null;if("hidden"===r.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ea(Ol,Dl),Dl|=n;else{if(0===(1073741824&n))return t=null!==s?s.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Ea(Ol,Dl),Dl|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Ea(Ol,Dl),Dl|=r}else null!==s?(r=s.baseLanes|n,e.memoizedState=null):r=n,Ea(Ol,Dl),Dl|=r;return xi(t,e,a,n),e.child}function Ei(t,e){var n=e.ref;(null===t&&null!==n||null!==t&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function Ci(t,e,n,r,a){var s=_a(n)?Ra:Ta.current;return s=Fa(e,s),Is(e,a),n=Io(t,e,n,r,s,a),r=No(),null===t||wi?(as&&r&&ts(e),e.flags|=1,xi(t,e,n,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Ti(t,e,n,r,a){if(_a(n)){var s=!0;La(e)}else s=!1;if(Is(e,a),null===e.stateNode)ji(t,e),Gs(e,n,r),Hs(e,n,r,a),r=!0;else if(null===t){var o=e.stateNode,i=e.memoizedProps;o.props=i;var l=o.context,c=n.contextType;"object"===typeof c&&null!==c?c=Ns(c):c=Fa(e,c=_a(n)?Ra:Ta.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof o.getSnapshotBeforeUpdate;h||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==r||l!==c)&&js(e,o,r,c),Rs=!1;var d=e.memoizedState;o.state=d,Ms(e,r,o,a),l=e.memoizedState,i!==r||d!==l||Aa.current||Rs?("function"===typeof u&&(Ws(e,n,u,r),l=e.memoizedState),(i=Rs||Vs(e,n,i,r,d,l,c))?(h||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(e.flags|=4194308)):("function"===typeof o.componentDidMount&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),o.props=r,o.state=l,o.context=c,r=i):("function"===typeof o.componentDidMount&&(e.flags|=4194308),r=!1)}else{o=e.stateNode,_s(t,e),i=e.memoizedProps,c=e.type===e.elementType?i:ms(e.type,i),o.props=c,h=e.pendingProps,d=o.context,"object"===typeof(l=n.contextType)&&null!==l?l=Ns(l):l=Fa(e,l=_a(n)?Ra:Ta.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==l)&&js(e,o,r,l),Rs=!1,d=e.memoizedState,o.state=d,Ms(e,r,o,a);var f=e.memoizedState;i!==h||d!==f||Aa.current||Rs?("function"===typeof p&&(Ws(e,n,p,r),f=e.memoizedState),(c=Rs||Vs(e,n,c,r,d,f,l)||!1)?(u||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(r,f,l),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof o.componentDidUpdate&&(e.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=f),o.props=r,o.state=f,o.context=l,r=c):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),r=!1)}return Ai(t,e,n,r,s,a)}function Ai(t,e,n,r,a,s){Ei(t,e);var o=0!==(128&e.flags);if(!r&&!o)return a&&Ma(e,n,!1),Hi(t,e,s);r=e.stateNode,vi.current=e;var i=o&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==t&&o?(e.child=Ys(e,t.child,null,s),e.child=Ys(e,null,i,s)):xi(t,e,i,s),e.memoizedState=r.state,a&&Ma(e,n,!0),e.child}function Ri(t){var e=t.stateNode;e.pendingContext?Oa(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Oa(0,e.context,!1),ro(t,e.containerInfo)}function Fi(t,e,n,r,a){return ps(),fs(a),e.flags|=256,xi(t,e,n,r),e.child}var _i,Di,Oi,zi,Li={dehydrated:null,treeContext:null,retryLane:0};function Mi(t){return{baseLanes:t,cachePool:null,transitions:null}}function Pi(t,e,n){var r,a=e.pendingProps,o=io.current,i=!1,l=0!==(128&e.flags);if((r=l)||(r=(null===t||null!==t.memoizedState)&&0!==(2&o)),r?(i=!0,e.flags&=-129):null!==t&&null===t.memoizedState||(o|=1),Ea(io,1&o),null===t)return cs(e),null!==(t=e.memoizedState)&&null!==(t=t.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===t.data?e.lanes=8:e.lanes=1073741824,null):(l=a.children,t=a.fallback,i?(a=e.mode,i=e.child,l={mode:"hidden",children:l},0===(1&a)&&null!==i?(i.childLanes=0,i.pendingProps=l):i=Mc(l,a,0,null),t=Lc(t,a,n,null),i.return=e,t.return=e,i.sibling=t,e.child=i,e.child.memoizedState=Mi(n),e.memoizedState=Li,t):Bi(e,l));if(null!==(o=t.memoizedState)&&null!==(r=o.dehydrated))return function(t,e,n,r,a,o,i){if(n)return 256&e.flags?(e.flags&=-257,Wi(t,e,i,r=hi(Error(s(422))))):null!==e.memoizedState?(e.child=t.child,e.flags|=128,null):(o=r.fallback,a=e.mode,r=Mc({mode:"visible",children:r.children},a,0,null),(o=Lc(o,a,i,null)).flags|=2,r.return=e,o.return=e,r.sibling=o,e.child=r,0!==(1&e.mode)&&Ys(e,t.child,null,i),e.child.memoizedState=Mi(i),e.memoizedState=Li,o);if(0===(1&e.mode))return Wi(t,e,i,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,Wi(t,e,i,r=hi(o=Error(s(419)),r,void 0))}if(l=0!==(i&t.childLanes),wi||l){if(null!==(r=Rl)){switch(i&-i){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|i))?0:a)&&a!==o.retryLane&&(o.retryLane=a,As(t,a),rc(r,t,a,-1))}return mc(),Wi(t,e,i,r=hi(Error(s(421))))}return"$?"===a.data?(e.flags|=128,e.child=t.child,e=Tc.bind(null,t),a._reactRetry=e,null):(t=o.treeContext,rs=ca(a.nextSibling),ns=e,as=!0,ss=null,null!==t&&(qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ya=t.id,Za=t.overflow,Ja=e),e=Bi(e,r.children),e.flags|=4096,e)}(t,e,l,a,r,o,n);if(i){i=a.fallback,l=e.mode,r=(o=t.child).sibling;var c={mode:"hidden",children:a.children};return 0===(1&l)&&e.child!==o?((a=e.child).childLanes=0,a.pendingProps=c,e.deletions=null):(a=Oc(o,c)).subtreeFlags=14680064&o.subtreeFlags,null!==r?i=Oc(r,i):(i=Lc(i,l,n,null)).flags|=2,i.return=e,a.return=e,a.sibling=i,e.child=a,a=i,i=e.child,l=null===(l=t.child.memoizedState)?Mi(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},i.memoizedState=l,i.childLanes=t.childLanes&~n,e.memoizedState=Li,a}return t=(i=t.child).sibling,a=Oc(i,{mode:"visible",children:a.children}),0===(1&e.mode)&&(a.lanes=n),a.return=e,a.sibling=null,null!==t&&(null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=a,e.memoizedState=null,a}function Bi(t,e){return(e=Mc({mode:"visible",children:e},t.mode,0,null)).return=t,t.child=e}function Wi(t,e,n,r){return null!==r&&fs(r),Ys(e,t.child,null,n),(t=Bi(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,t}function Ui(t,e,n){t.lanes|=e;var r=t.alternate;null!==r&&(r.lanes|=e),Ss(t.return,e,n)}function Vi(t,e,n,r,a){var s=t.memoizedState;null===s?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function Gi(t,e,n){var r=e.pendingProps,a=r.revealOrder,s=r.tail;if(xi(t,e,r.children,n),0!==(2&(r=io.current)))r=1&r|2,e.flags|=128;else{if(null!==t&&0!==(128&t.flags))t:for(t=e.child;null!==t;){if(13===t.tag)null!==t.memoizedState&&Ui(t,n,e);else if(19===t.tag)Ui(t,n,e);else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break t;for(;null===t.sibling;){if(null===t.return||t.return===e)break t;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(Ea(io,r),0===(1&e.mode))e.memoizedState=null;else switch(a){case"forwards":for(n=e.child,a=null;null!==n;)null!==(t=n.alternate)&&null===lo(t)&&(a=n),n=n.sibling;null===(n=a)?(a=e.child,e.child=null):(a=n.sibling,n.sibling=null),Vi(e,!1,a,n,s);break;case"backwards":for(n=null,a=e.child,e.child=null;null!==a;){if(null!==(t=a.alternate)&&null===lo(t)){e.child=a;break}t=a.sibling,a.sibling=n,n=a,a=t}Vi(e,!0,n,null,s);break;case"together":Vi(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function ji(t,e){0===(1&e.mode)&&null!==t&&(t.alternate=null,e.alternate=null,e.flags|=2)}function Hi(t,e,n){if(null!==t&&(e.dependencies=t.dependencies),Ml|=e.lanes,0===(n&e.childLanes))return null;if(null!==t&&e.child!==t.child)throw Error(s(153));if(null!==e.child){for(n=Oc(t=e.child,t.pendingProps),e.child=n,n.return=e;null!==t.sibling;)t=t.sibling,(n=n.sibling=Oc(t,t.pendingProps)).return=e;n.sibling=null}return e.child}function Ki(t,e){if(!as)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;null!==e;)null!==e.alternate&&(n=e),e=e.sibling;null===n?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?e||null===t.tail?t.tail=null:t.tail.sibling=null:r.sibling=null}}function qi(t){var e=null!==t.alternate&&t.alternate.child===t.child,n=0,r=0;if(e)for(var a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=t,a=a.sibling;else for(a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=t,a=a.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function Xi(t,e,n){var r=e.pendingProps;switch(es(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qi(e),null;case 1:case 17:return _a(e.type)&&Da(),qi(e),null;case 3:return r=e.stateNode,ao(),Na(Aa),Na(Ta),uo(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==t&&null!==t.child||(hs(e)?e.flags|=4:null===t||t.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ss&&(ic(ss),ss=null))),Di(t,e),qi(e),null;case 5:oo(e);var a=no(eo.current);if(n=e.type,null!==t&&null!=e.stateNode)Oi(t,e,n,r,a),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(null===e.stateNode)throw Error(s(166));return qi(e),null}if(t=no($s.current),hs(e)){r=e.stateNode,n=e.type;var o=e.memoizedProps;switch(r[da]=e,r[pa]=o,t=0!==(1&e.mode),n){case"dialog":Br("cancel",r),Br("close",r);break;case"iframe":case"object":case"embed":Br("load",r);break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],r);break;case"source":Br("error",r);break;case"img":case"image":case"link":Br("error",r),Br("load",r);break;case"details":Br("toggle",r);break;case"input":Y(r,o),Br("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},Br("invalid",r);break;case"textarea":at(r,o),Br("invalid",r)}for(var l in yt(n,o),a=null,o)if(o.hasOwnProperty(l)){var c=o[l];"children"===l?"string"===typeof c?r.textContent!==c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",c]):"number"===typeof c&&r.textContent!==""+c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",""+c]):i.hasOwnProperty(l)&&null!=c&&"onScroll"===l&&Br("scroll",r)}switch(n){case"input":K(r),$(r,o,!0);break;case"textarea":K(r),ot(r);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(r.onclick=$r)}r=a,e.updateQueue=r,null!==r&&(e.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===t&&(t=it(n)),"http://www.w3.org/1999/xhtml"===t?"script"===n?((t=l.createElement("div")).innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):"string"===typeof r.is?t=l.createElement(n,{is:r.is}):(t=l.createElement(n),"select"===n&&(l=t,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):t=l.createElementNS(t,n),t[da]=e,t[pa]=r,_i(t,e,!1,!1),e.stateNode=t;t:{switch(l=vt(n,r),n){case"dialog":Br("cancel",t),Br("close",t),a=r;break;case"iframe":case"object":case"embed":Br("load",t),a=r;break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],t);a=r;break;case"source":Br("error",t),a=r;break;case"img":case"image":case"link":Br("error",t),Br("load",t),a=r;break;case"details":Br("toggle",t),a=r;break;case"input":Y(t,r),a=J(t,r),Br("invalid",t);break;case"option":default:a=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},a=M({},r,{value:void 0}),Br("invalid",t);break;case"textarea":at(t,r),a=rt(t,r),Br("invalid",t)}for(o in yt(n,a),c=a)if(c.hasOwnProperty(o)){var u=c[o];"style"===o?mt(t,u):"dangerouslySetInnerHTML"===o?null!=(u=u?u.__html:void 0)&&ht(t,u):"children"===o?"string"===typeof u?("textarea"!==n||""!==u)&&dt(t,u):"number"===typeof u&&dt(t,""+u):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(i.hasOwnProperty(o)?null!=u&&"onScroll"===o&&Br("scroll",t):null!=u&&v(t,o,u,l))}switch(n){case"input":K(t),$(t,r,!1);break;case"textarea":K(t),ot(t);break;case"option":null!=r.value&&t.setAttribute("value",""+j(r.value));break;case"select":t.multiple=!!r.multiple,null!=(o=r.value)?nt(t,!!r.multiple,o,!1):null!=r.defaultValue&&nt(t,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(t.onclick=$r)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break t;case"img":r=!0;break t;default:r=!1}}r&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return qi(e),null;case 6:if(t&&null!=e.stateNode)zi(t,e,t.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(s(166));if(n=no(eo.current),no($s.current),hs(e)){if(r=e.stateNode,n=e.memoizedProps,r[da]=e,(o=r.nodeValue!==n)&&null!==(t=ns))switch(t.tag){case 3:Qr(r.nodeValue,n,0!==(1&t.mode));break;case 5:!0!==t.memoizedProps.suppressHydrationWarning&&Qr(r.nodeValue,n,0!==(1&t.mode))}o&&(e.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[da]=e,e.stateNode=r}return qi(e),null;case 13:if(Na(io),r=e.memoizedState,null===t||null!==t.memoizedState&&null!==t.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&e.mode)&&0===(128&e.flags))ds(),ps(),e.flags|=98560,o=!1;else if(o=hs(e),null!==r&&null!==r.dehydrated){if(null===t){if(!o)throw Error(s(318));if(!(o=null!==(o=e.memoizedState)?o.dehydrated:null))throw Error(s(317));o[da]=e}else ps(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;qi(e),o=!1}else null!==ss&&(ic(ss),ss=null),o=!0;if(!o)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=n,e):((r=null!==r)!==(null!==t&&null!==t.memoizedState)&&r&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===t||0!==(1&io.current)?0===zl&&(zl=3):mc())),null!==e.updateQueue&&(e.flags|=4),qi(e),null);case 4:return ao(),Di(t,e),null===t&&Vr(e.stateNode.containerInfo),qi(e),null;case 10:return ks(e.type._context),qi(e),null;case 19:if(Na(io),null===(o=e.memoizedState))return qi(e),null;if(r=0!==(128&e.flags),null===(l=o.rendering))if(r)Ki(o,!1);else{if(0!==zl||null!==t&&0!==(128&t.flags))for(t=e.child;null!==t;){if(null!==(l=lo(t))){for(e.flags|=128,Ki(o,!1),null!==(r=l.updateQueue)&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;null!==n;)t=r,(o=n).flags&=14680066,null===(l=o.alternate)?(o.childLanes=0,o.lanes=t,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=l.childLanes,o.lanes=l.lanes,o.child=l.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=l.memoizedProps,o.memoizedState=l.memoizedState,o.updateQueue=l.updateQueue,o.type=l.type,t=l.dependencies,o.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Ea(io,1&io.current|2),e.child}t=t.sibling}null!==o.tail&&Zt()>Gl&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304)}else{if(!r)if(null!==(t=lo(l))){if(e.flags|=128,r=!0,null!==(n=t.updateQueue)&&(e.updateQueue=n,e.flags|=4),Ki(o,!0),null===o.tail&&"hidden"===o.tailMode&&!l.alternate&&!as)return qi(e),null}else 2*Zt()-o.renderingStartTime>Gl&&1073741824!==n&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304);o.isBackwards?(l.sibling=e.child,e.child=l):(null!==(n=o.last)?n.sibling=l:e.child=l,o.last=l)}return null!==o.tail?(e=o.tail,o.rendering=e,o.tail=e.sibling,o.renderingStartTime=Zt(),e.sibling=null,n=io.current,Ea(io,r?1&n|2:1&n),e):(qi(e),null);case 22:case 23:return dc(),r=null!==e.memoizedState,null!==t&&null!==t.memoizedState!==r&&(e.flags|=8192),r&&0!==(1&e.mode)?0!==(1073741824&Dl)&&(qi(e),6&e.subtreeFlags&&(e.flags|=8192)):qi(e),null;case 24:case 25:return null}throw Error(s(156,e.tag))}function Ji(t,e){switch(es(e),e.tag){case 1:return _a(e.type)&&Da(),65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 3:return ao(),Na(Aa),Na(Ta),uo(),0!==(65536&(t=e.flags))&&0===(128&t)?(e.flags=-65537&t|128,e):null;case 5:return oo(e),null;case 13:if(Na(io),null!==(t=e.memoizedState)&&null!==t.dehydrated){if(null===e.alternate)throw Error(s(340));ps()}return 65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 19:return Na(io),null;case 4:return ao(),null;case 10:return ks(e.type._context),null;case 22:case 23:return dc(),null;default:return null}}_i=function(t,e){for(var n=e.child;null!==n;){if(5===n.tag||6===n.tag)t.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Di=function(){},Oi=function(t,e,n,r){var a=t.memoizedProps;if(a!==r){t=e.stateNode,no($s.current);var s,o=null;switch(n){case"input":a=J(t,a),r=J(t,r),o=[];break;case"select":a=M({},a,{value:void 0}),r=M({},r,{value:void 0}),o=[];break;case"textarea":a=rt(t,a),r=rt(t,r),o=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(t.onclick=$r)}for(u in yt(n,r),n=null,a)if(!r.hasOwnProperty(u)&&a.hasOwnProperty(u)&&null!=a[u])if("style"===u){var l=a[u];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in r){var c=r[u];if(l=null!=a?a[u]:void 0,r.hasOwnProperty(u)&&c!==l&&(null!=c||null!=l))if("style"===u)if(l){for(s in l)!l.hasOwnProperty(s)||c&&c.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in c)c.hasOwnProperty(s)&&l[s]!==c[s]&&(n||(n={}),n[s]=c[s])}else n||(o||(o=[]),o.push(u,n)),n=c;else"dangerouslySetInnerHTML"===u?(c=c?c.__html:void 0,l=l?l.__html:void 0,null!=c&&l!==c&&(o=o||[]).push(u,c)):"children"===u?"string"!==typeof c&&"number"!==typeof c||(o=o||[]).push(u,""+c):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=c&&"onScroll"===u&&Br("scroll",t),o||l===c||(o=[])):(o=o||[]).push(u,c))}n&&(o=o||[]).push("style",n);var u=o;(e.updateQueue=u)&&(e.flags|=4)}},zi=function(t,e,n,r){n!==r&&(e.flags|=4)};var Yi=!1,Zi=!1,Qi="function"===typeof WeakSet?WeakSet:Set,$i=null;function tl(t,e){var n=t.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Nc(t,e,r)}else n.current=null}function el(t,e,n){try{n()}catch(r){Nc(t,e,r)}}var nl=!1;function rl(t,e,n){var r=e.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&t)===t){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(e,n,s)}a=a.next}while(a!==r)}}function al(t,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function sl(t){var e=t.ref;if(null!==e){var n=t.stateNode;t.tag,t=n,"function"===typeof e?e(t):e.current=t}}function ol(t){var e=t.alternate;null!==e&&(t.alternate=null,ol(e)),t.child=null,t.deletions=null,t.sibling=null,5===t.tag&&(null!==(e=t.stateNode)&&(delete e[da],delete e[pa],delete e[ga],delete e[ma],delete e[ba])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function il(t){return 5===t.tag||3===t.tag||4===t.tag}function ll(t){t:for(;;){for(;null===t.sibling;){if(null===t.return||il(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue t;if(null===t.child||4===t.tag)continue t;t.child.return=t,t=t.child}if(!(2&t.flags))return t.stateNode}}function cl(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?8===n.nodeType?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(8===n.nodeType?(e=n.parentNode).insertBefore(t,n):(e=n).appendChild(t),null!==(n=n._reactRootContainer)&&void 0!==n||null!==e.onclick||(e.onclick=$r));else if(4!==r&&null!==(t=t.child))for(cl(t,e,n),t=t.sibling;null!==t;)cl(t,e,n),t=t.sibling}function ul(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(4!==r&&null!==(t=t.child))for(ul(t,e,n),t=t.sibling;null!==t;)ul(t,e,n),t=t.sibling}var hl=null,dl=!1;function pl(t,e,n){for(n=n.child;null!==n;)fl(t,e,n),n=n.sibling}function fl(t,e,n){if(se&&"function"===typeof se.onCommitFiberUnmount)try{se.onCommitFiberUnmount(ae,n)}catch(i){}switch(n.tag){case 5:Zi||tl(n,e);case 6:var r=hl,a=dl;hl=null,pl(t,e,n),dl=a,null!==(hl=r)&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?t.parentNode.removeChild(n):t.removeChild(n)):hl.removeChild(n.stateNode));break;case 18:null!==hl&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?la(t.parentNode,n):1===t.nodeType&&la(t,n),Ve(t)):la(hl,n.stateNode));break;case 4:r=hl,a=dl,hl=n.stateNode.containerInfo,dl=!0,pl(t,e,n),hl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Zi&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,o=s.destroy;s=s.tag,void 0!==o&&(0!==(2&s)||0!==(4&s))&&el(n,e,o),a=a.next}while(a!==r)}pl(t,e,n);break;case 1:if(!Zi&&(tl(n,e),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(i){Nc(n,e,i)}pl(t,e,n);break;case 21:pl(t,e,n);break;case 22:1&n.mode?(Zi=(r=Zi)||null!==n.memoizedState,pl(t,e,n),Zi=r):pl(t,e,n);break;default:pl(t,e,n)}}function gl(t){var e=t.updateQueue;if(null!==e){t.updateQueue=null;var n=t.stateNode;null===n&&(n=t.stateNode=new Qi),e.forEach((function(e){var r=Ac.bind(null,t,e);n.has(e)||(n.add(e),e.then(r,r))}))}}function ml(t,e){var n=e.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var o=t,i=e,l=i;t:for(;null!==l;){switch(l.tag){case 5:hl=l.stateNode,dl=!1;break t;case 3:case 4:hl=l.stateNode.containerInfo,dl=!0;break t}l=l.return}if(null===hl)throw Error(s(160));fl(o,i,a),hl=null,dl=!1;var c=a.alternate;null!==c&&(c.return=null),a.return=null}catch(u){Nc(a,e,u)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)bl(e,t),e=e.sibling}function bl(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(ml(e,t),yl(t),4&r){try{rl(3,t,t.return),al(3,t)}catch(m){Nc(t,t.return,m)}try{rl(5,t,t.return)}catch(m){Nc(t,t.return,m)}}break;case 1:ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return);break;case 5:if(ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return),32&t.flags){var a=t.stateNode;try{dt(a,"")}catch(m){Nc(t,t.return,m)}}if(4&r&&null!=(a=t.stateNode)){var o=t.memoizedProps,i=null!==n?n.memoizedProps:o,l=t.type,c=t.updateQueue;if(t.updateQueue=null,null!==c)try{"input"===l&&"radio"===o.type&&null!=o.name&&Z(a,o),vt(l,i);var u=vt(l,o);for(i=0;i<c.length;i+=2){var h=c[i],d=c[i+1];"style"===h?mt(a,d):"dangerouslySetInnerHTML"===h?ht(a,d):"children"===h?dt(a,d):v(a,h,d,u)}switch(l){case"input":Q(a,o);break;case"textarea":st(a,o);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!o.multiple;var f=o.value;null!=f?nt(a,!!o.multiple,f,!1):p!==!!o.multiple&&(null!=o.defaultValue?nt(a,!!o.multiple,o.defaultValue,!0):nt(a,!!o.multiple,o.multiple?[]:"",!1))}a[pa]=o}catch(m){Nc(t,t.return,m)}}break;case 6:if(ml(e,t),yl(t),4&r){if(null===t.stateNode)throw Error(s(162));a=t.stateNode,o=t.memoizedProps;try{a.nodeValue=o}catch(m){Nc(t,t.return,m)}}break;case 3:if(ml(e,t),yl(t),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ve(e.containerInfo)}catch(m){Nc(t,t.return,m)}break;case 4:default:ml(e,t),yl(t);break;case 13:ml(e,t),yl(t),8192&(a=t.child).flags&&(o=null!==a.memoizedState,a.stateNode.isHidden=o,!o||null!==a.alternate&&null!==a.alternate.memoizedState||(Vl=Zt())),4&r&&gl(t);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&t.mode?(Zi=(u=Zi)||h,ml(e,t),Zi=u):ml(e,t),yl(t),8192&r){if(u=null!==t.memoizedState,(t.stateNode.isHidden=u)&&!h&&0!==(1&t.mode))for($i=t,h=t.child;null!==h;){for(d=$i=h;null!==$i;){switch(f=(p=$i).child,p.tag){case 0:case 11:case 14:case 15:rl(4,p,p.return);break;case 1:tl(p,p.return);var g=p.stateNode;if("function"===typeof g.componentWillUnmount){r=p,n=p.return;try{e=r,g.props=e.memoizedProps,g.state=e.memoizedState,g.componentWillUnmount()}catch(m){Nc(r,n,m)}}break;case 5:tl(p,p.return);break;case 22:if(null!==p.memoizedState){kl(d);continue}}null!==f?(f.return=p,$i=f):kl(d)}h=h.sibling}t:for(h=null,d=t;;){if(5===d.tag){if(null===h){h=d;try{a=d.stateNode,u?"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none":(l=d.stateNode,i=void 0!==(c=d.memoizedProps.style)&&null!==c&&c.hasOwnProperty("display")?c.display:null,l.style.display=gt("display",i))}catch(m){Nc(t,t.return,m)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(m){Nc(t,t.return,m)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===t)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===t)break t;for(;null===d.sibling;){if(null===d.return||d.return===t)break t;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:ml(e,t),yl(t),4&r&&gl(t);case 21:}}function yl(t){var e=t.flags;if(2&e){try{t:{for(var n=t.return;null!==n;){if(il(n)){var r=n;break t}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(dt(a,""),r.flags&=-33),ul(t,ll(t),a);break;case 3:case 4:var o=r.stateNode.containerInfo;cl(t,ll(t),o);break;default:throw Error(s(161))}}catch(i){Nc(t,t.return,i)}t.flags&=-3}4096&e&&(t.flags&=-4097)}function vl(t,e,n){$i=t,wl(t,e,n)}function wl(t,e,n){for(var r=0!==(1&t.mode);null!==$i;){var a=$i,s=a.child;if(22===a.tag&&r){var o=null!==a.memoizedState||Yi;if(!o){var i=a.alternate,l=null!==i&&null!==i.memoizedState||Zi;i=Yi;var c=Zi;if(Yi=o,(Zi=l)&&!c)for($i=a;null!==$i;)l=(o=$i).child,22===o.tag&&null!==o.memoizedState?Sl(a):null!==l?(l.return=o,$i=l):Sl(a);for(;null!==s;)$i=s,wl(s,e,n),s=s.sibling;$i=a,Yi=i,Zi=c}xl(t)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,$i=s):xl(t)}}function xl(t){for(;null!==$i;){var e=$i;if(0!==(8772&e.flags)){var n=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Zi||al(5,e);break;case 1:var r=e.stateNode;if(4&e.flags&&!Zi)if(null===n)r.componentDidMount();else{var a=e.elementType===e.type?n.memoizedProps:ms(e.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var o=e.updateQueue;null!==o&&Ps(e,o,r);break;case 3:var i=e.updateQueue;if(null!==i){if(n=null,null!==e.child)switch(e.child.tag){case 5:case 1:n=e.child.stateNode}Ps(e,i,n)}break;case 5:var l=e.stateNode;if(null===n&&4&e.flags){n=l;var c=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var u=e.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Ve(d)}}}break;default:throw Error(s(163))}Zi||512&e.flags&&sl(e)}catch(p){Nc(e,e.return,p)}}if(e===t){$i=null;break}if(null!==(n=e.sibling)){n.return=e.return,$i=n;break}$i=e.return}}function kl(t){for(;null!==$i;){var e=$i;if(e===t){$i=null;break}var n=e.sibling;if(null!==n){n.return=e.return,$i=n;break}$i=e.return}}function Sl(t){for(;null!==$i;){var e=$i;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{al(4,e)}catch(l){Nc(e,n,l)}break;case 1:var r=e.stateNode;if("function"===typeof r.componentDidMount){var a=e.return;try{r.componentDidMount()}catch(l){Nc(e,a,l)}}var s=e.return;try{sl(e)}catch(l){Nc(e,s,l)}break;case 5:var o=e.return;try{sl(e)}catch(l){Nc(e,o,l)}}}catch(l){Nc(e,e.return,l)}if(e===t){$i=null;break}var i=e.sibling;if(null!==i){i.return=e.return,$i=i;break}$i=e.return}}var Il,Nl=Math.ceil,El=w.ReactCurrentDispatcher,Cl=w.ReactCurrentOwner,Tl=w.ReactCurrentBatchConfig,Al=0,Rl=null,Fl=null,_l=0,Dl=0,Ol=Ia(0),zl=0,Ll=null,Ml=0,Pl=0,Bl=0,Wl=null,Ul=null,Vl=0,Gl=1/0,jl=null,Hl=!1,Kl=null,ql=null,Xl=!1,Jl=null,Yl=0,Zl=0,Ql=null,$l=-1,tc=0;function ec(){return 0!==(6&Al)?Zt():-1!==$l?$l:$l=Zt()}function nc(t){return 0===(1&t.mode)?1:0!==(2&Al)&&0!==_l?_l&-_l:null!==gs.transition?(0===tc&&(tc=ge()),tc):0!==(t=ve)?t:t=void 0===(t=window.event)?16:Ye(t.type)}function rc(t,e,n,r){if(50<Zl)throw Zl=0,Ql=null,Error(s(185));be(t,n,r),0!==(2&Al)&&t===Rl||(t===Rl&&(0===(2&Al)&&(Pl|=n),4===zl&&lc(t,_l)),ac(t,r),1===n&&0===Al&&0===(1&e.mode)&&(Gl=Zt()+500,Ba&&Va()))}function ac(t,e){var n=t.callbackNode;!function(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,a=t.expirationTimes,s=t.pendingLanes;0<s;){var o=31-oe(s),i=1<<o,l=a[o];-1===l?0!==(i&n)&&0===(i&r)||(a[o]=pe(i,e)):l<=e&&(t.expiredLanes|=i),s&=~i}}(t,e);var r=de(t,t===Rl?_l:0);if(0===r)null!==n&&Xt(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(null!=n&&Xt(n),1===e)0===t.tag?function(t){Ba=!0,Ua(t)}(cc.bind(null,t)):Ua(cc.bind(null,t)),oa((function(){0===(6&Al)&&Va()})),n=null;else{switch(we(r)){case 1:n=$t;break;case 4:n=te;break;case 16:default:n=ee;break;case 536870912:n=re}n=Rc(n,sc.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function sc(t,e){if($l=-1,tc=0,0!==(6&Al))throw Error(s(327));var n=t.callbackNode;if(Sc()&&t.callbackNode!==n)return null;var r=de(t,t===Rl?_l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&t.expiredLanes)||e)e=bc(t,r);else{e=r;var a=Al;Al|=2;var o=gc();for(Rl===t&&_l===e||(jl=null,Gl=Zt()+500,pc(t,e));;)try{vc();break}catch(l){fc(t,l)}xs(),El.current=o,Al=a,null!==Fl?e=0:(Rl=null,_l=0,e=zl)}if(0!==e){if(2===e&&(0!==(a=fe(t))&&(r=a,e=oc(t,a))),1===e)throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;if(6===e)lc(t,r);else{if(a=t.current.alternate,0===(30&r)&&!function(t){for(var e=t;;){if(16384&e.flags){var n=e.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!ir(s(),a))return!1}catch(i){return!1}}}if(n=e.child,16384&e.subtreeFlags&&null!==n)n.return=e,e=n;else{if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(a)&&(2===(e=bc(t,r))&&(0!==(o=fe(t))&&(r=o,e=oc(t,o))),1===e))throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;switch(t.finishedWork=a,t.finishedLanes=r,e){case 0:case 1:throw Error(s(345));case 2:case 5:kc(t,Ul,jl);break;case 3:if(lc(t,r),(130023424&r)===r&&10<(e=Vl+500-Zt())){if(0!==de(t,0))break;if(((a=t.suspendedLanes)&r)!==r){ec(),t.pingedLanes|=t.suspendedLanes&a;break}t.timeoutHandle=ra(kc.bind(null,t,Ul,jl),e);break}kc(t,Ul,jl);break;case 4:if(lc(t,r),(4194240&r)===r)break;for(e=t.eventTimes,a=-1;0<r;){var i=31-oe(r);o=1<<i,(i=e[i])>a&&(a=i),r&=~o}if(r=a,10<(r=(120>(r=Zt()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Nl(r/1960))-r)){t.timeoutHandle=ra(kc.bind(null,t,Ul,jl),r);break}kc(t,Ul,jl);break;default:throw Error(s(329))}}}return ac(t,Zt()),t.callbackNode===n?sc.bind(null,t):null}function oc(t,e){var n=Wl;return t.current.memoizedState.isDehydrated&&(pc(t,e).flags|=256),2!==(t=bc(t,e))&&(e=Ul,Ul=n,null!==e&&ic(e)),t}function ic(t){null===Ul?Ul=t:Ul.push.apply(Ul,t)}function lc(t,e){for(e&=~Bl,e&=~Pl,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-oe(e),r=1<<n;t[n]=-1,e&=~r}}function cc(t){if(0!==(6&Al))throw Error(s(327));Sc();var e=de(t,0);if(0===(1&e))return ac(t,Zt()),null;var n=bc(t,e);if(0!==t.tag&&2===n){var r=fe(t);0!==r&&(e=r,n=oc(t,r))}if(1===n)throw n=Ll,pc(t,0),lc(t,e),ac(t,Zt()),n;if(6===n)throw Error(s(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,kc(t,Ul,jl),ac(t,Zt()),null}function uc(t,e){var n=Al;Al|=1;try{return t(e)}finally{0===(Al=n)&&(Gl=Zt()+500,Ba&&Va())}}function hc(t){null!==Jl&&0===Jl.tag&&0===(6&Al)&&Sc();var e=Al;Al|=1;var n=Tl.transition,r=ve;try{if(Tl.transition=null,ve=1,t)return t()}finally{ve=r,Tl.transition=n,0===(6&(Al=e))&&Va()}}function dc(){Dl=Ol.current,Na(Ol)}function pc(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(-1!==n&&(t.timeoutHandle=-1,aa(n)),null!==Fl)for(n=Fl.return;null!==n;){var r=n;switch(es(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:ao(),Na(Aa),Na(Ta),uo();break;case 5:oo(r);break;case 4:ao();break;case 13:case 19:Na(io);break;case 10:ks(r.type._context);break;case 22:case 23:dc()}n=n.return}if(Rl=t,Fl=t=Oc(t.current,null),_l=Dl=e,zl=0,Ll=null,Bl=Pl=Ml=0,Ul=Wl=null,null!==Es){for(e=0;e<Es.length;e++)if(null!==(r=(n=Es[e]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var o=s.next;s.next=a,r.next=o}n.pending=r}Es=null}return t}function fc(t,e){for(;;){var n=Fl;try{if(xs(),ho.current=oi,yo){for(var r=go.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}yo=!1}if(fo=0,bo=mo=go=null,vo=!1,wo=0,Cl.current=null,null===n||null===n.return){zl=1,Ll=e,Fl=null;break}t:{var o=t,i=n.return,l=n,c=e;if(e=_l,l.flags|=32768,null!==c&&"object"===typeof c&&"function"===typeof c.then){var u=c,h=l,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=bi(i);if(null!==f){f.flags&=-257,yi(f,i,l,0,e),1&f.mode&&mi(o,u,e),c=u;var g=(e=f).updateQueue;if(null===g){var m=new Set;m.add(c),e.updateQueue=m}else g.add(c);break t}if(0===(1&e)){mi(o,u,e),mc();break t}c=Error(s(426))}else if(as&&1&l.mode){var b=bi(i);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),yi(b,i,l,0,e),fs(ui(c,l));break t}}o=c=ui(c,l),4!==zl&&(zl=2),null===Wl?Wl=[o]:Wl.push(o),o=i;do{switch(o.tag){case 3:o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,fi(0,c,e));break t;case 1:l=c;var y=o.type,v=o.stateNode;if(0===(128&o.flags)&&("function"===typeof y.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===ql||!ql.has(v)))){o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,gi(o,l,e));break t}}o=o.return}while(null!==o)}xc(n)}catch(w){e=w,Fl===n&&null!==n&&(Fl=n=n.return);continue}break}}function gc(){var t=El.current;return El.current=oi,null===t?oi:t}function mc(){0!==zl&&3!==zl&&2!==zl||(zl=4),null===Rl||0===(268435455&Ml)&&0===(268435455&Pl)||lc(Rl,_l)}function bc(t,e){var n=Al;Al|=2;var r=gc();for(Rl===t&&_l===e||(jl=null,pc(t,e));;)try{yc();break}catch(a){fc(t,a)}if(xs(),Al=n,El.current=r,null!==Fl)throw Error(s(261));return Rl=null,_l=0,zl}function yc(){for(;null!==Fl;)wc(Fl)}function vc(){for(;null!==Fl&&!Jt();)wc(Fl)}function wc(t){var e=Il(t.alternate,t,Dl);t.memoizedProps=t.pendingProps,null===e?xc(t):Fl=e,Cl.current=null}function xc(t){var e=t;do{var n=e.alternate;if(t=e.return,0===(32768&e.flags)){if(null!==(n=Xi(n,e,Dl)))return void(Fl=n)}else{if(null!==(n=Ji(n,e)))return n.flags&=32767,void(Fl=n);if(null===t)return zl=6,void(Fl=null);t.flags|=32768,t.subtreeFlags=0,t.deletions=null}if(null!==(e=e.sibling))return void(Fl=e);Fl=e=t}while(null!==e);0===zl&&(zl=5)}function kc(t,e,n){var r=ve,a=Tl.transition;try{Tl.transition=null,ve=1,function(t,e,n,r){do{Sc()}while(null!==Jl);if(0!==(6&Al))throw Error(s(327));n=t.finishedWork;var a=t.finishedLanes;if(null===n)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(s(177));t.callbackNode=null,t.callbackPriority=0;var o=n.lanes|n.childLanes;if(function(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var a=31-oe(n),s=1<<a;e[a]=0,r[a]=-1,t[a]=-1,n&=~s}}(t,o),t===Rl&&(Fl=Rl=null,_l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||Xl||(Xl=!0,Rc(ee,(function(){return Sc(),null}))),o=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||o){o=Tl.transition,Tl.transition=null;var i=ve;ve=1;var l=Al;Al|=4,Cl.current=null,function(t,e){if(ta=je,pr(t=dr())){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else t:{var r=(n=(n=t.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch(x){n=null;break t}var i=0,l=-1,c=-1,u=0,h=0,d=t,p=null;e:for(;;){for(var f;d!==n||0!==a&&3!==d.nodeType||(l=i+a),d!==o||0!==r&&3!==d.nodeType||(c=i+r),3===d.nodeType&&(i+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===t)break e;if(p===n&&++u===a&&(l=i),p===o&&++h===r&&(c=i),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===c?null:{start:l,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(ea={focusedElem:t,selectionRange:n},je=!1,$i=e;null!==$i;)if(t=(e=$i).child,0!==(1028&e.subtreeFlags)&&null!==t)t.return=e,$i=t;else for(;null!==$i;){e=$i;try{var g=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==g){var m=g.memoizedProps,b=g.memoizedState,y=e.stateNode,v=y.getSnapshotBeforeUpdate(e.elementType===e.type?m:ms(e.type,m),b);y.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var w=e.stateNode.containerInfo;1===w.nodeType?w.textContent="":9===w.nodeType&&w.documentElement&&w.removeChild(w.documentElement);break;default:throw Error(s(163))}}catch(x){Nc(e,e.return,x)}if(null!==(t=e.sibling)){t.return=e.return,$i=t;break}$i=e.return}g=nl,nl=!1}(t,n),bl(n,t),fr(ea),je=!!ta,ea=ta=null,t.current=n,vl(n,t,a),Yt(),Al=l,ve=i,Tl.transition=o}else t.current=n;if(Xl&&(Xl=!1,Jl=t,Yl=a),o=t.pendingLanes,0===o&&(ql=null),function(t){if(se&&"function"===typeof se.onCommitFiberRoot)try{se.onCommitFiberRoot(ae,t,void 0,128===(128&t.current.flags))}catch(e){}}(n.stateNode),ac(t,Zt()),null!==e)for(r=t.onRecoverableError,n=0;n<e.length;n++)a=e[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(Hl)throw Hl=!1,t=Kl,Kl=null,t;0!==(1&Yl)&&0!==t.tag&&Sc(),o=t.pendingLanes,0!==(1&o)?t===Ql?Zl++:(Zl=0,Ql=t):Zl=0,Va()}(t,e,n,r)}finally{Tl.transition=a,ve=r}return null}function Sc(){if(null!==Jl){var t=we(Yl),e=Tl.transition,n=ve;try{if(Tl.transition=null,ve=16>t?16:t,null===Jl)var r=!1;else{if(t=Jl,Jl=null,Yl=0,0!==(6&Al))throw Error(s(331));var a=Al;for(Al|=4,$i=t.current;null!==$i;){var o=$i,i=o.child;if(0!==(16&$i.flags)){var l=o.deletions;if(null!==l){for(var c=0;c<l.length;c++){var u=l[c];for($i=u;null!==$i;){var h=$i;switch(h.tag){case 0:case 11:case 15:rl(8,h,o)}var d=h.child;if(null!==d)d.return=h,$i=d;else for(;null!==$i;){var p=(h=$i).sibling,f=h.return;if(ol(h),h===u){$i=null;break}if(null!==p){p.return=f,$i=p;break}$i=f}}}var g=o.alternate;if(null!==g){var m=g.child;if(null!==m){g.child=null;do{var b=m.sibling;m.sibling=null,m=b}while(null!==m)}}$i=o}}if(0!==(2064&o.subtreeFlags)&&null!==i)i.return=o,$i=i;else t:for(;null!==$i;){if(0!==(2048&(o=$i).flags))switch(o.tag){case 0:case 11:case 15:rl(9,o,o.return)}var y=o.sibling;if(null!==y){y.return=o.return,$i=y;break t}$i=o.return}}var v=t.current;for($i=v;null!==$i;){var w=(i=$i).child;if(0!==(2064&i.subtreeFlags)&&null!==w)w.return=i,$i=w;else t:for(i=v;null!==$i;){if(0!==(2048&(l=$i).flags))try{switch(l.tag){case 0:case 11:case 15:al(9,l)}}catch(k){Nc(l,l.return,k)}if(l===i){$i=null;break t}var x=l.sibling;if(null!==x){x.return=l.return,$i=x;break t}$i=l.return}}if(Al=a,Va(),se&&"function"===typeof se.onPostCommitFiberRoot)try{se.onPostCommitFiberRoot(ae,t)}catch(k){}r=!0}return r}finally{ve=n,Tl.transition=e}}return!1}function Ic(t,e,n){t=Os(t,e=fi(0,e=ui(n,e),1),1),e=ec(),null!==t&&(be(t,1,e),ac(t,e))}function Nc(t,e,n){if(3===t.tag)Ic(t,t,n);else for(;null!==e;){if(3===e.tag){Ic(e,t,n);break}if(1===e.tag){var r=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===ql||!ql.has(r))){e=Os(e,t=gi(e,t=ui(n,t),1),1),t=ec(),null!==e&&(be(e,1,t),ac(e,t));break}}e=e.return}}function Ec(t,e,n){var r=t.pingCache;null!==r&&r.delete(e),e=ec(),t.pingedLanes|=t.suspendedLanes&n,Rl===t&&(_l&n)===n&&(4===zl||3===zl&&(130023424&_l)===_l&&500>Zt()-Vl?pc(t,0):Bl|=n),ac(t,e)}function Cc(t,e){0===e&&(0===(1&t.mode)?e=1:(e=ue,0===(130023424&(ue<<=1))&&(ue=4194304)));var n=ec();null!==(t=As(t,e))&&(be(t,e,n),ac(t,n))}function Tc(t){var e=t.memoizedState,n=0;null!==e&&(n=e.retryLane),Cc(t,n)}function Ac(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,a=t.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(e),Cc(t,n)}function Rc(t,e){return qt(t,e)}function Fc(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _c(t,e,n,r){return new Fc(t,e,n,r)}function Dc(t){return!(!(t=t.prototype)||!t.isReactComponent)}function Oc(t,e){var n=t.alternate;return null===n?((n=_c(t.tag,e,t.key,t.mode)).elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&t.flags,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function zc(t,e,n,r,a,o){var i=2;if(r=t,"function"===typeof t)Dc(t)&&(i=1);else if("string"===typeof t)i=5;else t:switch(t){case S:return Lc(n.children,a,o,e);case I:i=8,a|=8;break;case N:return(t=_c(12,n,e,2|a)).elementType=N,t.lanes=o,t;case A:return(t=_c(13,n,e,a)).elementType=A,t.lanes=o,t;case R:return(t=_c(19,n,e,a)).elementType=R,t.lanes=o,t;case D:return Mc(n,a,o,e);default:if("object"===typeof t&&null!==t)switch(t.$$typeof){case E:i=10;break t;case C:i=9;break t;case T:i=11;break t;case F:i=14;break t;case _:i=16,r=null;break t}throw Error(s(130,null==t?t:typeof t,""))}return(e=_c(i,n,e,a)).elementType=t,e.type=r,e.lanes=o,e}function Lc(t,e,n,r){return(t=_c(7,t,r,e)).lanes=n,t}function Mc(t,e,n,r){return(t=_c(22,t,r,e)).elementType=D,t.lanes=n,t.stateNode={isHidden:!1},t}function Pc(t,e,n){return(t=_c(6,t,null,e)).lanes=n,t}function Bc(t,e,n){return(e=_c(4,null!==t.children?t.children:[],t.key,e)).lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function Wc(t,e,n,r,a){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=me(0),this.expirationTimes=me(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=me(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Uc(t,e,n,r,a,s,o,i,l){return t=new Wc(t,e,n,i,l),1===e?(e=1,!0===s&&(e|=8)):e=0,s=_c(3,null,null,e),t.current=s,s.stateNode=t,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fs(s),t}function Vc(t){if(!t)return Ca;t:{if(Vt(t=t._reactInternals)!==t||1!==t.tag)throw Error(s(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break t;case 1:if(_a(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break t}}e=e.return}while(null!==e);throw Error(s(171))}if(1===t.tag){var n=t.type;if(_a(n))return za(t,n,e)}return e}function Gc(t,e,n,r,a,s,o,i,l){return(t=Uc(n,r,!0,t,0,s,0,i,l)).context=Vc(null),n=t.current,(s=Ds(r=ec(),a=nc(n))).callback=void 0!==e&&null!==e?e:null,Os(n,s,a),t.current.lanes=a,be(t,a,r),ac(t,r),t}function jc(t,e,n,r){var a=e.current,s=ec(),o=nc(a);return n=Vc(n),null===e.context?e.context=n:e.pendingContext=n,(e=Ds(s,o)).payload={element:t},null!==(r=void 0===r?null:r)&&(e.callback=r),null!==(t=Os(a,e,o))&&(rc(t,a,o,s),zs(t,a,o)),o}function Hc(t){return(t=t.current).child?(t.child.tag,t.child.stateNode):null}function Kc(t,e){if(null!==(t=t.memoizedState)&&null!==t.dehydrated){var n=t.retryLane;t.retryLane=0!==n&&n<e?n:e}}function qc(t,e){Kc(t,e),(t=t.alternate)&&Kc(t,e)}Il=function(t,e,n){if(null!==t)if(t.memoizedProps!==e.pendingProps||Aa.current)wi=!0;else{if(0===(t.lanes&n)&&0===(128&e.flags))return wi=!1,function(t,e,n){switch(e.tag){case 3:Ri(e),ps();break;case 5:so(e);break;case 1:_a(e.type)&&La(e);break;case 4:ro(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,a=e.memoizedProps.value;Ea(bs,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=e.memoizedState))return null!==r.dehydrated?(Ea(io,1&io.current),e.flags|=128,null):0!==(n&e.child.childLanes)?Pi(t,e,n):(Ea(io,1&io.current),null!==(t=Hi(t,e,n))?t.sibling:null);Ea(io,1&io.current);break;case 19:if(r=0!==(n&e.childLanes),0!==(128&t.flags)){if(r)return Gi(t,e,n);e.flags|=128}if(null!==(a=e.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ea(io,io.current),r)break;return null;case 22:case 23:return e.lanes=0,Ni(t,e,n)}return Hi(t,e,n)}(t,e,n);wi=0!==(131072&t.flags)}else wi=!1,as&&0!==(1048576&e.flags)&&$a(e,Ka,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;ji(t,e),t=e.pendingProps;var a=Fa(e,Ta.current);Is(e,n),a=Io(null,e,r,t,a,n);var o=No();return e.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,_a(r)?(o=!0,La(e)):o=!1,e.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Fs(e),a.updater=Us,e.stateNode=a,a._reactInternals=e,Hs(e,r,t,n),e=Ai(null,e,r,!0,o,n)):(e.tag=0,as&&o&&ts(e),xi(null,e,a,n),e=e.child),e;case 16:r=e.elementType;t:{switch(ji(t,e),t=e.pendingProps,r=(a=r._init)(r._payload),e.type=r,a=e.tag=function(t){if("function"===typeof t)return Dc(t)?1:0;if(void 0!==t&&null!==t){if((t=t.$$typeof)===T)return 11;if(t===F)return 14}return 2}(r),t=ms(r,t),a){case 0:e=Ci(null,e,r,t,n);break t;case 1:e=Ti(null,e,r,t,n);break t;case 11:e=ki(null,e,r,t,n);break t;case 14:e=Si(null,e,r,ms(r.type,t),n);break t}throw Error(s(306,r,""))}return e;case 0:return r=e.type,a=e.pendingProps,Ci(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 1:return r=e.type,a=e.pendingProps,Ti(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 3:t:{if(Ri(e),null===t)throw Error(s(387));r=e.pendingProps,a=(o=e.memoizedState).element,_s(t,e),Ms(e,r,null,n);var i=e.memoizedState;if(r=i.element,o.isDehydrated){if(o={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},e.updateQueue.baseState=o,e.memoizedState=o,256&e.flags){e=Fi(t,e,r,n,a=ui(Error(s(423)),e));break t}if(r!==a){e=Fi(t,e,r,n,a=ui(Error(s(424)),e));break t}for(rs=ca(e.stateNode.containerInfo.firstChild),ns=e,as=!0,ss=null,n=Zs(e,null,r,n),e.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){e=Hi(t,e,n);break t}xi(t,e,r,n)}e=e.child}return e;case 5:return so(e),null===t&&cs(e),r=e.type,a=e.pendingProps,o=null!==t?t.memoizedProps:null,i=a.children,na(r,a)?i=null:null!==o&&na(r,o)&&(e.flags|=32),Ei(t,e),xi(t,e,i,n),e.child;case 6:return null===t&&cs(e),null;case 13:return Pi(t,e,n);case 4:return ro(e,e.stateNode.containerInfo),r=e.pendingProps,null===t?e.child=Ys(e,null,r,n):xi(t,e,r,n),e.child;case 11:return r=e.type,a=e.pendingProps,ki(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 7:return xi(t,e,e.pendingProps,n),e.child;case 8:case 12:return xi(t,e,e.pendingProps.children,n),e.child;case 10:t:{if(r=e.type._context,a=e.pendingProps,o=e.memoizedProps,i=a.value,Ea(bs,r._currentValue),r._currentValue=i,null!==o)if(ir(o.value,i)){if(o.children===a.children&&!Aa.current){e=Hi(t,e,n);break t}}else for(null!==(o=e.child)&&(o.return=e);null!==o;){var l=o.dependencies;if(null!==l){i=o.child;for(var c=l.firstContext;null!==c;){if(c.context===r){if(1===o.tag){(c=Ds(-1,n&-n)).tag=2;var u=o.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?c.next=c:(c.next=h.next,h.next=c),u.pending=c}}o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Ss(o.return,n,e),l.lanes|=n;break}c=c.next}}else if(10===o.tag)i=o.type===e.type?null:o.child;else if(18===o.tag){if(null===(i=o.return))throw Error(s(341));i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Ss(i,n,e),i=o.sibling}else i=o.child;if(null!==i)i.return=o;else for(i=o;null!==i;){if(i===e){i=null;break}if(null!==(o=i.sibling)){o.return=i.return,i=o;break}i=i.return}o=i}xi(t,e,a.children,n),e=e.child}return e;case 9:return a=e.type,r=e.pendingProps.children,Is(e,n),r=r(a=Ns(a)),e.flags|=1,xi(t,e,r,n),e.child;case 14:return a=ms(r=e.type,e.pendingProps),Si(t,e,r,a=ms(r.type,a),n);case 15:return Ii(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,a=e.pendingProps,a=e.elementType===r?a:ms(r,a),ji(t,e),e.tag=1,_a(r)?(t=!0,La(e)):t=!1,Is(e,n),Gs(e,r,a),Hs(e,r,a,n),Ai(null,e,r,!0,t,n);case 19:return Gi(t,e,n);case 22:return Ni(t,e,n)}throw Error(s(156,e.tag))};var Xc="function"===typeof reportError?reportError:function(t){console.error(t)};function Jc(t){this._internalRoot=t}function Yc(t){this._internalRoot=t}function Zc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)}function Qc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType&&(8!==t.nodeType||" react-mount-point-unstable "!==t.nodeValue))}function $c(){}function tu(t,e,n,r,a){var s=n._reactRootContainer;if(s){var o=s;if("function"===typeof a){var i=a;a=function(){var t=Hc(o);i.call(t)}}jc(e,o,t,a)}else o=function(t,e,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var t=Hc(o);s.call(t)}}var o=Gc(e,r,t,0,null,!1,0,"",$c);return t._reactRootContainer=o,t[fa]=o.current,Vr(8===t.nodeType?t.parentNode:t),hc(),o}for(;a=t.lastChild;)t.removeChild(a);if("function"===typeof r){var i=r;r=function(){var t=Hc(l);i.call(t)}}var l=Uc(t,0,!1,null,0,!1,0,"",$c);return t._reactRootContainer=l,t[fa]=l.current,Vr(8===t.nodeType?t.parentNode:t),hc((function(){jc(e,l,n,r)})),l}(n,e,t,a,r);return Hc(o)}Yc.prototype.render=Jc.prototype.render=function(t){var e=this._internalRoot;if(null===e)throw Error(s(409));jc(t,e,null,null)},Yc.prototype.unmount=Jc.prototype.unmount=function(){var t=this._internalRoot;if(null!==t){this._internalRoot=null;var e=t.containerInfo;hc((function(){jc(null,t,null,null)})),e[fa]=null}},Yc.prototype.unstable_scheduleHydration=function(t){if(t){var e=Ie();t={blockedOn:null,target:t,priority:e};for(var n=0;n<De.length&&0!==e&&e<De[n].priority;n++);De.splice(n,0,t),0===n&&Me(t)}},xe=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=he(e.pendingLanes);0!==n&&(ye(e,1|n),ac(e,Zt()),0===(6&Al)&&(Gl=Zt()+500,Va()))}break;case 13:hc((function(){var e=As(t,1);if(null!==e){var n=ec();rc(e,t,1,n)}})),qc(t,1)}},ke=function(t){if(13===t.tag){var e=As(t,134217728);if(null!==e)rc(e,t,134217728,ec());qc(t,134217728)}},Se=function(t){if(13===t.tag){var e=nc(t),n=As(t,e);if(null!==n)rc(n,t,e,ec());qc(t,e)}},Ie=function(){return ve},Ne=function(t,e){var n=ve;try{return ve=t,e()}finally{ve=n}},kt=function(t,e,n){switch(e){case"input":if(Q(t,n),e=n.name,"radio"===n.type&&null!=e){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var a=xa(r);if(!a)throw Error(s(90));q(r),Q(r,a)}}}break;case"textarea":st(t,n);break;case"select":null!=(e=n.value)&&nt(t,!!n.multiple,e,!1)}},Tt=uc,At=hc;var eu={usingClientEntryPoint:!1,Events:[va,wa,xa,Et,Ct,uc]},nu={findFiberByHostInstance:ya,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},ru={bundleType:nu.bundleType,version:nu.version,rendererPackageName:nu.rendererPackageName,rendererConfig:nu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:w.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return null===(t=Ht(t))?null:t.stateNode},findFiberByHostInstance:nu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{ae=au.inject(ru),se=au}catch(ut){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,e.createPortal=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Zc(e))throw Error(s(200));return function(t,e,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:t,containerInfo:e,implementation:n}}(t,e,null,n)},e.createRoot=function(t,e){if(!Zc(t))throw Error(s(299));var n=!1,r="",a=Xc;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(n=!0),void 0!==e.identifierPrefix&&(r=e.identifierPrefix),void 0!==e.onRecoverableError&&(a=e.onRecoverableError)),e=Uc(t,1,!1,null,0,n,0,r,a),t[fa]=e.current,Vr(8===t.nodeType?t.parentNode:t),new Jc(e)},e.findDOMNode=function(t){if(null==t)return null;if(1===t.nodeType)return t;var e=t._reactInternals;if(void 0===e){if("function"===typeof t.render)throw Error(s(188));throw t=Object.keys(t).join(","),Error(s(268,t))}return t=null===(t=Ht(e))?null:t.stateNode},e.flushSync=function(t){return hc(t)},e.hydrate=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!0,n)},e.hydrateRoot=function(t,e,n){if(!Zc(t))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,o="",i=Xc;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(o=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),e=Gc(e,null,t,1,null!=n?n:null,a,0,o,i),t[fa]=e.current,Vr(t),r)for(t=0;t<r.length;t++)a=(a=(n=r[t])._getVersion)(n._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[n,a]:e.mutableSourceEagerHydrationData.push(n,a);return new Yc(e)},e.render=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!1,n)},e.unmountComponentAtNode=function(t){if(!Qc(t))throw Error(s(40));return!!t._reactRootContainer&&(hc((function(){tu(null,null,t,!1,(function(){t._reactRootContainer=null,t[fa]=null}))})),!0)},e.unstable_batchedUpdates=uc,e.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!Qc(n))throw Error(s(200));if(null==t||void 0===t._reactInternals)throw Error(s(38));return tu(t,e,n,!1,r)},e.version="18.2.0-next-9e3b772b8-20220608"},4391:(t,e,n)=>{"use strict";var r=n(7950);e.createRoot=r.createRoot,e.hydrateRoot=r.hydrateRoot},7950:(t,e,n)=>{"use strict";!function t(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}(),t.exports=n(2730)},1153:(t,e,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,i=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(t,e,n){var r,s={},c=null,u=null;for(r in void 0!==n&&(c=""+n),void 0!==e.key&&(c=""+e.key),void 0!==e.ref&&(u=e.ref),e)o.call(e,r)&&!l.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps)void 0===s[r]&&(s[r]=e[r]);return{$$typeof:a,type:t,key:c,ref:u,props:s,_owner:i.current}}e.Fragment=s,e.jsx=c,e.jsxs=c},4202:(t,e)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),l=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}function y(){}function v(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(t,e){if("object"!==typeof t&&"function"!==typeof t&&null!=t)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},b.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")},y.prototype=b.prototype;var w=v.prototype=new y;w.constructor=v,g(w,b.prototype),w.isPureReactComponent=!0;var x=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(t,e,r){var a,s={},o=null,i=null;if(null!=e)for(a in void 0!==e.ref&&(i=e.ref),void 0!==e.key&&(o=""+e.key),e)k.call(e,a)&&!I.hasOwnProperty(a)&&(s[a]=e[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var c=Array(l),u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}if(t&&t.defaultProps)for(a in l=t.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:t,key:o,ref:i,props:s,_owner:S.current}}function E(t){return"object"===typeof t&&null!==t&&t.$$typeof===n}var C=/\/+/g;function T(t,e){return"object"===typeof t&&null!==t&&null!=t.key?function(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,(function(t){return e[t]}))}(""+t.key):e.toString(36)}function A(t,e,a,s,o){var i=typeof t;"undefined"!==i&&"boolean"!==i||(t=null);var l=!1;if(null===t)l=!0;else switch(i){case"string":case"number":l=!0;break;case"object":switch(t.$$typeof){case n:case r:l=!0}}if(l)return o=o(l=t),t=""===s?"."+T(l,0):s,x(o)?(a="",null!=t&&(a=t.replace(C,"$&/")+"/"),A(o,e,a,"",(function(t){return t}))):null!=o&&(E(o)&&(o=function(t,e){return{$$typeof:n,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}(o,a+(!o.key||l&&l.key===o.key?"":(""+o.key).replace(C,"$&/")+"/")+t)),e.push(o)),1;if(l=0,s=""===s?".":s+":",x(t))for(var c=0;c<t.length;c++){var u=s+T(i=t[c],c);l+=A(i,e,a,u,o)}else if(u=function(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=p&&t[p]||t["@@iterator"])?t:null}(t),"function"===typeof u)for(t=u.call(t),c=0;!(i=t.next()).done;)l+=A(i=i.value,e,a,u=s+T(i,c++),o);else if("object"===i)throw e=String(t),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return l}function R(t,e,n){if(null==t)return t;var r=[],a=0;return A(t,r,"","",(function(t){return e.call(n,t,a++)})),r}function F(t){if(-1===t._status){var e=t._result;(e=e()).then((function(e){0!==t._status&&-1!==t._status||(t._status=1,t._result=e)}),(function(e){0!==t._status&&-1!==t._status||(t._status=2,t._result=e)})),-1===t._status&&(t._status=0,t._result=e)}if(1===t._status)return t._result.default;throw t._result}var _={current:null},D={transition:null},O={ReactCurrentDispatcher:_,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};e.Children={map:R,forEach:function(t,e,n){R(t,(function(){e.apply(this,arguments)}),n)},count:function(t){var e=0;return R(t,(function(){e++})),e},toArray:function(t){return R(t,(function(t){return t}))||[]},only:function(t){if(!E(t))throw Error("React.Children.only expected to receive a single React element child.");return t}},e.Component=b,e.Fragment=a,e.Profiler=o,e.PureComponent=v,e.StrictMode=s,e.Suspense=u,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,e.cloneElement=function(t,e,r){if(null===t||void 0===t)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var a=g({},t.props),s=t.key,o=t.ref,i=t._owner;if(null!=e){if(void 0!==e.ref&&(o=e.ref,i=S.current),void 0!==e.key&&(s=""+e.key),t.type&&t.type.defaultProps)var l=t.type.defaultProps;for(c in e)k.call(e,c)&&!I.hasOwnProperty(c)&&(a[c]=void 0===e[c]&&void 0!==l?l[c]:e[c])}var c=arguments.length-2;if(1===c)a.children=r;else if(1<c){l=Array(c);for(var u=0;u<c;u++)l[u]=arguments[u+2];a.children=l}return{$$typeof:n,type:t.type,key:s,ref:o,props:a,_owner:i}},e.createContext=function(t){return(t={$$typeof:l,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:t},t.Consumer=t},e.createElement=N,e.createFactory=function(t){var e=N.bind(null,t);return e.type=t,e},e.createRef=function(){return{current:null}},e.forwardRef=function(t){return{$$typeof:c,render:t}},e.isValidElement=E,e.lazy=function(t){return{$$typeof:d,_payload:{_status:-1,_result:t},_init:F}},e.memo=function(t,e){return{$$typeof:h,type:t,compare:void 0===e?null:e}},e.startTransition=function(t){var e=D.transition;D.transition={};try{t()}finally{D.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(t,e){return _.current.useCallback(t,e)},e.useContext=function(t){return _.current.useContext(t)},e.useDebugValue=function(){},e.useDeferredValue=function(t){return _.current.useDeferredValue(t)},e.useEffect=function(t,e){return _.current.useEffect(t,e)},e.useId=function(){return _.current.useId()},e.useImperativeHandle=function(t,e,n){return _.current.useImperativeHandle(t,e,n)},e.useInsertionEffect=function(t,e){return _.current.useInsertionEffect(t,e)},e.useLayoutEffect=function(t,e){return _.current.useLayoutEffect(t,e)},e.useMemo=function(t,e){return _.current.useMemo(t,e)},e.useReducer=function(t,e,n){return _.current.useReducer(t,e,n)},e.useRef=function(t){return _.current.useRef(t)},e.useState=function(t){return _.current.useState(t)},e.useSyncExternalStore=function(t,e,n){return _.current.useSyncExternalStore(t,e,n)},e.useTransition=function(){return _.current.useTransition()},e.version="18.2.0"},5043:(t,e,n)=>{"use strict";t.exports=n(4202)},579:(t,e,n)=>{"use strict";t.exports=n(1153)},7234:(t,e)=>{"use strict";function n(t,e){var n=t.length;t.push(e);t:for(;0<n;){var r=n-1>>>1,a=t[r];if(!(0<s(a,e)))break t;t[r]=e,t[n]=a,n=r}}function r(t){return 0===t.length?null:t[0]}function a(t){if(0===t.length)return null;var e=t[0],n=t.pop();if(n!==e){t[0]=n;t:for(var r=0,a=t.length,o=a>>>1;r<o;){var i=2*(r+1)-1,l=t[i],c=i+1,u=t[c];if(0>s(l,n))c<a&&0>s(u,l)?(t[r]=u,t[c]=n,r=c):(t[r]=l,t[i]=n,r=i);else{if(!(c<a&&0>s(u,n)))break t;t[r]=u,t[c]=n,r=c}}}return e}function s(t,e){var n=t.sortIndex-e.sortIndex;return 0!==n?n:t.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var o=performance;e.unstable_now=function(){return o.now()}}else{var i=Date,l=i.now();e.unstable_now=function(){return i.now()-l}}var c=[],u=[],h=1,d=null,p=3,f=!1,g=!1,m=!1,b="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function w(t){for(var e=r(u);null!==e;){if(null===e.callback)a(u);else{if(!(e.startTime<=t))break;a(u),e.sortIndex=e.expirationTime,n(c,e)}e=r(u)}}function x(t){if(m=!1,w(t),!g)if(null!==r(c))g=!0,D(k);else{var e=r(u);null!==e&&O(x,e.startTime-t)}}function k(t,n){g=!1,m&&(m=!1,y(E),E=-1),f=!0;var s=p;try{for(w(n),d=r(c);null!==d&&(!(d.expirationTime>n)||t&&!A());){var o=d.callback;if("function"===typeof o){d.callback=null,p=d.priorityLevel;var i=o(d.expirationTime<=n);n=e.unstable_now(),"function"===typeof i?d.callback=i:d===r(c)&&a(c),w(n)}else a(c);d=r(c)}if(null!==d)var l=!0;else{var h=r(u);null!==h&&O(x,h.startTime-n),l=!1}return l}finally{d=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,E=-1,C=5,T=-1;function A(){return!(e.unstable_now()-T<C)}function R(){if(null!==N){var t=e.unstable_now();T=t;var n=!0;try{n=N(!0,t)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"===typeof v)S=function(){v(R)};else if("undefined"!==typeof MessageChannel){var F=new MessageChannel,_=F.port2;F.port1.onmessage=R,S=function(){_.postMessage(null)}}else S=function(){b(R,0)};function D(t){N=t,I||(I=!0,S())}function O(t,n){E=b((function(){t(e.unstable_now())}),n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(t){t.callback=null},e.unstable_continueExecution=function(){g||f||(g=!0,D(k))},e.unstable_forceFrameRate=function(t){0>t||125<t?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<t?Math.floor(1e3/t):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(c)},e.unstable_next=function(t){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var n=p;p=e;try{return t()}finally{p=n}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(t,e){switch(t){case 1:case 2:case 3:case 4:case 5:break;default:t=3}var n=p;p=t;try{return e()}finally{p=n}},e.unstable_scheduleCallback=function(t,a,s){var o=e.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?o+s:o:s=o,t){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return t={id:h++,callback:a,priorityLevel:t,startTime:s,expirationTime:i=s+i,sortIndex:-1},s>o?(t.sortIndex=s,n(u,t),null===r(c)&&t===r(u)&&(m?(y(E),E=-1):m=!0,O(x,s-o))):(t.sortIndex=i,n(c,t),g||f||(g=!0,D(k))),t},e.unstable_shouldYield=A,e.unstable_wrapCallback=function(t){var e=p;return function(){var n=p;p=e;try{return t.apply(this,arguments)}finally{p=n}}}},8853:(t,e,n)=>{"use strict";t.exports=n(7234)},4334:(t,e,n)=>{var r=n(7359),a=n(7066),s=n(9016),o=n(9538),i=n(6288),l=n(5262),c=n(2430);c.alea=r,c.xor128=a,c.xorwow=s,c.xorshift7=o,c.xor4096=i,c.tychei=l,t.exports=c},7359:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n=function(){var t=4022871197,e=function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)};return e}();e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=n(" "),e.s1=n(" "),e.s2=n(" "),e.s0-=n(t),e.s0<0&&(e.s0+=1),e.s1-=n(t),e.s1<0&&(e.s1+=1),e.s2-=n(t),e.s2<0&&(e.s2+=1),n=null}function i(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},5262:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,a=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^a,e.a=a-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},7066:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},6288:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.w,a=e.X,s=e.i;return e.w=r=r+1640531527|0,n=a[s+34&127],t=a[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=a[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,a,s,o,i=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),a=0,s=-32;s<l;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(n=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(e&&e.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;t.w=o,t.X=i,t.i=a}(e,t)}function i(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},9538:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.x,a=e.i;return t=r[a],n=(t^=t>>>7)^t<<24,n^=(t=r[a+1&7])^t>>>10,n^=(t=r[a+3&7])^t>>>3,n^=(t=r[a+4&7])^t<<7,t=r[a+7&7],n^=(t^=t<<13)^t<<9,r[a]=n,e.i=a+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function i(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},9016:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},2430:function(t,e,n){var r;!function(a,s,o){var i,l=256,c=o.pow(l,6),u=o.pow(2,52),h=2*u,d=l-1;function p(t,e,n){var r=[],d=b(m((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return i&&(t=i.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),y(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&g(r,p),t.state=function(){return g(p,{})}),n?(o.random=t,e):t})(v,d,"global"in e?e.global:this==o,e.state)}function f(t){var e,n=t.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);a<l;)o[a]=a++;for(a=0;a<l;a++)o[a]=o[s=d&s+t[a%n]+(e=o[a])],o[s]=e;(r.g=function(t){for(var e,n=0,a=r.i,s=r.j,o=r.S;t--;)e=o[a=d&a+1],n=n*l+o[d&(o[a]=o[s=d&s+e])+(o[s]=e)];return r.i=a,r.j=s,n})(l)}function g(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function m(t,e){var n,r=[],a=typeof t;if(e&&"object"==a)for(n in t)try{r.push(m(t[n],e-1))}catch(s){}return r.length?r:"string"==a?t:t+"\0"}function b(t,e){for(var n,r=t+"",a=0;a<r.length;)e[d&a]=d&(n^=19*e[d&a])+r.charCodeAt(a++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(b(o.random(),s),t.exports){t.exports=p;try{i=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}("undefined"!==typeof self?self:this,[],Math)},5438:(t,e,n)=>{"use strict";var r=n(2),a=n(4992),s=n(2101)(),o=n(5558),i=n(4902),l=r("%Math.floor%");t.exports=function(t,e){if("function"!==typeof t)throw new i("`fn` is not a function");if("number"!==typeof e||e<0||e>4294967295||l(e)!==e)throw new i("`length` must be a positive 32-bit integer");var n=arguments.length>2&&!!arguments[2],r=!0,c=!0;if("length"in t&&o){var u=o(t,"length");u&&!u.configurable&&(r=!1),u&&!u.writable&&(c=!1)}return(r||c||!n)&&(s?a(t,"length",e,!0,!0):a(t,"length",e)),t}},5446:t=>{t.exports=function(t){return t&&"object"===typeof t&&"function"===typeof t.copy&&"function"===typeof t.fill&&"function"===typeof t.readUInt8}},9321:(t,e,n)=>{"use strict";var r=n(8317),a=n(1583),s=n(8004),o=n(9849);function i(t){return t.call.bind(t)}var l="undefined"!==typeof BigInt,c="undefined"!==typeof Symbol,u=i(Object.prototype.toString),h=i(Number.prototype.valueOf),d=i(String.prototype.valueOf),p=i(Boolean.prototype.valueOf);if(l)var f=i(BigInt.prototype.valueOf);if(c)var g=i(Symbol.prototype.valueOf);function m(t,e){if("object"!==typeof t)return!1;try{return e(t),!0}catch(n){return!1}}function b(t){return"[object Map]"===u(t)}function y(t){return"[object Set]"===u(t)}function v(t){return"[object WeakMap]"===u(t)}function w(t){return"[object WeakSet]"===u(t)}function x(t){return"[object ArrayBuffer]"===u(t)}function k(t){return"undefined"!==typeof ArrayBuffer&&(x.working?x(t):t instanceof ArrayBuffer)}function S(t){return"[object DataView]"===u(t)}function I(t){return"undefined"!==typeof DataView&&(S.working?S(t):t instanceof DataView)}e.isArgumentsObject=r,e.isGeneratorFunction=a,e.isTypedArray=o,e.isPromise=function(t){return"undefined"!==typeof Promise&&t instanceof Promise||null!==t&&"object"===typeof t&&"function"===typeof t.then&&"function"===typeof t.catch},e.isArrayBufferView=function(t){return"undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):o(t)||I(t)},e.isUint8Array=function(t){return"Uint8Array"===s(t)},e.isUint8ClampedArray=function(t){return"Uint8ClampedArray"===s(t)},e.isUint16Array=function(t){return"Uint16Array"===s(t)},e.isUint32Array=function(t){return"Uint32Array"===s(t)},e.isInt8Array=function(t){return"Int8Array"===s(t)},e.isInt16Array=function(t){return"Int16Array"===s(t)},e.isInt32Array=function(t){return"Int32Array"===s(t)},e.isFloat32Array=function(t){return"Float32Array"===s(t)},e.isFloat64Array=function(t){return"Float64Array"===s(t)},e.isBigInt64Array=function(t){return"BigInt64Array"===s(t)},e.isBigUint64Array=function(t){return"BigUint64Array"===s(t)},b.working="undefined"!==typeof Map&&b(new Map),e.isMap=function(t){return"undefined"!==typeof Map&&(b.working?b(t):t instanceof Map)},y.working="undefined"!==typeof Set&&y(new Set),e.isSet=function(t){return"undefined"!==typeof Set&&(y.working?y(t):t instanceof Set)},v.working="undefined"!==typeof WeakMap&&v(new WeakMap),e.isWeakMap=function(t){return"undefined"!==typeof WeakMap&&(v.working?v(t):t instanceof WeakMap)},w.working="undefined"!==typeof WeakSet&&w(new WeakSet),e.isWeakSet=function(t){return w(t)},x.working="undefined"!==typeof ArrayBuffer&&x(new ArrayBuffer),e.isArrayBuffer=k,S.working="undefined"!==typeof ArrayBuffer&&"undefined"!==typeof DataView&&S(new DataView(new ArrayBuffer(1),0,1)),e.isDataView=I;var N="undefined"!==typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function E(t){return"[object SharedArrayBuffer]"===u(t)}function C(t){return"undefined"!==typeof N&&("undefined"===typeof E.working&&(E.working=E(new N)),E.working?E(t):t instanceof N)}function T(t){return m(t,h)}function A(t){return m(t,d)}function R(t){return m(t,p)}function F(t){return l&&m(t,f)}function _(t){return c&&m(t,g)}e.isSharedArrayBuffer=C,e.isAsyncFunction=function(t){return"[object AsyncFunction]"===u(t)},e.isMapIterator=function(t){return"[object Map Iterator]"===u(t)},e.isSetIterator=function(t){return"[object Set Iterator]"===u(t)},e.isGeneratorObject=function(t){return"[object Generator]"===u(t)},e.isWebAssemblyCompiledModule=function(t){return"[object WebAssembly.Module]"===u(t)},e.isNumberObject=T,e.isStringObject=A,e.isBooleanObject=R,e.isBigIntObject=F,e.isSymbolObject=_,e.isBoxedPrimitive=function(t){return T(t)||A(t)||R(t)||F(t)||_(t)},e.isAnyArrayBuffer=function(t){return"undefined"!==typeof Uint8Array&&(k(t)||C(t))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(t){Object.defineProperty(e,t,{enumerable:!1,value:function(){throw new Error(t+" is not supported in userland")}})}))},6494:(t,e,n)=>{var r=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),n={},r=0;r<e.length;r++)n[e[r]]=Object.getOwnPropertyDescriptor(t,e[r]);return n},a=/%[sdj%]/g;e.format=function(t){if(!y(t)){for(var e=[],n=0;n<arguments.length;n++)e.push(l(arguments[n]));return e.join(" ")}n=1;for(var r=arguments,s=r.length,o=String(t).replace(a,(function(t){if("%%"===t)return"%";if(n>=s)return t;switch(t){case"%s":return String(r[n++]);case"%d":return Number(r[n++]);case"%j":try{return JSON.stringify(r[n++])}catch(e){return"[Circular]"}default:return t}})),i=r[n];n<s;i=r[++n])m(i)||!x(i)?o+=" "+i:o+=" "+l(i);return o},e.deprecate=function(t,n){if("undefined"!==typeof process&&!0===process.noDeprecation)return t;if("undefined"===typeof process)return function(){return e.deprecate(t,n).apply(this,arguments)};var r=!1;return function(){if(!r){if(process.throwDeprecation)throw new Error(n);process.traceDeprecation?console.trace(n):console.error(n),r=!0}return t.apply(this,arguments)}};var s={},o=/^$/;if({NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG){var i={NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG;i=i.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),o=new RegExp("^"+i+"$","i")}function l(t,n){var r={seen:[],stylize:u};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),g(n)?r.showHidden=n:n&&e._extend(r,n),v(r.showHidden)&&(r.showHidden=!1),v(r.depth)&&(r.depth=2),v(r.colors)&&(r.colors=!1),v(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=c),h(r,t,r.depth)}function c(t,e){var n=l.styles[e];return n?"\x1b["+l.colors[n][0]+"m"+t+"\x1b["+l.colors[n][1]+"m":t}function u(t,e){return t}function h(t,n,r){if(t.customInspect&&n&&I(n.inspect)&&n.inspect!==e.inspect&&(!n.constructor||n.constructor.prototype!==n)){var a=n.inspect(r,t);return y(a)||(a=h(t,a,r)),a}var s=function(t,e){if(v(e))return t.stylize("undefined","undefined");if(y(e)){var n="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(n,"string")}if(b(e))return t.stylize(""+e,"number");if(g(e))return t.stylize(""+e,"boolean");if(m(e))return t.stylize("null","null")}(t,n);if(s)return s;var o=Object.keys(n),i=function(t){var e={};return t.forEach((function(t,n){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(n)),S(n)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return d(n);if(0===o.length){if(I(n)){var l=n.name?": "+n.name:"";return t.stylize("[Function"+l+"]","special")}if(w(n))return t.stylize(RegExp.prototype.toString.call(n),"regexp");if(k(n))return t.stylize(Date.prototype.toString.call(n),"date");if(S(n))return d(n)}var c,u="",x=!1,N=["{","}"];(f(n)&&(x=!0,N=["[","]"]),I(n))&&(u=" [Function"+(n.name?": "+n.name:"")+"]");return w(n)&&(u=" "+RegExp.prototype.toString.call(n)),k(n)&&(u=" "+Date.prototype.toUTCString.call(n)),S(n)&&(u=" "+d(n)),0!==o.length||x&&0!=n.length?r<0?w(n)?t.stylize(RegExp.prototype.toString.call(n),"regexp"):t.stylize("[Object]","special"):(t.seen.push(n),c=x?function(t,e,n,r,a){for(var s=[],o=0,i=e.length;o<i;++o)T(e,String(o))?s.push(p(t,e,n,r,String(o),!0)):s.push("");return a.forEach((function(a){a.match(/^\d+$/)||s.push(p(t,e,n,r,a,!0))})),s}(t,n,r,i,o):o.map((function(e){return p(t,n,r,i,e,x)})),t.seen.pop(),function(t,e,n){var r=t.reduce((function(t,e){return e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0);if(r>60)return n[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+n[1];return n[0]+e+" "+t.join(", ")+" "+n[1]}(c,u,N)):N[0]+u+N[1]}function d(t){return"["+Error.prototype.toString.call(t)+"]"}function p(t,e,n,r,a,s){var o,i,l;if((l=Object.getOwnPropertyDescriptor(e,a)||{value:e[a]}).get?i=l.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):l.set&&(i=t.stylize("[Setter]","special")),T(r,a)||(o="["+a+"]"),i||(t.seen.indexOf(l.value)<0?(i=m(n)?h(t,l.value,null):h(t,l.value,n-1)).indexOf("\n")>-1&&(i=s?i.split("\n").map((function(t){return"  "+t})).join("\n").slice(2):"\n"+i.split("\n").map((function(t){return"   "+t})).join("\n")):i=t.stylize("[Circular]","special")),v(o)){if(s&&a.match(/^\d+$/))return i;(o=JSON.stringify(""+a)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.slice(1,-1),o=t.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=t.stylize(o,"string"))}return o+": "+i}function f(t){return Array.isArray(t)}function g(t){return"boolean"===typeof t}function m(t){return null===t}function b(t){return"number"===typeof t}function y(t){return"string"===typeof t}function v(t){return void 0===t}function w(t){return x(t)&&"[object RegExp]"===N(t)}function x(t){return"object"===typeof t&&null!==t}function k(t){return x(t)&&"[object Date]"===N(t)}function S(t){return x(t)&&("[object Error]"===N(t)||t instanceof Error)}function I(t){return"function"===typeof t}function N(t){return Object.prototype.toString.call(t)}function E(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(t){if(t=t.toUpperCase(),!s[t])if(o.test(t)){var n=process.pid;s[t]=function(){var r=e.format.apply(e,arguments);console.error("%s %d: %s",t,n,r)}}else s[t]=function(){};return s[t]},e.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.types=n(9321),e.isArray=f,e.isBoolean=g,e.isNull=m,e.isNullOrUndefined=function(t){return null==t},e.isNumber=b,e.isString=y,e.isSymbol=function(t){return"symbol"===typeof t},e.isUndefined=v,e.isRegExp=w,e.types.isRegExp=w,e.isObject=x,e.isDate=k,e.types.isDate=k,e.isError=S,e.types.isNativeError=S,e.isFunction=I,e.isPrimitive=function(t){return null===t||"boolean"===typeof t||"number"===typeof t||"string"===typeof t||"symbol"===typeof t||"undefined"===typeof t},e.isBuffer=n(5446);var C=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function T(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){console.log("%s - %s",function(){var t=new Date,e=[E(t.getHours()),E(t.getMinutes()),E(t.getSeconds())].join(":");return[t.getDate(),C[t.getMonth()],e].join(" ")}(),e.format.apply(e,arguments))},e.inherits=n(6329),e._extend=function(t,e){if(!e||!x(e))return t;for(var n=Object.keys(e),r=n.length;r--;)t[n[r]]=e[n[r]];return t};var A="undefined"!==typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(t,e){if(!t){var n=new Error("Promise was rejected with a falsy value");n.reason=t,t=n}return e(t)}e.promisify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');if(A&&t[A]){var e;if("function"!==typeof(e=t[A]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,n,r=new Promise((function(t,r){e=t,n=r})),a=[],s=0;s<arguments.length;s++)a.push(arguments[s]);a.push((function(t,r){t?n(t):e(r)}));try{t.apply(this,a)}catch(o){n(o)}return r}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),A&&Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,r(t))},e.promisify.custom=A,e.callbackify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');function e(){for(var e=[],n=0;n<arguments.length;n++)e.push(arguments[n]);var r=e.pop();if("function"!==typeof r)throw new TypeError("The last argument must be of type Function");var a=this,s=function(){return r.apply(a,arguments)};t.apply(this,e).then((function(t){process.nextTick(s.bind(null,null,t))}),(function(t){process.nextTick(R.bind(null,t,s))}))}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),Object.defineProperties(e,r(t)),e}},8004:(t,e,n)=>{"use strict";var r=n(1903),a=n(2936),s=n(1712),o=n(2028),i=n(5558),l=o("Object.prototype.toString"),c=n(4635)(),u="undefined"===typeof globalThis?n.g:globalThis,h=a(),d=o("String.prototype.slice"),p=Object.getPrototypeOf,f=o("Array.prototype.indexOf",!0)||function(t,e){for(var n=0;n<t.length;n+=1)if(t[n]===e)return n;return-1},g={__proto__:null};r(h,c&&i&&p?function(t){var e=new u[t];if(Symbol.toStringTag in e){var n=p(e),r=i(n,Symbol.toStringTag);if(!r){var a=p(n);r=i(a,Symbol.toStringTag)}g["$"+t]=s(r.get)}}:function(t){var e=new u[t],n=e.slice||e.set;n&&(g["$"+t]=s(n))});t.exports=function(t){if(!t||"object"!==typeof t)return!1;if(!c){var e=d(l(t),8,-1);return f(h,e)>-1?e:"Object"===e&&function(t){var e=!1;return r(g,(function(n,r){if(!e)try{n(t),e=d(r,1)}catch(a){}})),e}(t)}return i?function(t){var e=!1;return r(g,(function(n,r){if(!e)try{"$"+n(t)===r&&(e=d(r,1))}catch(a){}})),e}(t):null}},7571:()=>{},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},7078:()=>{},6905:()=>{},4637:()=>{},279:()=>{},4222:()=>{},1234:()=>{},2936:(t,e,n)=>{"use strict";var r=n(7163),a="undefined"===typeof globalThis?n.g:globalThis;t.exports=function(){for(var t=[],e=0;e<r.length;e++)"function"===typeof a[r[e]]&&(t[t.length]=r[e]);return t}}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var s=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},(()=>{var t,e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var o={};t=t||[null,e({}),e([]),e(e)];for(var i=2&a&&r;"object"==typeof i&&!~t.indexOf(i);i=e(i))Object.getOwnPropertyNames(i).forEach((t=>o[t]=()=>r[t]));return o.default=()=>r,n.d(s,o),s}})(),n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"===typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),n.p="/supercircle/",(()=>{"use strict";var t={};n.r(t),n.d(t,{assertParamsValid:()=>$I,computeFlatOffset:()=>dN,computeOutShape:()=>eN,getNormalizedAxes:()=>sN,isSliceContinous:()=>hN,maskToAxes:()=>tN,parseSliceParams:()=>pN,sliceInfo:()=>fN,startForAxis:()=>cN,startIndicesWithElidedDims:()=>oN,stopForAxis:()=>uN,stopIndicesWithElidedDims:()=>iN,stridesForAxis:()=>lN,stridesWithElidedDims:()=>nN});var e={};n.r(e),n.d(e,{collectGatherOpShapeInfo:()=>RA,computeOutShape:()=>AA,segOpComputeOptimalWindowSize:()=>TA});var r={};n.r(r),n.d(r,{ERF_A1:()=>KT,ERF_A2:()=>qT,ERF_A3:()=>XT,ERF_A4:()=>JT,ERF_A5:()=>YT,ERF_P:()=>HT,PARALLELIZE_THRESHOLD:()=>FT,RowPartitionType:()=>ET,SELU_SCALE:()=>jT,SELU_SCALEALPHA:()=>GT,applyActivation:()=>AC,assertAndGetBroadcastShape:()=>LI,assertAxesAreInnerMostDims:()=>SE,assertParamsConsistent:()=>IT,assignToTypedArray:()=>nA,axesAreInnerMostDims:()=>vE,calculateShapes:()=>VT,checkEinsumDimSizes:()=>hA,checkPadOnDimRoundingMode:()=>DN,combineLocations:()=>wE,combineRaggedTensorToTensorShapes:()=>CT,complexWithEvenIndex:()=>$T,complexWithOddIndex:()=>tA,computeConv2DInfo:()=>kN,computeConv3DInfo:()=>SN,computeDefaultPad:()=>IN,computeDilation2DInfo:()=>vN,computeOptimalWindowSize:()=>_T,computeOutAndReduceShapes:()=>xE,computeOutShape:()=>NT,computePool2DInfo:()=>wN,computePool3DInfo:()=>xN,convertConv2DDataFormat:()=>_N,decodeEinsumEquation:()=>cA,eitherStridesOrDilationsAreOne:()=>RN,expandShapeToKeepDim:()=>kE,exponent:()=>aA,exponents:()=>rA,fromStringArrayToUint8:()=>_A,fromUint8ToStringArray:()=>FA,getAxesPermutation:()=>IE,getBroadcastDims:()=>OI,getComplexWithIndex:()=>eA,getEinsumComputePath:()=>dA,getEinsumPermutation:()=>uA,getFusedBiasGradient:()=>TC,getFusedDyActivation:()=>CC,getImageCenter:()=>DT,getInnerMostAxes:()=>EE,getPermuted:()=>zT,getRaggedRank:()=>AT,getReductionAxes:()=>zI,getReshaped:()=>OT,getReshapedPermuted:()=>LT,getRowPartitionTypesHelper:()=>TT,getSliceBeginCoords:()=>MT,getSliceSize:()=>PT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>mA,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>bA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>yA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>xA,getSparseReshapeInputOutputMismatchErrorMessage:()=>SA,getSparseReshapeInputOutputMultipleErrorMessage:()=>kA,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>vA,getSparseReshapeNegativeOutputDimErrorMessage:()=>wA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>CA,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>IA,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>NA,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>EA,getUndoAxesPermutation:()=>NE,isIdentityPermutation:()=>pA,log:()=>Hx,mergeRealAndImagArrays:()=>ZT,prepareAndValidate:()=>BT,prepareSplitSize:()=>gA,segment_util:()=>e,shouldFuse:()=>RC,slice_util:()=>t,splitRealAndImagArrays:()=>QT,stridesOrDilationsArePositive:()=>FN,tupleValuesAreOne:()=>AN,upcastType:()=>Hk,validateDefaultValueShape:()=>RT,validateInput:()=>UT,validateUpdateShape:()=>WT,warn:()=>jx});var a={};n.r(a),n.d(a,{addImpl:()=>vB,bincountImpl:()=>hW,bincountReduceImpl:()=>dW,bitwiseAndImpl:()=>fW,castImpl:()=>fB,ceilImpl:()=>bW,concatImpl:()=>SW,equalImpl:()=>iU,expImpl:()=>yU,expm1Impl:()=>SU,floorImpl:()=>WU,gatherNdImpl:()=>XU,gatherV2Impl:()=>YU,greaterEqualImpl:()=>eV,greaterImpl:()=>QU,lessEqualImpl:()=>fV,lessImpl:()=>hV,linSpaceImpl:()=>bV,logImpl:()=>vV,maxImpl:()=>OV,maximumImpl:()=>MV,minimumImpl:()=>qV,multiplyImpl:()=>$W,negImpl:()=>rG,notEqualImpl:()=>hG,prodImpl:()=>IG,raggedGatherImpl:()=>AG,raggedRangeImpl:()=>_G,raggedTensorToTensorImpl:()=>PG,rangeImpl:()=>WG,rsqrtImpl:()=>QG,scatterImpl:()=>ej,sigmoidImpl:()=>sB,simpleAbsImpl:()=>TB,sliceImpl:()=>iW,sparseFillEmptyRowsImpl:()=>xj,sparseReshapeImpl:()=>Sj,sparseSegmentReductionImpl:()=>Nj,sqrtImpl:()=>Rj,staticRegexReplaceImpl:()=>Mj,stridedSliceImpl:()=>Vj,stringNGramsImpl:()=>Hj,stringSplitImpl:()=>Xj,stringToHashBucketFastImpl:()=>Yj,subImpl:()=>AU,tileImpl:()=>nH,topKImpl:()=>oH,transposeImpl:()=>zB,uniqueImpl:()=>pH});var s,o=n(5043),i=n.t(o,2),l=n(4391),c=n(7950),u=n.t(c,2);function h(){return h=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},h.apply(this,arguments)}!function(t){t.Pop="POP",t.Push="PUSH",t.Replace="REPLACE"}(s||(s={}));const d="popstate";function p(t,e){if(!1===t||null===t||"undefined"===typeof t)throw new Error(e)}function f(t,e){if(!t){"undefined"!==typeof console&&console.warn(e);try{throw new Error(e)}catch(n){}}}function g(t,e){return{usr:t.state,key:t.key,idx:e}}function m(t,e,n,r){return void 0===n&&(n=null),h({pathname:"string"===typeof t?t:t.pathname,search:"",hash:""},"string"===typeof e?y(e):e,{state:n,key:e&&e.key||r||Math.random().toString(36).substr(2,8)})}function b(t){let{pathname:e="/",search:n="",hash:r=""}=t;return n&&"?"!==n&&(e+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(e+="#"===r.charAt(0)?r:"#"+r),e}function y(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let r=t.indexOf("?");r>=0&&(e.search=t.substr(r),t=t.substr(0,r)),t&&(e.pathname=t)}return e}function v(t,e,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:o=!1}=r,i=a.history,l=s.Pop,c=null,u=f();function f(){return(i.state||{idx:null}).idx}function y(){l=s.Pop;let t=f(),e=null==t?null:t-u;u=t,c&&c({action:l,location:w.location,delta:e})}function v(t){let e="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof t?t:b(t);return n=n.replace(/ $/,"%20"),p(e,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,e)}null==u&&(u=0,i.replaceState(h({},i.state,{idx:u}),""));let w={get action(){return l},get location(){return t(a,i)},listen(t){if(c)throw new Error("A history only accepts one active listener");return a.addEventListener(d,y),c=t,()=>{a.removeEventListener(d,y),c=null}},createHref:t=>e(a,t),createURL:v,encodeLocation(t){let e=v(t);return{pathname:e.pathname,search:e.search,hash:e.hash}},push:function(t,e){l=s.Push;let r=m(w.location,t,e);n&&n(r,t),u=f()+1;let h=g(r,u),d=w.createHref(r);try{i.pushState(h,"",d)}catch(p){if(p instanceof DOMException&&"DataCloneError"===p.name)throw p;a.location.assign(d)}o&&c&&c({action:l,location:w.location,delta:1})},replace:function(t,e){l=s.Replace;let r=m(w.location,t,e);n&&n(r,t),u=f();let a=g(r,u),h=w.createHref(r);i.replaceState(a,"",h),o&&c&&c({action:l,location:w.location,delta:0})},go:t=>i.go(t)};return w}var w;!function(t){t.data="data",t.deferred="deferred",t.redirect="redirect",t.error="error"}(w||(w={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function x(t,e,n){void 0===n&&(n="/");let r=z(("string"===typeof e?y(e):e).pathname||"/",n);if(null==r)return null;let a=k(t);!function(t){t.sort(((t,e)=>t.score!==e.score?e.score-t.score:function(t,e){let n=t.length===e.length&&t.slice(0,-1).every(((t,n)=>t===e[n]));return n?t[t.length-1]-e[e.length-1]:0}(t.routesMeta.map((t=>t.childrenIndex)),e.routesMeta.map((t=>t.childrenIndex)))))}(a);let s=null;for(let o=0;null==s&&o<a.length;++o){let t=O(r);s=_(a[o],t)}return s}function k(t,e,n,r){void 0===e&&(e=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(t,a,s)=>{let o={relativePath:void 0===s?t.path||"":s,caseSensitive:!0===t.caseSensitive,childrenIndex:a,route:t};o.relativePath.startsWith("/")&&(p(o.relativePath.startsWith(r),'Absolute route path "'+o.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),o.relativePath=o.relativePath.slice(r.length));let i=W([r,o.relativePath]),l=n.concat(o);t.children&&t.children.length>0&&(p(!0!==t.index,'Index routes must not have child routes. Please remove all child routes from route path "'+i+'".'),k(t.children,e,l,i)),(null!=t.path||t.index)&&e.push({path:i,score:F(i,t.index),routesMeta:l})};return t.forEach(((t,e)=>{var n;if(""!==t.path&&null!=(n=t.path)&&n.includes("?"))for(let r of S(t.path))a(t,e,r);else a(t,e)})),e}function S(t){let e=t.split("/");if(0===e.length)return[];let[n,...r]=e,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let o=S(r.join("/")),i=[];return i.push(...o.map((t=>""===t?s:[s,t].join("/")))),a&&i.push(...o),i.map((e=>t.startsWith("/")&&""===e?"/":e))}const I=/^:[\w-]+$/,N=3,E=2,C=1,T=10,A=-2,R=t=>"*"===t;function F(t,e){let n=t.split("/"),r=n.length;return n.some(R)&&(r+=A),e&&(r+=E),n.filter((t=>!R(t))).reduce(((t,e)=>t+(I.test(e)?N:""===e?C:T)),r)}function _(t,e){let{routesMeta:n}=t,r={},a="/",s=[];for(let o=0;o<n.length;++o){let t=n[o],i=o===n.length-1,l="/"===a?e:e.slice(a.length)||"/",c=D({path:t.relativePath,caseSensitive:t.caseSensitive,end:i},l);if(!c)return null;Object.assign(r,c.params);let u=t.route;s.push({params:r,pathname:W([a,c.pathname]),pathnameBase:U(W([a,c.pathnameBase])),route:u}),"/"!==c.pathnameBase&&(a=W([a,c.pathnameBase]))}return s}function D(t,e){"string"===typeof t&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=function(t,e,n){void 0===e&&(e=!1);void 0===n&&(n=!0);f("*"===t||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were "'+t.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+t.replace(/\*$/,"/*")+'".');let r=[],a="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((t,e,n)=>(r.push({paramName:e,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));t.endsWith("*")?(r.push({paramName:"*"}),a+="*"===t||"/*"===t?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==t&&"/"!==t&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,e?void 0:"i");return[s,r]}(t.path,t.caseSensitive,t.end),a=e.match(n);if(!a)return null;let s=a[0],o=s.replace(/(.)\/+$/,"$1"),i=a.slice(1);return{params:r.reduce(((t,e,n)=>{let{paramName:r,isOptional:a}=e;if("*"===r){let t=i[n]||"";o=s.slice(0,s.length-t.length).replace(/(.)\/+$/,"$1")}const l=i[n];return t[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),t}),{}),pathname:s,pathnameBase:o,pattern:t}}function O(t){try{return t.split("/").map((t=>decodeURIComponent(t).replace(/\//g,"%2F"))).join("/")}catch(e){return f(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+e+")."),t}}function z(t,e){if("/"===e)return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,r=t.charAt(n);return r&&"/"!==r?null:t.slice(n)||"/"}function L(t,e,n,r){return"Cannot include a '"+t+"' character in a manually specified `to."+e+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function M(t){return t.filter(((t,e)=>0===e||t.route.path&&t.route.path.length>0))}function P(t,e){let n=M(t);return e?n.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase)):n.map((t=>t.pathnameBase))}function B(t,e,n,r){let a;void 0===r&&(r=!1),"string"===typeof t?a=y(t):(a=h({},t),p(!a.pathname||!a.pathname.includes("?"),L("?","pathname","search",a)),p(!a.pathname||!a.pathname.includes("#"),L("#","pathname","hash",a)),p(!a.search||!a.search.includes("#"),L("#","search","hash",a)));let s,o=""===t||""===a.pathname,i=o?"/":a.pathname;if(null==i)s=n;else{let t=e.length-1;if(!r&&i.startsWith("..")){let e=i.split("/");for(;".."===e[0];)e.shift(),t-=1;a.pathname=e.join("/")}s=t>=0?e[t]:"/"}let l=function(t,e){void 0===e&&(e="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof t?y(t):t,s=n?n.startsWith("/")?n:function(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach((t=>{".."===t?n.length>1&&n.pop():"."!==t&&n.push(t)})),n.length>1?n.join("/"):"/"}(n,e):e;return{pathname:s,search:V(r),hash:G(a)}}(a,s),c=i&&"/"!==i&&i.endsWith("/"),u=(o||"."===i)&&n.endsWith("/");return l.pathname.endsWith("/")||!c&&!u||(l.pathname+="/"),l}const W=t=>t.join("/").replace(/\/\/+/g,"/"),U=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),V=t=>t&&"?"!==t?t.startsWith("?")?t:"?"+t:"",G=t=>t&&"#"!==t?t.startsWith("#")?t:"#"+t:"";Error;function j(t){return null!=t&&"number"===typeof t.status&&"string"===typeof t.statusText&&"boolean"===typeof t.internal&&"data"in t}const H=["post","put","patch","delete"],K=(new Set(H),["get",...H]);new Set(K),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function q(){return q=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},q.apply(this,arguments)}const X=o.createContext(null);const J=o.createContext(null);const Y=o.createContext(null);const Z=o.createContext(null);const Q=o.createContext({outlet:null,matches:[],isDataRoute:!1});const $=o.createContext(null);function tt(){return null!=o.useContext(Z)}function et(){return tt()||p(!1),o.useContext(Z).location}function nt(t){o.useContext(Y).static||o.useLayoutEffect(t)}function rt(){let{isDataRoute:t}=o.useContext(Q);return t?function(){let{router:t}=pt(ht.UseNavigateStable),e=gt(dt.UseNavigateStable),n=o.useRef(!1);return nt((()=>{n.current=!0})),o.useCallback((function(r,a){void 0===a&&(a={}),n.current&&("number"===typeof r?t.navigate(r):t.navigate(r,q({fromRouteId:e},a)))}),[t,e])}():function(){tt()||p(!1);let t=o.useContext(X),{basename:e,future:n,navigator:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,n.v7_relativeSplatPath)),l=o.useRef(!1);nt((()=>{l.current=!0}));let c=o.useCallback((function(n,a){if(void 0===a&&(a={}),!l.current)return;if("number"===typeof n)return void r.go(n);let o=B(n,JSON.parse(i),s,"path"===a.relative);null==t&&"/"!==e&&(o.pathname="/"===o.pathname?e:W([e,o.pathname])),(a.replace?r.replace:r.push)(o,a.state,a)}),[e,r,i,s,t]);return c}()}function at(t,e){let{relative:n}=void 0===e?{}:e,{future:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,r.v7_relativeSplatPath));return o.useMemo((()=>B(t,JSON.parse(i),s,"path"===n)),[t,i,s,n])}function st(t,e,n,r){tt()||p(!1);let{navigator:a}=o.useContext(Y),{matches:i}=o.useContext(Q),l=i[i.length-1],c=l?l.params:{},u=(l&&l.pathname,l?l.pathnameBase:"/");l&&l.route;let h,d=et();if(e){var f;let t="string"===typeof e?y(e):e;"/"===u||(null==(f=t.pathname)?void 0:f.startsWith(u))||p(!1),h=t}else h=d;let g=h.pathname||"/",m=g;if("/"!==u){let t=u.replace(/^\//,"").split("/");m="/"+g.replace(/^\//,"").split("/").slice(t.length).join("/")}let b=x(t,{pathname:m});let v=ut(b&&b.map((t=>Object.assign({},t,{params:Object.assign({},c,t.params),pathname:W([u,a.encodeLocation?a.encodeLocation(t.pathname).pathname:t.pathname]),pathnameBase:"/"===t.pathnameBase?u:W([u,a.encodeLocation?a.encodeLocation(t.pathnameBase).pathname:t.pathnameBase])}))),i,n,r);return e&&v?o.createElement(Z.Provider,{value:{location:q({pathname:"/",search:"",hash:"",state:null,key:"default"},h),navigationType:s.Pop}},v):v}function ot(){let t=function(){var t;let e=o.useContext($),n=ft(dt.UseRouteError),r=gt(dt.UseRouteError);if(void 0!==e)return e;return null==(t=n.errors)?void 0:t[r]}(),e=j(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return o.createElement(o.Fragment,null,o.createElement("h2",null,"Unexpected Application Error!"),o.createElement("h3",{style:{fontStyle:"italic"}},e),n?o.createElement("pre",{style:a},n):null,null)}const it=o.createElement(ot,null);class lt extends o.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,e){return e.location!==t.location||"idle"!==e.revalidation&&"idle"===t.revalidation?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:void 0!==t.error?t.error:e.error,location:e.location,revalidation:t.revalidation||e.revalidation}}componentDidCatch(t,e){console.error("React Router caught the following error during render",t,e)}render(){return void 0!==this.state.error?o.createElement(Q.Provider,{value:this.props.routeContext},o.createElement($.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function ct(t){let{routeContext:e,match:n,children:r}=t,a=o.useContext(X);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),o.createElement(Q.Provider,{value:e},r)}function ut(t,e,n,r){var a;if(void 0===e&&(e=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==t){var s;if(null==(s=n)||!s.errors)return null;t=n.matches}let i=t,l=null==(a=n)?void 0:a.errors;if(null!=l){let t=i.findIndex((t=>t.route.id&&(null==l?void 0:l[t.route.id])));t>=0||p(!1),i=i.slice(0,Math.min(i.length,t+1))}let c=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let o=0;o<i.length;o++){let t=i[o];if((t.route.HydrateFallback||t.route.hydrateFallbackElement)&&(u=o),t.route.id){let{loaderData:e,errors:r}=n,a=t.route.loader&&void 0===e[t.route.id]&&(!r||void 0===r[t.route.id]);if(t.route.lazy||a){c=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((t,r,a)=>{let s,h=!1,d=null,p=null;var f;n&&(s=l&&r.route.id?l[r.route.id]:void 0,d=r.route.errorElement||it,c&&(u<0&&0===a?(f="route-fallback",!1||mt[f]||(mt[f]=!0),h=!0,p=null):u===a&&(h=!0,p=r.route.hydrateFallbackElement||null)));let g=e.concat(i.slice(0,a+1)),m=()=>{let e;return e=s?d:h?p:r.route.Component?o.createElement(r.route.Component,null):r.route.element?r.route.element:t,o.createElement(ct,{match:r,routeContext:{outlet:t,matches:g,isDataRoute:null!=n},children:e})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?o.createElement(lt,{location:n.location,revalidation:n.revalidation,component:d,error:s,children:m(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):m()}),null)}var ht=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(ht||{}),dt=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(dt||{});function pt(t){let e=o.useContext(X);return e||p(!1),e}function ft(t){let e=o.useContext(J);return e||p(!1),e}function gt(t){let e=function(t){let e=o.useContext(Q);return e||p(!1),e}(),n=e.matches[e.matches.length-1];return n.route.id||p(!1),n.route.id}const mt={};i.startTransition;function bt(t){p(!1)}function yt(t){let{basename:e="/",children:n=null,location:r,navigationType:a=s.Pop,navigator:i,static:l=!1,future:c}=t;tt()&&p(!1);let u=e.replace(/^\/*/,"/"),h=o.useMemo((()=>({basename:u,navigator:i,static:l,future:q({v7_relativeSplatPath:!1},c)})),[u,c,i,l]);"string"===typeof r&&(r=y(r));let{pathname:d="/",search:f="",hash:g="",state:m=null,key:b="default"}=r,v=o.useMemo((()=>{let t=z(d,u);return null==t?null:{location:{pathname:t,search:f,hash:g,state:m,key:b},navigationType:a}}),[u,d,f,g,m,b,a]);return null==v?null:o.createElement(Y.Provider,{value:h},o.createElement(Z.Provider,{children:n,value:v}))}function vt(t){let{children:e,location:n}=t;return st(wt(e),n)}new Promise((()=>{}));o.Component;function wt(t,e){void 0===e&&(e=[]);let n=[];return o.Children.forEach(t,((t,r)=>{if(!o.isValidElement(t))return;let a=[...e,r];if(t.type===o.Fragment)return void n.push.apply(n,wt(t.props.children,a));t.type!==bt&&p(!1),t.props.index&&t.props.children&&p(!1);let s={id:t.props.id||a.join("-"),caseSensitive:t.props.caseSensitive,element:t.props.element,Component:t.props.Component,index:t.props.index,path:t.props.path,loader:t.props.loader,action:t.props.action,errorElement:t.props.errorElement,ErrorBoundary:t.props.ErrorBoundary,hasErrorBoundary:null!=t.props.ErrorBoundary||null!=t.props.errorElement,shouldRevalidate:t.props.shouldRevalidate,handle:t.props.handle,lazy:t.props.lazy};t.props.children&&(s.children=wt(t.props.children,a)),n.push(s)})),n}function xt(){return xt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},xt.apply(this,arguments)}function kt(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const St=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"];try{window.__reactRouterVersion="6"}catch(o1){}new Map;const It=i.startTransition;u.flushSync,i.useId;function Nt(t){let{basename:e,children:n,future:r,window:a}=t,s=o.useRef();var i;null==s.current&&(s.current=(void 0===(i={window:a,v5Compat:!0})&&(i={}),v((function(t,e){let{pathname:n,search:r,hash:a}=t.location;return m("",{pathname:n,search:r,hash:a},e.state&&e.state.usr||null,e.state&&e.state.key||"default")}),(function(t,e){return"string"===typeof e?e:b(e)}),null,i)));let l=s.current,[c,u]=o.useState({action:l.action,location:l.location}),{v7_startTransition:h}=r||{},d=o.useCallback((t=>{h&&It?It((()=>u(t))):u(t)}),[u,h]);return o.useLayoutEffect((()=>l.listen(d)),[l,d]),o.createElement(yt,{basename:e,children:n,location:c.location,navigationType:c.action,navigator:l,future:r})}const Et="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Ct=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Tt=o.forwardRef((function(t,e){let n,{onClick:r,relative:a,reloadDocument:s,replace:i,state:l,target:c,to:u,preventScrollReset:h,unstable_viewTransition:d}=t,f=kt(t,St),{basename:g}=o.useContext(Y),m=!1;if("string"===typeof u&&Ct.test(u)&&(n=u,Et))try{let t=new URL(window.location.href),e=u.startsWith("//")?new URL(t.protocol+u):new URL(u),n=z(e.pathname,g);e.origin===t.origin&&null!=n?u=n+e.search+e.hash:m=!0}catch(o1){}let y=function(t,e){let{relative:n}=void 0===e?{}:e;tt()||p(!1);let{basename:r,navigator:a}=o.useContext(Y),{hash:s,pathname:i,search:l}=at(t,{relative:n}),c=i;return"/"!==r&&(c="/"===i?r:W([r,i])),a.createHref({pathname:c,search:l,hash:s})}(u,{relative:a}),v=function(t,e){let{target:n,replace:r,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l}=void 0===e?{}:e,c=rt(),u=et(),h=at(t,{relative:i});return o.useCallback((e=>{if(function(t,e){return 0===t.button&&(!e||"_self"===e)&&!function(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}(t)}(e,n)){e.preventDefault();let n=void 0!==r?r:b(u)===b(h);c(t,{replace:n,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l})}}),[u,c,h,r,a,n,t,s,i,l])}(u,{replace:i,state:l,target:c,preventScrollReset:h,relative:a,unstable_viewTransition:d});return o.createElement("a",xt({},f,{href:n||y,onClick:m||s?r:function(t){r&&r(t),t.defaultPrevented||v(t)},ref:e,target:c}))}));var At,Rt;(function(t){t.UseScrollRestoration="useScrollRestoration",t.UseSubmit="useSubmit",t.UseSubmitFetcher="useSubmitFetcher",t.UseFetcher="useFetcher",t.useViewTransitionState="useViewTransitionState"})(At||(At={})),function(t){t.UseFetcher="useFetcher",t.UseFetchers="useFetchers",t.UseScrollRestoration="useScrollRestoration"}(Rt||(Rt={}));var Ft={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},_t=o.createContext&&o.createContext(Ft),Dt=["attr","size","title"];function Ot(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}function zt(){return zt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},zt.apply(this,arguments)}function Lt(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function Mt(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?Lt(Object(n),!0).forEach((function(e){Pt(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):Lt(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function Pt(t,e,n){return e=function(t){var e=function(t,e){if("object"!==typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!==typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"===typeof e?e:String(e)}(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Bt(t){return t&&t.map(((t,e)=>o.createElement(t.tag,Mt({key:e},t.attr),Bt(t.child))))}function Wt(t){return e=>o.createElement(Ut,zt({attr:Mt({},t.attr)},e),Bt(t.child))}function Ut(t){var e=e=>{var n,{attr:r,size:a,title:s}=t,i=Ot(t,Dt),l=a||e.size||"1em";return e.className&&(n=e.className),t.className&&(n=(n?n+" ":"")+t.className),o.createElement("svg",zt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},e.attr,r,i,{className:n,style:Mt(Mt({color:t.color||e.color},e.style),t.style),height:l,width:l,xmlns:"http://www.w3.org/2000/svg"}),s&&o.createElement("title",null,s),t.children)};return void 0!==_t?o.createElement(_t.Consumer,null,(t=>e(t))):e(Ft)}function Vt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"21",y1:"10",x2:"3",y2:"10"},child:[]},{tag:"line",attr:{x1:"21",y1:"6",x2:"3",y2:"6"},child:[]},{tag:"line",attr:{x1:"21",y1:"14",x2:"3",y2:"14"},child:[]},{tag:"line",attr:{x1:"21",y1:"18",x2:"3",y2:"18"},child:[]}]})(t)}function Gt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"path",attr:{d:"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"},child:[]},{tag:"polyline",attr:{points:"3.27 6.96 12 12.01 20.73 6.96"},child:[]},{tag:"line",attr:{x1:"12",y1:"22.08",x2:"12",y2:"12"},child:[]}]})(t)}function jt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"18",y1:"6",x2:"6",y2:"18"},child:[]},{tag:"line",attr:{x1:"6",y1:"6",x2:"18",y2:"18"},child:[]}]})(t)}var Ht=n(579);const Kt=function(){const[t,e]=(0,o.useState)(!1),[n,r]=(0,o.useState)(!1),a=()=>e(!1);return window.addEventListener("resize",(()=>{window.innerWidth<=960?r(!1):r(!0)})),(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)("nav",{className:"navbar",children:(0,Ht.jsxs)("div",{className:"navbar-container",children:[(0,Ht.jsxs)(Tt,{to:"/",className:"navbar-logo",onClick:a,children:["CIRCLE ",(0,Ht.jsx)(Gt,{className:"name-icon"})]}),(0,Ht.jsx)("div",{className:"menu-icon",onClick:()=>e(!t),children:t?(0,Ht.jsx)(jt,{className:"close-icon"}):(0,Ht.jsx)(Vt,{className:"open-icon"})}),(0,Ht.jsxs)("ul",{className:t?"nav-menu active":"nav-menu",children:[(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/",className:"nav-links",onClick:a,children:"Home"})}),(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/projects",className:"nav-links",onClick:a,children:"Projects"})})," ",(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/contact",className:"nav-links",onClick:a,children:"Contact Info"})})]})]})})})};function qt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"},child:[]}]})(t)}const Xt=function(){return(0,Ht.jsx)("div",{className:"contact-page",children:(0,Ht.jsx)("a",{href:"https://www.linkedin.com/in/wiramonth/",children:(0,Ht.jsx)(qt,{className:"sns-icon"})})})};const Jt=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Xt,{})})},Yt=n.p+"static/media/video3.438dba662d3f94358903.mp4";const Zt=function(){return(0,Ht.jsx)("div",{className:"hero-container",children:(0,Ht.jsx)("video",{src:Yt,autoPlay:!0,loop:!0,muted:!0})})};const Qt=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Zt,{})})};class $t{refCount(t){return te("refCount")}incRef(t){return te("incRef")}timerAvailable(){return!0}time(t){return te("time")}read(t){return te("read")}readSync(t){return te("readSync")}readToGPU(t,e){return te("readToGPU")}numDataIds(){return te("numDataIds")}disposeData(t,e){return te("disposeData")}write(t,e,n){return te("write")}move(t,e,n,r,a){return te("move")}memory(){return te("memory")}floatPrecision(){return te("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return te("dispose")}}function te(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function ee(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,ne(t,e,n)}function ne(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function re(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function ae(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";re(le(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function se(t){re(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function oe(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),Array.isArray(t)||de(t)&&!n)for(let r=0;r<t.length;++r)oe(t[r],e,n);else e.push(t);return e}function ie(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function le(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ce(t){return t%1===0}function ue(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function he(t,e){const n=e.length;return re((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),re(t.every((t=>ce(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function de(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function pe(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function fe(t){return"string"===typeof t||t instanceof String}function ge(t){return"number"===typeof t}function me(t){return Array.isArray(t)?me(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":ge(t)?"float32":fe(t)?"string":"boolean"===typeof t?"bool":"float32"}function be(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ye(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function ve(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=ve(t+e*i,o,n,r)}return a}function we(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return ve(0,t,e,n)}function xe(t,e){const n=ke(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function ke(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function Se(t){t.forEach((e=>{re(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function Ie(t){return t&&t.then&&"function"===typeof t.then}const Ne="tfjsflags";class Ee{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ce,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ie(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Ne in t){t[Ne].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if("".concat(+e)===e)return+e;throw new Error("Could not parse value flag value ".concat(e," for flag ").concat(t,"."))}(e,n)}))}}}function Ce(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Te(){return Re}let Ae,Re=null;function Fe(){if(null==Ae){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Ae=t}return Ae}function _e(t,e){const n=function(){const t=Fe();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const De="Add",Oe="ArgMax",ze="AvgPool",Le="AvgPool3D",Me="BatchMatMul",Pe="BatchToSpaceND",Be="Cast",We="ClipByValue",Ue="ComplexAbs",Ve="Concat",Ge="Conv2D",je="Conv2DBackpropInput",He="Conv3D",Ke="Cosh",qe="Cumsum",Xe="DepthwiseConv2dNative",Je="RealDiv",Ye="ExpandDims",Ze="Fill",Qe="Floor",$e="FloorDiv",tn="FusedBatchNorm",en="GatherV2",nn="GreaterEqual",rn="Identity",an="LeakyRelu",sn="Log1p",on="Maximum",ln="MaxPool",cn="MaxPool3D",un="Mean",hn="Minimum",dn="Multiply",pn="OnesLike",fn="OneHot",gn="Pack",mn="PadV2",bn="Prelu",yn="Range",vn="Relu",wn="Reshape",xn="ResizeNearestNeighbor",kn="ResizeBilinear",Sn="Relu6",In="Reverse",Nn="Round",En="Rsqrt",Cn="Select",Tn="Selu",An="Slice",Rn="Sinh",Fn="Sigmoid",_n="Softplus",Dn="Sqrt",On="SpaceToBatchND",zn="SplitV",Ln="Softmax",Mn="SquaredDifference",Pn="Tanh",Bn="Tile",Wn="Transpose",Un="Unpack",Vn="UnsortedSegmentSum",Gn="ZerosLike",jn="Step",Hn="FromPixels",Kn="_FusedMatMul",qn="FusedConv2D",Xn="FusedDepthwiseConv2D";function Jn(){Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn(...arguments)}const Yn=_e("kernelRegistry",(()=>new Map)),Zn=_e("gradRegistry",(()=>new Map));function Qn(t,e){const n=nr(t,e);return Yn.get(n)}function $n(t){return Zn.get(t)}function tr(t){const e=Yn.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function er(t){const{kernelName:e}=t;Zn.has(e)&&Te().getBool("DEBUG")&&Jn("Overriding the gradient for '".concat(e,"'")),Zn.set(e,t)}function nr(t,e){return"".concat(e,"_").concat(t)}var rr=n(7353),ar=n.n(rr);const sr=ar()||rr;function or(t){return sr.fromString(t,!0,16)}or("c3a5c85c97cb3127"),or("b492b66fbe98f273"),or("9ae16a3b2f90404f");function ir(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=oe(t)),Te().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function lr(){return Te().platform.now()}function cr(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Te().platform.encode(t,e)}function ur(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Te().platform.decode(t,e)}class hr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new pr)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=lr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:lr()-o})}if(Te().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{dr(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function dr(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class pr{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?ue("".concat(r,"ms"),9):r.error,i=ue(t,25),l=e.rank,c=e.size,u=ue(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const fr=20,gr=3,mr=7;function br(t,e,n,r){const a=ye(e),s=function(t,e,n,r){const a=ie(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?xr(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],yr(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=wr(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function yr(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(mr))," + ")+"".concat(parseFloat(t[1].toFixed(mr)),"j"):fe(t)?"'".concat(t,"'"):"bool"===n?vr(t):parseFloat(t.toFixed(mr)).toString(),ue(r,e)}function vr(t){return 0===t?"false":"true"}function wr(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[yr(xr(t)[0],0,n)]}return"bool"===n?[vr(t[0])]:[t[0].toString()]}if(1===l){if(i>fr){const e=gr*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-gr)*o,i*o));return"complex64"===n&&(r=xr(r),s=xr(s)),["["+r.map(((t,e)=>yr(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>yr(t,a[i-gr+e],n))).join(", ")+"]"]}return["["+("complex64"===n?xr(t):Array.from(t)).map(((t,e)=>yr(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>fr){for(let e=0;e<gr;e++){const r=e*h,s=r+h;d.push(...wr(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-gr;e<i;e++){const r=e*h,s=r+h;d.push(...wr(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...wr(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function xr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class kr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=ie(t),null!=n){const t=n.length;re(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||function(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}(e,this.size),this.strides=ye(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),re(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Sr().makeTensor(this.values,this.shape,this.dtype)}}let Sr=null,Ir=null,Nr=null;class Er{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ie(t),this.strides=ye(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Ir.buffer(this.shape,this.dtype,t)}bufferSync(){return Ir.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return we(this.shape,t,"complex64"===this.dtype)}arraySync(){return we(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Sr().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>ur(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Sr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Sr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>ur(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Sr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Sr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Ir.print(this,t)}clone(){return this.throwIfDisposed(),Ir.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return br(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ir.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Sr().makeVariable(this,t,e,n)}}Object.defineProperty(Er,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),_e("Tensor",(()=>Er));class Cr extends Er{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!le(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Sr().disposeTensor(this),this.dataId=t.dataId,Sr().incRef(this,null)}dispose(){Sr().disposeVariable(this),this.isDisposedInternal=!0}}var Tr,Ar,Rr,Fr,_r;Object.defineProperty(Cr,Symbol.hasInstance,{value:t=>t instanceof Er&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Tr||(Tr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Ar||(Ar={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Rr||(Rr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Fr||(Fr={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(_r||(_r={}));const Dr={float32:Fr,int32:Ar,bool:Rr,complex64:_r};function Or(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return Dr[t][e]}function zr(t,e){if(t.dtype===e.dtype)return[t,e];const n=Or(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Lr(t,e){return e.some((e=>e.id===t.id))}function Mr(t){const e=[];return Pr(t,e,new Set),e}function Pr(t,e,n){if(null==t)return;if(t instanceof Er)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),Pr(t,e,n))}}function Br(t){return null!=t.kernelName}class Wr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Ur{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Wr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(Jn("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new hr(this.backendInstance),!0}setupRegisteredKernels(){tr(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){tr(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof $t||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Jn("Initialization of backend ".concat(t," failed")),Jn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return Jn("Initialization of backend ".concat(t," failed")),Jn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return Ur.nextTensorId++}nextVariableId(){return Ur.nextVariableId++}clone(t){const e=Gr.runKernel(rn,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Gr.runKernel(Be,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=Qn(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Br(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Br(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=Qn(e,this.backendName);re(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=Br(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=$n(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(re(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&fe(t[0])&&(a=t.map((t=>cr(t))));const s=r.write(a,e,n),o=new Er(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Er(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Cr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*pe(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Cr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*pe(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=$n(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=ke(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Mr(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(re(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));re(a instanceof Er,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=xe(ie(t),"float32");return Gr.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!le(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),jr);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return re(be(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;re(r.every((t=>t instanceof Er)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),re(s.value instanceof Er,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),re(be(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];re(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),re(a.every((t=>t instanceof Er)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=lr(),n=await this.backend.time(t);return n.wallMs=lr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Wr;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Vr(){const t=Fe();if(null==t._tfengine){const e=new Ee(t);t._tfengine=new Ur(e)}var e;return e=t._tfengine.ENV,Re=e,Sr=()=>t._tfengine,t._tfengine}Ur.nextTensorId=0,Ur.nextVariableId=0;const Gr=Vr();function jr(t,e){const n={a:t,b:e};return Gr.runKernel(De,n)}const Hr=Te();function Kr(t,e){let n=t;if(de(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||de(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Te().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qr(t,r,[]),r}function qr(t,e,n){if(n=n||[],!Array.isArray(t)&&!de(t))return void re(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));re(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),re(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)qr(t[a],r,n.concat(a))}function Xr(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function Jr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Er)return Xr(r,t.dtype,e,n),t;let a=me(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Xr(r,a,e,n),null==t||!de(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=Kr(t,a);de(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?ir(t,a):oe(t,[],!0);return Gr.makeTensor(o,s,a)}function Yr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>Jr(t,"".concat(e,"[").concat(a,"]"),n,r)))}Hr.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Hr.registerFlag("IS_BROWSER",(()=>"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope)),Hr.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Hr.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Hr.registerFlag("PROD",(()=>!1)),Hr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Hr.getBool("DEBUG"))),Hr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Hr.registerFlag("IS_TEST",(()=>!1)),Hr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Hr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Hr.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),Hr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Hr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Zr(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Gr.startScope(n);try{const t=r(...arguments);return Ie(t)&&console.error("Cannot return a Promise inside of tidy."),Gr.endScope(t),t}catch(t){throw Gr.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const Qr=Zr({complex_:function(t,e){const n=Jr(t,"real","complex"),r=Jr(e,"imag","complex");ae(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return Gr.runKernel("Complex",a)}});function $r(t,e,n,r){if(null==r&&(r=me(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!de(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Se(e);const t=ie(e),r=ie(n);re(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==ie(e.slice(a));re(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return de(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?ir(t,r):oe(t,[],!0),Gr.makeTensor(t,e,r)}function ta(t,e,n){return $r(t,e,Kr(t,n),n)}const ea={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},na=4;async function ra(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+na*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=na,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:sa(await Promise.all(r)),specs:n}}function aa(t,e){const n={};let r,a=0;for(const s of e){const e=s.name,o=s.dtype,i=s.shape,l=ie(i);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(s.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(s.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==o)throw new Error("Weight ".concat(s.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(o,"."))}const i=ea[n.dtype],u=t.slice(a,a+l*i),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===r&&(r=da()),c=r(h)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");c=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=Math.round(e*n.scale+n.min)}}a+=l*i}else if("string"===o){const e=ie(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(a,a+na))[0];a+=na;const n=new Uint8Array(t.slice(a,a+e));c.push(n),a+=e}}else{const r=ea[o],s=t.slice(a,a+l*r);if("float32"===o)c=new Float32Array(s);else if("int32"===o)c=new Int32Array(s);else if("bool"===o)c=new Uint8Array(s);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const a=ta(t,i,"float32"),o=ta(r,i,"float32");n[e]=Qr(a,o),a.dispose(),o.dispose()}}a+=l*r}"complex64"!==o&&(n[e]=ta(c,i,o))}return n}function sa(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const oa="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function ia(t){return oa?Buffer.byteLength(t):new Blob([t]).size}function la(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function ca(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function ua(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),r}(t,n,r)}function ha(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:ia(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:ia(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function da(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0===(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const a=r[o],i=t[n[a>>10]+(1023&a)]+e[a>>10];s[o]=i}return new Float32Array(a)}}class pa{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==pa.instance&&(pa.instance=new pa),pa.instance}static registerSaveRouter(t){pa.getInstance().saveRouters.push(t)}static registerLoadRouter(t){pa.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return pa.getHandlers(t,"save")}static getLoadHandlers(t,e){return pa.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?pa.getInstance().loadRouters:pa.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const fa=(t,e)=>pa.getLoadHandlers(t,e),ga="tensorflowjs",ma="models_store",ba="model_info_store";function ya(){if(!Te().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function va(t){const e=t.result;e.createObjectStore(ma,{keyPath:"modelPath"}),e.createObjectStore(ba,{keyPath:"modelPath"})}class wa{constructor(t){if(this.indexedDB=ya(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(ga,1);r.onupgradeneeded=()=>va(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(ma,"readonly"),r=e.objectStore(ma).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{const r=ha(e),s=a.transaction(ba,"readwrite");let o=s.objectStore(ba);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;i.onsuccess=()=>{l=a.transaction(ma,"readwrite");const i=l.objectStore(ma).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});i.onsuccess=()=>t({modelArtifactsInfo:r}),i.onerror=t=>{o=s.objectStore(ba);const e=o.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(i.error)),e.onerror=t=>(a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}wa.URL_SCHEME="indexeddb://";const xa=t=>{return Te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(wa.URL_SCHEME)?(e=t.slice(wa.URL_SCHEME.length),new wa(e)):null;var e};pa.registerSaveRouter(xa),pa.registerLoadRouter(xa);class ka{constructor(){this.indexedDB=ya()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(ga,1);n.onupgradeneeded=()=>va(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(ba,"readonly"),s=a.objectStore(ba).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(wa.URL_SCHEME)?e.slice(wa.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(ga,1);r.onupgradeneeded=()=>va(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(ba,"readwrite"),o=s.objectStore(ba),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(ma,"readwrite");const r=l.objectStore(ma).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const Sa="/",Ia="tensorflowjs_models",Na="info",Ea="model_topology",Ca="weight_specs",Ta="weight_data",Aa="model_metadata";function Ra(t){return{info:[Ia,t,Na].join(Sa),topology:[Ia,t,Ea].join(Sa),weightSpecs:[Ia,t,Ca].join(Sa),weightData:[Ia,t,Ta].join(Sa),modelMetadata:[Ia,t,Aa].join(Sa)}}function Fa(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function _a(t){const e=t.split(Sa);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(Sa)}class Da{constructor(t){if(!Te().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Ra(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),a=ha(t);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(t){if(oa)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData));const e={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(e)),{modelArtifactsInfo:a}}catch(e){throw Fa(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(oa){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}Da.URL_SCHEME="localstorage://";const Oa=t=>{return Te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Da.URL_SCHEME)?(e=t.slice(Da.URL_SCHEME.length),new Da(e)):null;var e};pa.registerSaveRouter(Oa),pa.registerLoadRouter(Oa);class za{constructor(){re(Te().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),re("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Ia+Sa,n=Sa+Na;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[_a(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=Ra(t=(e=t).startsWith(Da.URL_SCHEME)?e.slice(Da.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return Fa(n),r}}const La="://";class Ma{constructor(){this.managers={}}static getInstance(){return null==Ma.instance&&(Ma.instance=new Ma),Ma.instance}static registerManager(t,e){re(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(La)&&(t=t.slice(0,t.indexOf(La))),re(t.length>0,(()=>"scheme must not be an empty string."));const n=Ma.getInstance();re(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=Ma.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(Ma.getInstance().managers)}}class Pa{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){window&&Te().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}}if(Te().get("IS_BROWSER")){Te().setPlatform("browser",new Pa);try{Ma.registerManager(Da.URL_SCHEME,new za)}catch(i1){}try{Ma.registerManager(wa.URL_SCHEME,new ka)}catch(i1){}}const Ba=()=>n(5817);let Wa;class Ua{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Te().global.fetch?Te().global.fetch(t,e):(null==Wa&&(Wa=Ba()),Wa(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}function Va(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",Se(t),new kr(t,e,n)}Te().get("IS_NODE")&&!Te().get("IS_BROWSER")&&Te().setPlatform("node",new Ua);const Ga=Zr({cast_:function(t,e){const n=Jr(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return Gr.runKernel(Be,r,a)}});const ja=Zr({clone_:function(t){const e={x:Jr(t,"x","clone","string_or_numeric")};return Gr.runKernel(rn,e)}});Vr();Ir={buffer:Va,cast:Ga,clone:ja,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}};function Ha(t){return new Promise((t=>setTimeout(t))).then(t)}class Ka{constructor(t){if(!Te().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ka.URL_SCHEME)&&(t=t.slice(Ka.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=ca(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Ha((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Ha((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:ha(t)}}}}Ka.URL_SCHEME="downloads://";function qa(t,e,n,r){!function(t){re(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){re(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),re(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),re(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function Xa(t,e){null==e&&(e={});const n=null==e.fetchFunc?Te().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await qa(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await qa(a,e.onProgress,.5,1)}pa.registerSaveRouter((t=>Te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ka.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Ka(t)}(t.slice(Ka.URL_SCHEME.length)):null));class Ja{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(re("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Te().platform.fetch,re(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&re(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=ca(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:ha(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(o1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return ua(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=function(t){const e=[];for(const n of t)e.push(...n.weights);return e}(t),o=[],i=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):o.push(a+t+r);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,la(await Xa(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Ya(t){return null!=t.match(Ja.URL_SCHEME_REGEX)}Ja.URL_SCHEME_REGEX=/^https?:\/\//;const Za=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Ya(t))):Ya(t),n)return Qa(t,e)}return null};function Qa(t,e){return new Ja(t,e)}pa.registerSaveRouter(Za),pa.registerLoadRouter(Za);class $a{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class ts{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function es(t,e,n,r){return new ts(function(t,e,n,r){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new $a(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $a({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $a({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r})}(...arguments))}function ns(t,e,n){if(se(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Kr(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return $r(t,e,r,n)}let rs;function as(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&t instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(t.constructor.name));i=!0}if(null!=Qn(Hn,Gr.backendName)){const n={pixels:t},r={numChannels:e};return Gr.runKernel(Hn,n,r)}const[l,c]=a?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,h;if(o)u=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)u=t.data;else if(s||a||i){if(null==rs)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");rs=new OffscreenCanvas(1,1).getContext("2d")}else rs=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});rs.canvas.width=l,rs.canvas.height=c,rs.drawImage(t,0,0,l,c),u=rs.getImageData(0,0,l,c).data}if(4===e)h=new Int32Array(u);else{const t=l*c;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=u[4*n+t]}return ns(h,[c,l,e],"int32")}Zr({fromPixels_:as});class ss{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class os{constructor(){this.classNameMap={}}static getMap(){return null==os.instance&&(os.instance=new os),os.instance}static register(t){os.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function is(t){re(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),re("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),re(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),os.register(t)}function ls(){return Gr.memory()}function cs(t,e){return Gr.tidy(t,e)}function us(t){Mr(t).forEach((t=>t.dispose()))}function hs(t){return Gr.keep(t)}function ds(){return Gr.backend}function ps(t){return Gr.customGrad(t)}function fs(t,e){if((de(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&de(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return $r(t,[],[],e)}Nr=function(t){Te().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class gs extends ss{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return us(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){re(be(t),(()=>"The f passed in variableGrads(f) must be a function")),re(null==e||Array.isArray(e)&&e.every((t=>t instanceof Cr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in Gr.registeredVariables)e.push(Gr.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),re(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=Gr.gradients(t,e,null,!0);re(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),re(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&us(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:fs(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(gs,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const ms=Zr({abs_:function(t){const e=Jr(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return Gr.runKernel(Ue,t)}{const t={x:e};return Gr.runKernel("Abs",t)}}});const bs=Zr({add_:function(t,e){let n=Jr(t,"a","add"),r=Jr(e,"b","add");[n,r]=zr(n,r);const a={a:n,b:r};return Gr.runKernel(De,a)}});const ys=Zr({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Jr(t,"x","all","bool")},a={axis:e,keepDims:n};return Gr.runKernel("All",r,a)}});const vs=Zr({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Jr(t,"x","any","bool")},a={axis:e,keepDims:n};return Gr.runKernel("Any",r,a)}});const ws=Zr({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Jr(t,"x","argMax")},r={axis:e};return Gr.runKernel(Oe,n,r)}});function xs(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=Ss(n),[b,y]=Ss(r),v=Is(d,b),w=Is(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=ks(t,e,n));const s=t[0],o=t[1],i=Ns((s-e+2*r)/n+1,a),l=Ns((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=Ns((e-s+d+p)/r+1,i),h=Ns((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function ks(t,e,n){const r=Is(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function Ss(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Is(t,e){return e<=1?t:t+(t-1)*(e-1)}function Ns(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function Es(t){const[e,n,r]=Ss(t);return 1===e&&1===n&&1===r}function Cs(t,e){return Es(t)||Es(e)}function Ts(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)re(ce(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{re(ce(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const As=Zr({reshape_:function(t,e){const n={x:Jr(t,"x","reshape","string_or_numeric")},r={shape:e};return Gr.runKernel(wn,n,r)}});const Rs=Zr({avgPool_:function(t,e,n,r,a){const s=Jr(t,"x","avgPool","float32");re(Cs(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=As(s,[1,s.shape[0],s.shape[1],s.shape[2]])),re(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),Ts("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=Gr.runKernel(ze,l,c);return u=Ga(u,s.dtype),i?As(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Fs=Zr({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Jr(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=As(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),re("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Ts("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=Gr.runKernel(Le,c,u);return h=Ga(h,i.dtype),l?As(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const _s=Zr({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=Jr(t,"x","batchNorm"),i=Jr(e,"mean","batchNorm"),l=Jr(n,"variance","batchNorm");let c,u;null!=a&&(c=Jr(a,"scale","batchNorm")),null!=r&&(u=Jr(r,"offset","batchNorm")),re(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),re(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),re(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?As(t,[1,1,1,t.size]):2===t.rank?As(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?As(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=Gr.runKernel(tn,h,d);return As(p,o.shape)}});const Ds=Zr({batchNorm2d_:function(t,e,n,r,a,s){const o=Jr(t,"x","batchNorm"),i=Jr(e,"mean","batchNorm"),l=Jr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Jr(a,"scale","batchNorm")),null!=r&&(u=Jr(r,"offset","batchNorm")),re(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),re(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),re(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&re(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&re(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),_s(o,i,l,u,c,s)}});const Os=Zr({batchNorm3d_:function(t,e,n,r,a,s){const o=Jr(t,"x","batchNorm"),i=Jr(e,"mean","batchNorm"),l=Jr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Jr(a,"scale","batchNorm")),null!=r&&(u=Jr(r,"offset","batchNorm")),re(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),re(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),re(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&re(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&re(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),_s(o,i,l,u,c,s)}});const zs=Zr({batchNorm4d_:function(t,e,n,r,a,s){const o=Jr(t,"x","batchNorm"),i=Jr(e,"mean","batchNorm"),l=Jr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Jr(a,"scale","batchNorm")),null!=r&&(u=Jr(r,"offset","batchNorm")),re(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),re(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),re(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&re(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&re(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),_s(o,i,l,u,c,s)}});function Ls(t,e,n){const r={shape:t,value:e,dtype:n};return Gr.runKernel(Ze,{},r)}const Ms=Zr({clipByValue_:function(t,e,n){const r=Jr(t,"x","clipByValue");if(re(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return Ls(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return Gr.runKernel(We,a,s)}});const Ps=Zr({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;re(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Yr(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return ja(n[0]);const r=n,a={axis:e};return Gr.runKernel(Ve,r,a)}});const Bs=Zr({concat1d_:function(t){return Ps(t,0)}});const Ws=Zr({concat2d_:function(t,e){return Ps(t,e)}});const Us=Zr({concat3d_:function(t,e){return Ps(t,e)}});const Vs=Zr({concat4d_:function(t,e){return Ps(t,e)}});const Gs=Zr({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Jr(t,"x","conv2d","float32"),l=Jr(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=As(i,[1,i.shape[0],i.shape[1],i.shape[2]])),re(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),re(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),Ts("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];re(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),re(Cs(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Ge,d,p);return u?As(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const js=Zr({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=Jr(t,"x","conv1d"),l=Jr(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=As(i,[1,i.shape[0],i.shape[1]])),re(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),re(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),Ts("conv1d",r,o),re(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),re(Cs(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),re("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=As(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=As(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Gs(d,h,[1,n],r,"NHWC",[1,s],o);return As(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Hs=Zr({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;re(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=As(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),re(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),re(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),re(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];re(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),re(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),Ts("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Gr.runKernel(je,d,p);return c?As(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Ks=Zr({conv2dTranspose_:function(t,e,n,r,a,s){const o=Jr(t,"x","conv2dTranspose"),i=Jr(e,"filter","conv2dTranspose");return Hs(n,o,i,r,a,"NHWC",s)}});const qs=Zr({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=Jr(t,"x","conv3d"),i=Jr(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=As(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),re(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),re(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),re(Cs(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),re("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported.")));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=Gr.runKernel(He,u,h);return c?As(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Xs=Zr({conv3DBackpropInput_:function(t,e,n,r,a){re(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=As(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];re(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),re(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),re(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),re(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),re(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=Gr.runKernel("Conv3DBackpropInputV2",u,h);return i?As(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Js=Zr({conv3dTranspose_:function(t,e,n,r,a){const s=Jr(t,"x","conv3dTranspose"),o=Jr(e,"filter","conv3dTranspose");return Xs(n,s,o,r,a)}});const Ys=Zr({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Jr(t,"x","depthwiseConv2d","float32"),l=Jr(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=As(i,[1,i.shape[0],i.shape[1],i.shape[2]])),re(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),re(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];re(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),Ts("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Xe,d,p);return u?As(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Zs=Zr({floorDiv_:function(t,e){let n=Jr(t,"a","floorDiv"),r=Jr(e,"b","floorDiv");[n,r]=zr(n,r);const a={a:n,b:r};return Gr.runKernel($e,a)}});const Qs=Zr({div_:function(t,e){let n=Jr(t,"a","div"),r=Jr(e,"b","div");if([n,r]=zr(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Zs(n,r);const a={a:n,b:r};return Gr.runKernel(Je,a,{})}});const $s=Zr({elu_:function(t){const e={x:Jr(t,"x","elu","float32")};return Gr.runKernel("Elu",e)}});function to(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function eo(t,e){const n=[],r=Math.max(t.length,e.length);for(let a=0;a<r;a++){let r=t[t.length-a-1];null==r&&(r=1);let s=e[e.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}n.unshift(r)}}return n}const no=Zr({equal_:function(t,e){let n=Jr(t,"a","equal","string_or_numeric"),r=Jr(e,"b","equal","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Equal",a)}});const ro=Zr({exp_:function(t){const e={x:Jr(t,"x","exp")};return Gr.runKernel("Exp",e)}});const ao=Zr({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Jr(t,"x","expandDims","string_or_numeric");re(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return Gr.runKernel(Ye,r,a)}});const so=Zr({tile_:function(t,e){const n=Jr(t,"x","tile","string_or_numeric");re(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return Gr.runKernel(Bn,r,a)}});const oo=Zr({eye_:function(t,e,n){null==e&&(e=t);const r=Va([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=As(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return so(ao(s,0),[n[0],1,1]);if(2===n.length)return so(ao(ao(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return so(ao(ao(ao(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const io=Zr({floor_:function(t){const e={x:Jr(t,"x","floor","float32")};return Gr.runKernel(Qe,e)}});const lo=Zr({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:Jr(t,"x","gather"),indices:Jr(e,"indices","gather","int32")},s={axis:n,batchDims:r};return Gr.runKernel(en,a,s)}});const co=Zr({greater_:function(t,e){let n=Jr(t,"a","greater","string_or_numeric"),r=Jr(e,"b","greater","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Greater",a)}});const uo=Zr({greaterEqual_:function(t,e){let n=Jr(t,"a","greaterEqual","string_or_numeric"),r=Jr(e,"b","greaterEqual","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(nn,a)}});const ho=Zr({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Jr(t,"x","leakyRelu")},r={alpha:e};return Gr.runKernel(an,n,r)}});const po=Zr({log_:function(t){const e={x:Jr(t,"x","log","float32")};return Gr.runKernel("Log",e)}});const fo=Zr({log1p_:function(t){const e={x:Jr(t,"x","log1p")};return Gr.runKernel(sn,e)}});const go=Zr({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Jr(t,"x","max")},a={reductionIndices:e,keepDims:n};return Gr.runKernel("Max",r,a)}});const mo=Zr({mul_:function(t,e){let n=Jr(t,"a","mul"),r=Jr(e,"b","mul");[n,r]=zr(n,r);const a={a:n,b:r};return Gr.runKernel(dn,a)}});const bo=Zr({sub_:function(t,e){let n=Jr(t,"a","sub"),r=Jr(e,"b","sub");[n,r]=zr(n,r);const a={a:n,b:r};return Gr.runKernel("Sub",a)}});const yo=Zr({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Jr(t,"x","sum");"bool"===r.dtype&&(r=Ga(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return Gr.runKernel("Sum",a,s)}});const vo=Zr({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Jr(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=ps(((t,n)=>{const r=go(t,e,!0),a=bo(t,r),s=bo(Ga(a,"float32"),po(yo(ro(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=ro(r);return bo(t,mo(yo(t,e,!0),a))}}}));return r(n)}});const wo=Zr({logicalAnd_:function(t,e){const n=Jr(t,"a","logicalAnd","bool"),r=Jr(e,"b","logicalAnd","bool");eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LogicalAnd",a)}});const xo=Zr({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Jr(t,"a","matMul"),s=Jr(e,"b","matMul");[a,s]=zr(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return Gr.runKernel(Me,o,i)}});const ko=Zr({maxPool_:function(t,e,n,r,a){const s=Jr(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=As(s,[1,s.shape[0],s.shape[1],s.shape[2]])),re(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),re(Cs(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),Ts("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=Gr.runKernel(ln,l,c);return i?As(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const So=Zr({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Jr(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=As(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),re("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Ts("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=Gr.runKernel(cn,c,u);return l?As(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Io=Zr({maximum_:function(t,e){let n=Jr(t,"a","maximum"),r=Jr(e,"b","maximum");[n,r]=zr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(on,a)}});const No=Zr({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Jr(t,"x","mean")},a={axis:e,keepDims:n};return Gr.runKernel(un,r,a)}});const Eo=Zr({minimum_:function(t,e){let n=Jr(t,"a","minimum"),r=Jr(e,"b","minimum");[n,r]=zr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(hn,a)}});function Co(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function To(t,e){return function(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}(t,e.map((t=>1)),e)}function Ao(t,e){if(Co(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Ro(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}const Fo=Zr({square_:function(t){const e=Jr(t,"x","square");return Gr.runKernel("Square",{x:e},{})}});const _o=Zr({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=he(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=Jr(t,"x","moments")).shape),r=No(t,n,e);let a=r.shape;e||(a=To(r.shape,n));const s=Fo(bo(Ga(t,"float32"),As(r,a)));return{mean:r,variance:No(s,n,e)}}});const Do=Zr({neg_:function(t){const e={x:Jr(t,"x","neg")};return Gr.runKernel("Neg",e)}});const Oo=Zr({notEqual_:function(t,e){let n=Jr(t,"a","notEqual","string_or_numeric"),r=Jr(e,"b","notEqual","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("NotEqual",a)}});const zo=Zr({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:Jr(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return Gr.runKernel(fn,s,o)}});function Lo(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Lo(t,"float32"),n=Lo(t,"float32");return Qr(e,n)}const n=ke(ie(t),e);return Gr.makeTensor(n,t,e)}function Mo(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Mo(t,"float32"),n=Lo(t,"float32");return Qr(e,n)}const n=xe(ie(t),e);return Gr.makeTensor(n,t,e)}const Po=Zr({onesLike_:function(t){const e={x:Jr(t,"x","onesLike")};return Gr.runKernel(pn,e)}});const Bo=Zr({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=Jr(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return Gr.runKernel(mn,s,a)}});const Wo=Zr({prelu_:function(t,e){const n={x:Jr(t,"x","prelu"),alpha:Jr(e,"alpha","prelu")};return Gr.runKernel(bn,n)}});var Uo=n(4334);class Vo{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Uo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Go{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Uo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const jo=Zr({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new Vo(e,n,r,!1,a),o=Va(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const Ho=Zr({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>4?arguments[4]:void 0;const a=Va(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=new Go(e,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}});const Ko=Zr({relu_:function(t){const e={x:Jr(t,"x","relu")};return Gr.runKernel(vn,e)}});const qo=Zr({reverse_:function(t,e){const n={x:Jr(t,"x","reverse")},r={dims:e};return Gr.runKernel(In,n,r)}});const Xo=Zr({selu_:function(t){const e={x:Jr(t,"x","selu")};return Gr.runKernel(Tn,e)}});const Jo=Zr({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Jr(t,"x","separableConv2d"),l=Jr(e,"depthwiseFilter","separableConv2d"),c=Jr(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=As(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");re(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),re(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),re(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),re(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),re(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];re(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=Ys(u,l,r,a,o,s),g=Gs(f,c,1,"valid",o);return h?As(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const Yo=Zr({sigmoid_:function(t){const e={x:Jr(t,"x","sigmoid","float32")};return Gr.runKernel(Fn,e)}});const Zo=Zr({slice_:function(t,e,n){const r=Jr(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return Gr.runKernel(An,a,s)}});const Qo=Zr({slice1d_:function(t,e,n){const r=Jr(t,"x","slice1d");return re(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),Zo(r,[e],[n])}});const $o=Zr({slice2d_:function(t,e,n){const r=Jr(t,"x","slice2d");return re(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),Zo(r,e,n)}});const ti=Zr({slice3d_:function(t,e,n){const r=Jr(t,"x","slice3d");return re(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),Zo(r,e,n)}});const ei=Zr({slice4d_:function(t,e,n){const r=Jr(t,"x","slice4d");return re(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),Zo(r,e,n)}});const ni=Zr({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Jr(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return Gr.runKernel(Ln,r,a)}});const ri=Zr({softplus_:function(t){const e={x:Jr(t,"x","softplus")};return Gr.runKernel(_n,e)}});const ai=Zr({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:Jr(t,"x","split")},a={numOrSizeSplits:e,axis:n};return Gr.runKernel(zn,r,a)}});const si=Zr({sqrt_:function(t){const e={x:Jr(t,"x","sqrt","float32")};return Gr.runKernel(Dn,e)}});const oi=Zr({squeeze_:function(t,e){const n=Jr(t,"x","squeeze","string_or_numeric");return As(n,function(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:he(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}(n.shape,e).newShape)}});const ii=Zr({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Yr(t,"tensors","stack","string_or_numeric");re(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&re(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return Gr.runKernel(gn,r,a)}});const li=Zr({tanh_:function(t){const e={x:Jr(t,"x","tanh","float32")};return Gr.runKernel(Pn,e)}});function ci(t,e){se(t);const n=Kr(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return $r(t,null,n,e)}function ui(t,e,n){if(se(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Kr(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return $r(t,e,r,n)}const hi=Zr({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Vo(e,n,r,!0,a),o=Va(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const di=Zr({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Jr(t,"x","unstack","string_or_numeric");re(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return Gr.runKernel(Un,r,a)}});const pi=Zr({broadcastTo_:function(t,e){let n=Jr(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!==0)))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(e,"]."));if(e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=As(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return ja(n);const o={x:n},i={reps:s};return Gr.runKernel(Bn,o,i)}});const fi=Zr({where_:function(t,e,n){const r=Jr(e,"a","where"),a=Jr(n,"b","where"),s=Jr(t,"condition","where","bool"),o=eo(eo(s.shape,r.shape),a.shape),i={condition:pi(s,o),t:pi(r,o),e:pi(a,o)};return Gr.runKernel(Cn,i)}});const gi=Zr({zerosLike_:function(t){const e={x:Jr(t,"x","zerosLike")};return Gr.runKernel(Gn,e)}});const mi=Zr({imag_:function(t){const e={input:Jr(t,"input","imag")};return Gr.runKernel("Imag",e)}});const bi=Zr({real_:function(t){const e={input:Jr(t,"input","real")};return Gr.runKernel("Real",e)}});const yi=Zr({transpose_:function(t,e,n){const r=Jr(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),re(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{re(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?cs((()=>{let t=bi(r),e=mi(r);return t=Gr.runKernel(Wn,{x:t},s),e=Gr.runKernel(Wn,{x:e},s),n&&(e=Do(e)),Qr(t,e)})):Gr.runKernel(Wn,a,s)}});const vi=Zr({dropout_:function(t,e,n,r){const a=Jr(t,"x","dropout");if(re("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),re(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Er?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if(le(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=Qs(io(bs(Ho(s,0,1,"float32",r),o)),o);return mo(a,i)}});const wi=Zr({fft_:function(t){re("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("FFT",e)}});const xi=Zr({rfft_:function(t,e){re("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=Zo(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=Ps([t,Lo(r)],t.shape.length-1),n=e}else a=t;const s=gi(a),o=As(Qr(a,s),[r,n]),i=wi(o),l=Math.floor(n/2)+1,c=bi(i),u=mi(i),h=ai(c,[l,n-l],c.shape.length-1),d=ai(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,As(Qr(h[0],d[0]),p)}});const ki=Zr({ifft_:function(t){re("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("IFFT",e)}});Zr({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=As(t,[n,e]);r=ki(a)}else{const a=[n,2*(e-1)],s=As(bi(t),[n,e]),o=As(mi(t),[n,e]),i=qo(Zo(s,[0,1],[n,e-2]),1),l=mo(qo(Zo(o,[0,1],[n,e-2]),1),fs(-1)),c=Ps([s,i],1),u=Ps([o,l],1),h=As(Qr(c,u),[a[0],a[1]]);r=ki(h)}if(r=bi(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=As(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const Si=Zr({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=As(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=As(e,[1,e.shape[0],e.shape[1],e.shape[2]])),re(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),re(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),re(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];re(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),re(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),Ts("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return Gr.runKernel("Conv2DBackpropFilter",h,d)}});const Ii=Zr({relu6_:function(t){const e={x:Jr(t,"x","relu6")};return Gr.runKernel(Sn,e)}});const Ni=Zr({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Jr(t,"x","step")},r={alpha:e};return Gr.runKernel(jn,n,r)}});function Ei(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return mo(t,Ni(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Ci(t,e){let n=e;const r=to(t.shape,e.shape);return r.length>0&&(n=yo(n,r)),As(n,t.shape)}function Ti(t,e,n,r){if("linear"===e)return t;if("relu"===e)return Ko(t);if("elu"===e)return $s(t);if("relu6"===e)return Ii(t);if("prelu"===e)return Wo(t,n);if("leakyrelu"===e)return ho(t,r);if("sigmoid"===e)return Yo(t);throw new Error("Unknown fused activation ".concat(e,"."))}const Ai=(t,e)=>!(t>0)||"linear"===e;const Ri=Zr({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===Ai(Gr.state.gradientDepth,c)){re("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=Gs(e,n,r,a,s,o,i);return null!=l&&(t=bs(t,l)),Ti(t,c,u,h)}const d=Jr(e,"x","conv2d","float32"),p=Jr(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=As(d,[1,d.shape[0],d.shape[1],d.shape[2]])),re(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),re(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),Ts("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];re(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),re(Cs(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=xs(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=Jr(l,"bias","fused conv2d"),[y]=zr(y,d),"NHWC"===s?eo(b.outShape,y.shape):(re(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),re(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(re(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)re(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{eo(t,b.outShape)}catch(o1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=Jr(u,"prelu weights","fused conv2d")}const w=(t,e)=>{re("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=Ei(t,l,c);re(Es(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[Hs(i.shape,h,n,r,a),Si(i,h,n.shape,r,a)];if(null!=u){const t=Ci(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=ps(((t,e,n)=>{let r=Gr.runKernel(qn,x,k);return n([e,t,r]),g&&(r=As(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=ps(((t,e,n,r)=>{let a=Gr.runKernel(qn,x,k);return r([e,t,a,n]),g&&(a=As(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const Fi=Zr({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=As(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=As(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return Gr.runKernel("DepthwiseConv2dNativeBackpropFilter",c,u)}});const _i=Zr({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=As(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=Gr.runKernel("DepthwiseConv2dNativeBackpropInput",c,u);return l?As(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Zr({fusedDepthwiseConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(!1===Ai(Gr.state.gradientDepth,c)){let t=Ys(e,n,r,a,s,o,i);return null!=l&&(t=bs(t,l)),Ti(t,c,u,h)}const d=Jr(e,"x","depthwiseConv2d","float32"),p=Jr(n,"filter","depthwiseConv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=As(d,[1,d.shape[0],d.shape[1],d.shape[2]])),re(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),re(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),re(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==o&&(o=[1,1]),re(Cs(r,o),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(r," and dilations '").concat(o,"'"))),Ts("fused depthwiseConv2d",a,i);const m=xs(f.shape,p.shape,r,o,a,i,!0);let b,y;null!=l&&(b=Jr(l,"bias","fused conv2d"),[b]=zr(b,d),eo(m.outShape,b.shape)),null!=u&&(y=Jr(u,"prelu weights","fused depthwiseConv2d"));const v=(t,e)=>{re(Es(o),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'")));const[n,s,l,u]=e,h=Ei(t,l,c),d=_i(s.shape,h,n,r,a,o,i),p=Fi(s,h,n.shape,r,a,o,i);if(null!=u){return[d,p,Ci(b,h)]}return[d,p]},w={x:f,filter:p,bias:b,preluActivationWeights:y},x={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=ps(((t,e,n)=>{let r=Gr.runKernel(Xn,w,x);return n([e,t,r]),g&&(r=As(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(f,p)}{const t=ps(((t,e,n,r)=>{let a=Gr.runKernel(Xn,w,x);return r([e,t,a,n]),g&&(a=As(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return t(f,p,b)}}});const Di=Zr({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===Ai(Gr.state.gradientDepth,o)){let t=xo(e,n,r,a);return null!=s&&(t=bs(t,s)),Ti(t,o,i,l)}let c=Jr(e,"a","fused matMul"),u=Jr(n,"b","fused matMul");[c,u]=zr(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=ie(g),y=ie(m);re(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=eo(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=As(c,r?[b,h,p]:[b,p,h]),x=As(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=Jr(s,"bias","fused matMul"),[k]=zr(k,c),eo(v,k.shape)),null!=i&&(S=Jr(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=Ei(As(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=xo(u,i,!1,!1),d=xo(u,n,!0,!1)):r&&!a?(h=xo(i,u,!1,!0),d=xo(n,u,!1,!1)):(h=xo(i,u,!0,!0),d=xo(u,n,!0,!0)):(h=xo(u,i,!1,!0),d=xo(n,u,!0,!1)),null!=s){return[h,d,Ci(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},E={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=ps(((t,e,n)=>{const r=Gr.runKernel(Kn,N,E);return n([t,e,r]),{value:As(r,v),gradFunc:I}}));return t(w,x)}{const t=ps(((t,e,n,r)=>{const a=Gr.runKernel(Kn,N,E);return r([t,e,a,n]),{value:As(a,v),gradFunc:I}}));return t(w,x,k)}}});function Oi(t,e,n){const r=1-t%2,a=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);a[s]=e-n*Math.cos(o)}return ci(a,"float32")}Zr({hammingWindow_:function(t){return Oi(t,.54,.46)}});const zi=Zr({hannWindow_:function(t){return Oi(t,.5,.5)}});const Li=Zr({frame_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const o=[];for(;s+e<=t.size;)o.push(Zo(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,i=Ps([Zo(t,s,e-r),Ls([r],a)]);o.push(i),s+=n}return 0===o.length?ui([],[0,e]):As(Ps(o),[o.length,e])}});Zr({stft_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:zi;var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=Li(t,e,n),i=mo(o,a(e));return xi(i,r)}});const Mi=Zr({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Jr(t,"image","cropAndResize"),i=Jr(e,"boxes","cropAndResize","float32"),l=Jr(n,"boxInd","cropAndResize","int32"),c=i.shape[0];re(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),re(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),re(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),re(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),re(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),re("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return Gr.runKernel("CropAndResize",u,h)}});const Pi=Zr({flipLeftRight_:function(t){const e=Jr(t,"image","flipLeftRight","float32");re(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return Gr.runKernel("FlipLeftRight",n,{})}});const Bi=Zr({grayscaleToRGB_:function(t){const e=Jr(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];re(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),re(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,so(e,a)}});const Wi=Zr({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Jr(t,"image","rotateWithOffset","float32");re(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return Gr.runKernel("RotateWithOffset",s,o)}});function Ui(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),re(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),re(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),re(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),re(1===e.rank,(()=>"scores must be a 1D tensor")),re(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),re(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const Vi=Zr({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Jr(t,"boxes","nonMaxSuppression","float32"),o=Jr(e,"scores","nonMaxSuppression","float32"),i=Ui(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Gr.runKernel("NonMaxSuppressionV3",{boxes:s,scores:o},l)}});function Gi(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||ji)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function ji(t,e){return t>e?1:t<e?-1:0}function Hi(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(Xi);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=Ki(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*qi(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&Gi(c,e,Xi))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function Ki(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function qi(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Xi(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const Ji=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Jr(t,"boxes","nonMaxSuppressionAsync"),o=Jr(e,"scores","nonMaxSuppressionAsync"),i=Ui(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=function(t,e,n,r,a){return Hi(t,e,n,r,a,0)}(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),ci(h,"int32")};const Yi=Zr({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Jr(t,"boxes","nonMaxSuppression"),i=Jr(e,"scores","nonMaxSuppression"),l=Ui(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=Gr.runKernel("NonMaxSuppressionV5",c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const Zi=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Jr(t,"boxes","nonMaxSuppressionAsync"),i=Jr(e,"scores","nonMaxSuppressionAsync"),l=Ui(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=function(t,e,n,r,a,s){return Hi(t,e,n,r,a,s,!0)}(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ci(d,"int32"),selectedScores:ci(p)}};const Qi=Zr({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Jr(t,"boxes","nonMaxSuppression"),i=Jr(e,"scores","nonMaxSuppression"),l=Ui(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=Gr.runKernel("NonMaxSuppressionV4",c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const $i=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Jr(t,"boxes","nonMaxSuppressionAsync"),i=Jr(e,"scores","nonMaxSuppressionAsync"),l=Ui(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=function(t,e,n,r,a,s){return Hi(t,e,n,r,a,0,!1,s,!0)}(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ci(f,"int32"),validOutputs:fs(g,"int32")}};const tl=Zr({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Jr(t,"images","resizeBilinear");re(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),re(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),re(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=As(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(kn,i,l);return o?As(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const el=Zr({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Jr(t,"images","resizeNearestNeighbor");re(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),re(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),re("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),re(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=As(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(xn,i,l);return o?As(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const nl=Zr({bincount_:function(t,e,n){const r=Jr(t,"x","bincount"),a=Jr(e,"weights","bincount");re("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),re(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),re(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return Gr.runKernel("Bincount",s,o)}});const rl=Zr({lessEqual_:function(t,e){let n=Jr(t,"a","lessEqual","string_or_numeric"),r=Jr(e,"b","lessEqual","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LessEqual",a)}});const al=Zr({round_:function(t){const e={x:Jr(t,"x","round")};return Gr.runKernel(Nn,e)}});function sl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return Gr.runKernel(yn,{},a)}const ol=Zr({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Jr(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=mo(ci([r]),255);if(re(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),re(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),re("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),re("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=ai(a,[1,1,1],-1);const t=mo(o,.2989),e=mo(i,.587),n=mo(l,.114);c=bs(bs(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=ci([-1]),c=ci([0]),u=ci([0]);for(let h=0;h<t.size-1;h++){n=Zo(t,0,h+1),r=Zo(t,h+1),o=Qs(yo(n),e),i=Qs(yo(r),e);const d=yo(mo(n,sl(0,n.size)));a=Qs(d,yo(n));const p=Ls(r.shape,n.size),f=bs(sl(0,r.size),p),g=mo(r,f);s=Qs(yo(g),yo(r));const m=bo(a,s),b=bo(a,s),y=mo(o,i);u=mo(mo(y,m),b);const v=co(u,c);c=fi(v,u,c),l=fi(v,ci([h]),l)}return l}(nl(Ga(al(c),"int32"),ta([]),256),s)}const h=n?rl(c,u):co(c,u);return Ga(mo(h,255),"int32")}});const il=Zr({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=Jr(t,"image","transform","float32"),i=Jr(e,"transforms","transform","float32");re(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),re(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),re(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Gr.runKernel("Transform",l,c)}});const ll=Zr({bandPart_:function(t,e,n){re(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),re(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")));const r=Jr(t,"a","bandPart");re(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);if(!(e<=s))throw new Error("bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=o))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."));e<0&&(e=s),n<0&&(n=o);const i=As(sl(0,s,1,"int32"),[-1,1]),l=sl(0,o,1,"int32"),c=bo(i,l),u=wo(rl(c,fs(+e,"int32")),uo(c,fs(-n,"int32"))),h=Lo([s,o],r.dtype);return As(ii(di(As(r,[-1,s,o])).map((t=>fi(u,t,h)))),a)}});const cl=Zr({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Jr(t,"x","min")},a={axis:e,keepDims:n};return Gr.runKernel("Min",r,a)}});const ul=Zr({pow_:function(t,e){let n=Jr(t,"base","pow"),r=Jr(e,"exp","pow");[n,r]=zr(n,r);const a={a:n,b:r};return Gr.runKernel("Pow",a)}});function hl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return ms(t);if(1!==t.rank&&null===n)return hl(As(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return yo(ms(t),n);if(e===1/0)return go(ms(t),n);if(e===-1/0)return cl(ms(t),n);if("euclidean"===e||2===e)return si(yo(ul(ms(t),fs(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return go(yo(ms(t),n[0]),n[1]-1);if(e===1/0)return go(yo(ms(t),n[1]),n[0]);if(e===-1/0)return cl(yo(ms(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return si(yo(Fo(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const dl=Zr({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=hl(t=Jr(t,"x","norm"),e,n);let s=a.shape;if(r){const e=he(n,t.shape);s=To(a.shape,e)}return As(a,s)}});const pl=Zr({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,re(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)re(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=ai(t,t.shape[0],0).map((t=>oi(t,[0])));re(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(Gr.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=mo(yo(mo(n[e],t)),n[e]);t=bo(t,r)}return Qs(t,dl(t,"euclidean"))})));return e?ii(n,0):n}});function fl(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Gr.tidy((()=>{re(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=oo(n),s=ja(t);const o=ui([[1]],[1,1]);let i=ja(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=Gr.tidy((()=>{const e=Zo(s,[t,t],[n-t,1]),l=dl(e),c=Zo(s,[t,t],[1,1]),u=fi(co(c,0),ui([[-1]]),ui([[1]])),h=bo(c,mo(u,l)),d=Qs(e,h);i=1===d.shape[0]?ja(o):Ps([o,Zo(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Do(Qs(xo(u,h),l)),f=Zo(s,[t,0],[n-t,r]),g=mo(p,i),m=yi(i);if(0===t)s=bo(f,xo(g,xo(m,f)));else{const e=bo(f,xo(g,xo(m,f)));s=Ps([Zo(s,[0,0],[t,r]),e],0)}const b=yi(g),y=Zo(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=bo(y,xo(xo(y,i),b));else{const e=bo(y,xo(xo(y,i),b));a=Ps([Zo(a,[0,0],[n,t]),e],1)}return[i,s,a]})),us([e,l,c])}return!e&&n>r&&(a=Zo(a,[0,0],[n,r]),s=Zo(s,[0,0],[r,r])),[a,s]}))}const gl=Zr({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(re(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return fl(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=di(As(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=fl(t,e);a.push(n),s.push(r)}));return[As(ii(a,0),t.shape),As(ii(s,0),t.shape)]}}});var ml;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ml||(ml={}));const bl=Zr({computeWeightedLoss_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ml.SUM_BY_NONZERO_WEIGHTS;const r=Jr(t,"losses","computeWeightedLoss");let a=null;null!=e&&(a=Jr(e,"weights","computeWeightedLoss"));const s=null==a?r:mo(r,a);if(n===ml.NONE)return s;if(n===ml.SUM)return yo(s);if(n===ml.MEAN){if(null==a)return No(s);{const t=r.size/a.size,e=Qs(yo(s),yo(a));return t>1?Qs(e,fs(t)):e}}if(n===ml.SUM_BY_NONZERO_WEIGHTS){if(null==a)return Qs(yo(s),fs(r.size));{const t=mo(a,Mo(r.shape)),e=Ga(yo(Oo(t,fs(0))),"float32");return Qs(yo(s),e)}}throw Error("Unknown reduction: ".concat(n))}});Zr({absoluteDifference_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ml.SUM_BY_NONZERO_WEIGHTS;const a=Jr(t,"labels","absoluteDifference"),s=Jr(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=Jr(n,"weights","absoluteDifference")),ae(a.shape,s.shape,"Error in absoluteDifference: ");const i=ms(bo(a,s));return bl(i,o,r)}});Zr({cosineDistance_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ml.SUM_BY_NONZERO_WEIGHTS;const s=Jr(t,"labels","cosineDistance"),o=Jr(e,"predictions","cosineDistance");let i=null;null!=r&&(i=Jr(r,"weights","cosineDistance")),ae(s.shape,o.shape,"Error in cosineDistance: ");const l=fs(1),c=bo(l,yo(mo(s,o),n,!0));return bl(c,i,a)}});Zr({hingeLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ml.SUM_BY_NONZERO_WEIGHTS,a=Jr(t,"labels","hingeLoss");const s=Jr(e,"predictions","hingeLoss");let o=null;null!=n&&(o=Jr(n,"weights","hingeLoss")),ae(a.shape,s.shape,"Error in hingeLoss: ");const i=fs(1);a=bo(mo(fs(2),a),i);const l=Ko(bo(i,mo(a,s)));return bl(l,o,r)}});Zr({huberLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ml.SUM_BY_NONZERO_WEIGHTS;const s=Jr(t,"labels","huberLoss"),o=Jr(e,"predictions","huberLoss");let i=null;null!=n&&(i=Jr(n,"weights","huberLoss")),ae(s.shape,o.shape,"Error in huberLoss: ");const l=fs(r),c=ms(bo(o,s)),u=Eo(c,l),h=bo(c,u),d=bs(mo(fs(.5),Fo(u)),mo(l,h));return bl(d,i,a)}});Zr({logLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ml.SUM_BY_NONZERO_WEIGHTS;const s=Jr(t,"labels","logLoss"),o=Jr(e,"predictions","logLoss");let i=null;null!=n&&(i=Jr(n,"weights","logLoss")),ae(s.shape,o.shape,"Error in logLoss: ");const l=fs(1),c=fs(r),u=Do(mo(s,po(bs(o,c)))),h=mo(bo(l,s),po(bs(bo(l,o),c))),d=bo(u,h);return bl(d,i,a)}});const yl=Zr({squaredDifference_:function(t,e){let n=Jr(t,"a","squaredDifference"),r=Jr(e,"b","squaredDifference");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(Mn,a,{})}});Zr({meanSquaredError_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ml.SUM_BY_NONZERO_WEIGHTS;const a=Jr(t,"labels","meanSquaredError"),s=Jr(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=Jr(n,"weights","meanSquaredError")),ae(a.shape,s.shape,"Error in meanSquaredError: ");const i=yl(a,s);return bl(i,o,r)}});Zr({sigmoidCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ml.SUM_BY_NONZERO_WEIGHTS,s=Jr(t,"multiClassLabels","sigmoidCrossEntropy");const o=Jr(e,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Jr(n,"weights","sigmoidCrossEntropy")),ae(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=fs(r),e=fs(1),n=fs(.5);s=bs(mo(s,bo(e,t)),mo(n,t))}const l=function(t,e){const n=Jr(t,"labels","sigmoidCrossEntropyWithLogits"),r=Jr(e,"logits","sigmoidCrossEntropyWithLogits");ae(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=Ko(r),s=mo(r,n),o=fo(ro(Do(ms(r))));return bs(bo(a,s),o)}(s,o);return bl(l,i,a)}});const vl=Zr({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=Jr(t,"x","logSumExp"),a=he(e,r.shape),s=go(r,a,!0),o=bo(r,s),i=ro(o),l=yo(i,a),c=po(l),u=bs(As(s,c.shape),c);if(n){const t=To(u.shape,a);return As(u,t)}return u}});Zr({softmaxCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ml.SUM_BY_NONZERO_WEIGHTS,s=Jr(t,"onehotLabels","softmaxCrossEntropy");const o=Jr(e,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Jr(n,"weights","softmaxCrossEntropy")),ae(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=fs(r),e=fs(1),n=fs(s.shape[1]);s=bs(mo(s,bo(e,t)),Qs(t,n))}const l=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(e.rank," ")+"and dim was ".concat(n));const r=ps(((t,e,r)=>{const a=vl(e,[n],!0),s=bo(Ga(e,"float32"),a);r([t,s]);const o=Do(mo(s,t));return{value:yo(o,[n]),gradFunc:(t,e)=>{const[r,a]=e,s=To(t.shape,[n]);return[mo(As(t,s),bo(Ga(r,"float32"),ro(a))),mo(As(t,s),bo(ro(a),Ga(r,"float32")))]}}}));return r(t,e)}(s,o);return bl(l,i,a)}});Zr({sparseFillEmptyRows_:function(t,e,n,r){const a=Jr(t,"indices","sparseFillEmptyRows","int32"),s=Jr(e,"values","sparseFillEmptyRows"),o=Jr(n,"denseShape","sparseFillEmptyRows","int32"),i=Jr(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const l={indices:a,values:s,denseShape:o,defaultValue:i},c=Gr.runKernel("SparseFillEmptyRows",l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}});Zr({sparseReshape_:function(t,e,n){const r=Jr(t,"inputIndices","sparseReshape","int32"),a=Jr(e,"inputShape","sparseReshape","int32"),s=Jr(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==a.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(a.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const o={inputIndices:r,inputShape:a,newShape:s},i=Gr.runKernel("SparseReshape",o);return{outputIndices:i[0],outputShape:i[1]}}});Zr({sparseSegmentMean_:function(t,e,n){const r=Jr(t,"data","sparseSegmentMean"),a=Jr(e,"indices","sparseSegmentMean","int32"),s=Jr(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentMean",o)}});Zr({sparseSegmentSum_:function(t,e,n){const r=Jr(t,"data","sparseSegmentSum"),a=Jr(e,"indices","sparseSegmentSum","int32"),s=Jr(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentSum",o)}});Zr({stringNGrams_:function(t,e,n,r,a,s,o,i){const l=Jr(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error("Data must be a vector, saw: ".concat(l.shape));const c=Jr(e,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},h={data:l,dataSplits:c},d=Gr.runKernel("StringNGrams",h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});Zr({stringSplit_:function(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Jr(t,"input","stringSplit","string"),a=Jr(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error("Input should be Tensor1D but received shape ".concat(r.shape));if(0!==a.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(a.shape));const s={skipEmpty:n},o={input:r,delimiter:a},i=Gr.runKernel("StringSplit",o,s);return{indices:i[0],values:i[1],shape:i[2]}}});Zr({stringToHashBucketFast_:function(t,e){const n=Jr(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return Gr.runKernel("StringToHashBucketFast",a,r)}});const wl={flipLeftRight:Pi,grayscaleToRGB:Bi,resizeNearestNeighbor:el,resizeBilinear:tl,rotateWithOffset:Wi,cropAndResize:Mi,nonMaxSuppression:Vi,nonMaxSuppressionAsync:Ji,nonMaxSuppressionWithScore:Yi,nonMaxSuppressionWithScoreAsync:Zi,nonMaxSuppressionPadded:Qi,nonMaxSuppressionPaddedAsync:$i,threshold:ol,transform:il},xl={bandPart:ll,gramSchmidt:pl,qr:gl};class kl extends gs{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:cs((()=>gi(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:cs((()=>gi(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;cs((()=>{const t=bs(mo(s,this.rho),mo(Fo(a),1-this.rho)),e=mo(Qs(si(bs(o,this.epsilon)),si(bs(s,this.epsilon))),a),n=bs(mo(o,this.rho),mo(Fo(e),1-this.rho));s.assign(t),o.assign(n);const i=bs(mo(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(us(this.accumulatedGrads.map((t=>t.variable))),us(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}kl.className="Adadelta",is(kl);class Sl extends gs{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:cs((()=>Ls(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;cs((()=>{const t=bs(s,Fo(a));s.assign(t);const e=bs(mo(Qs(a,si(bs(t,Gr.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&us(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}Sl.className="Adagrad",is(Sl);class Il extends gs{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],cs((()=>{this.accBeta1=fs(e).variable(),this.accBeta2=fs(n).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);cs((()=>{const n=bo(1,this.accBeta1),r=bo(1,this.accBeta2);e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:cs((()=>gi(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:cs((()=>gi(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=bs(mo(i,this.beta1),mo(o,1-this.beta1)),u=bs(mo(l,this.beta2),mo(Fo(o),1-this.beta2)),h=Qs(c,n),d=Qs(u,r);i.assign(c),l.assign(u);const p=bs(mo(Qs(h,bs(si(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(mo(this.accBeta1,this.beta1)),this.accBeta2.assign(mo(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&us(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&us(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),cs((()=>{this.accBeta1.assign(ul(this.beta1,this.iterations_+1)),this.accBeta2.assign(ul(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Il.className="Adam",is(Il);class Nl extends gs{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],cs((()=>{this.iteration=fs(0).variable(),this.accBeta1=fs(e).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);cs((()=>{const n=bo(1,this.accBeta1),r=Qs(-this.learningRate,bs(mo(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:gi(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:gi(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=bs(mo(i,this.beta1),mo(o,1-this.beta1)),u=mo(l,this.beta2),h=ms(o),d=Io(u,h);i.assign(c),l.assign(d);const p=bs(mo(Qs(r,n),Qs(c,bs(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(bs(this.iteration,1)),this.accBeta1.assign(mo(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&us(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&us(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Nl.className="Adamax",is(Nl);class El extends gs{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=Gr.registeredVariables[e];cs((()=>{const t=bs(mo(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=hs(fs(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}El.className="SGD",is(El);class Cl extends El{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=fs(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:cs((()=>gi(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&cs((()=>{let t;const e=bs(mo(this.m,a),s);t=this.useNesterov?bs(mo(this.c,bs(s,mo(e,this.m))),r):bs(mo(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&us(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Cl.className="Momentum",is(Cl);class Tl extends gs{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Gr.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:cs((()=>gi(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:cs((()=>gi(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:cs((()=>gi(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;cs((()=>{const t=bs(mo(o,this.decay),mo(Fo(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=bs(mo(e,this.decay),mo(s,1-this.decay)),l=Qs(mo(s,this.learningRate),si(bo(t,bs(Fo(a),this.epsilon)))),c=bs(mo(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=bo(r,c);r.assign(u)}else{const t=bs(mo(o,this.decay),mo(Fo(s),1-this.decay)),e=bs(mo(i,this.momentum),Qs(mo(s,this.learningRate),si(bs(t,this.epsilon))));o.assign(t),i.assign(e);const n=bo(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&us(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&us(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&us(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Tl.className="RMSProp",is(Tl);class Al{static sgd(t){return new El(t)}static momentum(t,e){return new Cl(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new Tl(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Il(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new kl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Nl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new Sl(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Rl={sgd:Al.sgd,momentum:Al.momentum,adadelta:Al.adadelta,adagrad:Al.adagrad,rmsprop:Al.rmsprop,adamax:Al.adamax,adam:Al.adam},Fl="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function _l(){return new Promise((t=>Fl((()=>t()))))}var Dl,Ol=n(6494);function zl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(Wl(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=zl(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function Ll(t){return Ml(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:Pl)}function Ml(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(Wl(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=Ml(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function Pl(t){return null===t?null:Wl(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function Bl(t,e){const n=new Map;zl(t,e,n);for(const r of Array.from(n.keys())){const t=n.get(r);if(Ie(t)){const e=await t;n.set(r,e)}}return zl(t,e,n)}function Wl(t){let e=!1;if(Te().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(551);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Er)&&!(t instanceof Promise)&&!e)}function Ul(t){return function(t,e){return zl(t,e)}(t,Vl)}function Vl(t){return t instanceof Er?{value:t.clone(),recurse:!1}:Wl(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class Gl{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class jl extends Gl{constructor(){super(jl.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function Hl(t){return new Jl(t)}function Kl(t){return new Yl(t)}function ql(t,e){return new ic(t,e)}jl.INITIAL_CAPACITY=32;class Xl{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new rc(this,t)}filter(t){return new ec(this,t)}map(t){return new nc(this,t)}mapAsync(t){return new ac(this,t)}serialMapAsync(t){return new ac(this,t).serial()}flatmap(t){return new oc(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new tc(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Pl;return this.rowMajorBatch(t,e).map((t=>Ll(t,n)))}concatenate(t,e){return new ic(Hl([this,t]),e)}take(t){return t<0||null==t?this:new $l(this,t)}skip(t){return t<0||null==t?this:new Ql(this,t)}prefetch(t){return new cc(this,t)}shuffle(t,e){return new uc(this,t,e)}serial(){return new Zl(this)}}class Jl extends Xl{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:Ul(t),done:!1}}}class Yl extends Xl{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(o1){throw o1.message="Error thrown while iterating through a dataset: ".concat(o1.message),o1}}}class Zl extends Xl{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class Ql extends Xl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;us(t.value)}return this.upstream.next()}}class $l extends Xl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class tc extends Xl{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class ec extends Xl{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;us(t.value)}}}class nc extends Xl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Mr(t.value),n=this.transform(t.value),r=Mr(n);for(const a of e)Lr(a,r)||a.dispose();return{value:n,done:!1}}}class rc extends Xl{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(o1){if(!this.handler(o1))return{value:null,done:!0}}}}class ac extends Xl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Mr(t.value),n=await this.transform(t.value),r=Mr(n);for(const a of e)Lr(a,r)||a.dispose();return{value:n,done:!1}}}class sc extends Xl{constructor(){super(),this.outputQueue=new jl,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class oc extends sc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Mr(t.value),n=this.transform(t.value),r=Mr(n);this.outputQueue.pushAll(n);for(const a of e)Lr(a,r)||a.dispose();return!0}}class ic extends Xl{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(Dl||(Dl={}));class lc extends Xl{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Dl.FAIL;super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{".concat("TODO: fill in upstream of zip summaries","} -> Zip")}async nextState(t){await t;let e=0,n=0;const r=await Bl(this.iterators,(function(t){if(t instanceof Xl){return{value:t.next().then((t=>(e++,t.done&&n++,t.value))),recurse:!1}}return{value:null,recurse:!0}}));if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Dl.FAIL:throw new Error("Zipped streams should have the same length. "+"Mismatched at element ".concat(this.count,"."));case Dl.SHORTEST:return{value:null,done:!0};case Dl.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class cc extends Xl{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new Gl(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class uc extends cc{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Uo.alea(n||lr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class hc{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return re(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),dc((async()=>(await n.iterator()).columnMajorBatch(t,e,gc)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,dc((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,dc((async()=>(await e.iterator()).filter((e=>cs((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return dc((async()=>(await e.iterator()).map((e=>cs((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return dc((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return dc((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,dc((async()=>ql(Kl((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,dc((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Uo.alea(e||lr().toString());return dc((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,dc((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function dc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends hc{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function pc(t){return dc((async()=>Hl(t)),t.length)}function fc(t){if(!Wl(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=null==e?t[n].size:Math.min(e,t[n].size);return dc((async()=>function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Dl.FAIL;return new lc(t,e)}(await Bl(t,(t=>{if(t instanceof hc)return{value:t.iterator(),recurse:!1};if(Wl(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),Dl.SHORTEST)),e)}function gc(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Er||de(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Er?ii(t):ta(t)}(t),recurse:!1}}return{value:null,recurse:!0}}hc.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");class mc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,mc.prototype)}}class bc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bc.prototype)}}class yc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,yc.prototype)}}class vc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vc.prototype)}}class wc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,wc.prototype)}}Error;class xc{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function kc(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function Sc(t,e){if(!t)throw new wc(e)}function Ic(t,e){let n=0;for(const r of t)r===e&&n++;return n}function Nc(t){return 1===t.length?t[0]:t}function Ec(t){return Array.isArray(t)?t:[t]}function Cc(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Tc(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let Ac={};function Rc(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Fc(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>Fc(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?Fc(e):t[n]=e.value)}}}function _c(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in Ac)s=Ac[a];else if(s=e[a],null==s)throw new yc("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new yc("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in Ac?[i,l]=Ac.className:o in e&&([i,l]=e[o]),null==i)throw new yc("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(Ac))t[n]=Ac[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},Ac);for(const a of Object.keys(n))Ac[a]=n[a];Fc(s.config);const r=l(i,s.config,n,a);return Ac=Object.assign({},e),r}{const t=Object.assign({},Ac);for(const r of Object.keys(n))Ac[r]=n[r];const e=new i(s.config);return Ac=Object.assign({},t),e}}}function Dc(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function Oc(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function zc(t){if(null==t)throw new yc("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Lc(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new yc("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function Mc(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Sc(n>=0),Sc(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function Pc(t,e){Array.isArray(t)?(re(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>Pc(t,"element ".concat(n+1," of ").concat(e))))):re(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(Bc(t),".")))}function Bc(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>Bc(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function Wc(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let Uc=0;function Vc(){return Uc++}const Gc={};function jc(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in Gc||(Gc[t]=0),Gc[t]+=1,t+Gc[t].toString()}const Hc=["channelsFirst","channelsLast"],Kc=["nearest","bilinear"],qc=["valid","same","causal"],Xc=["max","avg"],Jc=["sum","mul","concat","ave"],Yc=new Map;function Zc(t){Lc(Hc,"DataFormat",t)}function Qc(t){Lc(qc,"PaddingMode",t)}function $c(t){Lc(Xc,"PoolMode",t)}const tu=[],eu="/";function nu(t,e){tu.push(t);try{const t=e();return tu.pop(),t}catch(o1){throw tu.pop(),o1}}function ru(t){if(!ou(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===tu.length?"":tu.join(eu)+eu)+t}function au(t){if(!ou(t))throw new Error("Not a valid tensor name: '"+t+"'");Yc.has(t)||Yc.set(t,0);const e=Yc.get(t);if(Yc.set(t,Yc.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return Yc.set(n,1),n}return t}const su=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ou(t){return!!t.match(su)}function iu(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function lu(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function cu(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function uu(t,e){if(e<t)throw new yc("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let hu;function du(){return null==hu&&(hu=ds().epsilon()),hu}function pu(t,e){return Ga(t,e)}function fu(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),As(t,n)}function gu(t,e,n){return cs((()=>{switch(t.rank){case 1:return Qo(t,e,n);case 2:return $o(t,[e,0],[n,t.shape[1]]);case 3:return ti(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return ei(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Zo(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Zo(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new yc("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function mu(t,e,n){return cs((()=>{switch(t.rank){case 1:return Qo(t,e,n);case 2:return $o(t,[0,e],[t.shape[0],n]);case 3:return ti(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return ei(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new yc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function bu(t,e,n,r){return cs((()=>{switch(t.rank){case 1:return Qo(t,e,n);case 2:switch(r){case 1:return gu(t,e,n);case 2:return mu(t,e,n);default:throw new yc("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return gu(t,e,n);case 2:return ti(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return mu(t,e,n);default:throw new yc("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return gu(t,e,n);case 2:return ei(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return ei(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return mu(t,e,n);default:throw new yc("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new yc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function yu(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Ps(t,n)}function vu(t,e){switch(t.rank){case 1:return Bs([t,e]);case 2:return Ws([t,e],0);case 3:return Us([t,e],0);case 4:return Vs([t,e],0);default:throw new yc("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function wu(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new yc("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return so(t,e)}function xu(t){return jo(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function ku(t,e,n,r){if(t.rank<2||e.rank<2)throw new vc("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new vc("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return Di({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Nu(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=As(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=As(yi(e,u),[l,-1]);const h=[...a,...c];return As(Di({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Nu(t.rank,r,"channelsLast"):null,activation:n}),h)}}function Su(t,e,n){return cs((()=>(e=Array.isArray(e)?ci(e,"int32"):Ga(e,"int32"),lo(t,e,n))))}function Iu(t){return mo(t,t)}function Nu(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new yc("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?As(e,[1,r[0],1,1,1]):As(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?As(e,[1,1,1,1,r[0]]):As(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?As(e,[1,r[0],1,1]):As(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?As(e,[1,1,1,r[0]]):As(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?As(e,[1,r[0],1]):As(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?As(e,[1,1,r[0]]):As(e,[1].concat(r))}else if(t<3)return e;throw new yc("Unsupported input rank by biasAdd: ".concat(e.rank))}function Eu(t,e,n){return cs((()=>(null==n&&(n="channelsLast"),Zc(n),bs(t,Nu(t.rank,e,n)))))}function Cu(t,e,n,r){return cs((()=>vi(t,e,n,r)))}function Tu(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const Au=["fanIn","fanOut","fanAvg"],Ru=["normal","uniform","truncatedNormal"];class Fu extends ss{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _u extends Fu{apply(t,e){return Lo(t,e)}}_u.className="Zeros",is(_u);class Du extends Fu{apply(t,e){return Mo(t,e)}}Du.className="Ones",is(Du);class Ou extends Fu{constructor(t){if(super(),"object"!==typeof t)throw new yc("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new yc("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return cs((()=>mo(fs(this.value),Mo(t,e))))}getConfig(){return{value:this.value}}}Ou.className="Constant",is(Ou);class zu extends Fu{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Ho(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}zu.className="RandomUniform",is(zu);class Lu extends Fu{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new vc("randomNormal does not support dType ".concat(e,"."));return xu(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Lu.className="RandomNormal",is(Lu);class Mu extends Fu{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new vc("truncatedNormal does not support dType ".concat(e,"."));return hi(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Mu.className="TruncatedNormal",is(Mu);class Pu extends Fu{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return cs((()=>{if(2!==t.length||t[0]!==t[1])throw new yc("Identity matrix initializer can only be used for 2D square matrices.");return mo(this.gain,oo(t[0]))}))}getConfig(){return{gain:this.gain}}}Pu.className="Identity",is(Pu);class Bu extends Fu{constructor(t){if(super(),t.scale<0)throw new yc("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,Lc(Au,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){Lc(Ru,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Zc(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=iu(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=iu(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=iu(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new vc("".concat(this.getClassName()," does not support dType ").concat(e,"."));return hi(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return Ho(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Bu.className="VarianceScaling",is(Bu);class Wu extends Bu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}Wu.className="GlorotUniform",is(Wu);class Uu extends Bu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}Uu.className="GlorotNormal",is(Uu);class Vu extends Bu{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}Vu.className="HeNormal",is(Vu);class Gu extends Bu{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}Gu.className="HeUniform",is(Gu);class ju extends Bu{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}ju.className="LeCunNormal",is(ju);class Hu extends Bu{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Bu.className}}Hu.className="LeCunNormal",is(Hu);class Ku extends Fu{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new vc("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return cs((()=>{if(t.length<2)throw new vc("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than 2000 (".concat(t[0]*t[1],") elements: ")+"Slowness may result.");const e=xu(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=xl.gramSchmidt(e);return t[0]>t[1]&&(n=yi(n)),mo(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Ku.className="Orthogonal",is(Ku);const qu={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Xu(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _c(t,os.getMap().classNameMap,e,"initializer")}function Ju(t){return Rc(t)}function Yu(t){if("string"===typeof t){const e=t in qu?qu[t]:t;if("GlorotNormal"===e)return new Uu;if("GlorotUniform"===e)return new Wu;if("HeNormal"===e)return new Vu;if("HeUniform"===e)return new Gu;if("LeCunNormal"===e)return new ju;if("LeCunUniform"===e)return new Hu;{const t={};return t.className=e,t.config={},Xu(t)}}return t instanceof Fu?t:Xu(t)}function Zu(t){return Array.isArray(t)&&Array.isArray(t[0])}function Qu(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function $u(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new yc("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function th(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new yc("Expected exactly 1 Shape; got ".concat(t.length))}return t}function eh(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const nh="Variable";class rh{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:nh,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=Vc(),n=null==n?nh:n,this.originalName=ru(n),this.name=au(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Gr.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function ah(t){return t.map((t=>t.read()))}function sh(t){t.forEach((t=>{t[0].write(t[1])}))}class oh{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ih{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=Vc(),null!=s&&(this.originalName=ru(s),this.name=au(this.originalName)),this.rank=e.length}}let lh=0;class ch{constructor(t,e){this.callArgs=e,this.id=lh++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let uh=0;class hh extends ss{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=uh++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=Cc(t)+"_"+jc(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new bc("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new yc("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return Nc(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Nc(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new mc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new mc("Layer ".concat(this.name)+" is not connected, no input to return.");return Nc(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new mc("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new mc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Nc(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Ec(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=Ec(this.inputSpec);if(t.length!==e.length)throw new yc("Layer ".concat(this.name," expects ").concat(e.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(t));for(let n=0;n<t.length;n++){const r=t[n],a=e[n];if(null==a)continue;const s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new yc("Input ".concat(n," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new yc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new yc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&r.dtype!==a.dtype)throw new yc("Input ".concat(n," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(r.dtype,"."));if(a.axes){const t=r.shape;for(const e in a.axes){const r=Number(e),s=a.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(o))throw new yc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(r," of input shape to ")+"have value ".concat(s," but got shape ").concat(t,"."))}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const e=a.shape[t],s=r.shape[t];if(null!=e&&null!=s&&e!==s)throw new yc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(r.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=Ec(t);let r=!0;for(const s of n)if(!(s instanceof ih)){r=!1;break}let a=!0;for(const s of n)if(s instanceof ih){a=!1;break}if(r===a)throw new yc("Arguments to apply() must be all SymbolicTensors or all Tensors");return nu(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of Ec(t))e.push(n.shape);this.build(Nc(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);const a=Ec(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=Nc(s),null!=this.activityRegularizer)throw new vc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=Ec(t);const e=[];for(const n of t)e.push(n.shape);return Nc(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new ih(s,n,this,Ec(t),e,this.name,r))):new ih(s,r,this,Ec(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new vc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new mc("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new mc("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new bc("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return eh(this.weights)}build(t){this.built=!0}getWeights(){return ah(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){cs((()=>{const e=this.weights;if(e.length!==t.length)throw new yc('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=ah(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!le(s.shape,i.shape))throw new yc("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}sh(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new yc("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():Yu("zeros"));const l=r.apply(e,n),c=new rh(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Ec(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=Ec(t);e=Ec(e),n=Ec(n),r=Ec(r),a=Qu(a),s=Qu(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new ch({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function dh(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=dh(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class ph extends hh{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:jc("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new yc("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new yc("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new yc("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new ih(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ch({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new yc("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function fh(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new yc("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;null==n&&(n="float32");return new ph({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}ph.className="InputLayer",is(ph);class gh{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof gh)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new yc("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Ga(e,t.dtype)}catch(i1){throw new yc("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ih){if(null==this.id2Value[t.id])throw new yc("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new yc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof ih){if(null==this.id2Value[t.id])throw new yc("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new yc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&us(this.id2Mask)}}const mh=new xc,bh=new xc;function yh(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=mh.get(u);if(null==d){const t=function(t,e){re(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=wh(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=wh(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:vh(r)}}(o,e);d=t.sorted,h=t.recipientCounts,mh.put(u,d),bh.put(u,h)}h={},a||Object.assign(h,bh.get(u));const p=new gh(e);for(let f=0;f<d.length;++f){if(null!=r){const t=ls().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof ph)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=Ec(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=xh(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||us(u)}return p.disposeMasks(),s?l:l[0]}function vh(t){const e={};for(const n in t)e[n]=t[n].size;return e}function wh(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function xh(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}Te().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=mh&&mh.setMaxEntries(t),null!=bh&&bh.setMaxEntries(t)}));const kh={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,Ni(Ga(n,"float32"),-1))}}},Sh={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Fo(Ga(n,"float32")),r=si(bo(fs(1),e));return Do(Qs(t,r))}}}},Ih={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=si(bo(Fo(Ga(n,"float32")),1));return Qs(t,e)}}}},Nh={kernelName:De,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{let e=t;const r=to(n.shape,a);return r.length>0&&(e=yo(e,r)),As(e,n.shape)},b:()=>{let e=t;const n=to(r.shape,a);return n.length>0&&(e=yo(e,n)),As(e,r.shape)}}}},Eh={kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},Ch={kernelName:Oe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gi(n)}}},Th={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gi(n)}}},Ah={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,si(bo(fs(1),Fo(Ga(n,"float32")))))}}},Rh={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=si(bs(fs(1),Fo(Ga(n,"float32"))));return Qs(t,e)}}}},Fh={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{const e=bs(Fo(n),Fo(r));let s=mo(t,Qs(r,e));const o=to(n.shape,a);return o.length>0&&(s=yo(s,o)),As(s,n.shape)},b:()=>{const e=bs(Fo(n),Fo(r));let s=Do(mo(t,Qs(n,e)));const o=to(r.shape,a);return o.length>0&&(s=yo(s,o)),As(s,r.shape)}}}},_h={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,bs(Fo(Ga(n,"float32")),1))}}},Dh={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,bo(fs(1),Fo(Ga(n,"float32"))))}}};const Oh=Zr({avgPool3dGrad_:function(t,e,n,r,a,s){const o=Jr(t,"dy","avgPool3dGrad"),i=Jr(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=As(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=As(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),re(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),re(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),Ts("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Gr.runKernel("AvgPool3DGrad",h,d);return u?As(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),zh={kernelName:Le,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>Oh(t,r,a,s,o,i)}}};const Lh=Zr({avgPoolGrad_:function(t,e,n,r,a){const s=Jr(t,"dy","avgPoolGrad"),o=Jr(e,"input","avgPoolGrad");re(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=As(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=As(s,[1,s.shape[0],s.shape[1],s.shape[2]])),re(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),re(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=Gr.runKernel("AvgPoolGrad",u,h);return c?As(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Mh={kernelName:ze,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Lh(t,r,a,s,o)}}},Ph={kernelName:Me,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>xo(t,a,!1,!1),b:()=>xo(t,r,!0,!1)}:s&&!o?{a:()=>xo(a,t,!1,!0),b:()=>xo(r,t,!1,!1)}:{a:()=>xo(a,t,!0,!0),b:()=>xo(t,r,!0,!0)}:{a:()=>xo(t,a,!1,!0),b:()=>xo(r,t,!0,!1)}}};const Bh=Zr({spaceToBatchND_:function(t,e,n){const r=Jr(t,"x","spaceToBatchND");re(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),re(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),re(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return Gr.runKernel(On,a,s)}}),Wh={kernelName:Pe,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Bh(t,r,a)}}},Uh={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>yo(t,i,!0)}}},Vh={kernelName:Be,gradFunc:t=>({x:()=>t.clone()})},Gh={kernelName:"Ceil",gradFunc:t=>({x:()=>gi(t)})},jh={kernelName:We,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>fi(wo(uo(r,a),rl(r,s)),t,gi(t))}}},Hh={kernelName:Ue,inputsToSave:["x"],gradFunc:kh.gradFunc},Kh={kernelName:Ve,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=he(a,e[0].shape)[0],o=r.map((t=>t[s]));return ai(t,o,s).map((t=>()=>t))}},qh={kernelName:Ge,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return re(Es(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>Hs(r.shape,t,a,o,i,l),filter:()=>Si(r,t,a.shape,o,i,l)}}},Xh={kernelName:je,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Gs(t,a,s,o,i,1,l),filter:()=>Si(t,r,a.shape,s,o,i,l)}}};const Jh=Zr({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=As(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=As(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),re(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),re(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),re(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),re(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),re(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return Gr.runKernel("Conv3DBackpropFilterV2",i,l)}}),Yh={kernelName:He,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;re(Es(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>Xs(o.shape,t,i,a,s),filter:()=>Jh(o,t,i.shape,a,s)}}};const Zh=Zr({sin_:function(t){const e={x:Jr(t,"x","sin","float32")};return Gr.runKernel("Sin",e)}}),Qh={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(Do(Zh(Ga(n,"float32"))),t)}}};const $h=Zr({sinh_:function(t){const e={x:Jr(t,"x","sinh")};return Gr.runKernel(Rn,e)}}),td={kernelName:Ke,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo($h(Ga(n,"float32")),t)}}};const ed=Zr({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Jr(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel(qe,a,s)}}),nd={kernelName:qe,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=Ao([a],r.rank);let n=ed(t,a,s,!o);return null!=e&&(n=yi(n,e)),n}}}},rd={kernelName:Xe,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;re(Es(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return re(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),re(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),re(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),re(Cs(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),Ts("depthwiseConv2d",s,o),{x:()=>_i(l.shape,t,c,a,s,i,o),filter:()=>Fi(l,t,c.shape,a,s,i,o)}}},ad={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>Gr.runKernel("Dilation2DBackpropInput",s,n),filter:()=>Gr.runKernel("Dilation2DBackpropFilter",o,n)}}},sd={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Gr.runKernel("EluGrad",r)}}},od={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=mo(ro(Do(Fo(n))),2/Math.sqrt(Math.PI));return{x:()=>mo(t,r)}}},id={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,n)}}},ld={kernelName:Ye,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>As(t,n.shape)}}},cd={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,ro(n))}}},ud={kernelName:Qe,gradFunc:t=>({x:()=>gi(t)})},hd={kernelName:$e,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{const e=Qs(t,Ga(r,"float32")),s=to(n.shape,a);return s.length>0?As(yo(e,s),n.shape):e},b:()=>{let e=mo(t,Ga(n,"float32"));const s=to(r.shape,a);s.length>0&&(e=As(yo(e,s),r.shape));const o=Fo(r);return Do(Qs(e,Ga(o,"float32")))}}}};const dd=Zr({rsqrt_:function(t){const e={x:Jr(t,"x","rsqrt","float32")};return Gr.runKernel(En,e)}}),pd={kernelName:tn,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?fs(1):i,c=to(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=bo(a,s),d=mo(t,l),p=dd(bs(o,fs(r))),f=mo(mo(mo(p,p),p),fs(-.5));return{x:()=>1===s.rank?As(mo(mo(t,so(As(p,[1,1,1,s.shape[0]]),u)),l),a.shape):As(mo(mo(t,p),l),a.shape),mean:()=>{let t=mo(mo(p,fs(-1)),d);return 1===s.rank&&(t=yo(t,c)),As(t,s.shape)},variance:()=>{let t=mo(mo(f,h),d);return 1===s.rank&&(t=yo(t,c)),As(t,s.shape)},scale:()=>{const e=mo(h,p);let n=mo(t,e);return 1===s.rank&&(n=yo(n,c)),As(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=yo(e,c)),As(e,s.shape)}}}};const fd=Zr({unsortedSegmentSum_:function(t,e,n){const r=Jr(t,"x","unsortedSegmentSum"),a=Jr(e,"segmentIds","unsortedSegmentSum","int32");re(ce(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return Gr.runKernel(Vn,s,o)}}),gd={kernelName:en,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s}=n,o=he(s,r.shape)[0];return{x:()=>{const e=r.shape,n=a.size,i=e.slice(0,o),l=i.length,c=e.slice(s,e.length).slice(1),u=c.length,h=md(0,l),d=md(l+1,l+1+u),p=bd([i,[n],c]),f=As(t,p),g=As(a,[n]),m=bd([[l],h,d]),b=yi(f,m);let y=fd(b,g,r.shape[o]);const v=Ro(m);return y=yi(y,v),y},indices:()=>a}}};function md(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function bd(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const yd={kernelName:nn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>gi(n),b:()=>gi(r)}}},vd={kernelName:rn,gradFunc:t=>({x:()=>Ga(t,"float32")})},wd={kernelName:"IsFinite",gradFunc:t=>({x:()=>gi(t)})},xd={kernelName:"IsInf",gradFunc:t=>({x:()=>gi(t)})},kd={kernelName:"IsNan",gradFunc:t=>({x:()=>gi(t)})},Sd={kernelName:an,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=co(r,0);return{x:()=>fi(s,t,mo(t,a))}}},Id={kernelName:sn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,bs(n,1))}}},Nd={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,Ga(n,"float32"))}}},Ed={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=ro(r);return bo(t,mo(yo(t,a,!0),e))}}}};const Cd=Zr({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Gr.runKernel("LRNGrad",r,a)}}),Td={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>Cd(r,a,t,s,o,i,l)}}};function Ad(t,e,n,r){return e.rank<n.rank&&(e=As(e,To(e.shape,r))),t.rank<n.rank&&(t=As(t,To(t.shape,r))),{x:()=>mo(t,Ga(no(n,e),t.dtype))}}const Rd={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=Ad(t,e[1],s,he(a,s.shape));return{x:()=>o.x()}}};const Fd=Zr({less_:function(t,e){let n=Jr(t,"a","less","string_or_numeric"),r=Jr(e,"b","less","string_or_numeric");[n,r]=zr(n,r),eo(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Less",a)}}),_d={kernelName:on,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mo(t,Ga(uo(n,r),"float32")),b:()=>mo(t,Ga(Fd(n,r),"float32"))}}};const Dd=Zr({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=Jr(t,"dy","maxPool3dGrad"),l=Jr(e,"input","maxPool3dGrad"),c=Jr(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=As(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=As(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=As(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),re(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),re(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),re(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),Ts("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=Gr.runKernel("MaxPool3DGrad",f,g);return p?As(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),Od={kernelName:cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>Dd(t,r,a,s,o,i,l)}}};const zd=Zr({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=Jr(t,"dy","maxPoolGrad"),l=Jr(e,"input","maxPoolGrad"),c=Jr(n,"output","maxPoolGrad");re(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),re(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),re(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),Ts("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return Gr.runKernel("MaxPoolGrad",u,h)}}),Ld={kernelName:ln,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>zd(t,r,a,s,o,i)}}},Md={kernelName:un,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=he(a,r.shape),o=function(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}(r.shape,s),i=ie(o[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=As(t,e);return Qs(mo(n,Mo(r.shape,"float32")),i)}}}},Pd={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=Ad(t,o,s,he(a,s.shape));return{x:()=>i.x()}}},Bd={kernelName:hn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mo(t,Ga(rl(n,r),"float32")),b:()=>mo(t,Ga(co(n,r),"float32"))}}},Wd={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Zo(t,s,r.shape)}}},Ud={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{const e=to(n.shape,a);return e.length>0?As(yo(t,e),n.shape):t},b:()=>{const e=mo(t,Do(io(Qs(n,r)))),s=to(r.shape,a);return s.length>0?As(yo(e,s),r.shape):e}}}},Vd={kernelName:dn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{const e=mo(t,Ga(r,"float32")),s=to(n.shape,a);return s.length>0?As(yo(e,s),n.shape):e},b:()=>{const e=mo(t,Ga(n,"float32")),s=to(r.shape,a);return s.length>0?As(yo(e,s),r.shape):e}}}},Gd={kernelName:"Neg",gradFunc:t=>({x:()=>Do(t)})},jd={kernelName:fn,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Lo(n.shape,"float32")}}},Hd={kernelName:pn,gradFunc:t=>({x:()=>gi(t)})},Kd={kernelName:gn,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return di(t,r).map((t=>()=>t))}},qd={kernelName:mn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Zo(t,s,r.shape)}}},Xd={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=eo(s.shape,o.shape);return{a:()=>{const e=Ga(o,"float32");let n=mo(t,mo(e,ul(s,bo(e,fs(1)))));const r=to(s.shape,i);return r.length>0&&(n=yo(n,r)),As(n,s.shape)},b:()=>{const e=co(s,0),n=fi(e,po(s),gi(s));let r=mo(t,mo(a,n));const l=to(o.shape,i);return l.length>0&&(r=yo(r,l)),As(r,o.shape)}}}},Jd={kernelName:bn,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=co(n,0);return{x:()=>fi(a,t,mo(t,r)),alpha:()=>{let e=fi(a,gi(t),mo(t,n));const s=to(r.shape,t.shape);return s.length>0&&(e=yo(e,s)),As(e,r.shape)}}}};const Yd=Zr({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Jr(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel("Cumprod",a,s)}});function Zd(t,e,n){const r=t.shape.length,a=r-n.length,s=Ao(n,r);let o=t;null!=s&&(o=yi(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=As(e,r),s=Yd(t,n,!0,!1),o=Yd(t,n,!0,!0),i=mo(s,o);return mo(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=Ro(s);c=yi(c,t)}return c}const Qd={kernelName:"Prod",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>Zd(r,t,s)}}},$d={kernelName:Je,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{const e=Qs(t,Ga(r,"float32")),s=to(n.shape,a);return s.length>0?As(yo(e,s),n.shape):e},b:()=>{let e=mo(t,Ga(n,"float32"));const s=to(r.shape,a);s.length>0&&(e=As(yo(e,s),r.shape));const o=Fo(r);return Do(Qs(e,Ga(o,"float32")))}}}},tp={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,Do(Fo(n)))}}},ep={kernelName:Sn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=mo(rl(n,6),Ni(n));return{x:()=>mo(t,Ga(r,"float32"))}}},np={kernelName:vn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,Ga(Ni(n),"float32"))}}},rp={kernelName:wn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>As(t,n.shape)}}},ap={kernelName:kn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeBilinearGrad",a,n)}}},sp={kernelName:xn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeNearestNeighborGrad",a,n)}}},op={kernelName:In,gradFunc:(t,e,n)=>{const{dims:r}=n,a=he(r,t.shape);return{x:()=>qo(t,a)}}},ip={kernelName:Nn,gradFunc:t=>({x:()=>gi(t)})},lp={kernelName:En,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Do(Qs(t,mo(ul(n,1.5),2)))}}};const cp=Zr({logicalNot_:function(t){const e={x:Jr(t,"x","logicalNot","bool")};return Gr.runKernel("LogicalNot",e)}}),up={kernelName:Cn,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Ga(gi(n),"float32"),t:()=>mo(t,Ga(n,t.dtype)),e:()=>mo(t,Ga(cp(n),t.dtype))}}},hp={kernelName:Tn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=co(n,fs(0)),r=fs(1.7580993408473768),a=fs(1.0507009873554805),s=mo(t,a),o=mo(mo(t,r),ro(Ga(n,"float32")));return fi(e,s,o)}}}},dp={kernelName:Fn,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,mo(n,bo(fs(1),n)))}}},pp={kernelName:"Sign",gradFunc:t=>({x:()=>gi(t)})};const fp=Zr({cos_:function(t){const e={x:Jr(t,"x","cos","float32")};return Gr.runKernel("Cos",e)}}),gp={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(fp(Ga(n,"float32")),t)}}};const mp=Zr({cosh_:function(t){const e={x:Jr(t,"x","cosh","float32")};return Gr.runKernel(Ke,e)}}),bp={kernelName:Rn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(mp(Ga(n,"float32")),t)}}};const yp={kernelName:An,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=function(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{re(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(re(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>Bo(t,c)}}},vp={kernelName:Ln,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=mo(t,r);return{logits:()=>bo(s,mo(yo(s,[a],true),r))}}},wp={kernelName:_n,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,Yo(n))}}};const xp=Zr({batchToSpaceND_:function(t,e,n){const r=Jr(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));re(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),re(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),re(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return Gr.runKernel(Pe,s,o)}}),kp={kernelName:On,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>xp(t,r,a)}}},Sp={kernelName:zn,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Ps(t,r)}}};const Ip=[kh,Sh,Ih,Nh,Eh,Ch,Th,Ah,Rh,Fh,_h,Dh,zh,Mh,Ph,Wh,Uh,Vh,Gh,jh,Hh,Kh,Xh,qh,Yh,Qh,td,nd,rd,ad,$d,sd,od,id,ld,cd,hd,ud,pd,gd,yd,vd,wd,xd,kd,Sd,Id,Nd,Ed,Td,Rd,Rd,_d,Od,Ld,Md,Pd,Bd,Wd,Ud,Vd,Gd,jd,Hd,Kd,qd,qd,Xd,Jd,Qd,tp,ep,np,rp,ap,sp,op,ip,lp,up,hp,dp,pp,gp,bp,yp,vp,wp,kp,kp,Sp,Sp,{kernelName:Dn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,mo(si(Ga(n,"float32")),2))}}},{kernelName:Mn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=fs(2);return{a:()=>mo(t,mo(a,bo(n,r))),b:()=>mo(t,mo(a,bo(r,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(t,mo(Ga(n,"float32"),2))}}},{kernelName:jn,gradFunc:t=>({x:()=>gi(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=eo(n.shape,r.shape);return{a:()=>{let e=t;const r=to(n.shape,a);return r.length>0&&(e=yo(e,r)),As(e,n.shape)},b:()=>{let e=t;const n=to(r.shape,a);return n.length>0&&(e=yo(e,n)),As(Do(e),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;he(s,r.shape).forEach((t=>{a[t]=1}));const o=As(t,a),i=mo(o,Mo(r.shape,"float32"));return{x:()=>i}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Qs(t,Fo(fp(n)))}}},{kernelName:Pn,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mo(bo(fs(1),Fo(n)),t)}}},{kernelName:Bn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=gi(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=bs(e,Zo(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=bs(e,Zo(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=bs(e,Zo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=bs(e,Zo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Wn,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=Ro(a);return{x:()=>yi(t,s)}}},{kernelName:Un,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>ii(t,a)}}},{kernelName:Vn,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=Io(e,gi(e)),r=lo(t,n);let a=uo(e,fs(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=ao(a,i+1);a=wo(a,Mo(r.shape,"bool"));const o=gi(r);return fi(a,r,o)}(t,n)}}},{kernelName:Gn,gradFunc:t=>({x:()=>gi(t)})}];for(const n of Ip)er(n);function Np(t,e){return cs((()=>si(yo(mo(t,t),e,!0))))}class Ep extends ss{getConfig(){return{}}}class Cp extends Ep{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return cs((()=>{const e=Np(t,this.axis),n=Ms(e,0,this.maxValue);return mo(t,Qs(n,bs(du(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Cp.className="MaxNorm",is(Cp);class Tp extends Ep{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return cs((()=>Qs(t,bs(du(),Np(t,this.axis)))))}getConfig(){return{axis:this.axis}}}Tp.className="UnitNorm",is(Tp);class Ap extends Ep{apply(t){return Ko(t)}}Ap.className="NonNeg",is(Ap);class Rp extends Ep{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return cs((()=>{const e=Np(t,this.axis),n=bs(mo(this.rate,Ms(e,this.minValue,this.maxValue)),mo(1-this.rate,e));return mo(t,Qs(n,bs(du(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Rp.className="MinMaxNorm",is(Rp);const Fp={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _p(t){return Rc(t)}function Dp(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _c(t,os.getMap().classNameMap,e,"constraint")}function Op(t){if(null==t)return null;if("string"===typeof t){return Dp({className:t in Fp?Fp[t]:t,config:{}})}return t instanceof Ep?t:Dp(t)}async function zp(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];us(r)}}function Lp(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var Mp;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(Mp||(Mp={}));class Pp{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Bp{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class Wp extends Pp{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=cs((()=>bs(this.totals[r],mo(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:cs((()=>{const t=mo(Qs(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),hs(e[n])})))}}class Up extends Pp{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class Vp extends Pp{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||_l,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ge(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():lr();return function(){const s=null!=n?n():lr();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await zp(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await zp(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await zp(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await zp(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await zp(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ge(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await zp(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await zp(t),await this.trainEnd(t))}}function Gp(t,e){if(null==t&&(t={}),t instanceof Pp)return[t];if(Array.isArray(t)&&t[0]instanceof Pp)return t;return Ec(t).map((t=>new Vp(t,e)))}class jp{constructor(){}static registerCallbackConstructor(t,e){re(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),jp.checkForDuplicate(e),null==jp.constructors[t]&&(jp.constructors[t]=[]),jp.constructors[t].push(e)}static checkForDuplicate(t){for(const e in jp.constructors){jp.constructors[+e].forEach((e=>{if(e===t)throw new yc("Duplicate callback constructor.")}))}}static clear(){jp.constructors={}}static createCallbacks(t){const e=[];for(const n in jp.constructors){const r=+n;t>=r&&e.push(...jp.constructors[r])}return e.map((t=>new t))}}function Hp(t,e,n,r,a,s,o,i,l){const c=new Up,u=[new Wp,...jp.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new Bp(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function Kp(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return _c(t,os.getMap().classNameMap,e,"layer",n)}function qp(t,e){return cs((()=>{"float32"!==t.dtype&&(t=Ga(t,"float32"));const n=yo(Iu(t),e,!0),r=Ls(n.shape,du()),a=si(Io(n,r));return Qs(t,a)}))}function Xp(t,e){return cs((()=>No(Iu(bo(e,t)),-1)))}function Jp(t,e){return cs((()=>No(ms(bo(e,t)),-1)))}function Yp(t,e){return cs((()=>{const n=bo(t,e),r=Ms(ms(t),du(),Number.MAX_VALUE),a=ms(Qs(n,r));return mo(100,No(a,-1))}))}function Zp(t,e){return cs((()=>{const n=Ms(e,du(),Number.MAX_VALUE),r=po(bs(1,n)),a=Ms(t,du(),Number.MAX_VALUE),s=po(bs(1,a));return No(Iu(bo(r,s)),-1)}))}function Qp(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cs((()=>{if(n)e=ni(e);else{const t=yo(e,e.shape.length-1,!0);e=Qs(e,t)}return e=Ms(e,du(),1-du()),Do(yo(mo(Ga(t,"float32"),po(e)),e.shape.length-1))}))}function $p(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cs((()=>{const r=Ga(io(function(t){const e=[iu(t.shape)];return As(t,e)}(t)),"int32"),a=(e=Ms(e,du(),1-du())).shape;return Qp(As(zo(r,a[a.length-1]),a),e,n)}))}function tf(t,e){return cs((()=>{let n;return n=Ms(e,du(),1-du()),n=po(Qs(n,bo(1,n))),No(function(t,e){if(!le(t.shape,e.shape))throw new yc("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return cs((()=>{const n=Ko(e),r=Do(ms(e));return bs(bo(n,mo(e,t)),fo(ro(r)))}))}(t,n),-1)}))}function ef(t,e){return cs((()=>{const n=Ms(t,du(),1),r=Ms(e,du(),1);return yo(mo(t,po(Qs(n,r))),-1)}))}function nf(t,e){return cs((()=>{const n=qp(t,-1),r=qp(e,-1),a=mo(n,r);return Do(yo(a,-1))}))}jp.constructors={};const rf={meanSquaredError:Xp,meanAbsoluteError:Jp,meanAbsolutePercentageError:Yp,meanSquaredLogarithmicError:Zp,squaredHinge:function(t,e){return cs((()=>{const n=Io(0,bo(1,mo(t,e)));return No(Iu(n),-1)}))},hinge:function(t,e){return cs((()=>{const n=Io(0,bo(1,mo(t,e)));return No(n,-1)}))},categoricalHinge:function(t,e){return cs((()=>{const n=yo(mo(t,e),-1),r=go(mo(bo(1,t),e),-1);return Io(0,bs(1,bo(r,n)))}))},logcosh:function(t,e){return cs((()=>{const n=Math.log(2),r=bo(e,t),a=bo(bs(r,ri(mo(-2,r))),n);return No(a,-1)}))},categoricalCrossentropy:Qp,sparseCategoricalCrossentropy:$p,binaryCrossentropy:tf,kullbackLeiblerDivergence:ef,poisson:function(t,e){return cs((()=>{const n=po(bs(du(),e));return No(bo(e,mo(t,n)),-1)}))},cosineProximity:nf};function af(t){if("string"===typeof t){if(t in rf)return rf[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new yc(e)}return t}function sf(t,e){return cs((()=>{const n=mo(.5,Po(e)),r=pu(co(e,n),t.dtype);return No(no(t,r),-1)}))}function of(t,e){return cs((()=>pu(no(ws(t,-1),ws(e,-1)),"float32")))}function lf(t,e){return cs((()=>Ga(yo(wo(no(t,1),no(e,1))),"float32")))}function cf(t,e){return tf(t,e)}function uf(t,e){return t.rank===e.rank&&(t=oi(t,[t.rank-1])),(e=ws(e,-1)).dtype!==t.dtype&&(e=Ga(e,t.dtype)),Ga(no(t,e),"float32")}const hf=Qp,df=$p,pf={binaryAccuracy:sf,categoricalAccuracy:of,precision:function(t,e){return cs((()=>{const n=lf(t,e),r=function(t,e){return cs((()=>Ga(yo(wo(no(t,0),no(e,1))),"float32")))}(t,e),a=bs(n,r);return Ga(fi(co(a,0),Qs(n,a),0),"float32")}))},categoricalCrossentropy:hf,sparseCategoricalCrossentropy:df,mse:Xp,MSE:Xp,mae:Jp,MAE:Jp,mape:Yp,MAPE:Yp,cosine:nf};function ff(t){if("string"===typeof t&&t in pf)return pf[t];if("string"!==typeof t&&null!=t)return t;throw new yc("Unknown metric ".concat(t))}function gf(t){if(Sc(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys(rf))if(rf[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(pf))if(pf[n]===t){e=n;break}return void 0!==e?e:t.name}}const mf=1048576;function bf(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!yf(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>mf&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(mf,"."))}}function yf(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!yf(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!yf(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function vf(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),wf(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?xf(i[u],n,r):kf(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?eh(t.collectedTrainableWeights):eh(t.trainableWeights);return e}(t),c=eh(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function wf(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function xf(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(i1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(i1){r="multiple"}const s=t.name,o=t.getClassName();wf(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function kf(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(i1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(i1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];wf(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)wf(["","","","",o[u]],e,r)}function Sf(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function If(t,e){if(null===t)return null;if("string"===typeof t)return Tc(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];Sf(e,a,r)?n.push(r):n.push(If(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=Tc(n);e[t]=If(r,t)}}return e}}function Nf(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return Cc(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];Sf(e,a,r)?n.push(r):n.push(Nf(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=Cc(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?Nf(r,n):r}return e}}const Ef="3.21.0";class Cf extends hh{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=jc(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Oc(this.inputs).length!==this.inputs.length)throw new yc("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));Oc(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;Sc(0===e,"input layer has >1 nodes"),Sc(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof ph))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new bc("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(Cf.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(Dc);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Cf&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(Dc);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new bc("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new bc('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new ch({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new yc("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;for(const s of this.layers)for(const t of s.weights){if(null!=n[t.originalName])throw new yc("Duplicate weight name: ".concat(t.originalName));n[t.originalName]=t,r++}const a=[];for(const s in t){let r=s;if(null==n[s]){const t=s.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])a.push([n[r],t[s]]);else if(e)throw new yc("Provided weight data has no target variable: ".concat(s));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new yc("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}sh(a)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(Ef),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Nf(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return cs((()=>{t=Ec(t);const n=new gh;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return yh(this.outputs,n,e)}))}computeMask(t,e){return cs((()=>{let n;return t=Ec(t),n=null==e?kc(null,t.length):Ec(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=Qu(t);if(e.length!==this.inputLayers.length)throw new yc("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Dc);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=Qu(t.computeOutputShape(Nc(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];Sc(t in n),a.push(n[t])}return Nc(a)}runInternalGraph(t,e){null==e&&(e=kc(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Dc);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=Ec(t.call(e,c)),l=Ec(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=Ec(t.call(r,c)),l=Ec(t.computeMask(r,o));if(t.activityRegularizer)throw new vc("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){Sc(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof Cf?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=Cf.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new yc("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}if(null==t)throw new yc("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new yc("No such layer: ".concat(t))}calculateLosses(){return cs((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=Cf.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=Cf.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(i1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[Cf.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=Cf.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=Cf.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(Nc(n),a)}function i(t){const a=t.name,o=Kp(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new yc("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!zc(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];Sc(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];Sc(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new yc("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){cs((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function Tf(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Af(t,e){return Tf(t,e,"classWeight")}async function Rf(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=cs((()=>{if(1===t.shape.length)return ja(t);if(2===t.shape.length){if(t.shape[1]>1){return ws(t,1)}if(1===t.shape[1])return As(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());us(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),ci(a,"float32")}return null}function Ff(t,e){return mo(t,e)}function _f(t,e){let n,r;const a=e;n=a.xs,r=a.ys,re(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=Df("input",t.inputNames,n),o=Df("output",t.outputNames,r),i=s[0].shape[0];re(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),re(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)re(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)re(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function Df(t,e,n){if(n instanceof Er)return[n];if(Array.isArray(n))return re(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new yc("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function Of(t,e,n){const r=null!=n.batchesPerEpoch;if(re(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),re(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),re(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),re(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),re(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(zf(n.validationData))re(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new vc("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=Gp(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Hp(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=_f(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Af(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Rf(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);us(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,hs(n)}await d.onBatchEnd(h,s),Lp(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=zf(n.validationData)?Ec(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):Ec(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function zf(t){return"function"===typeof t.iterator}function Lf(t){re(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function Mf(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>gu(t,e,n-e))):gu(t,e,n-e)}function Pf(t,e){return cs((()=>null==t?null:Array.isArray(t)?t.map((t=>Pf(t,e))):Su(t,"int32"===e.dtype?e:Ga(e,"int32"))))}function Bf(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}async function Wf(t,e,n){let r,a,s,o,i,l,c,u,h,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const p=null==d.batchSize?32:d.batchSize;Lf(p);const f=!1,g=await t.standardizeUserData(e,n,d.sampleWeight,d.classWeight,f,p);r=g[0],a=g[1],h=g[2];let m,b=!1;if(null!=d.validationData&&d.validationData.length>0){if(b=!0,2!==d.validationData.length)throw 3===d.validationData.length?new vc("validationData including sample weights is not supported yet."):new yc("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));i=d.validationData[0],l=d.validationData[1];const e=!0,n=await t.standardizeUserData(i,l,null,null,e,p);c=n[0],u=n[1],m=c.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){b=!0;const t=Math.floor(r[0].shape[0]*(1-d.validationSplit)),e=r[0].shape[0];c=Mf(r,t,e),s=r,r=Mf(r,0,t),u=Mf(a,t,e),o=a,a=Mf(a,0,t),m=c.concat(u)}else null!=d.validationSteps&&(b=!0);const y=r.concat(a).concat(h);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),w=t.getDedupedMetricsNames();let x,k;b?(t.makeTestFunction(),x=t.testFunction,k=w.slice().concat(w.map((t=>"val_"+t)))):(x=null,m=[],k=w.slice());const S=Gp(d.callbacks,d.yieldEvery),I=await async function(t,e,n,r,a,s,o,i,l,c,u,h,d,p,f){null==a&&(a=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let g=!1;if(null!=l&&null!=c&&(g=!0),null!=f&&(g=!0,null==p))throw new yc("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=t.checkNumSamples(n,a,p,"steps_per_epoch");let b;null!=m&&(b=uu(0,m)),null==o&&(o=1);const{callbackList:y,history:v}=Hp(i,o,s,d,m,p,a,g,h);y.setModel(t),t.history=v,await y.onTrainBegin(),t.stopTraining_=!1;for(let w=d;w<s;++w){await y.onEpochBegin(w);const s={};if(null!=p)throw new vc("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new vc("batch shuffling is not implemneted yet");u&&ee(b);const o=ci(b),i=Bf(m,a);for(let u=0;u<i.length;++u){const h={};if(await y.onBatchBegin(u,h),cs((()=>{const d=i[u][0],p=i[u][1],f=gu(o,d,p-d);h.batch=u,h.size=p-d;const m=Pf(n,f),b=e(m);for(let t=0;t<r.length;++t){const e=r[t],n=b[t];h[e]=n,hs(n)}if(u===i.length-1&&g){const e=t.testLoop(l,c,a);for(let t=0;t<r.length;++t){const n=r[t],a=e[t];hs(a),s["val_"+n]=a}}})),await y.onBatchEnd(u,h),Lp(h),t.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(w,s),t.stopTraining_)break}return await y.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,w,p,d.epochs,d.verbose,S,x,m,d.shuffle,k,d.initialEpoch,null,null);return I}finally{t.isTraining=!1,Vf(r,e),Vf(a,n),Vf(s,e),Vf(o,n),Vf(c,i),Vf(u,l),null!=h&&us(h)}}function Uf(t){const e=[];t instanceof Er&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(fu(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Vf(t,e){if(null==t)return;const n=[];if(e instanceof Er)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Er)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Gf(t){return Array.isArray(t)}function jf(t){return!function(t){return t instanceof Er}(t)&&!Gf(t)}function Hf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Gf(t)&&t.length>0)e=!0;else if(jf(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new yc("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(jf(t)){r=[];for(const n of e){if(null==t[n])throw new yc('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Gf(t)){if(t.length!==e.length)throw new yc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new yc("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=Uf(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new yc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new yc("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function Kf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new yc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new yc("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new yc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new yc("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class qf extends Cf{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new yc("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");vf(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>Rl.adagrad(.01),Adadelta:()=>Rl.adadelta(1,.95,du()),Adam:()=>Rl.adam(.001,.9,.999,du()),Adamax:()=>Rl.adamax(.002,.9,.999,du(),0),RMSProp:()=>Rl.rmsprop(.001,.9,0,du()),SGD:()=>Rl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new yc("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof gs))throw new yc("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new yc("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>af(t)))}else{const n=af(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new yc('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push(af(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nu("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};nu("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===tf?-1!==["accuracy","acc"].indexOf(o)?r=sf:-1!==["crossentropy","ce"].indexOf(o)&&(r=cf):this.lossFunctions[t]===$p?-1!==["accuracy","acc"].indexOf(o)?r=uf:-1!==["crossentropy","ce"].indexOf(o)&&(r=df):-1!==["accuracy","acc"].indexOf(o)?r=of:-1!==["crossentropy","ce"].indexOf(o)&&(r=hf),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=ff(o);s=t,n=""+gf(o)}let e;nu(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Lf(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return Nc(this.testLoop(e,t,r,n.verbose,n.steps))}finally{Vf(a[0],t),Vf(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new vc("Verbose mode is not implemented yet.");re(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=cs((()=>{if(e.value){const{xs:n,ys:r}=_f(t,e.value),o=n.concat(r),c=cs((()=>a(o)));if(us(o),0===l)for(let t=0;t<c.length;++t)s.push(fs(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=cs((()=>bs(s[t],mo(u,e)))),l>0&&us(n)}us(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=Qs(s[c],i),us(t)}return Nc(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new yc("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new yc("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new yc("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new gh;if(t instanceof Er&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new yc("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new yc("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=yh(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=kc(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new yc("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cs((()=>{const r=this.checkNumSamples(t);if(n)throw new vc("Verbose predictLoop() is not implemented yet.");const a=Bf(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){cs((()=>{const n=a[e][0],r=a[e][1],s=Mf(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new gh(o);return yh(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return Nc(s.map((t=>Ps(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Uf(t);Kf(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return Lf(t),this.predictLoop(n,t)}finally{Vf(n,t)}}predictOnBatch(t){Kf(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new bc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===$p?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=Oc(t.map((t=>t.shape[0])));r.sort();const a=Oc(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new yc("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new yc("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!le(r,a))throw new yc("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=Hf(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Hf(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[Xp,tf,Qp];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===Qp&&1===s.shape[s.shape.length-1])throw new yc("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new yc("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new yc("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Af(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Rf(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return cs((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new vc("Verbose mode is not implemented yet.");if(null!=a)throw new vc("steps mode in testLoop() is not implemented yet");{const r=Bf(s,n),a=ci(uu(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=gu(a,s,i-s),c=Pf(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(fs(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=bs(o[t],mo(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=Qs(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(Ic(t,r)>1){const e=Ic(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new gh(t),i=yh(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=Ff(t,a[n]));const s=No(t);e.push(s),l=0===n?t:bs(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=No(e(r[a],i[a]))}hs(t),s.push(t)}return l=No(l),this.calculateLosses().forEach((t=>{l=bs(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>cs((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new gh(s),i=yh(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=No(r(a[t],i[t]));n=0===t?s:bs(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=No(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){return Wf(this,t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}async fitDataset(t,e){return Of(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return us(s),Vf(n[0],t),Vf(n[1],e),Nc(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=ls().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-ls().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=Cc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>Cc(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=Cc(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Cc(gf(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>Cc(gf(t))));{const t={};for(const e in this.metrics)t[e]=Cc(gf(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=Kp(If(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=Tc(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>Tc(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=Tc(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>Tc(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=Tc(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,pa.getSaveHandlers(n));if(0===e.length)throw new yc("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new yc("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new yc("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await ra(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Ef),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await ra(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=la([r.data,e])}if(null!=this.userDefinedMetadata){const t=!0;bf(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){bf(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}qf.className="Model",is(qf);class Xf extends qf{}async function Jf(t,e){if(null==e&&(e={}),"string"===typeof t){const n=fa(t,e);if(0===n.length)n.push(Qa(t,e));else if(n.length>1)throw new yc("Found more than one (".concat(n.length,") load handlers for ")+"URL '".concat(t,"'"));t=n[0]}return async function(t,e,n){null==n&&(n={});if(null==t.load)throw new yc("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let a=r.modelTopology;null!=a.model_config&&(a=a.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,i=Kp(If(a),e,o),l=r.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=r.userDefinedMetadata&&i.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new yc("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=aa(t,e),r={},a=[];return e.forEach((t=>{"optimizer"===t.group?a.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);i.loadWeights(t,s),null!=i.optimizer&&e.length>0&&await i.optimizer.setWeights(e),us(t),us(e.map((t=>t.tensor)))}return i}(t,void 0,e)}Xf.className="Functional",is(Xf);class Yf extends qf{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:jc("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new yc("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof Yf||t instanceof qf;let n;if(e){if(n=t,1!==n.outputs.length)throw new yc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new yc("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new yc("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=fh({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new yc("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new yc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=dh(this.outputs[0])}this.inboundNodes=[],new ch({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:kc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(th(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new qf({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new yc("Legacy serialization format not supported yet.");n=e}else re(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof Yf))throw new vc("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=Kp(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new yc("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new yc("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}function Zf(t){return new qf(t)}function Qf(t,e){return null==e&&(e={}),Jf(t,e)}Yf.className="Sequential",is(Yf);class $f extends ss{getConfig(){return{}}}class tg extends $f{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new vc("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return $s(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}tg.className="elu",is(tg);class eg extends $f{apply(t){return Xo(t)}}eg.className="selu",is(eg);class ng extends $f{apply(t){return Ko(t)}}ng.className="relu",is(ng);class rg extends $f{apply(t){return cs((()=>Eo(6,Ko(t))))}}rg.className="relu6",is(rg);class ag extends $f{apply(t){return t}}ag.className="linear",is(ag);class sg extends $f{apply(t){return Yo(t)}}sg.className="sigmoid",is(sg);class og extends $f{apply(t){return function(t){return cs((()=>{const e=bs(.5,mo(.2,t));return Ms(e,0,1)}))}(t)}}og.className="hardSigmoid",is(og);class ig extends $f{apply(t){return ri(t)}}ig.className="softplus",is(ig);class lg extends $f{apply(t){return function(t){return cs((()=>Qs(t,bs(ms(t),1))))}(t)}}lg.className="softsign",is(lg);class cg extends $f{apply(t){return li(t)}}cg.className="tanh",is(cg);class ug extends $f{apply(t){return ni(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}ug.className="softmax",is(ug);class hg extends $f{apply(t){return vo(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}hg.className="logSoftmax",is(hg);class dg extends $f{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return cs((()=>mo(Yo(mo(t,e)),t)))}}dg.className="swish",is(dg);class pg extends $f{apply(t){return cs((()=>mo(t,li(ri(t)))))}}function fg(t){return t.getClassName()}function gg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _c(t,os.getMap().classNameMap,e,"activation")}function mg(t){if(null==t){const t={className:"linear",config:{}};return gg(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},gg(e)}return t instanceof $f?t:gg(t)}function bg(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}pg.className="mish",is(pg);class yg extends ss{}class vg extends yg{constructor(t){super(),bg(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return cs((()=>{let e=Lo([1]);return this.hasL1&&(e=bs(e,yo(mo(this.l1,ms(t))))),this.hasL2&&(e=bs(e,yo(mo(this.l2,Iu(t))))),As(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}vg.className="L1L2",is(vg);const wg={l1l2:"L1L2"};function xg(t){return Rc(t)}function kg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _c(t,os.getMap().classNameMap,e,"regularizer")}function Sg(t){if(null==t)return null;if("string"===typeof t){return kg({className:t in wg?wg[t]:t,config:{}})}return t instanceof yg?t:kg(t)}class Ig extends hh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=$u(t);let n=Ko(t);return null!=this.maxValue&&(n=Ms(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}Ig.className="ReLU",is(Ig);class Ng extends hh{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=$u(t);return ho(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Ng.className="LeakyReLU",is(Ng);class Eg extends hh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Yu(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Sg(t.alphaRegularizer),this.alphaConstraint=Op(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new yc("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=th(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new oh({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=$u(t),Wo(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Ju(this.alphaInitializer),alphaRegularizer:xg(this.alphaRegularizer),alphaConstraint:_p(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}Eg.className="PReLU",is(Eg);class Cg extends hh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new vc("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=$u(t);return $s(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Cg.className="ELU",is(Cg);class Tg extends hh{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=$u(t);return mo(n,Ga(co(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}Tg.className="ThresholdedReLU",is(Tg);class Ag extends hh{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new ug).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=$u(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Rg(t,e,n){if("number"===typeof t)return kc(t,e);if(t.length!==e)throw new yc("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new yc("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function Fg(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function _g(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+cu([n-e,0]);else{if("same"!==r)throw new yc("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function Dg(t,e){return cs((()=>(Zc(e),"channelsFirst"===e?yi(t,[0,2,3,1]):t)))}function Og(t,e){return cs((()=>(Zc(e),"channelsFirst"===e?yi(t,[0,2,3,4,1]):t)))}function zg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return cs((()=>{if(null==s&&(s="channelsLast"),Zc(s),3!==t.shape.length)throw new yc("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new yc("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new yc("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=yi(t,[0,2,1])),"causal"===a)throw new vc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=js(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=Eu(i,n)),i}))}function Lg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return cs((()=>{if(null==s&&(s="channelsLast"),Zc(s),3!==t.rank&&4!==t.rank)throw new yc("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new yc("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=Dg(t,s);if("causal"===a)throw new vc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Ri({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=yi(l,[0,3,1,2])),l}))}function Mg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return cs((()=>{if(null==s&&(s="channelsLast"),Zc(s),4!==t.rank&&5!==t.rank)throw new yc("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new yc("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=Og(t,s);if("causal"===a)throw new vc("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=qs(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=Eu(i,n)),"channelsFirst"===s&&(i=yi(i,[0,4,1,2,3])),i}))}Ag.className="Softmax",is(Ag);class Pg extends hh{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Pg.verifyArgs(e),this.rank=t,Pc(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new vc("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=Rg(e.kernelSize,t,"kernelSize"),this.strides=Rg(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Qc(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Zc(this.dataFormat),this.activation=mg(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Yu(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Op(e.biasConstraint),this.biasRegularizer=Sg(e.biasRegularizer),this.activityRegularizer=Sg(e.activityRegularizer),this.dilationRate=Rg(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new yc("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new yc("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new yc("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(Sc("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!Mc(t.kernelSize,"number",1,3))throw new yc("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:fg(this.activation),useBias:this.useBias,biasInitializer:Ju(this.biasInitializer),biasRegularizer:xg(this.biasRegularizer),activityRegularizer:xg(this.activityRegularizer),biasConstraint:_p(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Bg extends Pg{constructor(t,e){super(t,e),this.kernel=null,Bg.verifyArgs(e),this.filters=e.filters,Pc(this.filters,"filters"),this.kernelInitializer=Yu(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Op(e.kernelConstraint),this.kernelRegularizer=Sg(e.kernelRegularizer)}build(t){t=th(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new yc("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return cs((()=>{let e;t=$u(t);const n=null==this.bias?null:this.bias.read(),r=Wc(this.activation.getClassName());if(null!=r&&2===this.rank)e=Lg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=zg(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=Lg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new vc("convolutions greater than 3D are not implemented yet.");e=Mg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=th(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=Fg(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Ju(this.kernelInitializer),kernelRegularizer:xg(this.kernelRegularizer),kernelConstraint:_p(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new yc("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class Wg extends Bg{constructor(t){super(2,t),Wg.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Mc(t.kernelSize,"number",1,2))throw new yc("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}Wg.className="Conv2D",is(Wg);class Ug extends Bg{constructor(t){super(3,t),Ug.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new yc("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}Ug.className="Conv3D",is(Ug);class Vg extends Wg{constructor(t){if(super(t),this.inputSpec=[new oh({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new yc("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=th(t)).length)throw new yc("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new yc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oh({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return cs((()=>{let e=$u(t);if(4!==e.shape.length)throw new yc("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,_g(o,u,l,this.padding),_g(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=yi(e,[0,2,3,1]));let p=Ks(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=yi(p,[0,3,1,2])),null!=this.bias&&(p=Eu(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=th(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=_g(e[r],i,s,this.padding),e[a]=_g(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Vg.className="Conv2DTranspose",is(Vg);class Gg extends Ug{constructor(t){if(super(t),this.inputSpec=[new oh({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new yc("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=th(t)).length)throw new yc("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new yc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oh({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return cs((()=>{let e=$u(t);if(5!==e.shape.length)throw new yc("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,_g(i,p,u,this.padding),_g(l,f,h,this.padding),_g(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=yi(e,[0,2,3,4,1]));let b=Js(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=yi(b,[0,4,1,2,3])),null!==this.bias&&(b=Eu(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=th(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=_g(e[r],c,o,this.padding),e[a]=_g(e[a],u,i,this.padding),e[s]=_g(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Gg.className="Conv3DTranspose",is(Gg);class jg extends Bg{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new yc("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new yc("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new yc("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Yu(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Sg(e.depthwiseRegularizer),this.depthwiseConstraint=Op(e.depthwiseConstraint),this.pointwiseInitializer=Yu(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Sg(e.pointwiseRegularizer),this.pointwiseConstraint=Op(e.pointwiseConstraint)}build(t){if((t=th(t)).length<this.rank+2)throw new yc("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new yc("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new oh({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return cs((()=>{let e;if(t=$u(t),1===this.rank)throw new vc("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=yi(t,[0,2,3,1])),e=Jo(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=Eu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=yi(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ju(this.depthwiseInitializer),t.pointwiseInitializer=Ju(this.pointwiseInitializer),t.depthwiseRegularizer=xg(this.depthwiseRegularizer),t.pointwiseRegularizer=xg(this.pointwiseRegularizer),t.depthwiseConstraint=_p(this.depthwiseConstraint),t.pointwiseConstraint=_p(this.pointwiseConstraint),t}}jg.className="SeparableConv";class Hg extends jg{constructor(t){super(2,t)}}Hg.className="SeparableConv2D",is(Hg);class Kg extends Bg{constructor(t){super(1,t),Kg.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Mc(t.kernelSize,"number",1,1))throw new yc("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}Kg.className="Conv1D",is(Kg);class qg extends hh{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return cs((()=>{if(t=$u(t),"channelsLast"===this.dataFormat){const e=bu(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return bu(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=bu(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return bu(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}qg.className="Cropping2D",is(qg);class Xg extends hh{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zc(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,Lc(Kc,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return cs((()=>{let e=$u(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=yi(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?wl.resizeNearestNeighbor(e,[t,r]):wl.resizeBilinear(e,[t,r]);return yi(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?wl.resizeNearestNeighbor(e,[t,r]):wl.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}Xg.className="UpSampling2D",is(Xg);class Jg extends Pg{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Yu(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Op(t.depthwiseConstraint),this.depthwiseRegularizer=Sg(t.depthwiseRegularizer)}build(t){if((t=th(t)).length<4)throw new yc("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new yc("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return cs((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return cs((()=>{null==a&&(a="channelsLast"),Zc(a);let o=Dg(t,a);if(4!==t.rank)throw new yc("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new yc("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=Ys(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=yi(o,[0,3,1,2])),o}))}(t=$u(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=Eu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=th(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=Fg(e,this.kernelSize[0],this.padding,this.strides[0]),s=Fg(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ju(this.depthwiseInitializer),t.depthwiseRegularizer=xg(this.depthwiseRegularizer),t.depthwiseConstraint=_p(this.depthwiseRegularizer),t}}function Yg(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new yc("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function Zg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return cs((()=>{const l=e.shape.length;if(l<3)throw new yc("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(uu(2,l));if(e=yi(e,c),null!=s)throw new vc("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=Ga(Ga(a,"bool"),"float32"),a.rank===l-1&&(a=ao(a,-1)),a=yi(a,c)),r&&(e=qo(e,0),null!=a&&(a=qo(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=di(e);let g,m;null!=a&&(g=di(a));for(let e=0;e<p;++e){const n=f[e],r=cs((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=cs((()=>{const t=g[e],n=bo(Po(t),t);return{output:bs(mo(r[0],t),mo(d[0],n)),newStates:d.map(((e,a)=>bs(mo(r[1][a],t),mo(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=ii(u,1)}return[h,m,d]}))}Jg.className="DepthwiseConv2D",is(Jg);class Qg extends hh{constructor(t){let e;if(super(t),null==t.cell)throw new yc("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new om({cells:t.cell}):t.cell,null==e.stateSize)throw new yc("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new oh({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return uu(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Zu(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return cs((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new vc("Constants support is not implemented in RNN yet.");Zu(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new oh({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!le(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new yc("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new oh({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];cs((()=>{if(!this.stateful)throw new mc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new yc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Lo([n,t]))):this.states_=[Lo([n,this.cell.stateSize])];else if(null==t)us(this.states_),null!=this.keptStates&&(us(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Lo([n,t]))):this.states_[0]=Lo([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new yc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):us(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!le(r.shape,s))throw new yc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>hs(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Yg(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new oh({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof ih){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return cs((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=$u(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new yc("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=Zg(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return cs((()=>{let e=Lo(t.shape);return e=yo(e,[1,2]),e=fu(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?wu(e,[1,t]):e)):this.cell.stateSize>1?[wu(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Qg.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Kp(e.cell,n);return new t(Object.assign(e,{cell:r}))}}Qg.className="RNN",is(Qg);class $g extends hh{}class tm extends $g{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Pc(this.units,"units"),this.activation=mg(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Yu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Sg(t.kernelRegularizer),this.recurrentRegularizer=Sg(t.recurrentRegularizer),this.biasRegularizer=Sg(t.biasRegularizer),this.kernelConstraint=Op(t.kernelConstraint),this.recurrentConstraint=Op(t.recurrentConstraint),this.biasConstraint=Op(t.biasConstraint),this.dropout=lu([1,cu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lu([1,cu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=th(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return cs((()=>{if(2!==t.length)throw new yc("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=im({ones:()=>Po(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=im({ones:()=>Po(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=ku(null!=s?mo(t,s):t,this.kernel.read()),null!=this.bias&&(a=Eu(a,this.bias.read())),null!=o&&(n=mo(n,o));let i=bs(a,ku(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:fg(this.activation),useBias:this.useBias,kernelInitializer:Ju(this.kernelInitializer),recurrentInitializer:Ju(this.recurrentInitializer),biasInitializer:Ju(this.biasInitializer),kernelRegularizer:xg(this.kernelRegularizer),recurrentRegularizer:xg(this.recurrentRegularizer),biasRegularizer:xg(this.biasRegularizer),activityRegularizer:xg(this.activityRegularizer),kernelConstraint:_p(this.kernelConstraint),recurrentConstraint:_p(this.recurrentConstraint),biasConstraint:_p(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}tm.className="SimpleRNNCell",is(tm);class em extends Qg{constructor(t){t.cell=new tm(t),super(t)}call(t,e){return cs((()=>{null!=this.cell.dropoutMask&&(us(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(us(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}em.className="SimpleRNN",is(em);class nm extends $g{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new yc("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Pc(this.units,"units"),this.activation=mg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=mg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Yu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Sg(t.kernelRegularizer),this.recurrentRegularizer=Sg(t.recurrentRegularizer),this.biasRegularizer=Sg(t.biasRegularizer),this.kernelConstraint=Op(t.kernelConstraint),this.recurrentConstraint=Op(t.recurrentConstraint),this.biasConstraint=Op(t.biasConstraint),this.dropout=lu([1,cu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lu([1,cu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=th(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return cs((()=>{if(2!==t.length)throw new yc("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=im({ones:()=>Po(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=im({ones:()=>Po(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=mo(t,a[0]));let c=ku(t,this.kernel.read());this.useBias&&(c=Eu(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mo(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=ai(u,[2*this.units,this.units],u.rank-1),p=ku(r,h),[f,g,m]=ai(c,3,c.rank-1),[b,y]=ai(p,2,p.rank-1);o=this.recurrentActivation.apply(bs(f,b)),i=this.recurrentActivation.apply(bs(g,y));const v=ku(mo(i,r),d);l=this.activation.apply(bs(m,v));const w=bs(mo(o,r),mo(bs(1,Do(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:fg(this.activation),recurrentActivation:fg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ju(this.kernelInitializer),recurrentInitializer:Ju(this.recurrentInitializer),biasInitializer:Ju(this.biasInitializer),kernelRegularizer:xg(this.kernelRegularizer),recurrentRegularizer:xg(this.recurrentRegularizer),biasRegularizer:xg(this.biasRegularizer),activityRegularizer:xg(this.activityRegularizer),kernelConstraint:_p(this.kernelConstraint),recurrentConstraint:_p(this.recurrentConstraint),biasConstraint:_p(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}nm.className="GRUCell",is(nm);class rm extends Qg{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new nm(t),super(t)}call(t,e){return cs((()=>{null!=this.cell.dropoutMask&&(us(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(us(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}rm.className="GRU",is(rm);class am extends $g{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Pc(this.units,"units"),this.activation=mg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=mg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Yu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Sg(t.kernelRegularizer),this.recurrentRegularizer=Sg(t.recurrentRegularizer),this.biasRegularizer=Sg(t.biasRegularizer),this.kernelConstraint=Op(t.kernelConstraint),this.recurrentConstraint=Op(t.recurrentConstraint),this.biasConstraint=Op(t.biasConstraint),this.dropout=lu([1,cu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lu([1,cu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=th(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends Fu{apply(e,r){const a=t.apply([n]),s=(new Du).apply([n]),o=t.apply([2*n]);return vu(vu(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return cs((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new yc("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=im({ones:()=>Po(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=im({ones:()=>Po(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=mo(t,s[0]));let h=ku(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mo(r,o[0])),h=bs(h,ku(r,this.recurrentKernel.read())),this.useBias&&(h=Eu(h,this.bias.read()));const[d,p,f,g]=ai(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=bs(mo(l,a),mo(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=mo(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:fg(this.activation),recurrentActivation:fg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ju(this.kernelInitializer),recurrentInitializer:Ju(this.recurrentInitializer),biasInitializer:Ju(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:xg(this.kernelRegularizer),recurrentRegularizer:xg(this.recurrentRegularizer),biasRegularizer:xg(this.biasRegularizer),activityRegularizer:xg(this.activityRegularizer),kernelConstraint:_p(this.kernelConstraint),recurrentConstraint:_p(this.recurrentConstraint),biasConstraint:_p(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}am.className="LSTMCell",is(am);class sm extends Qg{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new am(t),super(t)}call(t,e){return cs((()=>{null!=this.cell.dropoutMask&&(us(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(us(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}sm.className="LSTM",is(sm);class om extends $g{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return cs((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;Zu(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{nu("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign({},t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(Kp(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return ah(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}sh(e)}}function im(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):Cu(e(),n),i=()=>Tu(o,e,r);if(!a||a<=1)return hs(i().clone());return Array(a).fill(void 0).map(i).map((t=>hs(t.clone())))}om.className="StackedRNNCells",is(om);var lm=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class cm extends Qg{constructor(t){if(t.unroll)throw new vc("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new vc("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new oh({ndim:5})]}call(t,e){return cs((()=>{if(null!=this.cell.dropoutMask&&(us(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(us(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new yc("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return cs((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=Lo([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];cs((()=>{if(!this.stateful)throw new mc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new yc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Lo(a))):this.states_=[Lo(a)];else if(null==t)us(this.states_),null!=this.keptStates&&(us(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Lo(a))):this.states_[0]=Lo(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new yc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):us(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!le(n.shape,r))throw new yc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>hs(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=Fg(l,r[0],a,s[0],o[0]),h=Fg(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}cm.className="ConvRNN2D";class um extends am{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign({},t,{units:e})),this.filters=e,Pc(this.filters,"filters"),this.kernelSize=Rg(n,2,"kernelSize"),this.kernelSize.forEach((t=>Pc(t,"kernelSize"))),this.strides=Rg(r||1,2,"strides"),this.strides.forEach((t=>Pc(t,"strides"))),this.padding=a||"valid",Qc(this.padding),this.dataFormat=s||"channelsLast",Zc(this.dataFormat),this.dilationRate=Rg(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>Pc(t,"dilationRate")))}build(t){var e;t=th(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new yc("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends Fu{apply(t,e){return yu([n.apply([r]),Mo([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return cs((()=>{if(3!==t.length)throw new yc("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=im({ones:()=>Po(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?mo(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=im({ones:()=>Po(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=ai(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?ai(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,E,C,T]=ai(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,E),g=this.recurrentConv(g,C),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(bs(l,p)),R=this.recurrentActivation.apply(bs(c,f)),F=bs(mo(R,s),mo(A,this.activation.apply(bs(u,g)))),_=mo(this.recurrentActivation.apply(bs(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=lm(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(t,e,n,r){const a=Gs(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Eu(a,n,this.dataFormat):a}recurrentConv(t,e){return Gs(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}um.className="ConvLSTM2DCell",is(um);class hm extends cm{constructor(t){const e=new um(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}hm.className="ConvLSTM2D",is(hm);class dm extends hh{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return Tu((()=>Cu(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}dm.className="Dropout",is(dm);class pm extends dm{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}pm.className="SpatialDropout1D",is(pm);class fm extends hh{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Pc(this.units,"units"),this.activation=mg(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=Yu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Yu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Op(t.kernelConstraint),this.biasConstraint=Op(t.biasConstraint),this.kernelRegularizer=Sg(t.kernelRegularizer),this.biasRegularizer=Sg(t.biasRegularizer),this.activityRegularizer=Sg(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=th(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=th(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t),r=Wc(this.activation.getClassName());let a;return null!=r?a=ku(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=ku(n,this.kernel.read()),null!=this.bias&&(a=Eu(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:fg(this.activation),useBias:this.useBias,kernelInitializer:Ju(this.kernelInitializer),biasInitializer:Ju(this.biasInitializer),kernelRegularizer:xg(this.kernelRegularizer),biasRegularizer:xg(this.biasRegularizer),activityRegularizer:xg(this.activityRegularizer),kernelConstraint:_p(this.kernelConstraint),biasConstraint:_p(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}fm.className="Dense",is(fm);class gm extends hh{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=th(t);for(const e of t.slice(1))if(null==e)throw new yc('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],iu(t,1)]}call(t,e){return cs((()=>{this.invokeCallHook(t,e);let n=$u(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=yi(n,t)}return function(t){if(t.rank<=1)throw new yc("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],iu(t.shape,1)];return As(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}gm.className="Flatten",is(gm);class mm extends hh{constructor(t){super(t),this.supportsMasking=!0,this.activation=mg(t.activation)}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t);return this.activation.apply(n)}))}getConfig(){const t={activation:fg(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}mm.className="Activation",is(mm);class bm extends hh{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return cs((()=>{return t=$u(t),e=t,n=this.n,cs((()=>{if(2!==e.shape.length)throw new yc("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return wu(fu(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}bm.className="RepeatVector",is(bm);class ym extends hh{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new yc("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=iu(t);if(null!==s){if(0===a||o%a!==0)throw new yc(n);r[s]=o/a}else if(o!==a)throw new yc(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return As(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}ym.className="Reshape",is(ym);class vm extends hh{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=uu(1,t.dims.length+1);if(!le(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new oh({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=th(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return yi($u(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}vm.className="Permute",is(vm);class wm extends hh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=$u(t);return vs(Oo(n,this.maskValue),-1)}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t),r=vs(Oo(n,this.maskValue),-1,!0);return mo(n,Ga(r,n.dtype))}))}}wm.className="Masking",is(wm);class xm extends hh{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Ec(t.inputLength))}this.inputDim=t.inputDim,Pc(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Pc(this.outputDim,"outputDim"),this.embeddingsInitializer=Yu(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Sg(t.embeddingsRegularizer),this.activityRegularizer=Sg(t.activityRegularizer),this.embeddingsConstraint=Op(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return cs((()=>this.maskZero?(t=$u(t),Oo(t,gi(t))):null))}computeOutputShape(t){if(t=th(t),null==this.inputLength)return[...t,this.outputDim];const e=Ec(this.inputLength);if(e.length!==t.length-1)throw new yc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new yc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return cs((()=>{this.invokeCallHook(t,e);let n=$u(t);"int32"!==n.dtype&&(n=pu(n,"int32"));const r=Su(this.embeddings.read(),As(n,[n.size]));return As(r,th(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ju(this.embeddingsInitializer),embeddingsRegularizer:xg(this.embeddingsRegularizer),activityRegularizer:xg(this.activityRegularizer),embeddingsConstraint:_p(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}xm.className="Embedding",is(xm);class km extends hh{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new vc}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new yc("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[th(t)]),t.length<2)throw new yc("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=Oc(e),e.length>1)throw new yc("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===Oc(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return cs((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=cu(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=fu(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=As(s,[r].concat(iu(t.slice(1))));o=yi(o,[1,0]),o=As(o,a),e.push(o),n=!0}else if(t>1){const r=uu(1,t).concat([0]);e.push(yi(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=As(yi(As(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(uu(0,a-1));r=yi(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=Oc(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return cs((()=>{if(null==e)return null;if(!Array.isArray(e))throw new yc("`mask` should be an Array");if(!Array.isArray(t))throw new yc("`inputs` should be an Array");if(e.length!==t.length)throw new yc("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:ao(t,0))))[0];for(let t=1;t<e.length-1;++t)n=wo(n,e[t]);return n}))}}class Sm extends km{constructor(t){super(t)}mergeFunction(t){return cs((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bs(e,t[n]);return e}))}}Sm.className="Add",is(Sm);class Im extends km{constructor(t){super(t)}mergeFunction(t){return cs((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=mo(e,t[n]);return e}))}}Im.className="Multiply",is(Im);class Nm extends km{constructor(t){super(t)}mergeFunction(t){return cs((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bs(e,t[n]);return mo(1/t.length,e)}))}}Nm.className="Average",is(Nm);class Em extends km{constructor(t){super(t)}mergeFunction(t){return cs((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Io(e,t[n]);return e}))}}Em.className="Maximum",is(Em);class Cm extends km{constructor(t){super(t)}mergeFunction(t){return cs((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Eo(e,t[n]);return e}))}}Cm.className="Minimum",is(Cm);class Tm extends km{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new yc("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if(le(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new yc("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return cs((()=>yu(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new yc("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new yc("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new yc("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new yc("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return cs((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(Ga(Po(t[s]),"bool")):e[s].rank<t[s].rank?r.push(ao(e[s],-1)):r.push(e[s]);const a=Ps(r,this.axis);return ys(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Am(t,e){for(;t<0;)t+=e;return t}Tm.className="Concatenate",is(Tm);class Rm extends km{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){re(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new vc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new yc("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new yc("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>Am(e,t[n].shape.length))):[Am(this.axes,n.shape.length),Am(this.axes,r.shape.length)],this.normalize&&(n=qp(n,e[0]),r=qp(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new vc("batchDot is not implemented for tensors of 4D or higher rank yet");if(re(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),re(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new vc("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return cs((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=As(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=As(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?yo(mo(t,e),s[0]):yo(mo(yi(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=xo(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=oi(o,e)}return 1===o.shape.length&&(o=ao(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[Am(this.axes,t.length),Am(this.axes,e.length)],n}computeOutputShape(t){re(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new vc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Rm.className="Dot",is(Rm);class Fm extends hh{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t);return Tu((()=>bs(xu(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}Fm.className="GaussianNoise",is(Fm);class _m extends hh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return cs((()=>{this.invokeCallHook(t,e);const n=$u(t);if(this.rate>0&&this.rate<1){return Tu((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return mo(n,xu(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}_m.className="GaussianDropout",is(_m);class Dm extends hh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||$u(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return cs((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=$u(t),r=-1.7580993408473766;let a=uo(Ho(n),this.rate);a=pu(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=bs(mo(e,a),mo(bs(a,-1),r));return bs(mo(i,s),o)};return Tu(r,(()=>$u(t)),e.training||!1)}return t}))}}function Om(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=Ds(t,e,n,r,a,o);else if(3===t.rank)s=Os(t,e,n,r,a,o);else{if(4!==t.rank)throw new vc("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=zs(t,e,n,r,a,o)}return s}function zm(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return le(r.slice().sort(),uu(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return cs((()=>{const s=_o(t,r),o=s.mean,i=s.variance;return[Om(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return cs((()=>{const s=_o(t,r),o=s.mean,i=s.variance,l=[];for(const e of uu(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=As(o,l),u=As(i,l),h=null==e?null:As(e,l),d=null==n?null:As(n,l);return[Om(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}Dm.className="AlphaDropout",is(Dm);class Lm extends hh{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Yu(t.betaInitializer||"zeros"),this.gammaInitializer=Yu(t.gammaInitializer||"ones"),this.movingMeanInitializer=Yu(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Yu(t.movingVarianceInitializer||"ones"),this.betaConstraint=Op(t.betaConstraint),this.gammaConstraint=Op(t.gammaConstraint),this.betaRegularizer=Sg(t.betaRegularizer),this.gammaRegularizer=Sg(t.gammaRegularizer)}build(t){t=th(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new yc("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new oh({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return cs((()=>{const n=null!=e.training&&e.training,r=$u(t),a=r.shape,s=a.length,o=uu(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=kc(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!le(c,uu(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=As(this.movingMean.read(),l),e=As(this.movingVariance.read(),l),n=this.center?As(this.beta.read(),l):null,a=this.scale?As(this.gamma.read(),l):null;return Om(r,t,e,n,a,this.epsilon)}return Om(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=zm(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{cs((()=>{const r=1-n,a=t.read(),s=mo(bo(a,e),r);t.write(bo(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ju(this.betaInitializer),gammaInitializer:Ju(this.gammaInitializer),movingMeanInitializer:Ju(this.movingMeanInitializer),movingVarianceInitializer:Ju(this.movingVarianceInitializer),betaRegularizer:xg(this.betaRegularizer),gammaRegularizer:xg(this.gammaRegularizer),betaConstraint:_p(this.betaConstraint),gammaConstraint:_p(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Lm.className="BatchNormalization",is(Lm);class Mm extends hh{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Yu(t.betaInitializer||"zeros"),this.gammaInitializer=Yu(t.gammaInitializer||"ones"),this.betaRegularizer=Sg(t.betaRegularizer),this.gammaRegularizer=Sg(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=th(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==Oc(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=$u(t),r=n.shape,a=r.length;return cs((()=>{let{mean:t,variance:e}=_o(n,this.axis,!0);const s=kc(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?As(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=so(t,c),e=so(e,c),null!=i&&(i=so(i,u)),null!=l&&(l=so(l,u)),Om(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ju(this.betaInitializer),gammaInitializer:Ju(this.gammaInitializer),betaRegularizer:xg(this.betaRegularizer),gammaRegularizer:xg(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Mm.className="LayerNormalization",is(Mm);class Pm extends hh{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new yc("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new yc("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new yc("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new oh({ndim:4})]}computeOutputShape(t){let e,n;return t=th(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return cs((()=>{return e=$u(t),n=this.padding,r=this.dataFormat,cs((()=>{if(4!==e.rank)throw new yc("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new yc("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new yc("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Bo(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function Bm(t,e,n,r,a,s){return cs((()=>{let o;Zc(a),$c(s),Qc(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Dg(t,a);const i="same"===r?"same":"valid";return o="max"===s?ko(t,e,n,i):Rs(t,e,n,i),"channelsFirst"===a&&(o=yi(o,[0,3,1,2])),o}))}function Wm(t,e,n,r,a,s){return cs((()=>{let o;Zc(a),$c(s),Qc(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Og(t,a);const i="same"===r?"same":"valid";return o="max"===s?So(t,e,n,i):Fs(t,e,n,i),"channelsFirst"===a&&(o=yi(o,[0,4,1,2,3])),o}))}Pm.className="ZeroPadding2D",is(Pm);class Um extends hh{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new yc("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(Pc(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new yc("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}Pc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Qc(this.padding),this.inputSpec=[new oh({ndim:3})]}computeOutputShape(t){const e=Fg((t=th(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return cs((()=>{this.invokeCallHook(t,e),t=fu($u(t),2);const n=this.poolingFunction($u(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return oi(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Vm extends Um{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Bm(t,e,n,r,a,"max")}}Vm.className="MaxPooling1D",is(Vm);class Gm extends Um{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Bm(t,e,n,r,a,"avg")}}Gm.className="AveragePooling1D",is(Gm);class jm extends hh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new yc("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];Pc(this.poolSize,"poolSize"),Pc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zc(this.dataFormat),Qc(this.padding),this.inputSpec=[new oh({ndim:4})]}computeOutputShape(t){t=th(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Fg(e,this.poolSize[0],this.padding,this.strides[0]),n=Fg(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return cs((()=>(this.invokeCallHook(t,e),this.poolingFunction($u(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Hm extends jm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Bm(t,e,n,r,a,"max")}}Hm.className="MaxPooling2D",is(Hm);class Km extends jm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Bm(t,e,n,r,a,"avg")}}Km.className="AveragePooling2D",is(Km);class qm extends hh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new yc("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Pc(this.poolSize,"poolSize"),Pc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zc(this.dataFormat),Qc(this.padding),this.inputSpec=[new oh({ndim:5})]}computeOutputShape(t){t=th(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Fg(e,this.poolSize[0],this.padding,this.strides[0]),n=Fg(n,this.poolSize[1],this.padding,this.strides[1]),r=Fg(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return cs((()=>(this.invokeCallHook(t,e),this.poolingFunction($u(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Xm extends qm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Wm(t,e,n,r,a,"max")}}Xm.className="MaxPooling3D",is(Xm);class Jm extends qm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Zc(a),Qc(r),Wm(t,e,n,r,a,"avg")}}Jm.className="AveragePooling3D",is(Jm);class Ym extends hh{constructor(t){super(t),this.inputSpec=[new oh({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new vc}}class Zm extends Ym{constructor(t){super(t||{})}call(t,e){return cs((()=>{const e=$u(t);return No(e,1)}))}}Zm.className="GlobalAveragePooling1D",is(Zm);class Qm extends Ym{constructor(t){super(t||{})}call(t,e){return cs((()=>{const e=$u(t);return go(e,1)}))}}Qm.className="GlobalMaxPooling1D",is(Qm);class $m extends hh{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Zc(this.dataFormat),this.inputSpec=[new oh({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new vc}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class tb extends $m{call(t,e){return cs((()=>{const e=$u(t);return"channelsLast"===this.dataFormat?No(e,[1,2]):No(e,[2,3])}))}}tb.className="GlobalAveragePooling2D",is(tb);class eb extends $m{call(t,e){return cs((()=>{const e=$u(t);return"channelsLast"===this.dataFormat?go(e,[1,2]):go(e,[2,3])}))}}eb.className="GlobalMaxPooling2D",is(eb);class nb extends hh{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Kp(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class rb extends nb{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=th(t)).length<3)throw new yc("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=th(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return cs((()=>Zg(((t,n)=>[$u(this.layer.call(t,e)),[]]),t=$u(t),[],!1,null,null,!1,!0)[1]))}}rb.className="TimeDistributed",is(rb);class ab extends nb{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=Kp(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=Kp(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,Lc(Jc,"BidirectionalMergeMode",a),t.weights)throw new vc("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Nc(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Yg(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new yc("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new oh({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new vc("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof ih;for(const l of s)if(l instanceof ih!==i)throw new yc("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return cs((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=qo(a,1)),"concat"===this.mergeMode?o=yu([r,a]):"sum"===this.mergeMode?o=bs(r,a):"ave"===this.mergeMode?o=mo(.5,bs(r,a)):"mul"===this.mergeMode?o=mo(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){nu(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),nu(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=Kp(e.layer);if(delete e.layer,null!=e.numConstants)throw new vc("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}ab.className="Bidirectional",is(ab);class sb extends hh{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return cs((()=>("float32"!==(t=$u(t)).dtype&&(t=pu(t,"float32")),bs(mo(t,this.scale),this.offset))))}}sb.className="Rescaling",is(sb);var ob=function(t,e){return(ob=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};var ib=function(){return(ib=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var a in e=arguments[n])Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t}).apply(this,arguments)};function lb(t,e,n,r){return new(n||(n=Promise))((function(a,s){function o(t){try{l(r.next(t))}catch(t){s(t)}}function i(t){try{l(r.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?a(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,i)}l((r=r.apply(t,e||[])).next())}))}function cb(t,e){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}function ub(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],r=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function hb(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var r,a,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(r=s.next()).done;)o.push(r.value)}catch(t){a={error:t}}finally{try{r&&!r.done&&(n=s.return)&&n.call(s)}finally{if(a)throw a.error}}return o}function db(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(hb(arguments[e]));return t}function pb(t){return lb(this,void 0,void 0,(function(){var e,r,a,s,o;return cb(this,(function(i){switch(i.label){case 0:return"http://","https://",e="file://",0!==t.indexOf("http://")&&0!==t.indexOf("https://")?[3,3]:[4,fetch(t)];case 1:return[4,i.sent().json()];case 2:return[2,i.sent()];case 3:return 0!==t.indexOf(e)?[3,5]:(r=n(7571),a=(0,Ol.promisify)(r.readFile),o=(s=JSON).parse,[4,a(t.slice(e.length),{encoding:"utf-8"})]);case 4:return[2,o.apply(s,[i.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+t+". Supported schemes are: http://, https://, and (node.js-only) file://")}}))}))}var fb=null;function gb(t){return null==fb&&(fb=ds().epsilon()),cs((function(){var e=_o(t),n=e.mean,r=e.variance;return Qs(bo(t,n),bs(si(r),fb))}))}function mb(t){if(t.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return null==fb&&(fb=ds().epsilon()),cs((function(){var e=_o(ci(t)),n=e.mean,r=e.variance,a=n.arraySync(),s=Math.sqrt(r.arraySync()),o=Array.from(t).map((function(t){return(t-a)/(s+fb)}));return new Float32Array(o)}))}function bb(t){return lb(this,void 0,void 0,(function(){return cb(this,(function(e){return[2,navigator.mediaDevices.getUserMedia({audio:null==t||t,video:!1})]}))}))}var yb=function(){function t(t){var e=this;if(null==t)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(null==t.spectrogramCallback)throw new Error("spectrogramCallback cannot be null or undefined");if(!(t.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+t.numFramesPerSpectrogram);if(t.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+t.suppressionTimeMillis);if(this.suppressionTimeMillis=t.suppressionTimeMillis,this.spectrogramCallback=t.spectrogramCallback,this.numFrames=t.numFramesPerSpectrogram,this.sampleRateHz=t.sampleRateHz||44100,this.fftSize=t.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.overlapFactor=t.overlapFactor,this.includeRawAudio=t.includeRawAudio,re(this.overlapFactor>=0&&this.overlapFactor<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+e.overlapFactor})),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=window.AudioContext||window.webkitAudioContext}return t.prototype.start=function(t){return lb(this,void 0,void 0,(function(){var e,n,r;return cb(this,(function(a){switch(a.label){case 0:if(null!=this.frameIntervalTask)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return e=this,[4,bb(t)];case 1:return e.stream=a.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),n=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,n.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),r=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new xb(r,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}}))}))},t.prototype.onAudioFrame=function(){return lb(this,void 0,void 0,(function(){var t,e,n,r;return cb(this,(function(a){switch(a.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(t=vb(this.freqDataQueue),e=wb(t,[1,this.numFrames,this.columnTruncateLength,1]),n=void 0,this.includeRawAudio&&(r=vb(this.timeDataQueue),n=wb(r,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(e,n)]):[3,2]);case 1:a.sent()&&this.tracker.suppress(),us([e,n]),a.label=2;case 2:return[2]}}))}))},t.prototype.stop=function(){return lb(this,void 0,void 0,(function(){return cb(this,(function(t){if(null==this.frameIntervalTask)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]}))}))},t.prototype.setConfig=function(t){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},t.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},t}();function vb(t){var e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((function(t,r){return n.set(t,r*e)})),n}function wb(t,e){var n=new Float32Array(ie(e));return n.set(t,n.length-t.length),ta(n,e)}var xb=function(){function t(t,e){var n=this;this.period=t,this.suppressionTime=null==e?0:e,this.counter=0,re(this.period>0,(function(){return"Expected period to be positive, but got "+n.period}))}return t.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(null==this.suppressionOnset||this.counter-this.suppressionOnset>this.suppressionTime)},t.prototype.suppress=function(){this.suppressionOnset=this.counter},t}();function kb(t){var e=0;t.forEach((function(t){e+=t.byteLength}));var n=new Uint8Array(e),r=0;return t.forEach((function(t){n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Sb(t){var e=0;t.forEach((function(t){return e+=t.length}));var n=new Float32Array(e),r=0;return t.forEach((function(t){n.set(t,r),r+=t.length})),n}function Ib(t){if(null==t)throw new Error("Received null or undefind string");for(var e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n.buffer}function Nb(t){if(null==t)throw new Error("Received null or undefind buffer");var e=new Uint8Array(t);return decodeURIComponent(escape(String.fromCharCode.apply(String,db(e))))}var Eb="TFJSSCDS",Cb="_background_noise_",Tb=function(){function t(t){if(this.examples={},this.label2Ids={},null!=t)for(var e=function(t){re(null!=t,(function(){return"Received null or undefined buffer"}));var e=0,n=Nb(t.slice(e,8));re(n===Eb,(function(){return"Deserialization error: Invalid descriptor"})),e+=8,e+=4;var r=new Uint32Array(t,e,1),a=e+=4;e=a+r[0];var s=Nb(t.slice(a,e));return{manifest:JSON.parse(s),data:t.slice(e)}}(t),n=0,r=0;r<e.manifest.length;++r){var a=e.manifest[r],s=a.spectrogramNumFrames*a.spectrogramFrameSize;null!=a.rawAudioNumSamples&&(s+=a.rawAudioNumSamples),s*=4,this.addExample(Rb({spec:a,data:e.data.slice(n,n+s)})),n+=s}}return t.prototype.addExample=function(t){re(null!=t,(function(){return"Got null or undefined example"})),re(null!=t.label&&t.label.length>0,(function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(t.label)}));var e=function(){function t(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return t()+t()+"-"+t()+"-"+t()+"-"+t()+"-"+t()+t()+t()}();return this.examples[e]=t,t.label in this.label2Ids||(this.label2Ids[t.label]=[]),this.label2Ids[t.label].push(e),e},t.prototype.merge=function(t){var e,n,r,a;re(t!==this,(function(){return"Cannot merge a dataset into itself"}));var s=t.getVocabulary();try{for(var o=ub(s),i=o.next();!i.done;i=o.next()){var l=i.value,c=t.getExamples(l);try{for(var u=(r=void 0,ub(c)),h=u.next();!h.done;h=u.next()){var d=h.value;this.addExample(d.example)}}catch(t){r={error:t}}finally{try{h&&!h.done&&(a=u.return)&&a.call(u)}finally{if(r)throw r.error}}}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}},t.prototype.getExampleCounts=function(){var t={};for(var e in this.examples){var n=this.examples[e];n.label in t||(t[n.label]=0),t[n.label]++}return t},t.prototype.getExamples=function(t){var e=this;re(null!=t,(function(){return"Expected label to be a string, but got "+JSON.stringify(t)})),re(t in this.label2Ids,(function(){return'No example of label "'+t+'" exists in dataset'}));var n=[];return this.label2Ids[t].forEach((function(t){n.push({uid:t,example:e.examples[t]})})),n},t.prototype.getData=function(t,e){var n=this;re(this.size()>0,(function(){return"Cannot get spectrograms as tensors because the dataset is empty"}));var r=this.getVocabulary();null!=t?re(-1!==r.indexOf(t),(function(){return"Label "+t+" is not in the vocabulary ("+JSON.stringify(r)+")"})):re(r.length>1,(function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+r.length+" word."})),null==e&&(e={});var a,s,o=this.getSortedUniqueNumFrames();1===o.length?(a=null==e.numFrames?o[0]:e.numFrames,s=null==e.hopFrames?1:e.hopFrames):(re(null!=(a=e.numFrames)&&Number.isInteger(a)&&a>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."})),re(a<=o[0],(function(){return"numFrames ("+a+") exceeds the minimum numFrames ("+o[0]+") among the examples of the Dataset."})),re(null!=(s=e.hopFrames)&&Number.isInteger(s)&&s>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."})));var i=null==e.normalize||e.normalize;return cs((function(){for(var o,l,c,u=[],h=[],d=[],p=0;p<r.length;++p){var f=r[p];if(null==t||f===t){var g=n.label2Ids[f],m=function(r){var o,l,g=n.examples[r].spectrogram,m=g.frameSize;null==c?c=m:re(m===c,(function(){return"Mismatch in frameSize  ("+m+" vs "+c+")"}));var b=g.data.length/m,y=null;f!==Cb&&(y=null==g.keyFrameIndex?_b(g).dataSync()[0]:g.keyFrameIndex);var v=ns(g.data,[b,m,1]),w=Fb(b,y,a,s),x=function(n){var r=cs((function(){var t=Zo(v,[n[0],0,0],[n[1]-n[0],-1,-1]);return i?gb(t):t}));e.getDataset?h.push(r.dataSync()):u.push(r),null==t&&d.push(p)};try{for(var k=(o=void 0,ub(w)),S=k.next();!S.done;S=k.next())x(S.value)}catch(t){o={error:t}}finally{try{S&&!S.done&&(l=k.return)&&l.call(k)}finally{if(o)throw o.error}}us(v)};try{for(var b=(o=void 0,ub(g)),y=b.next();!y.done;y=b.next())m(y.value)}catch(t){o={error:t}}finally{try{y&&!y.done&&(l=b.return)&&l.call(b)}finally{if(o)throw o.error}}}}null!=e.augmentByMixingNoiseRatio&&n.augmentByMixingNoise(e.getDataset?h:u,d,e.augmentByMixingNoiseRatio);var v=null==e.shuffle||e.shuffle;if(e.getDataset){var w=null==e.datasetBatchSize?32:e.datasetBatchSize,x=null==e.datasetValidationSplit?.15:e.datasetValidationSplit;re(x>0&&x<1,(function(){return"Invalid dataset validation split: "+x}));var k=h.map((function(t,e){return[t,d[e]]}));ee(k),h=k.map((function(t){return t[0]}));var S=k.map((function(t){return t[1]})),I=function(t,e,n){var r,a,s,o,i,l,c,u;re(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n}));for(var h=!Array.isArray(t[0]),d=e,p=[],f=0;f<d.length;++f){var g=d[f];null==p[g]&&(p[g]=[]),p[g].push(f)}var m=p.length,b=[],y=[];for(p.map((function(t){return ee(t)})),f=0;f<m;++f)for(var v=p[f],w=Math.round(v.length*(1-n)),x=0;x<v.length;++x)x<w?b.push(v[x]):y.push(v[x]);if(h){var k=[],S=[],I=[],N=[];try{for(var E=ub(b),C=E.next();!C.done;C=E.next()){var T=C.value;k.push(t[T]),S.push(e[T])}}catch(t){r={error:t}}finally{try{C&&!C.done&&(a=E.return)&&a.call(E)}finally{if(r)throw r.error}}try{for(var A=ub(y),R=A.next();!R.done;R=A.next())T=R.value,I.push(t[T]),N.push(e[T])}catch(t){s={error:t}}finally{try{R&&!R.done&&(o=A.return)&&o.call(A)}finally{if(s)throw s.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}k=[],S=[],I=[],N=[];try{for(var F=ub(b),_=F.next();!_.done;_=F.next())T=_.value,k.push(t[T]),S.push(e[T])}catch(t){i={error:t}}finally{try{_&&!_.done&&(l=F.return)&&l.call(F)}finally{if(i)throw i.error}}try{for(var D=ub(y),O=D.next();!O.done;O=D.next())T=O.value,I.push(t[T]),N.push(e[T])}catch(t){c={error:t}}finally{try{O&&!O.done&&(u=D.return)&&u.call(D)}finally{if(c)throw c.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}(h,S,x),N=I.trainXs,E=I.trainYs,C=I.valXs,T=I.valYs,A=pc(N).map((function(t){return ns(t,[a,c,1])})),R=pc(E).map((function(t){return oi(zo([t],r.length),[0])})),F=fc({xs:A,ys:R});v&&(F=F.shuffle(h.length)),F=F.batch(w).prefetch(4);var _=pc(C).map((function(t){return ns(t,[a,c,1])})),D=pc(T).map((function(t){return oi(zo([t],r.length),[0])})),O=fc({xs:_,ys:D});return[F,O=O.batch(w).prefetch(4)]}if(v){var z=[];u.forEach((function(t,e){z.push({x:t,y:d[e]})})),ee(z),u=z.map((function(t){return t.x})),d=z.map((function(t){return t.y}))}var L=null==t?Ga(zo(ci(d,"int32"),r.length),"float32"):void 0;return{xs:ii(u),ys:L}}))},t.prototype.augmentByMixingNoise=function(t,e,n){var r,a;if(null==t||0===t.length)throw new Error("Cannot perform augmentation because data is null or empty");for(var s=t[0]instanceof Float32Array,o=this.getVocabulary(),i=[],l=[],c=0;c<e.length;++c)o[e[c]]===Cb?i.push(c):l.push(c);if(0===i.length)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+Cb);var u=[],h=[],d=function(r){var a=i[function(t,e){return Math.floor((e-t)*Math.random())+t}(0,i.length)],o=s?ci(t[r]):t[r],l=s?ci(t[a]):t[a],c=cs((function(){return gb(bs(o,mo(l,n)))}));s?u.push(c.dataSync()):u.push(c),h.push(e[r])};try{for(var p=ub(l),f=p.next();!f.done;f=p.next())d(f.value)}catch(t){r={error:t}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(r)throw r.error}}console.log("Data augmentation: mixing noise: added "+u.length+" examples"),u.forEach((function(e){return t.push(e)})),e.push.apply(e,db(h))},t.prototype.getSortedUniqueNumFrames=function(){for(var t,e,n=new Set,r=this.getVocabulary(),a=0;a<r.length;++a){var s=r[a],o=this.label2Ids[s];try{for(var i=(t=void 0,ub(o)),l=i.next();!l.done;l=i.next()){var c=l.value,u=this.examples[c].spectrogram,h=u.data.length/u.frameSize;n.add(h)}}catch(e){t={error:e}}finally{try{l&&!l.done&&(e=i.return)&&e.call(i)}finally{if(t)throw t.error}}}var d=db(n);return d.sort(),d},t.prototype.removeExample=function(t){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var e=this.examples[t].label;delete this.examples[t];var n=this.label2Ids[e].indexOf(t);this.label2Ids[e].splice(n,1),0===this.label2Ids[e].length&&delete this.label2Ids[e]},t.prototype.setExampleKeyFrameIndex=function(t,e){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var n=this.examples[t].spectrogram,r=n.data.length/n.frameSize;re(e>=0&&e<r&&Number.isInteger(e),(function(){return"Invalid keyFrameIndex: "+e+". Must be >= 0, < "+r+", and an integer."})),n.keyFrameIndex=e},t.prototype.size=function(){return Object.keys(this.examples).length},t.prototype.durationMillis=function(){var t=0;for(var e in this.examples){var n=this.examples[e].spectrogram,r=23.22|n.frameDurationMillis;t+=n.data.length/n.frameSize*r}return t},t.prototype.empty=function(){return 0===this.size()},t.prototype.clear=function(){this.examples={}},t.prototype.getVocabulary=function(){var t=new Set;for(var e in this.examples){var n=this.examples[e];t.add(n.label)}var r=db(t);return r.sort(),r},t.prototype.serialize=function(t){var e,n,r,a,s=this.getVocabulary();re(!this.empty(),(function(){return"Cannot serialize empty Dataset"})),null!=t&&(Array.isArray(t)||(t=[t]),t.forEach((function(t){if(-1===s.indexOf(t))throw new Error('Word label "'+t+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(s)+".")})));var o=[],i=[];try{for(var l=ub(s),c=l.next();!c.done;c=l.next()){var u=c.value;if(null==t||-1!==t.indexOf(u)){var h=this.label2Ids[u];try{for(var d=(r=void 0,ub(h)),p=d.next();!p.done;p=d.next()){var f=p.value,g=Ab(this.examples[f]);o.push(g.spec),i.push(g.data)}}catch(t){r={error:t}}finally{try{p&&!p.done&&(a=d.return)&&a.call(d)}finally{if(r)throw r.error}}}}}catch(t){e={error:t}}finally{try{c&&!c.done&&(n=l.return)&&n.call(l)}finally{if(e)throw e.error}}return function(t){var e=Ib(JSON.stringify(t.manifest)),n=Ib(Eb),r=new Uint32Array([1]),a=new Uint32Array([e.byteLength]);return kb([kb([n,r.buffer,a.buffer]),e,t.data])}({manifest:o,data:kb(i)})},t}();function Ab(t){var e=null!=t.rawAudio,n={label:t.label,spectrogramNumFrames:t.spectrogram.data.length/t.spectrogram.frameSize,spectrogramFrameSize:t.spectrogram.frameSize};null!=t.spectrogram.keyFrameIndex&&(n.spectrogramKeyFrameIndex=t.spectrogram.keyFrameIndex);var r=t.spectrogram.data.buffer.slice(0);return e&&(n.rawAudioNumSamples=t.rawAudio.data.length,n.rawAudioSampleRateHz=t.rawAudio.sampleRateHz,r=kb([r,t.rawAudio.data.buffer])),{spec:n,data:r}}function Rb(t){var e={frameSize:t.spec.spectrogramFrameSize,data:new Float32Array(t.data.slice(0,4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))};null!=t.spec.spectrogramKeyFrameIndex&&(e.keyFrameIndex=t.spec.spectrogramKeyFrameIndex);var n={label:t.spec.label,spectrogram:e};return null!=t.spec.rawAudioNumSamples&&(n.rawAudio={sampleRateHz:t.spec.rawAudioSampleRateHz,data:new Float32Array(t.data.slice(4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))}),n}function Fb(t,e,n,r){if(re(Number.isInteger(t)&&t>0,(function(){return"snippetLength must be a positive integer, but got "+t})),null!=e&&re(Number.isInteger(e)&&e>=0,(function(){return"focusIndex must be a non-negative integer, but got "+e})),re(Number.isInteger(n)&&n>0,(function(){return"windowLength must be a positive integer, but got "+n})),re(Number.isInteger(r)&&r>0,(function(){return"windowHop must be a positive integer, but got "+r})),re(n<=t,(function(){return"windowLength ("+n+") exceeds snippetLength ("+t+")"})),re(e<t,(function(){return"focusIndex ("+e+") equals or exceeds snippetLength ("+t+")"})),n===t)return[[0,t]];var a=[];if(null==e){for(var s=0;s+n<=t;)a.push([s,s+n]),s+=r;return a}var o=Math.floor(n/2),i=e-o;for(i<0?i=0:i+n>t&&(i=t-n);!(i-r<0||e>=i-r+n);)i-=r;for(;i+n<=t&&!(e<i);)a.push([i,i+n]),i+=r;return a}function _b(t){return cs((function(){return ws(function(t){return cs((function(){var e=t.data.length/t.frameSize,n=ui(t.data,[e,t.frameSize]);return No(n,-1)}))}(t))}))}var Db="0.5.4",Ob="tfjs-speech-commands-saved-model-metadata",zb="indexeddb://tfjs-speech-commands-model/",Lb={localStorage:"undefined"==typeof window?null:window.localStorage};var Mb=.25,Pb=function(){function t(e,n,r){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+function(t){return t.split(".").slice(0,2).join(".")}(Db)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},re(null==n&&null==r||null!=n&&null!=r,(function(){return"modelURL and metadataURL must be both provided or both not provided."})),null==n?(null==e?e=t.DEFAULT_VOCABULARY_NAME:re(-1!==t.VALID_VOCABULARY_NAMES.indexOf(e),(function(){return"Invalid vocabulary name: '"+e+"'"})),this.vocabulary=e,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(re(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided"})),this.modelArtifactsOrURL=n,this.metadataOrURL=r),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return t.prototype.listen=function(t,e){return lb(this,void 0,void 0,(function(){var n,r,a,s,o,i=this;return cb(this,(function(l){switch(l.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(l.sent(),null==e&&(e={}),n=null==e.probabilityThreshold?0:e.probabilityThreshold,e.includeEmbedding&&(n=0),re(n>=0&&n<=1,(function(){return"Invalid probabilityThreshold value: "+n})),r=null!=e.invokeCallbackOnNoiseAndUnknown&&e.invokeCallbackOnNoiseAndUnknown,e.includeEmbedding&&(r=!0),e.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+e.suppressionTimeMillis);return re((a=null==e.overlapFactor?.5:e.overlapFactor)>=0&&a<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+a})),s=function(a,s){return lb(i,void 0,void 0,(function(){var s,o,i,l,c,u,h,d,p,f,g;return cb(this,(function(m){switch(m.label){case 0:return s=gb(a),e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return m.sent(),g=hb(this.modelWithEmbeddingOutput.predict(s),2),o=g[0],i=g[1],[3,3];case 2:o=this.model.predict(s),m.label=3;case 3:return[4,o.data()];case 4:return l=m.sent(),[4,(c=o.argMax(-1)).data()];case 5:return u=m.sent()[0],h=Math.max.apply(Math,db(l)),us([o,c,s]),h<n?[2,!1]:[3,6];case 6:return d=void 0,e.includeSpectrogram?(p={},[4,a.data()]):[3,8];case 7:p.data=m.sent(),p.frameSize=this.nonBatchInputShape[1],d=p,m.label=8;case 8:return f=!0,r||this.words[u]!==Cb&&"_unknown_"!==this.words[u]||(f=!1),f&&t({scores:l,spectrogram:d,embedding:i}),[2,f]}}))}))},o=null==e.suppressionTimeMillis?this.DEFAULT_SUPPRESSION_TIME_MILLIS:e.suppressionTimeMillis,this.audioDataExtractor=new yb({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:o,spectrogramCallback:s,overlapFactor:a}),[4,this.audioDataExtractor.start(e.audioTrackConstraints)];case 2:return l.sent(),this.streaming=!0,[2]}}))}))},t.prototype.ensureModelLoaded=function(){return lb(this,void 0,void 0,(function(){var t,e,n,r,a=this;return cb(this,(function(s){switch(s.label){case 0:return null!=this.model?[2]:[4,this.ensureMetadataLoaded()];case 1:return s.sent(),"string"!=typeof this.modelArtifactsOrURL?[3,3]:[4,Qf(this.modelArtifactsOrURL)];case 2:return t=s.sent(),[3,5];case 3:return[4,Qf(es(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:t=s.sent(),s.label=5;case 5:if(1!==t.inputs.length)throw new Error("Expected model to have 1 input, but got a model with "+t.inputs.length+" inputs");if(4!==t.inputs[0].shape.length)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+t.inputs[0].shape.length);if(1!==t.inputs[0].shape[3])throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(t.inputs[0].shape[3])+"}");if(2!==(e=t.outputShape).length)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(e));if(e[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+e[1]+") and number of words ("+this.words.length+").");return this.model=t,this.freezeModel(),this.nonBatchInputShape=t.inputs[0].shape.slice(1),this.elementsPerExample=1,t.inputs[0].shape.slice(1).forEach((function(t){return a.elementsPerExample*=t})),this.warmUpModel(),n=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,r=t.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=r*n,[2]}}))}))},t.prototype.ensureModelWithEmbeddingOutputCreated=function(){return lb(this,void 0,void 0,(function(){var t,e;return cb(this,(function(n){switch(n.label){case 0:return null!=this.modelWithEmbeddingOutput?[2]:[4,this.ensureModelLoaded()];case 1:for(n.sent(),e=this.model.layers.length-2;e>=0;--e)if("Dense"===this.model.layers[e].getClassName()){t=this.model.layers[e];break}if(null==t)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=Zf({inputs:this.model.inputs,outputs:[this.model.outputs[0],t.output]}),[2]}}))}))},t.prototype.warmUpModel=function(){var t=this;cs((function(){for(var e=Lo([1].concat(t.nonBatchInputShape)),n=0;n<3;++n)t.model.predict(e)}))},t.prototype.ensureMetadataLoaded=function(){return lb(this,void 0,void 0,(function(){var t,e,n;return cb(this,(function(r){switch(r.label){case 0:return null!=this.words?[2]:"string"!=typeof this.metadataOrURL?[3,2]:[4,pb(this.metadataOrURL)];case 1:return e=r.sent(),[3,3];case 2:e=this.metadataOrURL,r.label=3;case 3:if(null==(t=e).wordLabels){if(null==(n=t.words))throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=n}else this.words=t.wordLabels;return[2]}}))}))},t.prototype.stopListening=function(){return lb(this,void 0,void 0,(function(){return cb(this,(function(t){switch(t.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return t.sent(),this.streaming=!1,[2]}}))}))},t.prototype.isListening=function(){return this.streaming},t.prototype.wordLabels=function(){return this.words},t.prototype.params=function(){return this.parameters},t.prototype.modelInputShape=function(){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},t.prototype.recognize=function(t,e){return lb(this,void 0,void 0,(function(){var n,r,a,s,o,i,l,c,u,h,d,p,f;return cb(this,(function(g){switch(g.label){case 0:return null==e&&(e={}),[4,this.ensureModelLoaded()];case 1:return g.sent(),null!=t?[3,3]:[4,this.recognizeOnline()];case 2:n=g.sent(),t=n.data,g.label=3;case 3:if(t instanceof Er)this.checkInputTensorShape(t),a=t,r=t.shape[0];else{if(t.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+t.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");r=t.length/this.elementsPerExample,a=function(t,e,n){if(se(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Kr(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return $r(t,e,r,n)}(t,[r].concat(this.nonBatchInputShape))}return o={scores:null},e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return g.sent(),i=this.modelWithEmbeddingOutput.predict(a),s=i[0],o.embedding=i[1],[3,6];case 5:s=this.model.predict(a),g.label=6;case 6:return 1!==r?[3,8]:(l=o,[4,s.data()]);case 7:return l.scores=g.sent(),[3,10];case 8:return c=di(s),u=c.map((function(t){return t.data()})),h=o,[4,Promise.all(u)];case 9:h.scores=g.sent(),us(c),g.label=10;case 10:return e.includeSpectrogram?(d=o,p={},t instanceof Er?[4,t.data()]:[3,12]):[3,14];case 11:return f=g.sent(),[3,13];case 12:f=t,g.label=13;case 13:d.spectrogram=(p.data=f,p.frameSize=this.nonBatchInputShape[1],p),g.label=14;case 14:return us(s),[2,o]}}))}))},t.prototype.recognizeOnline=function(){return lb(this,void 0,void 0,(function(){var t=this;return cb(this,(function(e){return[2,new Promise((function(e,n){t.audioDataExtractor=new yb({sampleRateHz:t.parameters.sampleRateHz,numFramesPerSpectrogram:t.nonBatchInputShape[0],columnTruncateLength:t.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n){return lb(t,void 0,void 0,(function(){var t,r,a;return cb(this,(function(s){switch(s.label){case 0:return t=gb(n),[4,this.audioDataExtractor.stop()];case 1:return s.sent(),r=e,a={},[4,t.data()];case 2:return r.apply(void 0,[(a.data=s.sent(),a.frameSize=this.nonBatchInputShape[1],a)]),t.dispose(),[2,!1]}}))}))},overlapFactor:0}),t.audioDataExtractor.start()}))]}))}))},t.prototype.createTransfer=function(t){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");re(null!=t&&"string"==typeof t&&t.length>1,(function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(t)})),re(null==this.transferRecognizers[t],(function(){return"There is already a transfer-learning model named '"+t+"'"}));var e=new Bb(t,this.parameters,this.model);return this.transferRecognizers[t]=e,e},t.prototype.freezeModel=function(){var t,e;try{for(var n=ub(this.model.layers),r=n.next();!r.done;r=n.next())r.value.trainable=!1}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}},t.prototype.checkInputTensorShape=function(t){var e=this.model.inputs[0].shape.length;if(t.shape.length!==e)throw new Error("Expected input Tensor to have rank "+e+", but got rank "+t.shape.length+" that differs ");var n=t.shape.slice(1),r=this.model.inputs[0].shape.slice(1);if(!le(n,r))throw new Error("Expected input to have shape [null,"+r+"], but got shape [null,"+n+"]")},t.VALID_VOCABULARY_NAMES=["18w","directional4w"],t.DEFAULT_VOCABULARY_NAME="18w",t}(),Bb=function(t){function e(e,n,r){var a=t.call(this)||this;return a.name=e,a.parameters=n,a.baseModel=r,re(null!=e&&"string"==typeof e&&e.length>0,(function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(e)})),a.nonBatchInputShape=a.baseModel.inputs[0].shape.slice(1),a.words=null,a.dataset=new Tb,a}return function(t,e){function n(){this.constructor=t}ob(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}(e,t),e.prototype.collectExample=function(t,e){return lb(this,void 0,void 0,(function(){var n,r,a,s,o=this;return cb(this,(function(i){if(re(!this.streaming,(function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"})),re(null!=t&&"string"==typeof t&&t.length>0,(function(){return"Must provide a non-empty string when collecting transfer-learning example"})),null==e&&(e={}),null!=e.durationMultiplier&&null!=e.durationSec)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return null!=e.durationSec?(re(e.durationSec>0,(function(){return"Expected durationSec to be > 0, but got "+e.durationSec})),r=this.parameters.fftSize/this.parameters.sampleRateHz,n=Math.ceil(e.durationSec/r)):null!=e.durationMultiplier?(re(e.durationMultiplier>=1,(function(){return"Expected duration multiplier to be >= 1, but got "+e.durationMultiplier})),n=Math.round(this.nonBatchInputShape[0]*e.durationMultiplier)):n=this.nonBatchInputShape[0],null!=e.snippetDurationSec&&(re(e.snippetDurationSec>0,(function(){return"snippetDurationSec is expected to be > 0, but got "+e.snippetDurationSec})),re(null!=e.onSnippet,(function(){return"onSnippet must be provided if snippetDurationSec is provided."}))),null!=e.onSnippet&&re(null!=e.snippetDurationSec,(function(){return"snippetDurationSec must be provided if onSnippet is provided."})),a=this.parameters.fftSize/this.parameters.sampleRateHz,s=a*n,this.streaming=!0,[2,new Promise((function(r){var a=null==e.snippetDurationSec?1:e.snippetDurationSec/s,i=1-a,l=Math.round(1/a),c=0,u=-1,h=[];o.audioDataExtractor=new yb({sampleRateHz:o.parameters.sampleRateHz,numFramesPerSpectrogram:n,columnTruncateLength:o.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n,a){return lb(o,void 0,void 0,(function(){var s,o,i,d,p,f,g,m,b,y,v,w,x,k,S,I,N,E,C,T;return cb(this,(function(A){switch(A.label){case 0:return null!=e.onSnippet?[3,7]:(s=gb(n),i=(o=this.dataset).addExample,d={label:t},p={},[4,s.data()]);case 1:return d.spectrogram=(p.data=A.sent(),p.frameSize=this.nonBatchInputShape[1],p),e.includeRawAudio?(g={},[4,a.data()]):[3,3];case 2:return g.data=A.sent(),g.sampleRateHz=this.audioDataExtractor.sampleRateHz,f=g,[3,4];case 3:f=void 0,A.label=4;case 4:return i.apply(o,[(d.rawAudio=f,d)]),s.dispose(),[4,this.audioDataExtractor.stop()];case 5:return A.sent(),this.streaming=!1,this.collateTransferWords(),m=r,b={},[4,n.data()];case 6:return m.apply(void 0,[(b.data=A.sent(),b.frameSize=this.nonBatchInputShape[1],b)]),[3,13];case 7:return[4,n.data()];case 8:for(y=A.sent(),-1===u&&(u=y.length),v=u-1;0!==y[v]&&v>=0;)v--;return w=u-v-1,u=v+1,x=y.slice(y.length-w,y.length),h.push(x),null!=e.onSnippet&&e.onSnippet({data:x,frameSize:this.nonBatchInputShape[1]}),c++!==l?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return A.sent(),this.streaming=!1,this.collateTransferWords(),k=mb(Sb(h)),S={data:k,frameSize:this.nonBatchInputShape[1]},N=(I=this.dataset).addExample,E={label:t,spectrogram:S},e.includeRawAudio?(T={},[4,a.data()]):[3,11];case 10:return T.data=A.sent(),T.sampleRateHz=this.audioDataExtractor.sampleRateHz,C=T,[3,12];case 11:C=void 0,A.label=12;case 12:N.apply(I,[(E.rawAudio=C,E)]),r(S),A.label=13;case 13:return[2,!1]}}))}))},overlapFactor:i,includeRawAudio:e.includeRawAudio}),o.audioDataExtractor.start(e.audioTrackConstraints)}))]}))}))},e.prototype.clearExamples=function(){var t=this;re(null!=this.words&&this.words.length>0&&!this.dataset.empty(),(function(){return"No transfer learning examples exist for model name "+t.name})),this.dataset.clear(),this.words=null},e.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},e.prototype.getExamples=function(t){return this.dataset.getExamples(t)},e.prototype.setExampleKeyFrameIndex=function(t,e){this.dataset.setExampleKeyFrameIndex(t,e)},e.prototype.removeExample=function(t){this.dataset.removeExample(t),this.collateTransferWords()},e.prototype.isDatasetEmpty=function(){return this.dataset.empty()},e.prototype.loadExamples=function(t,e){var n,r,a,s;void 0===e&&(e=!1);var o=new Tb(t);e&&this.clearExamples();var i=o.getVocabulary();try{for(var l=ub(i),c=l.next();!c.done;c=l.next()){var u=c.value,h=o.getExamples(u);try{for(var d=(a=void 0,ub(h)),p=d.next();!p.done;p=d.next()){var f=p.value;this.dataset.addExample(f.example)}}catch(t){a={error:t}}finally{try{p&&!p.done&&(s=d.return)&&s.call(d)}finally{if(a)throw a.error}}}}catch(t){n={error:t}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}this.collateTransferWords()},e.prototype.serializeExamples=function(t){return this.dataset.serialize(t)},e.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},e.prototype.collectTransferDataAsTensors=function(t,e){var n=this.nonBatchInputShape[0];t=t||Mb;var r=Math.round(t*n),a=this.dataset.getData(null,ib({numFrames:n,hopFrames:r},e));return{xs:a.xs,ys:a.ys}},e.prototype.collectTransferDataAsTfDataset=function(t,e,n,r){void 0===e&&(e=.15),void 0===n&&(n=32);var a=this.nonBatchInputShape[0];t=t||Mb;var s=Math.round(t*a);return this.dataset.getData(null,ib({numFrames:a,hopFrames:s,getDataset:!0,datasetBatchSize:n,datasetValidationSplit:e},r))},e.prototype.train=function(t){return lb(this,void 0,void 0,(function(){var e,n=this;return cb(this,(function(r){return re(null!=this.words&&this.words.length>0,(function(){return"Cannot train transfer-learning model '"+n.name+"' because no transfer learning example has been collected."})),re(this.words.length>1,(function(){return"Cannot train transfer-learning model '"+n.name+"' because only 1 word label ('"+JSON.stringify(n.words)+"') has been collected for transfer learning. Requires at least 2."})),null!=t.fineTuningEpochs&&re(t.fineTuningEpochs>=0&&Number.isInteger(t.fineTuningEpochs),(function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+t.fineTuningEpochs})),null==t&&(t={}),null==this.model&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:t.optimizer||"sgd",metrics:["acc"]}),e=null==t.fitDatasetDurationMillisThreshold?6e4:t.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>e?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+e+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(t)]):[2,this.trainOnTensors(t)]}))}))},e.prototype.trainOnDataset=function(t){return lb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c;return cb(this,(function(u){switch(u.label){case 0:return re(t.epochs>0,(function(){return"Invalid config.epochs"})),e=null==t.batchSize?32:t.batchSize,n=t.windowHopRatio||Mb,r=hb(this.collectTransferDataAsTfDataset(n,t.validationSplit,e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),2),a=r[0],s=r[1],o=lr(),[4,this.model.fitDataset(a,{epochs:t.epochs,validationData:t.validationSplit>0?s:null,callbacks:null==t.callback?null:[t.callback]})];case 1:return i=u.sent(),console.log("fitDataset() took "+(lr()-o).toFixed(2)+" ms"),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?(l=lr(),[4,this.fineTuningUsingTfDatasets(t,a,s)]):[3,3];case 2:return c=u.sent(),console.log("fitDataset() (fine-tuning) took "+(lr()-l).toFixed(2)+" ms"),[2,[i,c]];case 3:return[2,i]}}))}))},e.prototype.trainOnTensors=function(t){return lb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c,u;return cb(this,(function(h){switch(h.label){case 0:e=t.windowHopRatio||Mb,n=this.collectTransferDataAsTensors(e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),r=n.xs,a=n.ys,console.log("Training data: xs.shape = "+r.shape+", ys.shape = "+a.shape),h.label=1;case 1:return h.trys.push([1,,6,7]),null!=t.validationSplit?(l=function(t,e,n){return re(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n})),cs((function(){for(var r=ws(e,-1).dataSync(),a=[],s=0;s<r.length;++s){var o=r[s];null==a[o]&&(a[o]=[]),a[o].push(s)}var i=a.length,l=[],c=[];for(a.map((function(t){return ee(t)})),s=0;s<i;++s)for(var u=a[s],h=Math.round(u.length*(1-n)),d=0;d<u.length;++d)d<h?l.push(u[d]):c.push(u[d]);return{trainXs:lo(t,l),trainYs:lo(e,l),valXs:lo(t,c),valYs:lo(e,c)}}))}(r,a,t.validationSplit),s=l.trainXs,o=l.trainYs,i=[l.valXs,l.valYs]):(s=r,o=a),[4,this.model.fit(s,o,{epochs:null==t.epochs?20:t.epochs,validationData:i,batchSize:t.batchSize,callbacks:null==t.callback?null:[t.callback]})];case 2:return c=h.sent(),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(t,s,o,i)]:[3,4];case 3:return u=h.sent(),[2,[c,u]];case 4:return[2,c];case 5:return[3,7];case 6:return us([r,a,s,o,i]),[7];case 7:return[2]}}))}))},e.prototype.fineTuningUsingTfDatasets=function(t,e,n){return lb(this,void 0,void 0,(function(){var r,a,s;return cb(this,(function(o){switch(o.label){case 0:return r=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,a=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:a,metrics:["acc"]}),[4,this.model.fitDataset(e,{epochs:t.fineTuningEpochs,validationData:n,callbacks:null==t.callback?null:[t.callback]})];case 1:return s=o.sent(),this.secondLastBaseDenseLayer.trainable=r,[2,s]}}))}))},e.prototype.fineTuningUsingTensors=function(t,e,n,r){return lb(this,void 0,void 0,(function(){var a,s,o;return cb(this,(function(i){switch(i.label){case 0:return a=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,s=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:s,metrics:["acc"]}),[4,this.model.fit(e,n,{epochs:t.fineTuningEpochs,validationData:r,batchSize:t.batchSize,callbacks:null==t.fineTuningCallback?null:[t.fineTuningCallback]})];case 1:return o=i.sent(),this.secondLastBaseDenseLayer.trainable=a,[2,o]}}))}))},e.prototype.evaluate=function(t){return lb(this,void 0,void 0,(function(){var e=this;return cb(this,(function(n){return re(null!=t.wordProbThresholds&&t.wordProbThresholds.length>0,(function(){return"Received null or empty wordProbThresholds"})),0,re(this.words[0]===Cb,(function(){return"Cannot perform evaluation when the first tag is not "+Cb})),[2,cs((function(){for(var n=[],r=0,a=e.collectTransferDataAsTensors(t.windowHopRatio),s=a.xs,o=a.ys.argMax(-1).dataSync(),i=e.model.predict(s),l=go(Zo(i,[0,1],[i.shape[0],i.shape[1]-1]),-1),c=i.shape[0],u=0;u<t.wordProbThresholds.length;++u){for(var h=t.wordProbThresholds[u],d=l.greater(fs(h)).dataSync(),p=0,f=0,g=0,m=0,b=0;b<c;++b)0===o[b]?(p++,d[b]&&g++):(f++,d[b]&&m++);var y=g/p,v=m/f;n.push({probThreshold:h,fpr:y,tpr:v}),console.log("ROC thresh="+h+": fpr="+y.toFixed(4)+", tpr="+v.toFixed(4)),u>0&&(r+=Math.abs(n[u-1].fpr-n[u].fpr)*(n[u-1].tpr+n[u].tpr)/2)}return{rocCurve:n,auc:r}}))]}))}))},e.prototype.createTransferModelFromBaseModel=function(){var t=this;re(null!=this.words,(function(){return"No word example is available for tranfer-learning model of name "+t.name}));for(var e=this.baseModel.layers,n=e.length-2;n>=0&&"dense"!==e[n].getClassName().toLowerCase();)n--;if(n<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=e[n];var r,a,s=this.secondLastBaseDenseLayer.output;this.transferHead=new Yf(a),this.transferHead.add((r={units:this.words.length,activation:"softmax",inputShape:s.shape.slice(1),name:"NewHeadDense"},new fm(r)));var o=this.transferHead.apply(s);this.model=Zf({inputs:this.baseModel.inputs,outputs:o})},e.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},e.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:Db,modelName:this.name,timeStamp:(new Date).toISOString(),wordLabels:this.wordLabels()}},e.prototype.save=function(t){return lb(this,void 0,void 0,(function(){var e,n,r;return cb(this,(function(a){return e=null!=t,t=t||Wb(this.name),e||(n=Lb.localStorage.getItem(Ob),(r=null==n?{}:JSON.parse(n))[this.name]=this.getMetadata(),Lb.localStorage.setItem(Ob,JSON.stringify(r))),console.log("Saving model to "+t),[2,this.model.save(t)]}))}))},e.prototype.load=function(t){return lb(this,void 0,void 0,(function(){var e,n,r;return cb(this,(function(a){switch(a.label){case 0:if(e=null!=t,t=t||Wb(this.name),!e){if(null==(n=JSON.parse(Lb.localStorage.getItem(Ob)))||null==n[this.name])throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=n[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return r=this,[4,Qf(t)];case 1:return r.model=a.sent(),console.log("Loaded model from "+t+":"),this.model.summary(),[2]}}))}))},e.prototype.createTransfer=function(t){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},e}(Pb);function Wb(t){return""+zb+t}class Ub{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Vb{refCount(t){return Gb("refCount")}incRef(t){return Gb("incRef")}timerAvailable(){return!0}time(t){return Gb("time")}read(t){return Gb("read")}readSync(t){return Gb("readSync")}readToGPU(t,e){return Gb("readToGPU")}numDataIds(){return Gb("numDataIds")}disposeData(t,e){return Gb("disposeData")}write(t,e,n){return Gb("write")}move(t,e,n,r,a){return Gb("move")}createTensorFromGPUData(t,e,n){return Gb("createTensorFromGPUData")}memory(){return Gb("memory")}floatPrecision(){return Gb("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Gb("dispose")}}function Gb(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function jb(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,qb(t,e,n)}function Hb(t,e,n){return Math.max(t,Math.min(e,n))}function Kb(t){return t%2===0?t:t+1}function qb(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Xb(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function Jb(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Xb(Qb(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function Yb(t){Xb(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function Zb(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function Qb(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function $b(t){return t%1===0}function ty(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function ey(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function ny(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let o=0;const i=()=>{if(t())return void a();o++;const l=e(o);null!=n&&o>=n?s():null!=r?r(i,l):setTimeout(i,l)};i()}))}function ry(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(-1===t[s]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(r," and dim ").concat(s));r=s}else if(t[s]<0)throw Error("Shapes can not be < 0. Found ".concat(t[s]," at dim ").concat(s));if(-1===r){if(e>0&&e!==n)throw Error("Size(".concat(e,") must match the product of shape ").concat(t));return t}if(0===n)throw Error("Cannot infer the missing size in [".concat(t,"] when ")+"there are 0 elements");if(e%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(e," / ").concat(n));const a=t.slice();return a[r]=e/n,a}function ay(t,e){const n=e.length;return Xb((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),Xb(t.every((t=>$b(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function sy(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:ay(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function oy(t,e){return iy(t,e)}function iy(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}function ly(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function cy(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function uy(t){return"string"===typeof t||t instanceof String}function hy(t){return"number"===typeof t}function dy(t){return Array.isArray(t)?dy(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":hy(t)?"float32":uy(t)?"string":"boolean"===typeof t?"bool":"float32"}function py(t){return!!(t&&t.constructor&&t.call&&t.apply)}function fy(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function gy(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function my(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=my(t+e*i,o,n,r)}return a}function by(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return my(0,t,e,n)}function yy(t,e){const n=vy(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function vy(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function wy(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return by(t,new Float32Array(n));if("int32"===e)return by(t,new Int32Array(n));if("bool"===e)return by(t,new Uint8Array(n));throw new Error("Unknown data type ".concat(e))}function xy(t){t.forEach((e=>{Xb(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function ky(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let a=0;a<t.length-1;++a)r+=n[a]*t[a];return r}function Sy(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(t/n[a]),t-=r[a]*n[a];return r[r.length-1]=t,r}function Iy(t){return t&&t.then&&"function"===typeof t.then}const Ny="tfjsflags";class Ey{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Cy,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ty().getBool("IS_TEST")||Ty().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Ty().getBool("IS_TEST")||Ty().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Iy(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Ny in t){t[Ny].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){const n=e.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:e}(0,n)}))}}}function Cy(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Ty(){return Ry}let Ay,Ry=null;function Fy(){if(null==Ay){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Ay=t}return Ay}function _y(t,e){const n=function(){const t=Fy();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Dy="Abs",Oy="Acos",zy="Acosh",Ly="Add",My="AddN",Py="All",By="Any",Wy="ArgMax",Uy="ArgMin",Vy="Asin",Gy="Asinh",jy="Atan",Hy="Atanh",Ky="Atan2",qy="AvgPool",Xy="AvgPoolGrad",Jy="AvgPool3D",Yy="AvgPool3DGrad",Zy="BatchMatMul",Qy="BatchToSpaceND",$y="Bincount",tv="BitwiseAnd",ev="BroadcastArgs",nv="Cast",rv="Ceil",av="ClipByValue",sv="Complex",ov="ComplexAbs",iv="Concat",lv="Conv2D",cv="Conv2DBackpropFilter",uv="Conv2DBackpropInput",hv="Conv3D",dv="Conv3DBackpropFilterV2",pv="Conv3DBackpropInputV2",fv="Cos",gv="Cosh",mv="Cumprod",bv="Cumsum",yv="CropAndResize",vv="DenseBincount",wv="DepthToSpace",xv="DepthwiseConv2dNative",kv="DepthwiseConv2dNativeBackpropFilter",Sv="DepthwiseConv2dNativeBackpropInput",Iv="Diag",Nv="Dilation2D",Ev="Dilation2DBackpropInput",Cv="Dilation2DBackpropFilter",Tv="Draw",Av="RealDiv",Rv="Einsum",Fv="Elu",_v="EluGrad",Dv="Erf",Ov="Equal",zv="Exp",Lv="ExpandDims",Mv="Expm1",Pv="FFT",Bv="Fill",Wv="FlipLeftRight",Uv="Floor",Vv="FloorDiv",Gv="FusedBatchNorm",jv="GatherV2",Hv="GatherNd",Kv="Greater",qv="GreaterEqual",Xv="Identity",Jv="IFFT",Yv="Imag",Zv="IsFinite",Qv="IsInf",$v="IsNan",tw="LeakyRelu",ew="Less",nw="LessEqual",rw="LinSpace",aw="Log",sw="Log1p",ow="LogicalAnd",iw="LogicalNot",lw="LogicalOr",cw="LRN",uw="LRNGrad",hw="Max",dw="Maximum",pw="MaxPool",fw="MaxPoolGrad",gw="MaxPool3D",mw="MaxPool3DGrad",bw="MaxPoolWithArgmax",yw="Mean",vw="Min",ww="Minimum",xw="MirrorPad",kw="Mod",Sw="Multinomial",Iw="Multiply",Nw="Neg",Ew="NotEqual",Cw="NonMaxSuppressionV3",Tw="NonMaxSuppressionV4",Aw="NonMaxSuppressionV5",Rw="OnesLike",Fw="OneHot",_w="Pack",Dw="PadV2",Ow="Pow",zw="Prelu",Lw="Prod",Mw="RaggedGather",Pw="RaggedRange",Bw="RaggedTensorToTensor",Ww="Range",Uw="Real",Vw="Reciprocal",Gw="Relu",jw="Reshape",Hw="ResizeNearestNeighbor",Kw="ResizeNearestNeighborGrad",qw="ResizeBilinear",Xw="ResizeBilinearGrad",Jw="Relu6",Yw="Reverse",Zw="Round",Qw="Rsqrt",$w="ScatterNd",tx="TensorScatterUpdate",ex="SearchSorted",nx="Select",rx="Selu",ax="Slice",sx="Sin",ox="Sinh",ix="Sign",lx="Sigmoid",cx="Softplus",ux="Sqrt",hx="Sum",dx="SpaceToBatchND",px="SplitV",fx="Softmax",gx="SparseFillEmptyRows",mx="SparseReshape",bx="SparseSegmentMean",yx="SparseSegmentSum",vx="SparseToDense",wx="SquaredDifference",xx="Square",kx="StaticRegexReplace",Sx="StridedSlice",Ix="StringNGrams",Nx="StringSplit",Ex="StringToHashBucketFast",Cx="Sub",Tx="Tan",Ax="Tanh",Rx="Tile",Fx="TopK",_x="Transform",Dx="Transpose",Ox="Unique",zx="Unpack",Lx="UnsortedSegmentSum",Mx="ZerosLike",Px="Step",Bx="FromPixels",Wx="RotateWithOffset",Ux="_FusedMatMul",Vx="FusedConv2D",Gx="FusedDepthwiseConv2D";function jx(){Ty().getBool("IS_TEST")||Ty().getBool("PROD")||console.warn(...arguments)}function Hx(){Ty().getBool("IS_TEST")||Ty().getBool("PROD")||console.log(...arguments)}const Kx=_y("kernelRegistry",(()=>new Map)),qx=_y("gradRegistry",(()=>new Map));function Xx(t,e){const n=$x(t,e);return Kx.get(n)}function Jx(t){return qx.get(t)}function Yx(t){const e=Kx.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function Zx(t){const{kernelName:e,backendName:n}=t,r=$x(e,n);Kx.has(r)&&jx("The kernel '".concat(e,"' for backend ")+"'".concat(n,"' is already registered")),Kx.set(r,t)}function Qx(t){const{kernelName:e}=t;qx.has(e)&&Ty().getBool("DEBUG")&&jx("Overriding the gradient for '".concat(e,"'")),qx.set(e,t)}function $x(t,e){return"".concat(e,"_").concat(t)}function tk(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}const ek=ar()||rr;function nk(t){return ek.fromString(t,!0,16)}const rk=nk("c3a5c85c97cb3127"),ak=nk("b492b66fbe98f273"),sk=nk("9ae16a3b2f90404f");function ok(t){return t.xor(t.shru(47))}function ik(t,e,n){const r=t.slice(e,e+n);return ek.fromBytes(Array.from(r),!0,!0)}function lk(t,e){return ik(t,e,8)}function ck(t,e){return ik(t,e,4)}function uk(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function hk(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:nk("9ddfea08eb382d69"),r=t.xor(e).mul(n);r=r.xor(r.shru(47));let a=e.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function dk(t,e,n,r){return function(t,e,n,r,a,s){a=a.add(t),s=uk(s.add(a).add(r),21);const o=a;return a=(a=a.add(e)).add(n),s=s.add(uk(a,44)),[a.add(r),s.add(o)]}(lk(t,e),lk(t,e+8),lk(t,e+16),lk(t,e+24),n,r)}function pk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=ek.fromNumber(81,!0);if(e<=32)return e<=16?function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;if(e>=8){const n=sk.add(2*e),r=lk(t,0).add(sk),a=lk(t,e-8);return hk(uk(a,37).mul(n).add(r),uk(r,25).add(a).mul(n),n)}if(e>=4){const n=sk.add(2*e);return hk(ck(t,0).shl(3).add(e),ck(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return ok(sk.mul(n).xor(rk.mul(r))).mul(sk)}return sk}(t,e):function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=sk.add(2*e),r=lk(t,0).mul(ak),a=lk(t,8),s=lk(t,e-8).mul(n),o=lk(t,e-16).mul(sk);return hk(uk(r.add(a),43).add(uk(s,30)).add(o),r.add(uk(a.add(sk),18)).add(s),n)}(t,e);if(e<=64)return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=sk.add(2*e),r=lk(t,0).mul(sk),a=lk(t,8),s=lk(t,e-8).mul(n),o=lk(t,e-16).mul(sk),i=uk(r.add(a),43).add(uk(s,30)).add(o),l=hk(i,r.add(uk(a.add(sk),18)).add(s),n),c=lk(t,16).mul(n),u=lk(t,24),h=i.add(lk(t,e-32)).mul(n),d=l.add(lk(t,e-24)).mul(n);return hk(uk(c.add(u),43).add(uk(h,30)).add(d),c.add(uk(u.add(r),18)).add(h),n)}(t,e);let r=n,a=n.mul(ak).add(113),s=ok(a.mul(sk).add(113)).mul(sk),o=[ek.UZERO,ek.UZERO],i=[ek.UZERO,ek.UZERO];r=r.mul(sk).add(lk(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{r=uk(r.add(a).add(o[0]).add(lk(t,l+8)),37).mul(ak),a=uk(a.add(o[1]).add(lk(t,l+48)),42).mul(ak),r=r.xor(i[1]),a=a.add(o[0]).add(lk(t,l+40)),s=uk(s.add(i[0]),33).mul(ak),o=dk(t,l,o[1].mul(ak),r.add(i[0])),i=dk(t,l+32,s.add(i[1]),a.add(lk(t,l+16))),[s,r]=[r,s],l+=64}while(l!==c);const h=ak.add(s.and(255).shl(1));return l=u,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=uk(r.add(a).add(o[0]).add(lk(t,l+8)),37).mul(h),a=uk(a.add(o[1]).add(lk(t,l+48)),42).mul(h),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(lk(t,l+40))),s=uk(s.add(i[0]),33).mul(h),o=dk(t,l,o[1].mul(h),r.add(i[0])),i=dk(t,l+32,s.add(i[1]),a.add(lk(t,l+16))),[s,r]=[r,s],hk(hk(o[0],i[0],h).add(ok(a).mul(rk)).add(s),hk(o[1],i[1],h).add(r),h)}function fk(t,e){return"string"===e?bk(t):gk([t],e)}function gk(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=wk(t)),Ty().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function mk(){return Ty().platform.now()}function bk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ty().platform.encode(t,e)}function yk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ty().platform.decode(t,e)}function vk(t){return null!=Ty().platform.isTypedArray?Ty().platform.isTypedArray(t):tk(t)}function wk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),"boolean"===typeof t||"number"===typeof t||"string"===typeof t||Iy(t)||null==t||vk(t)&&n)e.push(t);else if(Array.isArray(t)||vk(t))for(let r=0;r<t.length;++r)wk(t[r],e,n);else{let r=-1;for(const e of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(e)&&(r=Math.max(r,Number(e)));for(let a=0;a<=r;a++)wk(t[a],e,n)}return e}class xk{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Sk)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=mk();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:mk()-o})}if(Ty().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{kk(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function kk(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class Sk{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?ey("".concat(r,"ms"),9):r.error,i=ey(t,25),l=e.rank,c=e.size,u=ey(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Ik=20,Nk=3,Ek=7;function Ck(t,e,n,r){const a=gy(e),s=function(t,e,n,r){const a=Zb(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?Fk(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Tk(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=Rk(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function Tk(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(Ek))," + ")+"".concat(parseFloat(t[1].toFixed(Ek)),"j"):uy(t)?"'".concat(t,"'"):"bool"===n?Ak(t):parseFloat(t.toFixed(Ek)).toString(),ey(r,e)}function Ak(t){return 0===t?"false":"true"}function Rk(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[Tk(Fk(t)[0],0,n)]}return"bool"===n?[Ak(t[0])]:[t[0].toString()]}if(1===l){if(i>Ik){const e=Nk*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-Nk)*o,i*o));return"complex64"===n&&(r=Fk(r),s=Fk(s)),["["+r.map(((t,e)=>Tk(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>Tk(t,a[i-Nk+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Fk(t):Array.from(t)).map(((t,e)=>Tk(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>Ik){for(let e=0;e<Nk;e++){const r=e*h,s=r+h;d.push(...Rk(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-Nk;e<i;e++){const r=e*h,s=r+h;d.push(...Rk(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...Rk(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+(i>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function Fk(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class _k{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Zb(t),null!=n){const t=n.length;Xb(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||iy(e,this.size),this.strides=gy(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Xb(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Dk().makeTensor(this.values,this.shape,this.dtype)}}let Dk=null,Ok=null,zk=null;class Lk{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Zb(t),this.strides=gy(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Ok.buffer(this.shape,this.dtype,t)}bufferSync(){return Ok.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return by(this.shape,t,"complex64"===this.dtype)}arraySync(){return by(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Dk().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>yk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Dk().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Dk().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>yk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Dk().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Dk().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Ok.print(this,t)}clone(){return this.throwIfDisposed(),Ok.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Ck(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ok.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Dk().makeVariable(this,t,e,n)}}function Mk(){return _y("Tensor",(()=>Lk))}Object.defineProperty(Lk,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Mk();class Pk extends Lk{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!Qb(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Dk().disposeTensor(this),this.dataId=t.dataId,Dk().incRef(this,null)}dispose(){Dk().disposeVariable(this),this.isDisposedInternal=!0}}var Bk,Wk,Uk,Vk,Gk;Object.defineProperty(Pk,Symbol.hasInstance,{value:t=>t instanceof Lk&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Bk||(Bk={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Wk||(Wk={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Uk||(Uk={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Vk||(Vk={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Gk||(Gk={}));const jk={float32:Vk,int32:Wk,bool:Uk,complex64:Gk};function Hk(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return jk[t][e]}function Kk(t){return Hk(t,"int32")}function qk(t){return null!=t&&"object"===typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function Xk(t){return"undefined"!==typeof GPUBuffer&&null!=t&&"object"===typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function Jk(t,e){if(t.dtype===e.dtype)return[t,e];const n=Hk(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Yk(t,e){return e.some((e=>e.id===t.id))}function Zk(t){const e=[];return Qk(t,e,new Set),e}function Qk(t,e,n){if(null==t)return;if(t instanceof Lk)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),Qk(t,e,n))}}function $k(t){return null!=t.kernelName}class tS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class eS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new tS}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(jx("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new xk(this.backendInstance),!0}setupRegisteredKernels(){Yx(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Yx(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof Vb||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,jx("Initialization of backend ".concat(t," failed")),jx(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(i1){return jx("Initialization of backend ".concat(t," failed")),jx(i1.stack||i1.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return eS.nextTensorId++}nextVariableId(){return eS.nextVariableId++}clone(t){const e=rS.runKernel(Xv,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return rS.runKernel(nv,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=Xx(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=$k(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if($k(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=Xx(e,this.backendName);Xb(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=$k(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=Jx(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Xb(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&uy(t[0])&&(a=t.map((t=>bk(t))));const s=r.write(a,e,n),o=new Lk(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Lk(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Pk(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*cy(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Pk||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*cy(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=Jx(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=vy(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Zk(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Xb(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));Xb(a instanceof Lk,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=yy(Zb(t),"float32");return rS.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!Qb(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),aS);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return Xb(py(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Xb(r.every((t=>t instanceof Lk)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),Xb(s.value instanceof Lk,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Xb(py(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];Xb(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Xb(a.every((t=>t instanceof Lk)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=mk(),n=await this.backend.time(t);return n.wallMs=mk()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new tS;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function nS(){const t=Fy();if(null==t._tfengine){const e=new Ey(t);t._tfengine=new eS(e)}var e;return e=t._tfengine.ENV,Ry=e,function(t){Dk=t}((()=>t._tfengine)),t._tfengine}eS.nextTensorId=0,eS.nextVariableId=0;const rS=nS();function aS(t,e){const n={a:t,b:e};return rS.runKernel(Ly,n)}let sS;function oS(t){if(void 0!==sS)return sS;if(t||"undefined"!==typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!==typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function iS(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const lS=Ty();function cS(t,e){let n=t;if(vk(t))return"string"===e?[]:[t.length];if(qk(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if(Xk(t))return[t.buffer.size/(null==e?4:cy(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||vk(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Ty().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uS(t,r,[]),r}function uS(t,e,n){if(n=n||[],!Array.isArray(t)&&!vk(t))return void Xb(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));Xb(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),Xb(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)uS(t[a],r,n.concat(a))}function hS(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function dS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Mk())return hS(r,t.dtype,e,n),t;let a=dy(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),hS(r,a,e,n),null==t||!vk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=cS(t,a);vk(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?gk(t,a):wk(t,[],!0);return rS.makeTensor(o,s,a)}function pS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>dS(t,"".concat(e,"[").concat(a,"]"),n,r)))}lS.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),lS.registerFlag("IS_BROWSER",(()=>iS())),lS.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),lS.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),lS.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),lS.registerFlag("PROD",(()=>!1)),lS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>lS.getBool("DEBUG"))),lS.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),lS.registerFlag("IS_TEST",(()=>!1)),lS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>lS.getBool("DEBUG"))),lS.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),lS.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),lS.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function fS(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){rS.startScope(n);try{const t=r(...arguments);return Iy(t)&&console.error("Cannot return a Promise inside of tidy."),rS.endScope(t),t}catch(t){throw rS.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const gS=fS({complex_:function(t,e){const n=dS(t,"real","complex"),r=dS(e,"imag","complex");Jb(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return rS.runKernel(sv,a)}});function mS(t,e,n,r){if(null==r)r=dy(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Xk(t)||qk(t)){if("float32"!==r&&"int32"!==r)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(r,"."));return rS.backend.createTensorFromGPUData(t,e||n,r)}if(!vk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){xy(e);const t=Zb(e),r=Zb(n);Xb(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==Zb(e.slice(a));Xb(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return vk(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?gk(t,r):wk(t,[],!0),rS.makeTensor(t,e,r)}function bS(t,e,n){return mS(t,e,cS(t,n),n)}class yS{static join(t){return new yS(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t)return;if(t instanceof Array||(t=[t]),0===(t=t.map((t=>vk(t)?t.buffer:t))).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=e+r.byteLength;this.shards.push({buffer:r,start:e,end:a}),e=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(-1===n)throw new Error("Could not find start shard for byte ".concat(t));const r=new ArrayBuffer(e-t),a=new Uint8Array(r);let s=0;for(let o=n;o<this.shards.length;o++){const n=this.shards[o],r=t+s-n.start,i=s,l=Math.min(e,n.end)-n.start,c=new Uint8Array(n.buffer,r,l-r);if(a.set(c,i),s+=c.length,e<n.end)break}return r}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(t,e){let n=0,r=t.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=e(t[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,e);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function vS(){return rS}function wS(){return rS.memory()}function xS(t,e){return rS.tidy(t,e)}function kS(t){Zk(t).forEach((t=>t.dispose()))}function SS(t){return rS.keep(t)}function IS(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return rS.registerBackend(t,e,n)}function NS(){return rS.backend}!function(t){zk=t}((function(t){Ty().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const ES=4;async function CS(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+ES*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=ES,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:TS(await Promise.all(r)),specs:n}}function TS(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const AS="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function RS(t){return AS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function FS(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(n.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function _S(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}(t,n,r)}function DS(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:RS(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:RS(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:new yS(t.weightData).byteLength}}function OS(t){const e=[];for(const n of t)e.push(...n.weights);return e}class zS{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==zS.instance&&(zS.instance=new zS),zS.instance}static registerSaveRouter(t){zS.getInstance().saveRouters.push(t)}static registerLoadRouter(t){zS.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return zS.getHandlers(t,"save")}static getLoadHandlers(t,e){return zS.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?zS.getInstance().loadRouters:zS.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const LS="tensorflowjs",MS="models_store",PS="model_info_store";function BS(){if(!Ty().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function WS(t){const e=t.result;e.createObjectStore(MS,{keyPath:"modelPath"}),e.createObjectStore(PS,{keyPath:"modelPath"})}class US{constructor(t){if(this.indexedDB=BS(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(LS,1);r.onupgradeneeded=()=>WS(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(MS,"readonly"),r=e.objectStore(MS).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{e.weightData=yS.join(e.weightData);const r=DS(e),o=a.transaction(PS,"readwrite");let i,l,c=o.objectStore(PS);try{i=c.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}i.onsuccess=()=>{l=a.transaction(MS,"readwrite");const i=l.objectStore(MS);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r})}catch(s){return n(s)}u.onsuccess=()=>t({modelArtifactsInfo:r}),u.onerror=t=>{c=o.objectStore(PS);const e=c.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(u.error)),e.onerror=t=>(a.close(),n(u.error))}},i.onerror=t=>(a.close(),n(i.error)),o.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}US.URL_SCHEME="indexeddb://";const VS=t=>{return Ty().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(US.URL_SCHEME)?(e=t.slice(US.URL_SCHEME.length),new US(e)):null;var e};zS.registerSaveRouter(VS),zS.registerLoadRouter(VS);class GS{constructor(){this.indexedDB=BS()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(LS,1);n.onupgradeneeded=()=>WS(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(PS,"readonly"),s=a.objectStore(PS).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(US.URL_SCHEME)?e.slice(US.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(LS,1);r.onupgradeneeded=()=>WS(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(PS,"readwrite"),o=s.objectStore(PS),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(MS,"readwrite");const r=l.objectStore(MS).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const jS="/",HS="tensorflowjs_models",KS="info",qS="model_topology",XS="weight_specs",JS="weight_data",YS="model_metadata";function ZS(t){return{info:[HS,t,KS].join(jS),topology:[HS,t,qS].join(jS),weightSpecs:[HS,t,XS].join(jS),weightData:[HS,t,JS].join(jS),modelMetadata:[HS,t,YS].join(jS)}}function QS(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function $S(t){const e=t.split(jS);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(jS)}class tI{constructor(t){if(!Ty().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=ZS(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=DS(t),a=yS.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(AS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(a));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(i1){throw QS(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(AS){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}tI.URL_SCHEME="localstorage://";const eI=t=>{return Ty().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(tI.URL_SCHEME)?(e=t.slice(tI.URL_SCHEME.length),new tI(e)):null;var e};zS.registerSaveRouter(eI),zS.registerLoadRouter(eI);class nI{constructor(){Xb(Ty().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Xb("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=HS+jS,n=jS+KS;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[$S(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=ZS(t=(e=t).startsWith(tI.URL_SCHEME)?e.slice(tI.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return QS(n),r}}const rI="://";class aI{constructor(){this.managers={}}static getInstance(){return null==aI.instance&&(aI.instance=new aI),aI.instance}static registerManager(t,e){Xb(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(rI)&&(t=t.slice(0,t.indexOf(rI))),Xb(t.length>0,(()=>"scheme must not be an empty string."));const n=aI.getInstance();Xb(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=aI.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(aI.getInstance().managers)}}class sI{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!==typeof window&&Ty().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return tk(t)}}if(Ty().get("IS_BROWSER")){Ty().setPlatform("browser",new sI);try{aI.registerManager(tI.URL_SCHEME,new nI)}catch(i1){}try{aI.registerManager(US.URL_SCHEME,new GS)}catch(i1){}}const oI=()=>n(7078);let iI;class lI{constructor(){this.util=n(6905),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ty().global.fetch?Ty().global.fetch(t,e):(null==iI&&(iI=oI()),iI(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}function cI(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",xy(t),new _k(t,e,n)}Ty().get("IS_NODE")&&!Ty().get("IS_BROWSER")&&Ty().setPlatform("node",new lI);const uI=fS({cast_:function(t,e){const n=dS(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return rS.runKernel(nv,r,a)}});const hI=fS({clone_:function(t){const e={x:dS(t,"x","clone","string_or_numeric")};return rS.runKernel(Xv,e)}});nS();!function(t){Ok=t}({buffer:cI,cast:uI,clone:hI,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}});const dI=fS({add_:function(t,e){let n=dS(t,"a","add"),r=dS(e,"b","add");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Ly,a)}});const pI=fS({floorDiv_:function(t,e){let n=dS(t,"a","floorDiv"),r=dS(e,"b","floorDiv");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Vv,a)}});const fI=fS({div_:function(t,e){let n=dS(t,"a","div"),r=dS(e,"b","div");if([n,r]=Jk(n,r),"int32"===n.dtype&&"int32"===r.dtype)return pI(n,r);const a={a:n,b:r};return rS.runKernel(Av,a,{})}});const gI=fS({mul_:function(t,e){let n=dS(t,"a","mul"),r=dS(e,"b","mul");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Iw,a)}});const mI=fS({sqrt_:function(t){const e={x:dS(t,"x","sqrt","float32")};return rS.runKernel(ux,e)}});const bI=fS({square_:function(t){const e=dS(t,"x","square");return rS.runKernel("Square",{x:e},{})}});const yI=fS({zerosLike_:function(t){const e={x:dS(t,"x","zerosLike")};return rS.runKernel(Mx,e)}});function vI(t){return rS.customGrad(t)}function wI(t,e){if((vk(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&vk(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mS(t,[],[],e)}const xI=new Map,kI=new Map;class SI{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class II{constructor(){this.classNameMap={}}static getMap(){return null==II.instance&&(II.instance=new II),II.instance}static register(t){II.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function NI(t,e,n){Xb(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),Xb("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),Xb(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof e&&(e="Custom"),"undefined"===typeof n&&(n=t.className);const r=e+">"+n;return II.register(t),xI.set(r,t),kI.set(t,r),t}class EI extends SI{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return kS(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){Xb(py(t),(()=>"The f passed in variableGrads(f) must be a function")),Xb(null==e||Array.isArray(e)&&e.every((t=>t instanceof Pk)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in rS.registeredVariables)e.push(rS.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),Xb(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=rS.gradients(t,e,null,!0);Xb(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Xb(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&kS(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:wI(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(EI,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class CI extends EI{static get className(){return"Adadelta"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=rS.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=rS.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:xS((()=>yI(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:xS((()=>yI(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;xS((()=>{const t=dI(gI(s,this.rho),gI(bI(a),1-this.rho)),e=gI(fI(mI(dI(o,this.epsilon)),mI(dI(s,this.epsilon))),a),n=dI(gI(o,this.rho),gI(bI(e),1-this.rho));s.assign(t),o.assign(n);const i=dI(gI(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(kS(this.accumulatedGrads.map((t=>t.variable))),kS(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function TI(t,e,n){xy(t);const r={shape:t,value:e,dtype:n=n||dy(e)};return rS.runKernel(Bv,{},r)}class AI extends EI{static get className(){return"Adagrad"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=rS.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:xS((()=>TI(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;xS((()=>{const t=dI(s,bI(a));s.assign(t);const e=dI(gI(fI(a,mI(dI(t,rS.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&kS(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const RI=fS({pow_:function(t,e){let n=dS(t,"base","pow"),r=dS(e,"exp","pow");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Ow,a)}});const FI=fS({sub_:function(t,e){let n=dS(t,"a","sub"),r=dS(e,"b","sub");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Cx,a)}});class _I extends EI{static get className(){return"Adam"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],xS((()=>{this.accBeta1=wI(e).variable(),this.accBeta2=wI(n).variable()})),null==r&&(this.epsilon=rS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);xS((()=>{const n=FI(1,this.accBeta1),r=FI(1,this.accBeta2);e.forEach(((e,a)=>{const s=rS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:xS((()=>yI(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:xS((()=>yI(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=dI(gI(i,this.beta1),gI(o,1-this.beta1)),u=dI(gI(l,this.beta2),gI(bI(o),1-this.beta2)),h=fI(c,n),d=fI(u,r);i.assign(c),l.assign(u);const p=dI(gI(fI(h,dI(mI(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(gI(this.accBeta1,this.beta1)),this.accBeta2.assign(gI(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&kS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&kS(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),xS((()=>{this.accBeta1.assign(RI(this.beta1,this.iterations_+1)),this.accBeta2.assign(RI(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const DI=fS({abs_:function(t){const e=dS(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return rS.runKernel(ov,t)}{const t={x:e};return rS.runKernel(Dy,t)}}});function OI(t,e){const n=t.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=t[s]||1;(e[e.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function zI(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function LI(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let a=0;a<n;a++){let s=t[t.length-a-1];null==s&&(s=1);let o=e[e.length-a-1];if(null==o&&(o=1),1===s)r[n-a-1]=o;else if(1===o)r[n-a-1]=s;else{if(s!==o){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}r[n-a-1]=s}}return r}const MI=fS({maximum_:function(t,e){let n=dS(t,"a","maximum"),r=dS(e,"b","maximum");[n,r]=Jk(n,r),"bool"===n.dtype&&(n=uI(n,"int32"),r=uI(r,"int32")),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(dw,a)}});class PI extends EI{static get className(){return"Adamax"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],xS((()=>{this.iteration=wI(0).variable(),this.accBeta1=wI(e).variable()})),null==r&&(this.epsilon=rS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);xS((()=>{const n=FI(1,this.accBeta1),r=fI(-this.learningRate,dI(gI(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=rS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:yI(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:yI(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=dI(gI(i,this.beta1),gI(o,1-this.beta1)),u=gI(l,this.beta2),h=DI(o),d=MI(u,h);i.assign(c),l.assign(d);const p=dI(gI(fI(r,n),fI(c,dI(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(dI(this.iteration,1)),this.accBeta1.assign(gI(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&kS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&kS(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class BI extends EI{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=rS.registeredVariables[e];xS((()=>{const t=dI(gI(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=SS(wI(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class WI extends BI{static get className(){return"Momentum"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=wI(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=rS.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:xS((()=>yI(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&xS((()=>{let t;const e=dI(gI(this.m,a),s);t=this.useNesterov?dI(gI(this.c,dI(s,gI(e,this.m))),r):dI(gI(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&kS(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class UI extends EI{static get className(){return"RMSProp"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=rS.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=rS.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:xS((()=>yI(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:xS((()=>yI(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:xS((()=>yI(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;xS((()=>{const t=dI(gI(o,this.decay),gI(bI(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=dI(gI(e,this.decay),gI(s,1-this.decay)),l=fI(gI(s,this.learningRate),mI(FI(t,dI(bI(a),this.epsilon)))),c=dI(gI(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=FI(r,c);r.assign(u)}else{const t=dI(gI(o,this.decay),gI(bI(s),1-this.decay)),e=dI(gI(i,this.momentum),fI(gI(s,this.learningRate),mI(dI(t,this.epsilon))));o.assign(t),i.assign(e);const n=FI(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&kS(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&kS(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&kS(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const VI=[CI,AI,_I,PI,WI,UI,BI];function GI(t){return new Promise((t=>setTimeout(t))).then(t)}class jI{constructor(t){if(!Ty().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(jI.URL_SCHEME)&&(t=t.slice(jI.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=yS.join(t.weightData),n=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const e=FS(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(e)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await GI((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=n,await GI((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:DS(t)}}}}jI.URL_SCHEME="downloads://";function HI(t,e,n,r){!function(t){Xb(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Xb(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),Xb(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),Xb(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function KI(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ty().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await HI(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await HI(a,e.onProgress,.5,1)}zS.registerSaveRouter((t=>Ty().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(jI.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new jI(t)}(t.slice(jI.URL_SCHEME.length)):null));class qI{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Xb("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Ty().platform.fetch,Xb(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&Xb(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=FS(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);if(e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData){const n=yS.join(t.weightData);e.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:DS(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(o1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return _S(await this.loadModelJSON(),(t=>this.loadWeights(t)))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),n=OS(t.weightsManifest);return Object.assign(Object.assign({},t),{weightSpecs:n,getWeightStream:()=>function(t,e){var n;const r=null==e.fetchFunc?Ty().platform.fetch:e.fetchFunc;let a,s=0;return null===(n=e.onProgress)||void 0===n||n.call(e,0),new ReadableStream({pull:async n=>{for(var o;s<t.length;){if(!a){const n=(await r(t[s],e.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:i,value:l}=await a.read();if(!i)return void n.enqueue(l);s++,a=void 0,null===(o=e.onProgress)||void 0===o||o.call(e,s/t.length)}n.close()}})}(e,this.loadOptions)})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=[],o=[];for(const i of t)for(const t of i.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):s.push(a+t+r);return this.weightUrlConverter&&s.push(...await Promise.all(o)),s}async loadWeights(t){const e=await this.getWeightUrls(t);return[OS(t),await KI(e,this.loadOptions)]}}function XI(t){return null!=t.match(qI.URL_SCHEME_REGEX)}qI.URL_SCHEME_REGEX=/^https?:\/\//;const JI=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>XI(t))):XI(t),n)return YI(t,e)}return null};function YI(t,e){return new qI(t,e)}zS.registerSaveRouter(JI),zS.registerLoadRouter(JI);const ZI=-2,QI=-1;function $I(t,e,n){const r=t.shape.length;Xb(r===e.length,(()=>"Error in slice".concat(r,"D: Length of begin ").concat(e," must ")+"match the rank of the array (".concat(r,")."))),Xb(r===n.length,(()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,").")));for(let a=0;a<r;++a)Xb(e[a]+n[a]<=t.shape[a],(()=>"Error in slice".concat(r,"D: begin[").concat(a,"] + size[").concat(a,"] ")+"(".concat(e[a]+n[a],") would overflow input.shape[").concat(a,"] (").concat(t.shape[a],")")))}function tN(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function eN(t,e,n){const r=[];for(let a=0;a<t.length;a++)r[a]=Math.ceil((e[a]-t[a])/n[a]);return r}function nN(t,e,n,r){const a=[...t];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[e]=1:(a.splice(e,0,1),a.pop());return a}function rN(t,e,n){return n<=t?n:n-(e-1)}function aN(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function sN(t,e,n,r,a,s,o,i,l){const c=t.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;u=oN(o,l,c,r,t),h=iN(i,l,c,a,t),d=nN(s,l,c,t)}else for(let p=0;p<c;p++)u[p]=cN(o,r,s,t,p,l),h[p]=uN(i,a,s,t,p,l),d[p]=lN(s,p,l);return{begin:u,end:h,strides:d}}function oN(t,e,n,r,a){const s=[...a],o=aN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const a=rN(e,n,i);let o=r[a];t&1<<a&&(o=0),s[i]=o}return s}function iN(t,e,n,r,a){const s=[...a],o=aN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const a=rN(e,n,i);let o=r[a];t&1<<a&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const t=a[i];s[i]<0&&(s[i]+=t),s[i]=Hb(0,s[i],a[i])}return s}function lN(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function cN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=Hb(0,o,l-1),o}function uN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=i>0?Hb(0,o,l):Hb(-1,o,l-1),o}function hN(t,e,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(e[a]>0||n[a]!==t[a])return!1;return!0}function dN(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function pN(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{Xb(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(Xb(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}function fN(t,e,n,r,a,s,o,i,l){let c;if(null==r?(c=new Array(e.length),c.fill(1)):c=r,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let y=0;y<h.dims;y++)u&&0!==(1<<y&i)&&h.numAddAxisAfterEllipsis++,1<<y&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const a=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<a;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(ZI),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(e.dims," dims, ").concat(e.begin.length,"."));null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(QI),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let y=0;y<t.length;++y){if(0===d.strides[y])throw Error("strides[".concat(y,"] must be non-zero"));const e=!!(d.shrinkAxisMask&1<<y),n=t[y];if(-1===n){m.push(e?1:-1);continue}const r=[d.beginMask&1<<y,d.endMask&1<<y],a=[d.strides[y]>0?0:-1,d.strides[y]>0?n:n-1];if(e&&d.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[y];const s=!!(d.beginMask&1<<y&&d.endMask&1<<y);if(d.beginValid&&d.endValid){if(e){const t=d.begin[y]<0?n+d.begin[y]:d.begin[y];if(d.begin[y]=t,d.end[y]=d.begin[y]+1,t<0||t>=n)throw Error("slice index ".concat(d.begin[y]," of dimension ").concat(y," out of bounds."))}else d.begin[y]=gN(d.begin[y],0,d.strides[y],n,r,a),d.end[y]=gN(d.end[y],1,d.strides[y],n,r,a);const t=1===d.strides[y]&&0===d.begin[y]&&d.end[y]===n;p=p&&t,f=f&&(0===y&&1===d.strides[y]||t)}else p=p&&1===d.strides[y]&&s,f=f&&(0===y&&1===d.strides[y]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[y]-d.begin[y],i=!0):e?(o=1,i=!0):s&&n>=0&&(o=d.strides[y]<0?-n:n,i=!0),i){let t;t=0===o||o<0!==d.strides[y]<0?0:Math.trunc(o/d.strides[y])+(o%d.strides[y]!==0?1:0),m.push(t)}else m.push(-1)}for(let y=0;y<d.finalShapeGatherIndices.length;++y){const t=d.finalShapeGatherIndices[y];t>=0?b.push(m[t]):t===ZI&&b.push(1)}return{finalShapeSparse:b.filter(((t,e)=>d.finalShapeGatherIndices[e]!==ZI)),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function gN(t,e,n,r,a,s){if(a[e])return n>0?s[e]:s[e+1&1];{const e=t<0?r+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}const mN=fS({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:dS(t,"x","all","bool")},a={axis:e,keepDims:n};return rS.runKernel(Py,r,a)}});const bN=fS({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:dS(t,"x","any","bool")},a={axis:e,keepDims:n};return rS.runKernel(By,r,a)}});const yN=fS({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:dS(t,"x","argMax")},r={axis:e};return rS.runKernel(Wy,n,r)}});function vN(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return kN(t,[...e,t[3]],n,s,r,null,null,_N(a))}function wN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,l]=NN(e);let c;if("channelsLast"===o)c=[i,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));c=[i,l,t[1],t[1]]}return kN(t,c,n,r,a,s,!1,o)}function xN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,l,c]=EN(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,l,c,t[1],t[1]]}return SN(t,u,n,r,a,!1,h,s)}function kN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=NN(n),[b,y]=NN(r),v=CN(d,b),w=CN(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=IN(t,e,n));const s=t[0],o=t[1],i=TN((s-e+2*r)/n+1,a),l=TN((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=TN((e-s+d+p)/r+1,i),h=TN((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function SN(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[l,d,c,u,h]=t}const[p,f,g,,m]=e,[b,y,v]=EN(n),[w,x,k]=EN(r),S=CN(p,w),I=CN(f,x),N=CN(g,k),{padInfo:E,outDepth:C,outHeight:T,outWidth:A}=function(t,e,n,r,a,s,o,i,l,c,u){let h,d,p,f;"valid"===t&&(t=0);if("number"===typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const g=function(t,e,n,r,a,s){null==a&&(a=IN(t,e[0],r[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)t[i]+2*a>=e[i]&&(o[i]=TN((t[i]-e[i]+2*a)/r[i]+1,s));return o}([e,n,r,1],[i,l,c],1,[a,s,o],t,u);d=g[0],p=g[1],f=g[2]}else{if("same"!==t)throw Error("Unknown padding parameter: ".concat(t));{d=Math.ceil(e/a),p=Math.ceil(n/s),f=Math.ceil(r/o);const t=(d-1)*a+i-e,u=(p-1)*s+l-n,g=(f-1)*o+c-r,m=Math.floor(t/2),b=t-m,y=Math.floor(u/2),v=u-y,w=Math.floor(g/2);h={top:y,bottom:v,left:w,right:g-w,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(a,c,u,h,b,y,v,S,I,N,i),R=s?m*d:m;let F;return"channelsFirst"===o?F=[l,R,C,T,A]:"channelsLast"===o&&(F=[l,C,T,A,R]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:C,outHeight:T,outWidth:A,outChannels:R,padInfo:E,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:x,dilationWidth:k,inShape:t,outShape:F,filterShape:e}}function IN(t,e,n){const r=CN(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function NN(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function EN(t){return"number"===typeof t?[t,t,t]:t}function CN(t,e){return e<=1?t:t+(t-1)*(e-1)}function TN(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function AN(t){const[e,n,r]=NN(t);return 1===e&&1===n&&1===r}function RN(t,e){return AN(t)||AN(e)}function FN(t){return NN(t).every((t=>t>0))}function _N(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(t))}function DN(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)Xb($b(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{Xb($b(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const ON=fS({reshape_:function(t,e){const n={x:dS(t,"x","reshape","string_or_numeric")},r={shape:e};return rS.runKernel(jw,n,r)}});const zN=fS({avgPool_:function(t,e,n,r,a){const s=dS(t,"x","avgPool","float32");Xb(RN(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=ON(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Xb(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),DN("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=rS.runKernel(qy,l,c);return u=uI(u,s.dtype),i?ON(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const LN=fS({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=dS(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=ON(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Xb(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Xb("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Xb("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),DN("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=rS.runKernel(Jy,c,u);return h=uI(h,i.dtype),l?ON(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const MN=fS({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=dS(t,"x","batchNorm"),i=dS(e,"mean","batchNorm"),l=dS(n,"variance","batchNorm");let c,u;null!=a&&(c=dS(a,"scale","batchNorm")),null!=r&&(u=dS(r,"offset","batchNorm")),Xb(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Xb(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Xb(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?ON(t,[1,1,1,t.size]):2===t.rank?ON(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?ON(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=rS.runKernel(Gv,h,d);return ON(p,o.shape)}});const PN=fS({batchNorm2d_:function(t,e,n,r,a,s){const o=dS(t,"x","batchNorm"),i=dS(e,"mean","batchNorm"),l=dS(n,"variance","batchNorm");let c,u;return null!=a&&(c=dS(a,"scale","batchNorm")),null!=r&&(u=dS(r,"offset","batchNorm")),Xb(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),Xb(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Xb(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Xb(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Xb(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),MN(o,i,l,u,c,s)}});const BN=fS({batchNorm3d_:function(t,e,n,r,a,s){const o=dS(t,"x","batchNorm"),i=dS(e,"mean","batchNorm"),l=dS(n,"variance","batchNorm");let c,u;return null!=a&&(c=dS(a,"scale","batchNorm")),null!=r&&(u=dS(r,"offset","batchNorm")),Xb(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),Xb(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Xb(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Xb(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Xb(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),MN(o,i,l,u,c,s)}});const WN=fS({batchNorm4d_:function(t,e,n,r,a,s){const o=dS(t,"x","batchNorm"),i=dS(e,"mean","batchNorm"),l=dS(n,"variance","batchNorm");let c,u;return null!=a&&(c=dS(a,"scale","batchNorm")),null!=r&&(u=dS(r,"offset","batchNorm")),Xb(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),Xb(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Xb(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Xb(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Xb(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),MN(o,i,l,u,c,s)}});const UN=fS({broadcastTo_:function(t,e){let n=dS(t,"broadcastTo","x");const r=n.shape;if(xy(e),e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=ON(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return hI(n);const o={x:n},i={reps:s};return rS.runKernel(Rx,o,i)}});const VN=fS({clipByValue_:function(t,e,n){const r=dS(t,"x","clipByValue");if(Xb(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return TI(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return rS.runKernel(av,a,s)}});const GN=fS({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Xb(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=pS(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return hI(n[0]);const r=n,a={axis:e};return rS.runKernel(iv,r,a)}});const jN=fS({concat1d_:function(t){return GN(t,0)}});const HN=fS({concat2d_:function(t,e){return GN(t,e)}});const KN=fS({concat3d_:function(t,e){return GN(t,e)}});const qN=fS({concat4d_:function(t,e){return GN(t,e)}});const XN=fS({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=dS(t,"x","conv2d","float32"),l=dS(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=ON(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Xb(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),Xb(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),DN("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];Xb(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),Xb(RN(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Xb(FN(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Xb(FN(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=rS.runKernel(lv,d,p);return u?ON(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const JN=fS({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=dS(t,"x","conv1d"),l=dS(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=ON(i,[1,i.shape[0],i.shape[1]])),Xb(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),Xb(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),DN("conv1d",r,o),Xb(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),Xb(RN(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),Xb(FN(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Xb(FN(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Xb("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=ON(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ON(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=XN(d,h,[1,n],r,"NHWC",[1,s],o);return ON(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const YN=fS({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;Xb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=ON(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),Xb(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Xb(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),Xb(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];Xb(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Xb(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),DN("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=rS.runKernel(uv,d,p);return c?ON(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const ZN=fS({conv2dTranspose_:function(t,e,n,r,a,s){const o=dS(t,"x","conv2dTranspose"),i=dS(e,"filter","conv2dTranspose");return YN(n,o,i,r,a,"NHWC",s)}});const QN=fS({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=dS(t,"x","conv3d"),i=dS(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=ON(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Xb(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),Xb(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Xb(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Xb(RN(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Xb("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported."))),Xb(FN(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Xb(FN(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=rS.runKernel(hv,u,h);return c?ON(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const $N=fS({conv3DBackpropInput_:function(t,e,n,r,a){Xb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=ON(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];Xb(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),Xb(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),Xb(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Xb(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Xb(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=rS.runKernel(pv,u,h);return i?ON(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const tE=fS({conv3dTranspose_:function(t,e,n,r,a){const s=dS(t,"x","conv3dTranspose"),o=dS(e,"filter","conv3dTranspose");return $N(n,s,o,r,a)}});const eE=fS({denseBincount_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dS(t,"x","denseBincount"),s=dS(e,"weights","denseBincount");Xb("int32"===a.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Xb(a.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(a.rank,"."))),Xb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Xb(s.size===a.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(a.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:a,weights:s},i={size:n,binaryOutput:r};return rS.runKernel(vv,o,i)}});const nE=fS({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=dS(t,"x","depthwiseConv2d","float32"),l=dS(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=ON(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Xb(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),Xb(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];Xb(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),DN("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=rS.runKernel(xv,d,p);return u?ON(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const rE=fS({elu_:function(t){const e={x:dS(t,"x","elu","float32")};return rS.runKernel(Fv,e)}});const aE=fS({equal_:function(t,e){let n=dS(t,"a","equal","string_or_numeric"),r=dS(e,"b","equal","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(Ov,a)}});const sE=fS({exp_:function(t){const e={x:dS(t,"x","exp")};return rS.runKernel(zv,e)}});const oE=fS({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=dS(t,"x","expandDims","string_or_numeric");Xb(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return rS.runKernel(Lv,r,a)}});const iE=fS({tile_:function(t,e){const n=dS(t,"x","tile","string_or_numeric");Xb(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return rS.runKernel(Rx,r,a)}});const lE=fS({eye_:function(t,e,n){null==e&&(e=t);const r=cI([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=ON(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return iE(oE(s,0),[n[0],1,1]);if(2===n.length)return iE(oE(oE(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return iE(oE(oE(oE(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const cE=fS({floor_:function(t){const e={x:dS(t,"x","floor","float32")};return rS.runKernel(Uv,e)}});const uE=fS({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:dS(t,"x","gather"),indices:dS(e,"indices","gather","int32")},s={axis:n,batchDims:r};return rS.runKernel(jv,a,s)}});const hE=fS({greater_:function(t,e){let n=dS(t,"a","greater","string_or_numeric"),r=dS(e,"b","greater","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(Kv,a)}});const dE=fS({greaterEqual_:function(t,e){let n=dS(t,"a","greaterEqual","string_or_numeric"),r=dS(e,"b","greaterEqual","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(qv,a)}});const pE=fS({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:dS(t,"x","leakyRelu")},r={alpha:e};return rS.runKernel(tw,n,r)}});const fE=fS({log_:function(t){const e={x:dS(t,"x","log","float32")};return rS.runKernel(aw,e)}});const gE=fS({log1p_:function(t){const e={x:dS(t,"x","log1p")};return rS.runKernel(sw,e)}});const mE=fS({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:dS(t,"x","max")},a={reductionIndices:e,keepDims:n};return rS.runKernel(hw,r,a)}});const bE=fS({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=dS(t,"x","sum");"bool"===r.dtype&&(r=uI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return rS.runKernel(hx,a,s)}});const yE=fS({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=dS(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=vI(((t,n)=>{const r=mE(t,e,!0),a=FI(t,r),s=FI(uI(a,"float32"),fE(bE(sE(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=sE(r);return FI(t,gI(bE(t,e,!0),a))}}}));return r(n)}});function vE(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function wE(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}function xE(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}function kE(t,e){return wE(t,e.map((t=>1)),e)}function SE(t,e,n){Xb(vE(e,n),(()=>"".concat(t," supports only inner-most axes for now. ")+"Got axes ".concat(e," and rank-").concat(n," input.")))}function IE(t,e){if(vE(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function NE(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function EE(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const CE=fS({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=dS(t,"x","logSumExp"),a=ay(e,r.shape),s=mE(r,a,!0),o=FI(r,s),i=sE(o),l=bE(i,a),c=fE(l),u=dI(ON(s,c.shape),c);if(n){const t=kE(u.shape,a);return ON(u,t)}return u}});const TE=fS({logicalAnd_:function(t,e){const n=dS(t,"a","logicalAnd","bool"),r=dS(e,"b","logicalAnd","bool");LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(ow,a)}});const AE=fS({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=dS(t,"a","matMul"),s=dS(e,"b","matMul");[a,s]=Jk(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return rS.runKernel(Zy,o,i)}});const RE=fS({maxPool_:function(t,e,n,r,a){const s=dS(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=ON(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Xb(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),Xb(RN(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),DN("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=rS.runKernel(pw,l,c);return i?ON(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const FE=fS({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=dS(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=ON(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Xb(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Xb("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),DN("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=rS.runKernel(gw,c,u);return l?ON(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const _E=fS({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:dS(t,"x","mean")},a={axis:e,keepDims:n};return rS.runKernel(yw,r,a)}});const DE=fS({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:dS(t,"x","min")},a={axis:e,keepDims:n};return rS.runKernel(vw,r,a)}});const OE=fS({minimum_:function(t,e){let n=dS(t,"a","minimum"),r=dS(e,"b","minimum");[n,r]=Jk(n,r),"bool"===n.dtype&&(n=uI(n,"int32"),r=uI(r,"int32")),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(ww,a)}});const zE=fS({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=ay(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=dS(t,"x","moments")).shape),r=_E(t,n,e);let a=r.shape;e||(a=kE(r.shape,n));const s=bI(FI(uI(t,"float32"),ON(r,a)));return{mean:r,variance:_E(s,n,e)}}});const LE=fS({neg_:function(t){const e={x:dS(t,"x","neg")};return rS.runKernel(Nw,e)}});const ME=fS({notEqual_:function(t,e){let n=dS(t,"a","notEqual","string_or_numeric"),r=dS(e,"b","notEqual","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(Ew,a)}});const PE=fS({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:dS(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return rS.runKernel(Fw,s,o)}});function BE(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(xy(t),"complex64"===e){const e=BE(t,"float32"),n=BE(t,"float32");return gS(e,n)}const n=vy(Zb(t),e);return rS.makeTensor(n,t,e)}function WE(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(xy(t),"complex64"===e){const e=WE(t,"float32"),n=BE(t,"float32");return gS(e,n)}const n=yy(Zb(t),e);return rS.makeTensor(n,t,e)}const UE=fS({onesLike_:function(t){const e={x:dS(t,"x","onesLike")};return rS.runKernel(Rw,e)}});const VE=fS({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=dS(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return rS.runKernel(Dw,s,a)}});const GE=fS({prelu_:function(t,e){const n={x:dS(t,"x","prelu"),alpha:dS(e,"alpha","prelu")};return rS.runKernel(zw,n)}});class jE{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Uo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class HE{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Uo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const KE=fS({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(xy(t),null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new jE(e,n,r,!1,a),o=cI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const qE=fS({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;xy(t);const s=cI(t,r),o=new HE(e,n,null,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});function XE(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return rS.runKernel(Ww,{},a)}const JE=fS({relu_:function(t){const e={x:dS(t,"x","relu")};return rS.runKernel(Gw,e)}});const YE=fS({reverse_:function(t,e){const n={x:dS(t,"x","reverse")},r={dims:e};return rS.runKernel(Yw,n,r)}});const ZE=fS({selu_:function(t){const e={x:dS(t,"x","selu")};return rS.runKernel(rx,e)}});const QE=fS({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=dS(t,"x","separableConv2d"),l=dS(e,"depthwiseFilter","separableConv2d"),c=dS(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=ON(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Xb(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Xb(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Xb(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Xb(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),Xb(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];Xb(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=nE(u,l,r,a,o,s),g=XN(f,c,1,"valid",o);return h?ON(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const $E=fS({sigmoid_:function(t){const e={x:dS(t,"x","sigmoid","float32")};return rS.runKernel(lx,e)}});const tC=fS({slice_:function(t,e,n){const r=dS(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return rS.runKernel(ax,a,s)}});const eC=fS({slice1d_:function(t,e,n){const r=dS(t,"x","slice1d");return Xb(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),tC(r,[e],[n])}});const nC=fS({slice2d_:function(t,e,n){const r=dS(t,"x","slice2d");return Xb(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),tC(r,e,n)}});const rC=fS({slice3d_:function(t,e,n){const r=dS(t,"x","slice3d");return Xb(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),tC(r,e,n)}});const aC=fS({slice4d_:function(t,e,n){const r=dS(t,"x","slice4d");return Xb(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),tC(r,e,n)}});const sC=fS({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=dS(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return rS.runKernel(fx,r,a)}});const oC=fS({softplus_:function(t){const e={x:dS(t,"x","softplus")};return rS.runKernel(cx,e)}});const iC=fS({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:dS(t,"x","split")},a={numOrSizeSplits:e,axis:n};return rS.runKernel(px,r,a)}});const lC=fS({squeeze_:function(t,e){const n=dS(t,"x","squeeze","string_or_numeric");return ON(n,sy(n.shape,e).newShape)}});const cC=fS({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"tensors","stack","string_or_numeric");Xb(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Xb(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return rS.runKernel(_w,r,a)}});const uC=fS({tanh_:function(t){const e={x:dS(t,"x","tanh","float32")};return rS.runKernel(Ax,e)}});function hC(t,e){Yb(t);const n=cS(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mS(t,null,n,e)}function dC(t,e,n){if(Yb(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=cS(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mS(t,e,r,n)}const pC=fS({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(xy(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new jE(e,n,r,!0,a),o=cI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const fC=fS({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=dS(t,"x","unstack","string_or_numeric");Xb(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return rS.runKernel(zx,r,a)}});const gC=fS({where_:function(t,e,n){const r=dS(e,"a","where"),a=dS(n,"b","where"),s=dS(t,"condition","where","bool"),o=LI(LI(s.shape,r.shape),a.shape),i={condition:UN(s,o),t:UN(r,o),e:UN(a,o)};return rS.runKernel(nx,i)}});const mC=fS({imag_:function(t){const e={input:dS(t,"input","imag")};return rS.runKernel(Yv,e)}});const bC=fS({real_:function(t){const e={input:dS(t,"input","real")};return rS.runKernel(Uw,e)}});const yC=fS({transpose_:function(t,e,n){const r=dS(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),Xb(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{Xb(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?xS((()=>{let t=bC(r),e=mC(r);return t=rS.runKernel(Dx,{x:t},s),e=rS.runKernel(Dx,{x:e},s),n&&(e=LE(e)),gS(t,e)})):rS.runKernel(Dx,a,s)}});const vC=fS({dropout_:function(t,e,n,r){const a=dS(t,"x","dropout");if(Xb("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),Xb(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Lk?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if(Qb(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=fI(cE(dI(qE(s,0,1,"float32",r),o)),o);return gI(a,i)}});const wC=fS({fft_:function(t){Xb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return rS.runKernel(Pv,e)}});const xC=fS({rfft_:function(t,e){Xb("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=tC(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=GN([t,BE(r)],t.shape.length-1),n=e}else a=t;const s=yI(a),o=ON(gS(a,s),[r,n]),i=wC(o),l=Math.floor(n/2)+1,c=bC(i),u=mC(i),h=iC(c,[l,n-l],c.shape.length-1),d=iC(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,ON(gS(h[0],d[0]),p)}});const kC=fS({ifft_:function(t){Xb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return rS.runKernel(Jv,e)}});const SC=fS({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=ON(t,[n,e]);r=kC(a)}else{const a=[n,2*(e-1)],s=ON(bC(t),[n,e]),o=ON(mC(t),[n,e]),i=YE(tC(s,[0,1],[n,e-2]),1),l=gI(YE(tC(o,[0,1],[n,e-2]),1),wI(-1)),c=GN([s,i],1),u=GN([o,l],1),h=ON(gS(c,u),[a[0],a[1]]);r=kC(h)}if(r=bC(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=ON(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const IC=fS({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=ON(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=ON(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Xb(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Xb(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),Xb(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];Xb(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),Xb(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),DN("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return rS.runKernel(cv,h,d)}});const NC=fS({relu6_:function(t){const e={x:dS(t,"x","relu6")};return rS.runKernel(Jw,e)}});const EC=fS({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:dS(t,"x","step")},r={alpha:e};return rS.runKernel(Px,n,r)}});function CC(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return gI(t,EC(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function TC(t,e){let n=e;const r=zI(t.shape,e.shape);return r.length>0&&(n=bE(n,r)),ON(n,t.shape)}function AC(t,e,n,r){if("linear"===e)return t;if("relu"===e)return JE(t);if("elu"===e)return rE(t);if("relu6"===e)return NC(t);if("prelu"===e)return GE(t,n);if("leakyrelu"===e)return pE(t,r);if("sigmoid"===e)return $E(t);throw new Error("Unknown fused activation ".concat(e,"."))}const RC=(t,e)=>!(t>0)||"linear"===e;const FC=fS({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===RC(rS.state.gradientDepth,c)){Xb("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=XN(e,n,r,a,s,o,i);return null!=l&&(t=dI(t,l)),AC(t,c,u,h)}const d=dS(e,"x","conv2d","float32"),p=dS(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=ON(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Xb(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Xb(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),DN("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];Xb(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Xb(RN(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=kN(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=dS(l,"bias","fused conv2d"),[y]=Jk(y,d),"NHWC"===s?LI(b.outShape,y.shape):(Xb(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),Xb(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(Xb(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)Xb(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{LI(t,b.outShape)}catch(o1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=dS(u,"prelu weights","fused conv2d")}const w=(t,e)=>{Xb("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=CC(t,l,c);Xb(AN(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[YN(i.shape,h,n,r,a),IC(i,h,n.shape,r,a)];if(null!=u){const t=TC(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=vI(((t,e,n)=>{let r=rS.runKernel(Vx,x,k);return n([e,t,r]),g&&(r=ON(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=vI(((t,e,n,r)=>{let a=rS.runKernel(Vx,x,k);return r([e,t,a,n]),g&&(a=ON(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const _C=fS({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=ON(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=ON(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return rS.runKernel(kv,c,u)}});const DC=fS({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=ON(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=rS.runKernel(Sv,c,u);return l?ON(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const OC=fS({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===RC(rS.state.gradientDepth,o)){let t=AE(e,n,r,a);return null!=s&&(t=dI(t,s)),AC(t,o,i,l)}let c=dS(e,"a","fused matMul"),u=dS(n,"b","fused matMul");[c,u]=Jk(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=Zb(g),y=Zb(m);Xb(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=LI(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=ON(c,r?[b,h,p]:[b,p,h]),x=ON(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=dS(s,"bias","fused matMul"),[k]=Jk(k,c),LI(v,k.shape)),null!=i&&(S=dS(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=CC(ON(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=AE(u,i,!1,!1),d=AE(u,n,!0,!1)):r&&!a?(h=AE(i,u,!1,!0),d=AE(n,u,!1,!1)):(h=AE(i,u,!0,!0),d=AE(u,n,!0,!0)):(h=AE(u,i,!1,!0),d=AE(n,u,!0,!1)),null!=s){return[h,d,TC(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},E={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=vI(((t,e,n)=>{const r=rS.runKernel(Ux,N,E);return n([t,e,r]),{value:ON(r,v),gradFunc:I}}));return t(w,x)}{const t=vI(((t,e,n,r)=>{const a=rS.runKernel(Ux,N,E);return r([t,e,a,n]),{value:ON(a,v),gradFunc:I}}));return t(w,x,k)}}});const zC=fS({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=dS(t,"image","cropAndResize"),i=dS(e,"boxes","cropAndResize","float32"),l=dS(n,"boxInd","cropAndResize","int32"),c=i.shape[0];Xb(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Xb(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),Xb(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),Xb(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),Xb(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),Xb("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return rS.runKernel(yv,u,h)}});const LC=fS({flipLeftRight_:function(t){const e=dS(t,"image","flipLeftRight","float32");Xb(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return rS.runKernel(Wv,n,{})}});const MC=fS({grayscaleToRGB_:function(t){const e=dS(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];Xb(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Xb(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,iE(e,a)}});const PC=fS({einsum_:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const a=n.map(((t,e)=>dS(t,"tensors".concat(e),"einsum"))),s={equation:t};return rS.runKernel(Rv,a,s)}});const BC=fS({rgbToGrayscale_:function(t){const e=dS(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];Xb(e.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Xb(3===r,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(r,".")));const a=e.dtype,s=uI(e,"float32"),o=hC([.2989,.587,.114]);let i;switch(e.rank){case 2:i=PC("ij,j->i",s,o);break;case 3:i=PC("ijk,k->ij",s,o);break;case 4:i=PC("ijkl,l->ijk",s,o);break;case 5:i=PC("ijklm,m->ijkl",s,o);break;case 6:i=PC("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return i=oE(i,-1),uI(i,a)}});const WC=fS({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=dS(t,"image","rotateWithOffset","float32");Xb(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return rS.runKernel(Wx,s,o)}});function UC(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),Xb(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),Xb(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),Xb(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),Xb(1===e.rank,(()=>"scores must be a 1D tensor")),Xb(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),Xb(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const VC=fS({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=dS(t,"boxes","nonMaxSuppression","float32"),o=dS(e,"scores","nonMaxSuppression","float32"),i=UC(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return rS.runKernel(Cw,{boxes:s,scores:o},l)}});function GC(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||jC)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function jC(t,e){return t>e?1:t<e?-1:0}function HC(t,e,n,r,a){return XC(t,e,n,r,a,0)}function KC(t,e,n,r,a,s){return XC(t,e,n,r,a,0,!1,s,!0)}function qC(t,e,n,r,a,s){return XC(t,e,n,r,a,s,!0)}function XC(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(ZC);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=JC(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*YC(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&GC(c,e,ZC))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function JC(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function YC(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function ZC(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const QC=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=dS(t,"boxes","nonMaxSuppressionAsync"),o=dS(e,"scores","nonMaxSuppressionAsync"),i=UC(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=HC(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),hC(h,"int32")};const $C=fS({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=dS(t,"boxes","nonMaxSuppression"),i=dS(e,"scores","nonMaxSuppression"),l=UC(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=rS.runKernel(Aw,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const tT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=dS(t,"boxes","nonMaxSuppressionAsync"),i=dS(e,"scores","nonMaxSuppressionAsync"),l=UC(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=qC(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:hC(d,"int32"),selectedScores:hC(p)}};const eT=fS({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=dS(t,"boxes","nonMaxSuppression"),i=dS(e,"scores","nonMaxSuppression"),l=UC(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=rS.runKernel(Tw,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const nT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=dS(t,"boxes","nonMaxSuppressionAsync"),i=dS(e,"scores","nonMaxSuppressionAsync"),l=UC(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=KC(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:hC(f,"int32"),validOutputs:wI(g,"int32")}};const rT=fS({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dS(t,"images","resizeBilinear");Xb(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Xb(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),Xb(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=ON(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=rS.runKernel(qw,i,l);return o?ON(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const aT=fS({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dS(t,"images","resizeNearestNeighbor");Xb(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Xb(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),Xb("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Xb(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=ON(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=rS.runKernel(Hw,i,l);return o?ON(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const sT=fS({bincount_:function(t,e,n){const r=dS(t,"x","bincount"),a=dS(e,"weights","bincount");Xb("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Xb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Xb(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return rS.runKernel($y,s,o)}});const oT=fS({lessEqual_:function(t,e){let n=dS(t,"a","lessEqual","string_or_numeric"),r=dS(e,"b","lessEqual","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(nw,a)}});const iT=fS({round_:function(t){const e={x:dS(t,"x","round")};return rS.runKernel(Zw,e)}});const lT=fS({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=dS(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=gI(hC([r]),255);if(Xb(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),Xb(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),Xb("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),Xb("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=iC(a,[1,1,1],-1);const t=gI(o,.2989),e=gI(i,.587),n=gI(l,.114);c=dI(dI(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=hC([-1]),c=hC([0]),u=hC([0]);for(let h=0;h<t.size-1;h++){n=tC(t,0,h+1),r=tC(t,h+1),o=fI(bE(n),e),i=fI(bE(r),e);const d=bE(gI(n,XE(0,n.size)));a=fI(d,bE(n));const p=TI(r.shape,n.size),f=dI(XE(0,r.size),p),g=gI(r,f);s=fI(bE(g),bE(r));const m=FI(a,s),b=FI(a,s),y=gI(o,i);u=gI(gI(y,m),b);const v=hE(u,c);c=gC(v,u,c),l=gC(v,hC([h]),l)}return l}(sT(uI(iT(c),"int32"),bS([]),256),s)}const h=n?oT(c,u):hE(c,u);return uI(gI(h,255),"int32")}});const cT=fS({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=dS(t,"image","transform","float32"),i=dS(e,"transforms","transform","float32");Xb(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Xb(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Xb(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return rS.runKernel(_x,l,c)}});const uT=fS({less_:function(t,e){let n=dS(t,"a","less","string_or_numeric"),r=dS(e,"b","less","string_or_numeric");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(ew,a)}});const hT=fS({bandPart_:function(t,e,n){const r=dS(t,"a","bandPart");Xb(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);let i,l;"number"===typeof e?(Xb(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),Xb(e<=s,(()=>"bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."))),i=dS(e<0?s:e,"numLower","bandPart")):(Xb("int32"===e.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=gC(uT(e,0),s,OE(e,s))),"number"===typeof n?(Xb(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Xb(n<=o,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."))),l=dS(n<0?o:n,"numUpper","bandPart")):(Xb("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=gC(uT(n,0),o,OE(n,o)));const c=ON(XE(0,s,1,"int32"),[-1,1]),u=XE(0,o,1,"int32"),h=FI(c,u),d=TE(oT(h,i),dE(h,LE(l))),p=BE([s,o],r.dtype);return ON(cC(fC(ON(r,[-1,s,o])).map((t=>gC(d,t,p)))),a)}});function dT(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return DI(t);if(1!==t.rank&&null===n)return dT(ON(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return bE(DI(t),n);if(e===1/0)return mE(DI(t),n);if(e===-1/0)return DE(DI(t),n);if("euclidean"===e||2===e)return mI(bE(RI(DI(t),wI(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return mE(bE(DI(t),n[0]),n[1]-1);if(e===1/0)return mE(bE(DI(t),n[1]),n[0]);if(e===-1/0)return DE(bE(DI(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return mI(bE(bI(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const pT=fS({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dT(t=dS(t,"x","norm"),e,n);let s=a.shape;if(r){const e=ay(n,t.shape);s=kE(a.shape,e)}return ON(a,s)}});const fT=fS({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Xb(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Xb(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=iC(t,t.shape[0],0).map((t=>lC(t,[0])));Xb(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(rS.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=gI(bE(gI(n[e],t)),n[e]);t=FI(t,r)}return fI(t,pT(t,"euclidean"))})));return e?cC(n,0):n}});function gT(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return rS.tidy((()=>{Xb(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=lE(n),s=hI(t);const o=dC([[1]],[1,1]);let i=hI(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=rS.tidy((()=>{const e=tC(s,[t,t],[n-t,1]),l=pT(e),c=tC(s,[t,t],[1,1]),u=gC(hE(c,0),dC([[-1]]),dC([[1]])),h=FI(c,gI(u,l)),d=fI(e,h);i=1===d.shape[0]?hI(o):GN([o,tC(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=LE(fI(AE(u,h),l)),f=tC(s,[t,0],[n-t,r]),g=gI(p,i),m=yC(i);if(0===t)s=FI(f,AE(g,AE(m,f)));else{const e=FI(f,AE(g,AE(m,f)));s=GN([tC(s,[0,0],[t,r]),e],0)}const b=yC(g),y=tC(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=FI(y,AE(AE(y,i),b));else{const e=FI(y,AE(AE(y,i),b));a=GN([tC(a,[0,0],[n,t]),e],1)}return[i,s,a]})),kS([e,l,c])}return!e&&n>r&&(a=tC(a,[0,0],[n,r]),s=tC(s,[0,0],[r,r])),[a,s]}))}const mT=fS({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Xb(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return gT(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=fC(ON(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=gT(t,e);a.push(n),s.push(r)}));return[ON(cC(a,0),t.shape),ON(cC(s,0),t.shape)]}}});var bT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(bT||(bT={}));const yT=fS({squaredDifference_:function(t,e){let n=dS(t,"a","squaredDifference"),r=dS(e,"b","squaredDifference");[n,r]=Jk(n,r),LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(wx,a,{})}});const vT={flipLeftRight:LC,grayscaleToRGB:MC,resizeNearestNeighbor:aT,resizeBilinear:rT,rgbToGrayscale:BC,rotateWithOffset:WC,cropAndResize:zC,nonMaxSuppression:VC,nonMaxSuppressionAsync:QC,nonMaxSuppressionWithScore:$C,nonMaxSuppressionWithScoreAsync:tT,nonMaxSuppressionPadded:eT,nonMaxSuppressionPaddedAsync:nT,threshold:lT,transform:cT},wT={bandPart:hT,gramSchmidt:fT,qr:mT};const xT=class{static sgd(t){return new BI(t)}static momentum(t,e){return new WI(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new UI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new _I(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new CI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new PI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new AI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},kT="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function ST(){return new Promise((t=>kT((()=>t()))))}function IT(t,e){const n=t[0].length;t.forEach(((t,e)=>{Xb(t.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(e,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Xb(e>=0&&e<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const r=t[0];t.forEach(((t,a)=>{for(let s=0;s<n;s++)Xb(s===e||t[s]===r[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(a,"] (").concat(t,") ")+"does not match the shape of the rest (".concat(r,") ")+"along the non-concatenated axis ".concat(a,".")))}))}function NT(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var ET;function CT(t,e,n){let r=new Array;if(null==n&&null==e)return r;if(null==e)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(null==n)return r;if(t+n.length!==r.length)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.rank = ").concat(t+n.length,", but shape.rank = ").concat(r.length));for(let a=1;a<n.length;++a){const s=n[a],o=r[r.length-n.length+a],i=r[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.shape[").concat(a+t,"] = ").concat(s," but shape[").concat(a+t,"] = ").concat(i))}else r[o]=s}return r}function TT(t){const e={FIRST_DIM_SIZE:ET.FIRST_DIM_SIZE,VALUE_ROWIDS:ET.VALUE_ROWIDS,ROW_LENGTHS:ET.ROW_LENGTHS,ROW_SPLITS:ET.ROW_SPLITS,ROW_LIMITS:ET.ROW_LIMITS,ROW_STARTS:ET.ROW_STARTS},n=[];for(const r of t){if(!(r in e))break;n.push(e[r])}return n}function AT(t){return 0===t.length?0:t[0]===ET.FIRST_DIM_SIZE?t.length-1:t.length}function RT(t,e){if(null==t||null==e)return;const n=t.length,r=e.length;if(n>=r)throw new Error("defaultValue.shape=".concat(t," and ragged tensor flatValues.shape=").concat(e,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(r,")"));for(let a=0;a<Math.min(n,r-1);++a){const n=t[a],r=e[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error("defaultValue.shape=".concat(t,", and ragged tensor input flatValues.shape=").concat(e," are incompatible: defaultValue.shape[").concat(a-t.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(a-t.length,"] = ").concat(r))}}!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(ET||(ET={}));const FT=30;function _T(t){return t<=FT?t:fy(t,Math.floor(Math.sqrt(t)))}function DT(t,e,n){return[n*("number"===typeof t?t:t[0]),e*("number"===typeof t?t:t[1])]}function OT(t,e,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let a=0;a<n;++a)r=r.concat([t[a+1]/e[a],e[a]]);r=r.concat(t.slice(n+1))}return r}function zT(t,e){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(e);for(let r=e+1;r<t;++r)r<=2*e?(n.push(r),n.push(r-(e+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<t;++n)n>=2*e+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function LT(t,e,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(t[0]/n):a.push(t[0]*n);for(let s=1;s<t.length;++s)s<=e.length?r?a.push(e[s-1]*t[s]):a.push(t[s]/e[s-1]):a.push(t[s]);return a}function MT(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function PT(t,e,n){const r=t.slice(0,1);for(let a=0;a<n;++a)r.push(t[a+1]-e[a][0]-e[a][1]);return r}function BT(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(r,"."));if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(e.shape[r-1]," vs. ").concat(n));if(0===Zb(t.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(t.shape,"."));const a=e.shape,s=a[a.length-1];let o=1;for(let h=0;h<a.length-1;++h)o*=a[h];const i=t.shape,l=a.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=i[h],l.push(i[h]);const u=[...gy(t.shape).map((t=>t/c)),1].slice(0,s);return[l,o,c,u]}function WT(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,a=e.rank>1?e.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(e.shape,", shape: ").concat(t)+", sliceDim: ".concat(r,", and batchDim: ").concat(a,".");if(n.rank<a)throw new Error(s+" update.rank < ".concat(a,". "));if(t.length<r+(n.rank-a))throw new Error(s+" Output shape length < ".concat(r+(n.rank-a)));if(n.rank!==a+t.length-r)throw new Error(s+" update.rank != ".concat(a+t.length-r));for(let o=0;o<a;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(e.shape[o],")."));for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==t[o+r])throw new Error(s+" updates.shape[".concat(o+a,"] (").concat(n.shape[o+a],") != shape[").concat(o+a,"] (").concat(t[o+a],")"))}function UT(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(e.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: ".concat(e.shape));if(0===t.size)throw new Error("Updates specified for empty output. updates shape: ".concat(t.shape))}WT(n,e,t)}function VT(t,e,n){const r=e.shape.length,a=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let l=a;l<s;++l)o*=n[l];const i=a<1?1:a;return{sliceRank:a,numUpdates:Zb(e.shape)/i,sliceSize:o,strides:[...gy(n.slice(0,a)),1],outputSize:Zb(n)}}const GT=1.7580993408473768,jT=1.0507009873554805,HT=.3275911,KT=.254829592,qT=-.284496736,XT=1.421413741,JT=-1.453152027,YT=1.061405429;function ZT(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(t.length,", imag: ").concat(e.length,"."));const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function QT(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function $T(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=0;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function tA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=2;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function eA(t,e){return{real:t[2*e],imag:t[2*e+1]}}function nA(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function rA(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let a=0;a<Math.ceil(t/2);a++){const s=(e?2:-2)*Math.PI*(a/t);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function aA(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const sA="->",oA=/->/g,iA=",",lA="...";function cA(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(oA,"").length)/sA.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(sA,'").'));const[r,a]=t.split(sA);Xb(-1===r.indexOf(lA),(()=>'The ellipsis notation ("'.concat(lA,'") is not supported yet.')));const s=r.split(iA),o=s.length;if(e!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(e));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<a.length;++h){const t=a[h];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error("Output subscripts contain the label ".concat(t," ")+"not present in the input subscripts.");-1===i.indexOf(t)&&i.push(t)}for(let h=0;h<r.length;++h){const t=r[h];-1===i.indexOf(t)&&t!==iA&&i.push(t)}const l=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");l[h]=[];for(let t=0;t<s[h].length;++t)l[h].push(i.indexOf(s[h][t]))}const c=i.length,u=[];for(let h=a.length;h<c;++h)u.push(h);return{allDims:i,summedDims:u,idDims:l}}function uA(t,e){let n=new Array(t);n.fill(-1);for(let a=0;a<e.length;++a)n[e[a]]=a;const r=[];for(let a=0;a<t;++a)-1===n[a]&&r.push(a);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function hA(t,e,n){const r=new Array(t);for(let a=0;a<n.length;++a){const t=n[a].shape;for(let n=0;n<e[a].length;++n)void 0===r[e[a][n]]?r[e[a][n]]=t[n]:Xb(r[e[a][n]]===t[n],(()=>"Expected dimension ".concat(r[e[a][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(t),", ")+"but got dimension ".concat(t[n])))}}function dA(t,e){const n=t,r=[];let a=0;0===t.length&&n.push(-1),a=t.length+1;for(let o=0;o<a;++o)r.push([]);const s=[];for(let o=0;o<n.length;++o){const t=fA(e,n[o]);for(const e of t)-1===s.indexOf(e)&&(r[o].push(e),s.push(e))}return{path:n,steps:r}}function pA(t){return t.every(((t,e)=>t===e))}function fA(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function gA(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof e)Xb(t.shape[n]%e===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{const a=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Xb(a<=1,(()=>"There should be only one negative value in split array."));const s=e.indexOf(-1);if(-1!==s){const r=e.reduce(((t,e)=>e>0?t+e:t));e[s]=t.shape[n]-r}Xb(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function mA(t){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(t)}function bA(t,e){return"indices(".concat(t,", 0) is invalid: ").concat(e," < 0")}function yA(t,e,n){return"indices(".concat(t,", 0) is invalid: ").concat(e," >= ").concat(n)}function vA(t,e){return"only one output dimension may be -1, not both ".concat(t," and ").concat(e)}function wA(t,e){return"size ".concat(t," must be non-negative, not ").concat(e)}function xA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function kA(t,e){const n=Zb(t),r=Zb(e);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(r,". inputShape=").concat(t," outputShape= ").concat(e)}function SA(t,e){const n=Zb(t),r=Zb(e);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(r,". inputShape=").concat(t," outputShape=").concat(e)}function IA(){return"segment ids must be >= 0"}function NA(){return"segment ids are not increasing"}function EA(t,e){return"Segment id ".concat(t," out of range [0, ").concat(e,"), possibly because segmentIds input is not sorted.")}function CA(t,e,n){return"Bad: indices[".concat(t,"] == ").concat(e," out of range [0, ").concat(n,")")}function TA(t,e){let n,r=!1;for(t<=FT?(n=t,r=!0):n=fy(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=fy(t,n+1);return n}function AA(t,e,n){const r=[],a=t.length;for(let s=0;s<a;s++)s!==e?r.push(t[s]):r.push(n);return r}function RA(t,e,n,r){const a=e.shape.length,s=t.shape.length;if(0!==r&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-".concat(a,", ").concat(a,"], but got ").concat(r));if(r<0&&(r+=a),r>s)throw new Error("batchDims (".concat(r,") must be less than rank(x) (\n    ").concat(s,")."));if(n<r)throw new Error("batchDims (".concat(r,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(t.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(e.shape[h],"."));const o=t.shape[n],i=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),c*=t.shape[h];for(let h=r;h<a;h++)i.push(e.shape[h]);for(let h=n+1;h<s;h++)i.push(t.shape[h]),u*=t.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:i}}function FA(t){try{return t.map((t=>yk(t)))}catch(i1){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(i1))}}function _A(t){return t.map((t=>bk(t)))}function DA(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const r=cI(t,"int32"),a=cI([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const e=r.indexToLoc(n[s]),o=s*t.length;a.values.set(e,o)}return a.toTensor()}!function(){for(const t of VI)NI(t)}();const OA={kernelName:Dy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,EC(uI(n,"float32"),-1))}}},zA={kernelName:Oy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=bI(uI(n,"float32")),r=mI(FI(wI(1),e));return LE(fI(t,r))}}}},LA={kernelName:zy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=mI(FI(bI(uI(n,"float32")),1));return fI(t,e)}}}},MA={kernelName:Ly,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{let e=t;const r=zI(n.shape,a);return r.length>0&&(e=bE(e,r)),ON(e,n.shape)},b:()=>{let e=t;const n=zI(r.shape,a);return n.length>0&&(e=bE(e,n)),ON(e,r.shape)}}}},PA={kernelName:My,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},BA={kernelName:Wy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yI(n)}}},WA={kernelName:Uy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yI(n)}}},UA={kernelName:Vy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,mI(FI(wI(1),bI(uI(n,"float32")))))}}},VA={kernelName:Gy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=mI(dI(wI(1),bI(uI(n,"float32"))));return fI(t,e)}}}},GA={kernelName:Ky,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{const e=dI(bI(n),bI(r));let s=gI(t,fI(r,e));const o=zI(n.shape,a);return o.length>0&&(s=bE(s,o)),ON(s,n.shape)},b:()=>{const e=dI(bI(n),bI(r));let s=LE(gI(t,fI(n,e)));const o=zI(r.shape,a);return o.length>0&&(s=bE(s,o)),ON(s,r.shape)}}}},jA={kernelName:jy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,dI(bI(uI(n,"float32")),1))}}},HA={kernelName:Hy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,FI(wI(1),bI(uI(n,"float32"))))}}};const KA=fS({avgPool3dGrad_:function(t,e,n,r,a,s){const o=dS(t,"dy","avgPool3dGrad"),i=dS(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=ON(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ON(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Xb(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),Xb(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),DN("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=rS.runKernel(Yy,h,d);return u?ON(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),qA={kernelName:Jy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>KA(t,r,a,s,o,i)}}};const XA=fS({avgPoolGrad_:function(t,e,n,r,a){const s=dS(t,"dy","avgPoolGrad"),o=dS(e,"input","avgPoolGrad");Xb(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=ON(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ON(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Xb(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),Xb(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=rS.runKernel(Xy,u,h);return c?ON(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),JA={kernelName:qy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>XA(t,r,a,s,o)}}},YA={kernelName:Zy,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>AE(t,a,!1,!1),b:()=>AE(t,r,!0,!1)}:s&&!o?{a:()=>AE(a,t,!1,!0),b:()=>AE(r,t,!1,!1)}:{a:()=>AE(a,t,!0,!0),b:()=>AE(t,r,!0,!0)}:{a:()=>AE(t,a,!1,!0),b:()=>AE(r,t,!0,!1)}}};const ZA=fS({spaceToBatchND_:function(t,e,n){const r=dS(t,"x","spaceToBatchND");Xb(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),Xb(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),Xb(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return rS.runKernel(dx,a,s)}}),QA={kernelName:Qy,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>ZA(t,r,a)}}},$A={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>bE(t,i,!0)}}},tR={kernelName:nv,gradFunc:t=>({x:()=>t.clone()})},eR={kernelName:rv,gradFunc:t=>({x:()=>yI(t)})},nR={kernelName:av,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>gC(TE(dE(r,a),oT(r,s)),t,yI(t))}}},rR={kernelName:ov,inputsToSave:["x"],gradFunc:OA.gradFunc},aR={kernelName:iv,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=ay(a,e[0].shape)[0],o=r.map((t=>t[s]));return iC(t,o,s).map((t=>()=>t))}},sR={kernelName:lv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return Xb(AN(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>YN(r.shape,t,a,o,i,l),filter:()=>IC(r,t,a.shape,o,i,l)}}},oR={kernelName:uv,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>XN(t,a,s,o,i,1,l),filter:()=>IC(t,r,a.shape,s,o,i,l)}}};const iR=fS({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=ON(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=ON(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),Xb(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),Xb(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),Xb(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Xb(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Xb(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return rS.runKernel(dv,i,l)}}),lR={kernelName:hv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;Xb(AN(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>$N(o.shape,t,i,a,s),filter:()=>iR(o,t,i.shape,a,s)}}};const cR=fS({sin_:function(t){const e={x:dS(t,"x","sin","float32")};return rS.runKernel(sx,e)}}),uR={kernelName:fv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(LE(cR(uI(n,"float32"))),t)}}};const hR=fS({sinh_:function(t){const e={x:dS(t,"x","sinh")};return rS.runKernel(ox,e)}}),dR={kernelName:gv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(hR(uI(n,"float32")),t)}}};const pR=fS({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:dS(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return rS.runKernel(bv,a,s)}}),fR={kernelName:bv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=IE([a],r.rank);let n=pR(t,a,s,!o);return null!=e&&(n=yC(n,e)),n}}}},gR={kernelName:xv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;Xb(AN(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return Xb(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),Xb(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),Xb(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),Xb(RN(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),DN("depthwiseConv2d",s,o),{x:()=>DC(l.shape,t,c,a,s,i,o),filter:()=>_C(l,t,c.shape,a,s,i,o)}}},mR={kernelName:Nv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>rS.runKernel(Ev,s,n),filter:()=>rS.runKernel(Cv,o,n)}}},bR={kernelName:Fv,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>rS.runKernel(_v,r)}}},yR={kernelName:Dv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=gI(sE(LE(bI(n))),2/Math.sqrt(Math.PI));return{x:()=>gI(t,r)}}},vR={kernelName:zv,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,n)}}},wR={kernelName:Lv,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>ON(t,n.shape)}}},xR={kernelName:Mv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,sE(n))}}},kR={kernelName:Uv,gradFunc:t=>({x:()=>yI(t)})},SR={kernelName:Vv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{const e=fI(t,uI(r,"float32")),s=zI(n.shape,a);return s.length>0?ON(bE(e,s),n.shape):e},b:()=>{let e=gI(t,uI(n,"float32"));const s=zI(r.shape,a);s.length>0&&(e=ON(bE(e,s),r.shape));const o=bI(r);return LE(fI(e,uI(o,"float32")))}}}};const IR=fS({rsqrt_:function(t){const e={x:dS(t,"x","rsqrt","float32")};return rS.runKernel(Qw,e)}}),NR={kernelName:Gv,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?wI(1):i,c=zI(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=FI(a,s),d=gI(t,l),p=IR(dI(o,wI(r))),f=gI(gI(gI(p,p),p),wI(-.5));return{x:()=>1===s.rank?ON(gI(gI(t,iE(ON(p,[1,1,1,s.shape[0]]),u)),l),a.shape):ON(gI(gI(t,p),l),a.shape),mean:()=>{let t=gI(gI(p,wI(-1)),d);return 1===s.rank&&(t=bE(t,c)),ON(t,s.shape)},variance:()=>{let t=gI(gI(f,h),d);return 1===s.rank&&(t=bE(t,c)),ON(t,s.shape)},scale:()=>{const e=gI(h,p);let n=gI(t,e);return 1===s.rank&&(n=bE(n,c)),ON(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=bE(e,c)),ON(e,s.shape)}}}};const ER=fS({unsortedSegmentSum_:function(t,e,n){const r=dS(t,"x","unsortedSegmentSum"),a=dS(e,"segmentIds","unsortedSegmentSum","int32");Xb($b(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return rS.runKernel(Lx,s,o)}}),CR={kernelName:jv,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s,batchDims:o}=n,i=ay(s,r.shape)[0],l=(t,e,n)=>()=>{const r=t.shape,a=e.size,o=r.slice(0,i),l=o.length,c=r.slice(s,r.length).slice(1),u=c.length,h=TR(0,l),d=TR(l+1,l+1+u),p=AR([o,[a],c]),f=ON(n,p),g=ON(e,[a]),m=AR([[l],h,d]),b=yC(f,m);let y=ER(b,g,t.shape[i]);const v=NE(m);return y=yC(y,v),y};if(1===o){const e=r.shape[0],n=r.split(e,0);return{x:()=>{const e=cC(n.map(((e,n)=>l(e,a.slice(n,1),t.slice(n,1))())));return e.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,t),indices:()=>a}}};function TR(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function AR(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const RR={kernelName:qv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>yI(n),b:()=>yI(r)}}},FR={kernelName:Xv,gradFunc:t=>({x:()=>uI(t,"float32")})},_R={kernelName:Zv,gradFunc:t=>({x:()=>yI(t)})},DR={kernelName:Qv,gradFunc:t=>({x:()=>yI(t)})},OR={kernelName:$v,gradFunc:t=>({x:()=>yI(t)})},zR={kernelName:tw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=hE(r,0);return{x:()=>gC(s,t,gI(t,a))}}},LR={kernelName:sw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,dI(n,1))}}},MR={kernelName:aw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,uI(n,"float32"))}}},PR={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=sE(r);return FI(t,gI(bE(t,a,!0),e))}}}};const BR=fS({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return rS.runKernel(uw,r,a)}}),WR={kernelName:cw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>BR(r,a,t,s,o,i,l)}}};function UR(t,e,n,r){return e.rank<n.rank&&(e=ON(e,kE(e.shape,r))),t.rank<n.rank&&(t=ON(t,kE(t.shape,r))),{x:()=>gI(t,uI(aE(n,e),t.dtype))}}const VR={kernelName:hw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=UR(t,e[1],s,ay(a,s.shape));return{x:()=>o.x()}}},GR={kernelName:dw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>gI(t,uI(dE(n,r),"float32")),b:()=>gI(t,uI(uT(n,r),"float32"))}}};const jR=fS({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=dS(t,"dy","maxPool3dGrad"),l=dS(e,"input","maxPool3dGrad"),c=dS(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=ON(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=ON(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ON(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Xb(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Xb(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Xb(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),DN("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=rS.runKernel(mw,f,g);return p?ON(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),HR={kernelName:gw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>jR(t,r,a,s,o,i,l)}}};const KR=fS({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=dS(t,"dy","maxPoolGrad"),l=dS(e,"input","maxPoolGrad"),c=dS(n,"output","maxPoolGrad");Xb(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),Xb(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),Xb(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),DN("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return rS.runKernel(fw,u,h)}}),qR={kernelName:pw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>KR(t,r,a,s,o,i)}}},XR={kernelName:yw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=ay(a,r.shape),o=Zb(xE(r.shape,s)[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=ON(t,e);return fI(gI(n,WE(r.shape,"float32")),o)}}}},JR={kernelName:vw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=UR(t,o,s,ay(a,s.shape));return{x:()=>i.x()}}},YR={kernelName:ww,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>gI(t,uI(oT(n,r),"float32")),b:()=>gI(t,uI(hE(n,r),"float32"))}}},ZR={kernelName:xw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>tC(t,s,r.shape)}}},QR={kernelName:kw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{const e=zI(n.shape,a);return e.length>0?ON(bE(t,e),n.shape):t},b:()=>{const e=gI(t,LE(cE(fI(n,r)))),s=zI(r.shape,a);return s.length>0?ON(bE(e,s),r.shape):e}}}},$R={kernelName:Iw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{const e=gI(t,uI(r,"float32")),s=zI(n.shape,a);return s.length>0?ON(bE(e,s),n.shape):e},b:()=>{const e=gI(t,uI(n,"float32")),s=zI(r.shape,a);return s.length>0?ON(bE(e,s),r.shape):e}}}},tF={kernelName:Nw,gradFunc:t=>({x:()=>LE(t)})},eF={kernelName:Fw,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>BE(n.shape,"float32")}}},nF={kernelName:Rw,gradFunc:t=>({x:()=>yI(t)})},rF={kernelName:_w,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return fC(t,r).map((t=>()=>t))}},aF={kernelName:Dw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>tC(t,s,r.shape)}}},sF={kernelName:Ow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=LI(s.shape,o.shape);return{a:()=>{const e=uI(o,"float32");let n=gI(t,gI(e,RI(s,FI(e,wI(1)))));const r=zI(s.shape,i);return r.length>0&&(n=bE(n,r)),ON(n,s.shape)},b:()=>{const e=hE(s,0),n=gC(e,fE(s),yI(s));let r=gI(t,gI(a,n));const l=zI(o.shape,i);return l.length>0&&(r=bE(r,l)),ON(r,o.shape)}}}},oF={kernelName:zw,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=hE(n,0);return{x:()=>gC(a,t,gI(t,r)),alpha:()=>{let e=gC(a,yI(t),gI(t,n));const s=zI(r.shape,t.shape);return s.length>0&&(e=bE(e,s)),ON(e,r.shape)}}}};const iF=fS({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:dS(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return rS.runKernel(mv,a,s)}});function lF(t,e,n){const r=t.shape.length,a=r-n.length,s=IE(n,r);let o=t;null!=s&&(o=yC(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=ON(e,r),s=iF(t,n,!0,!1),o=iF(t,n,!0,!0),i=gI(s,o);return gI(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=NE(s);c=yC(c,t)}return c}const cF={kernelName:Lw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>lF(r,t,s)}}},uF={kernelName:Av,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{const e=fI(t,uI(r,"float32")),s=zI(n.shape,a);return s.length>0?ON(bE(e,s),n.shape):e},b:()=>{let e=gI(t,uI(n,"float32"));const s=zI(r.shape,a);s.length>0&&(e=ON(bE(e,s),r.shape));const o=bI(r);return LE(fI(e,uI(o,"float32")))}}}},hF={kernelName:Vw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,LE(bI(n)))}}},dF={kernelName:Jw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=gI(oT(n,6),EC(n));return{x:()=>gI(t,uI(r,"float32"))}}},pF={kernelName:Gw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,uI(EC(n),"float32"))}}},fF={kernelName:jw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ON(t,n.shape)}}},gF={kernelName:qw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>rS.runKernel(Xw,a,n)}}},mF={kernelName:Hw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>rS.runKernel(Kw,a,n)}}},bF={kernelName:Yw,gradFunc:(t,e,n)=>{const{dims:r}=n,a=ay(r,t.shape);return{x:()=>YE(t,a)}}},yF={kernelName:Zw,gradFunc:t=>({x:()=>yI(t)})},vF={kernelName:Qw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>LE(fI(t,gI(RI(n,1.5),2)))}}};const wF=fS({logicalNot_:function(t){const e={x:dS(t,"x","logicalNot","bool")};return rS.runKernel(iw,e)}}),xF={kernelName:nx,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>uI(yI(n),"float32"),t:()=>gI(t,uI(n,t.dtype)),e:()=>gI(t,uI(wF(n),t.dtype))}}},kF={kernelName:rx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=hE(n,wI(0)),r=wI(GT),a=wI(jT),s=gI(t,a),o=gI(gI(t,r),sE(uI(n,"float32")));return gC(e,s,o)}}}},SF={kernelName:lx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,gI(n,FI(wI(1),n)))}}},IF={kernelName:ix,gradFunc:t=>({x:()=>yI(t)})};const NF=fS({cos_:function(t){const e={x:dS(t,"x","cos","float32")};return rS.runKernel(fv,e)}}),EF={kernelName:sx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(NF(uI(n,"float32")),t)}}};const CF=fS({cosh_:function(t){const e={x:dS(t,"x","cosh","float32")};return rS.runKernel(gv,e)}}),TF={kernelName:ox,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(CF(uI(n,"float32")),t)}}},AF={kernelName:ax,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=pN(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>VE(t,c)}}},RF={kernelName:fx,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=gI(t,r);return{logits:()=>FI(s,gI(bE(s,[a],true),r))}}},FF={kernelName:cx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,$E(n))}}};const _F=fS({batchToSpaceND_:function(t,e,n){const r=dS(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));Xb(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),Xb(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),Xb(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return rS.runKernel(Qy,s,o)}}),DF={kernelName:dx,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>_F(t,r,a)}}},OF={kernelName:px,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>GN(t,r)}}};const zF=[OA,zA,LA,MA,PA,BA,WA,UA,VA,GA,jA,HA,qA,JA,YA,QA,$A,tR,eR,nR,rR,aR,oR,sR,lR,uR,dR,fR,gR,mR,uF,bR,yR,vR,wR,xR,SR,kR,NR,CR,RR,FR,_R,DR,OR,zR,LR,MR,PR,WR,VR,VR,GR,HR,qR,XR,JR,YR,ZR,QR,$R,tF,eF,nF,rF,aF,aF,sF,oF,cF,hF,dF,pF,fF,gF,mF,bF,yF,vF,xF,kF,SF,IF,EF,TF,AF,RF,FF,DF,DF,OF,OF,{kernelName:ux,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,gI(mI(uI(n,"float32")),2))}}},{kernelName:wx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=wI(2);return{a:()=>gI(t,gI(a,FI(n,r))),b:()=>gI(t,gI(a,FI(r,n)))}}},{kernelName:xx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,gI(uI(n,"float32"),2))}}},{kernelName:Px,gradFunc:t=>({x:()=>yI(t)})},{kernelName:Cx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=LI(n.shape,r.shape);return{a:()=>{let e=t;const r=zI(n.shape,a);return r.length>0&&(e=bE(e,r)),ON(e,n.shape)},b:()=>{let e=t;const n=zI(r.shape,a);return n.length>0&&(e=bE(e,n)),ON(LE(e),r.shape)}}}},{kernelName:hx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;ay(s,r.shape).forEach((t=>{a[t]=1}));const o=ON(t,a),i=gI(o,WE(r.shape,"float32"));return{x:()=>i}}},{kernelName:Tx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>fI(t,bI(NF(n)))}}},{kernelName:Ax,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(FI(wI(1),bI(n)),t)}}},{kernelName:Rx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=yI(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=dI(e,tC(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=dI(e,tC(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=dI(e,tC(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=dI(e,tC(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Dx,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=NE(a);return{x:()=>yC(t,s)}}},{kernelName:zx,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>cC(t,a)}}},{kernelName:Lx,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=MI(e,yI(e)),r=uE(t,n);let a=dE(e,wI(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=oE(a,i+1);a=TE(a,WE(r.shape,"bool"));const o=yI(r);return gC(a,r,o)}(t,n)}}},{kernelName:Mx,gradFunc:t=>({x:()=>yI(t)})}];for(const n of zF)Qx(n);Mk().prototype.abs=function(){return this.throwIfDisposed(),DI(this)};const LF=fS({acos_:function(t){const e={x:dS(t,"x","acos")};return rS.runKernel(Oy,e)}});Mk().prototype.acos=function(){return this.throwIfDisposed(),LF(this)};const MF=fS({acosh_:function(t){const e={x:dS(t,"x","acosh")};return rS.runKernel(zy,e)}});Mk().prototype.acosh=function(){return this.throwIfDisposed(),MF(this)},Mk().prototype.add=function(t){return this.throwIfDisposed(),dI(this,t)},Mk().prototype.all=function(t,e){return this.throwIfDisposed(),mN(this,t,e)},Mk().prototype.any=function(t,e){return this.throwIfDisposed(),bN(this,t,e)},Mk().prototype.argMax=function(t){return this.throwIfDisposed(),yN(this,t)};const PF=fS({argMin_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:dS(t,"x","argMin")},r={axis:e};return rS.runKernel(Uy,n,r)}});Mk().prototype.argMin=function(t){return this.throwIfDisposed(),PF(this,t)},Mk().prototype.asScalar=function(){return this.throwIfDisposed(),Xb(1===this.size,(()=>"The array must have only 1 element.")),ON(this,[])},Mk().prototype.asType=function(t){return this.throwIfDisposed(),uI(this,t)},Mk().prototype.as1D=function(){return this.throwIfDisposed(),ON(this,[this.size])},Mk().prototype.as2D=function(t,e){return this.throwIfDisposed(),ON(this,[t,e])},Mk().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),ON(this,[t,e,n])},Mk().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),ON(this,[t,e,n,r])},Mk().prototype.as5D=function(t,e,n,r,a){return this.throwIfDisposed(),ON(this,[t,e,n,r,a])};const BF=fS({asin_:function(t){const e={x:dS(t,"x","asin")};return rS.runKernel(Vy,e)}});Mk().prototype.asin=function(){return this.throwIfDisposed(),BF(this)};const WF=fS({asinh_:function(t){const e={x:dS(t,"x","asinh")};return rS.runKernel(Gy,e)}});Mk().prototype.asinh=function(){return this.throwIfDisposed(),WF(this)};const UF=fS({atan_:function(t){const e={x:dS(t,"x","atan")};return rS.runKernel(jy,e)}});Mk().prototype.atan=function(){return this.throwIfDisposed(),UF(this)};const VF=fS({atan2_:function(t,e){let n=dS(t,"a","atan2"),r=dS(e,"b","atan2");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(Ky,a)}});Mk().prototype.atan2=function(t){return this.throwIfDisposed(),VF(this,t)};const GF=fS({atanh_:function(t){const e={x:dS(t,"x","atanh")};return rS.runKernel(Hy,e)}});Mk().prototype.atanh=function(){return this.throwIfDisposed(),GF(this)},Mk().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),zN(this,t,e,n,r)},Mk().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),_F(this,t,e)},Mk().prototype.batchNorm=function(t,e,n,r,a){return this.throwIfDisposed(),MN(this,t,e,n,r,a)},Mk().prototype.broadcastTo=function(t){return this.throwIfDisposed(),UN(this,t)},Mk().prototype.cast=function(t){return this.throwIfDisposed(),uI(this,t)};const jF=fS({ceil_:function(t){const e={x:dS(t,"x","ceil","float32")};return rS.runKernel(rv,e)}});Mk().prototype.ceil=function(){return this.throwIfDisposed(),jF(this)},Mk().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),VN(this,t,e)},Mk().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Lk&&(t=[t]),GN([this,...t],e)},Mk().prototype.conv1d=function(t,e,n,r,a,s){return this.throwIfDisposed(),JN(this,t,e,n,r,a,s)},Mk().prototype.conv2dTranspose=function(t,e,n,r,a){return this.throwIfDisposed(),ZN(this,t,e,n,r,a)},Mk().prototype.conv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),XN(this,t,e,n,r,a,s)},Mk().prototype.cos=function(){return this.throwIfDisposed(),NF(this)},Mk().prototype.cosh=function(){return this.throwIfDisposed(),CF(this)},Mk().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),iF(this,t,e,n)},Mk().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),pR(this,t,e,n)};const HF=fS({depthToSpace_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=dS(t,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];Xb(e>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(e))),Xb(a*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(a," and ").concat(e,"  for depthToSpace with input shape\n    ").concat(r.shape))),Xb(s*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(e," for depthToSpace with input shape\n        ").concat(r.shape))),Xb(o%(e*e)===0,(()=>"Dimension size must be evenly divisible by ".concat(e*e," but is ").concat(o," for depthToSpace with input shape ").concat(r.shape)));const i={x:r},l={blockSize:e,dataFormat:n};return rS.runKernel(wv,i,l)}});Mk().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),HF(this,t,e)},Mk().prototype.depthwiseConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),nE(this,t,e,n,r,a,s)};const KF=fS({dilation2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=dS(t,"x","dilation2d"),i=dS(e,"filter","dilation2d");Xb(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),Xb(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Xb("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let l=o,c=!1;3===o.rank&&(l=ON(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),Xb(l.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(l.shape[3]," vs ").concat(i.shape[2])));const u={x:l,filter:i},h={strides:n,pad:r,dilations:a},d=rS.runKernel(Nv,u,h);return c?ON(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});Mk().prototype.dilation2d=function(t,e,n,r,a){return this.throwIfDisposed(),KF(this,t,e,n,r,a)};const qF=fS({divNoNan_:function(t,e){let n=dS(t,"a","div"),r=dS(e,"b","div");[n,r]=Jk(n,r);const a=fI(n,r),s=yI(a),o=aE(r,s);return gC(o,s,a)}});Mk().prototype.divNoNan=function(t){return this.throwIfDisposed(),qF(this,t)},Mk().prototype.div=function(t){return this.throwIfDisposed(),fI(this,t)};const XF=fS({dot_:function(t,e){const n=dS(t,"t1","dot"),r=dS(e,"t2","dot");Xb((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(r.rank,".")));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Xb(a===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(a," and ").concat(s,"."))),1===n.rank&&1===r.rank){const t=ON(n,[1,-1]),e=ON(r,[-1,1]),a=AE(t,e);return ON(a,[])}if(1===n.rank&&2===r.rank){const t=ON(n,[1,-1]),e=ON(r,[r.shape[0],r.shape[1]]),a=AE(t,e);return ON(a,[a.size])}if(2===n.rank&&1===r.rank){const t=ON(r,[-1,1]),e=AE(n,t);return ON(e,[e.size])}{const t=ON(r,[r.shape[0],r.shape[1]]);return AE(n,t)}}});Mk().prototype.dot=function(t){return this.throwIfDisposed(),XF(this,t)},Mk().prototype.elu=function(){return this.throwIfDisposed(),rE(this)},Mk().prototype.equal=function(t){return this.throwIfDisposed(),aE(this,t)};const JF=fS({erf_:function(t){let e=dS(t,"x","erf");Xb("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=uI(e,"float32"));const n={x:e};return rS.runKernel(Dv,n)}});Mk().prototype.erf=function(){return this.throwIfDisposed(),JF(this)};const YF=fS({euclideanNorm_:function(t){return pT(t,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Mk().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),YF(this,t,e)},Mk().prototype.exp=function(){return this.throwIfDisposed(),sE(this)},Mk().prototype.expandDims=function(t){return this.throwIfDisposed(),oE(this,t)};const ZF=fS({expm1_:function(t){const e={x:dS(t,"x","expm1")};return rS.runKernel(Mv,e)}});Mk().prototype.expm1=function(){return this.throwIfDisposed(),ZF(this)},Mk().prototype.fft=function(){return this.throwIfDisposed(),wC(this)},Mk().prototype.flatten=function(){return this.throwIfDisposed(),ON(this,[this.size])},Mk().prototype.floor=function(){return this.throwIfDisposed(),cE(this)},Mk().prototype.floorDiv=function(t){return this.throwIfDisposed(),pI(this,t)},Mk().prototype.gather=function(t,e,n){return this.throwIfDisposed(),uE(this,t,e,n)},Mk().prototype.greaterEqual=function(t){return this.throwIfDisposed(),dE(this,t)},Mk().prototype.greater=function(t){return this.throwIfDisposed(),hE(this,t)},Mk().prototype.ifft=function(){return this.throwIfDisposed(),kC(this)},Mk().prototype.irfft=function(){return this.throwIfDisposed(),SC(this)};const QF=fS({isFinite_:function(t){const e={x:dS(t,"x","isFinite")};return rS.runKernel(Zv,e)}});Mk().prototype.isFinite=function(){return this.throwIfDisposed(),QF(this)};const $F=fS({isInf_:function(t){const e={x:dS(t,"x","isInf")};return rS.runKernel(Qv,e)}});Mk().prototype.isInf=function(){return this.throwIfDisposed(),$F(this)};const t_=fS({isNaN_:function(t){const e={x:dS(t,"x","isNaN")};return rS.runKernel($v,e)}});Mk().prototype.isNaN=function(){return this.throwIfDisposed(),t_(this)},Mk().prototype.leakyRelu=function(t){return this.throwIfDisposed(),pE(this,t)},Mk().prototype.lessEqual=function(t){return this.throwIfDisposed(),oT(this,t)},Mk().prototype.less=function(t){return this.throwIfDisposed(),uT(this,t)};const e_=fS({localResponseNormalization_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=dS(t,"x","localResponseNormalization");Xb(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),Xb($b(e),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(e,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=ON(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:n,alpha:r,beta:a},u=rS.runKernel(cw,l,c);return i?ON(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Mk().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),e_(this,t,e,n,r)};const n_=fS({logSigmoid_:function(t){const e=dS(t,"x","logSigmoid");return vI((t=>({value:LE(oC(LE(t))),gradFunc:e=>gI(e,$E(LE(t)))})))(e)}});Mk().prototype.logSigmoid=function(){return this.throwIfDisposed(),n_(this)},Mk().prototype.logSoftmax=function(t){return this.throwIfDisposed(),yE(this,t)},Mk().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),CE(this,t,e)},Mk().prototype.log=function(){return this.throwIfDisposed(),fE(this)},Mk().prototype.log1p=function(){return this.throwIfDisposed(),gE(this)},Mk().prototype.logicalAnd=function(t){return this.throwIfDisposed(),TE(this,t)},Mk().prototype.logicalNot=function(){return this.throwIfDisposed(),wF(this)};const r_=fS({logicalOr_:function(t,e){const n=dS(t,"a","logicalOr","bool"),r=dS(e,"b","logicalOr","bool");LI(n.shape,r.shape);const a={a:n,b:r};return rS.runKernel(lw,a)}});Mk().prototype.logicalOr=function(t){return this.throwIfDisposed(),r_(this,t)};const a_=fS({logicalXor_:function(t,e){const n=dS(t,"a","logicalXor","bool"),r=dS(e,"b","logicalXor","bool");return LI(n.shape,r.shape),TE(r_(t,e),wF(TE(t,e)))}});Mk().prototype.logicalXor=function(t){return this.throwIfDisposed(),a_(this,t)},Mk().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),AE(this,t,e,n)},Mk().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),RE(this,t,e,n,r)},Mk().prototype.max=function(t,e){return this.throwIfDisposed(),mE(this,t,e)},Mk().prototype.maximum=function(t){return this.throwIfDisposed(),MI(this,t)},Mk().prototype.mean=function(t,e){return this.throwIfDisposed(),_E(this,t,e)},Mk().prototype.min=function(t,e){return this.throwIfDisposed(),DE(this,t,e)},Mk().prototype.minimum=function(t){return this.throwIfDisposed(),OE(this,t)};const s_=fS({mirrorPad_:function(t,e,n){Xb("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const r=dS(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Xb(e.length===r.rank,(()=>"Padding doesn't match input. Must be ".concat(r.rank,". ")+"Got ".concat(e.length,".")));const a="reflect"===n?1:0;for(let i=0;i<r.rank;i++)Xb(2===e[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Xb(e[i][0]>=0&&e[i][0]<=r.shape[i]-a&&e[i][1]>=0&&e[i][1]<=r.shape[i]-a,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(r.shape[i]-a," or less than 0 for input of ")+"shape ".concat(r.shape)));const s={paddings:e,mode:n},o={x:r};return rS.runKernel(xw,o,s)}});Mk().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),s_(this,t,e)};const o_=fS({mod_:function(t,e){let n=dS(t,"a","mod"),r=dS(e,"b","mod");[n,r]=Jk(n,r);const a={a:n,b:r};return rS.runKernel(kw,a)}});Mk().prototype.mod=function(t){return this.throwIfDisposed(),o_(this,t)},Mk().prototype.mul=function(t){return this.throwIfDisposed(),gI(this,t)},Mk().prototype.neg=function(){return this.throwIfDisposed(),LE(this)},Mk().prototype.norm=function(t,e,n){return this.throwIfDisposed(),pT(this,t,e,n)},Mk().prototype.notEqual=function(t){return this.throwIfDisposed(),ME(this,t)},Mk().prototype.oneHot=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),PE(this,t,e,n)},Mk().prototype.onesLike=function(){return this.throwIfDisposed(),UE(this)},Mk().prototype.pad=function(t,e){return this.throwIfDisposed(),VE(this,t,e)};const i_=fS({pool_:function(t,e,n,r,a,s,o){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=dS(t,"x","maxPool");let l=i,c=!1;3===i.rank&&(c=!0,l=ON(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Xb(RN(s,a),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(a,"'")));const u=wN(l.shape,e,s,a,r),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))),r=n.map((t=>t-1)),a=r.map((t=>Math.floor(t/2))),s=r.map(((t,e)=>t-a[e]));return r.map(((t,e)=>[a[e],s[e]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(t,e,n){const r=n.map((t=>t[0])),a=n.map((t=>t[1])),s=t.concat(r,a),o=e.map(((t,e)=>(t-s[e]%t)%t)),i=a.map(((t,e)=>t+o[e])),l=e.map(((t,e)=>[r[e],i[e]])),c=e.map(((t,e)=>[0,o[e]]));return[l,c]}([u.inHeight,u.inWidth],h,d),m=p?r:"valid",b=p?l:ZA(l,h,f),y=("avg"===n?()=>zN(b,e,s,m,o):()=>RE(b,e,s,m,o))(),v=p?y:_F(y,h,g);return c?ON(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Mk().prototype.pool=function(t,e,n,r,a,s){return this.throwIfDisposed(),i_(this,t,e,n,r,a,s)},Mk().prototype.pow=function(t){return this.throwIfDisposed(),RI(this,t)},Mk().prototype.prelu=function(t){return this.throwIfDisposed(),GE(this,t)};const l_=fS({prod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=dS(t,"x","prod");"bool"===r.dtype&&(r=uI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return rS.runKernel(Lw,a,s)}});Mk().prototype.prod=function(t,e){return this.throwIfDisposed(),l_(this,t,e)};const c_=fS({reciprocal_:function(t){const e={x:dS(t,"x","reciprocal")};return rS.runKernel(Vw,e)}});Mk().prototype.reciprocal=function(){return this.throwIfDisposed(),c_(this)},Mk().prototype.relu=function(){return this.throwIfDisposed(),JE(this)},Mk().prototype.relu6=function(){return this.throwIfDisposed(),NC(this)},Mk().prototype.reshapeAs=function(t){return this.throwIfDisposed(),ON(this,t.shape)},Mk().prototype.reshape=function(t){return this.throwIfDisposed(),ON(this,t)},Mk().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),rT(this,t,e,n)},Mk().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),aT(this,t,e,n)},Mk().prototype.reverse=function(t){return this.throwIfDisposed(),YE(this,t)},Mk().prototype.rfft=function(){return this.throwIfDisposed(),xC(this)},Mk().prototype.round=function(){return this.throwIfDisposed(),iT(this)},Mk().prototype.rsqrt=function(){return this.throwIfDisposed(),IR(this)},Mk().prototype.selu=function(){return this.throwIfDisposed(),ZE(this)},Mk().prototype.separableConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),QE(this,t,e,n,r,a,s)},Mk().prototype.sigmoid=function(){return this.throwIfDisposed(),$E(this)};const u_=fS({sign_:function(t){const e={x:dS(t,"x","sign")};return rS.runKernel(ix,e)}});Mk().prototype.sign=function(){return this.throwIfDisposed(),u_(this)},Mk().prototype.sin=function(){return this.throwIfDisposed(),cR(this)},Mk().prototype.sinh=function(){return this.throwIfDisposed(),hR(this)},Mk().prototype.slice=function(t,e){return this.throwIfDisposed(),tC(this,t,e)},Mk().prototype.softmax=function(t){return this.throwIfDisposed(),sC(this,t)},Mk().prototype.softplus=function(){return this.throwIfDisposed(),oC(this)},Mk().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),ZA(this,t,e)},Mk().prototype.split=function(t,e){return this.throwIfDisposed(),iC(this,t,e)},Mk().prototype.sqrt=function(){return this.throwIfDisposed(),mI(this)},Mk().prototype.square=function(){return this.throwIfDisposed(),bI(this)},Mk().prototype.squaredDifference=function(t){return this.throwIfDisposed(),yT(this,t)},Mk().prototype.squeeze=function(t){return this.throwIfDisposed(),lC(this,t)},Mk().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Lk?[this,t]:[this,...t];return cC(n,e)},Mk().prototype.step=function(t){return this.throwIfDisposed(),EC(this,t)};const h_=fS({stridedSlice_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const c={x:dS(t,"x","stridedSlice","string_or_numeric")},u={begin:e,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};return rS.runKernel(Sx,c,u)}});Mk().prototype.stridedSlice=function(t,e,n,r,a,s,o,i){return this.throwIfDisposed(),h_(this,t,e,n,r,a,s,o,i)},Mk().prototype.sub=function(t){return this.throwIfDisposed(),FI(this,t)},Mk().prototype.sum=function(t,e){return this.throwIfDisposed(),bE(this,t,e)};const d_=fS({tan_:function(t){const e={x:dS(t,"x","tan","float32")};return rS.runKernel(Tx,e)}});Mk().prototype.tan=function(){return this.throwIfDisposed(),d_(this)},Mk().prototype.tanh=function(){return this.throwIfDisposed(),uC(this)},Mk().prototype.tile=function(t){return this.throwIfDisposed(),iE(this,t)},Mk().prototype.toBool=function(){return this.throwIfDisposed(),uI(this,"bool")},Mk().prototype.toFloat=function(){return this.throwIfDisposed(),uI(this,"float32")},Mk().prototype.toInt=function(){return this.throwIfDisposed(),uI(this,"int32")};const p_=fS({topk_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=dS(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(e<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(e));if(e>a)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a,") ")+"but got ".concat(e));const s={x:r},o={k:e,sorted:n},[i,l]=rS.runKernel(Fx,s,o);return{values:i,indices:l}}});Mk().prototype.topk=function(t,e){return this.throwIfDisposed(),p_(this,t,e)},Mk().prototype.transpose=function(t){return this.throwIfDisposed(),yC(this,t)};const f_=fS({unique_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=dS(t,"x","unique","string_or_numeric");Xb(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:e},[s,o]=rS.runKernel(Ox,r,a);return{values:s,indices:o}}});Mk().prototype.unique=function(t){return this.throwIfDisposed(),f_(this,t)},Mk().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),ER(this,t,e)},Mk().prototype.unstack=function(t){return this.throwIfDisposed(),fC(this,t)},Mk().prototype.where=function(t,e){return this.throwIfDisposed(),gC(t,this,e)},Mk().prototype.zerosLike=function(){return this.throwIfDisposed(),yI(this)};class g_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,g_.prototype)}}class m_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,m_.prototype)}}class b_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,b_.prototype)}}class y_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,y_.prototype)}}class v_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,v_.prototype)}}Error;class w_{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function x_(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function k_(t,e){if(!t)throw new v_(e)}function S_(t,e){let n=0;for(const r of t)r===e&&n++;return n}function I_(t){return 1===t.length?t[0]:t}function N_(t){return Array.isArray(t)?t:[t]}function E_(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function C_(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let T_={};function A_(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function R_(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>R_(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?R_(e):t[n]=e.value)}}}function F_(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in T_)s=T_[a];else if(s=e[a],null==s)throw new b_("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new b_("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in T_?[i,l]=T_.className:o in e&&([i,l]=e[o]),null==i)throw new b_("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(T_))t[n]=T_[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},T_);for(const a of Object.keys(n))T_[a]=n[a];R_(s.config);const r=l(i,s.config,n,a);return T_=Object.assign({},e),r}{const t=Object.assign({},T_);for(const r of Object.keys(n))T_[r]=n[r];const e=new i(s.config);return T_=Object.assign({},t),e}}}function __(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function D_(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function O_(t){if(null==t)throw new b_("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function z_(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new b_("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function L_(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return k_(n>=0),k_(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function M_(t,e){Array.isArray(t)?(Xb(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>M_(t,"element ".concat(n+1," of ").concat(e))))):Xb(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(P_(t),".")))}function P_(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>P_(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function B_(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let W_=0;function U_(){return W_++}const V_={};function G_(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in V_||(V_[t]=0),V_[t]+=1,t+V_[t].toString()}const j_=["channelsFirst","channelsLast"],H_=["nearest","bilinear"],K_=["valid","same","causal"],q_=["max","avg"],X_=["sum","mul","concat","ave"],J_=new Map;function Y_(t){z_(j_,"DataFormat",t)}function Z_(t){z_(K_,"PaddingMode",t)}function Q_(t){z_(q_,"PoolMode",t)}const $_=[],tD="/";function eD(t,e){$_.push(t);try{const t=e();return $_.pop(),t}catch(o1){throw $_.pop(),o1}}function nD(t){if(!sD(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===$_.length?"":$_.join(tD)+tD)+t}function rD(t){if(!sD(t))throw new Error("Not a valid tensor name: '"+t+"'");J_.has(t)||J_.set(t,0);const e=J_.get(t);if(J_.set(t,J_.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return J_.set(n,1),n}return t}const aD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function sD(t){return!!t.match(aD)}function oD(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function iD(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function lD(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function cD(t,e){if(e<t)throw new b_("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let uD;function hD(){return null==uD&&(uD=NS().epsilon()),uD}function dD(t,e){return uI(t,e)}function pD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),ON(t,n)}function fD(t,e,n){return xS((()=>{switch(t.rank){case 1:return eC(t,e,n);case 2:return nC(t,[e,0],[n,t.shape[1]]);case 3:return rC(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return aC(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return tC(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return tC(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new b_("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function gD(t,e,n){return xS((()=>{switch(t.rank){case 1:return eC(t,e,n);case 2:return nC(t,[0,e],[t.shape[0],n]);case 3:return rC(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return aC(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new b_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function mD(t,e,n,r){return xS((()=>{switch(t.rank){case 1:return eC(t,e,n);case 2:switch(r){case 1:return fD(t,e,n);case 2:return gD(t,e,n);default:throw new b_("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return fD(t,e,n);case 2:return rC(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return gD(t,e,n);default:throw new b_("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return fD(t,e,n);case 2:return aC(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return aC(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return gD(t,e,n);default:throw new b_("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new b_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function bD(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),GN(t,n)}function yD(t,e){switch(t.rank){case 1:return jN([t,e]);case 2:return HN([t,e],0);case 3:return KN([t,e],0);case 4:return qN([t,e],0);default:throw new b_("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function vD(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new b_("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return iE(t,e)}function wD(t){return KE(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function xD(t,e,n,r){if(t.rank<2||e.rank<2)throw new y_("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new y_("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return OC({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?ID(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=ON(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=ON(yC(e,u),[l,-1]);const h=[...a,...c];return ON(OC({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?ID(t.rank,r,"channelsLast"):null,activation:n}),h)}}function kD(t,e,n){return xS((()=>(e=Array.isArray(e)?hC(e,"int32"):uI(e,"int32"),uE(t,e,n))))}function SD(t){return gI(t,t)}function ID(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new b_("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?ON(e,[1,r[0],1,1,1]):ON(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?ON(e,[1,1,1,1,r[0]]):ON(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?ON(e,[1,r[0],1,1]):ON(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?ON(e,[1,1,1,r[0]]):ON(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?ON(e,[1,r[0],1]):ON(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?ON(e,[1,1,r[0]]):ON(e,[1].concat(r))}else if(t<3)return e;throw new b_("Unsupported input rank by biasAdd: ".concat(e.rank))}function ND(t,e,n){return xS((()=>(null==n&&(n="channelsLast"),Y_(n),dI(t,ID(t.rank,e,n)))))}function ED(t,e,n,r){return xS((()=>vC(t,e,n,r)))}function CD(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const TD=["fanIn","fanOut","fanAvg"],AD=["normal","uniform","truncatedNormal"];class RD extends SI{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class FD extends RD{apply(t,e){return BE(t,e)}}FD.className="Zeros",NI(FD);class _D extends RD{apply(t,e){return WE(t,e)}}_D.className="Ones",NI(_D);class DD extends RD{constructor(t){if(super(),"object"!==typeof t)throw new b_("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new b_("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return xS((()=>gI(wI(this.value),WE(t,e))))}getConfig(){return{value:this.value}}}DD.className="Constant",NI(DD);class OD extends RD{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return qE(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}OD.className="RandomUniform",NI(OD);class zD extends RD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new y_("randomNormal does not support dType ".concat(e,"."));return wD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}zD.className="RandomNormal",NI(zD);class LD extends RD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new y_("truncatedNormal does not support dType ".concat(e,"."));return pC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LD.className="TruncatedNormal",NI(LD);class MD extends RD{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return xS((()=>{if(2!==t.length||t[0]!==t[1])throw new b_("Identity matrix initializer can only be used for 2D square matrices.");return gI(this.gain,lE(t[0]))}))}getConfig(){return{gain:this.gain}}}MD.className="Identity",NI(MD);class PD extends RD{constructor(t){if(super(),t.scale<0)throw new b_("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,z_(TD,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){z_(AD,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Y_(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=oD(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=oD(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=oD(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new y_("".concat(this.getClassName()," does not support dType ").concat(e,"."));return pC(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return qE(t,-n,n,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}PD.className="VarianceScaling",NI(PD);class BD extends PD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return PD.className}}BD.className="GlorotUniform",NI(BD);class WD extends PD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return PD.className}}WD.className="GlorotNormal",NI(WD);class UD extends PD{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return PD.className}}UD.className="HeNormal",NI(UD);class VD extends PD{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return PD.className}}VD.className="HeUniform",NI(VD);class GD extends PD{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return PD.className}}GD.className="LeCunNormal",NI(GD);class jD extends PD{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return PD.className}}jD.className="LeCunUniform",NI(jD);class HD extends RD{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return xS((()=>{if(t.length<2)throw new y_("Shape must be at least 2D.");if("int32"!==e&&"float32"!==e&&void 0!==e)throw new TypeError("Unsupported data type ".concat(e,"."));const n=Zb(t.slice(0,-1)),r=t[t.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(a,") elements: ")+"Slowness may result.");const s=wD([Math.max(r,n),Math.min(r,n)],0,1,e,this.seed),o=wT.qr(s,!1);let i=o[0];const l=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return i=gI(i,l.sign()),n<r&&(i=i.transpose()),gI(wI(this.gain),i.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}HD.className="Orthogonal",NI(HD);const KD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function qD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return F_(t,II.getMap().classNameMap,e,"initializer")}function XD(t){return A_(t)}function JD(t){if("string"===typeof t){const e=t in KD?KD[t]:t;if("GlorotNormal"===e)return new WD;if("GlorotUniform"===e)return new BD;if("HeNormal"===e)return new UD;if("HeUniform"===e)return new VD;if("LeCunNormal"===e)return new GD;if("LeCunUniform"===e)return new jD;{const t={};return t.className=e,t.config={},qD(t)}}return t instanceof RD?t:qD(t)}function YD(t){return Array.isArray(t)&&Array.isArray(t[0])}function ZD(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function QD(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new b_("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function $D(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new b_("Expected exactly 1 Shape; got ".concat(t.length))}return t}function tO(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const eO="Variable";class nO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:eO,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=U_(),n=null==n?eO:n,this.originalName=nD(n),this.name=rD(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return rS.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function rO(t){return t.map((t=>t.read()))}function aO(t){t.forEach((t=>{t[0].write(t[1])}))}class sO{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class oO{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=U_(),null!=s&&(this.originalName=nD(s),this.name=rD(this.originalName)),this.rank=e.length}}let iO=0;class lO{constructor(t,e){this.callArgs=e,this.id=iO++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let cO=0;class uO extends SI{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=cO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=E_(t)+"_"+G_(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new m_("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new b_("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return I_(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return I_(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new g_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new g_("Layer ".concat(this.name)+" is not connected, no input to return.");return I_(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new g_("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new g_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return I_(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=N_(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=N_(this.inputSpec);if(e.length!==n.length)throw new b_("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(e.length," input tensors. ")+"Input received: ".concat(t));for(let r=0;r<e.length;r++){const t=e[r],a=n[r];if(null==a)continue;const s=t.rank;if(null!=a.ndim&&s!==a.ndim)throw new b_("Input ".concat(r," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new b_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new b_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&t.dtype!==a.dtype)throw new b_("Input ".concat(r," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(t.dtype,"."));if(a.axes){const e=t.shape;for(const t in a.axes){const n=Number(t),s=a.axes[t],o=n>=0?e[n]:e[e.length+n];if(null!=s&&-1===[s,null].indexOf(o))throw new b_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(s," but got shape ").concat(e,"."))}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){const n=a.shape[e],s=t.shape[e];if(null!=n&&null!=s&&n!==s)throw new b_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(t.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=N_(t),r=function(t){let e=!0;for(const n of N_(t))if(!(n instanceof oO)){e=!1;break}return e}(t),a=function(t){let e=!0;for(const n of N_(t))if(n instanceof oO){e=!1;break}return e}(t);if(r===a)throw new b_("Arguments to apply() must be all SymbolicTensors or all Tensors");return eD(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of N_(t))e.push(n.shape);this.build(I_(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,r);const a=N_(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=I_(s),null!=this.activityRegularizer)throw new y_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=N_(t);const e=[];for(const n of t)e.push(n.shape);return I_(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new oO(s,n,this,N_(t),e,this.name,r))):new oO(s,r,this,N_(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new y_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new g_("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new g_("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new m_("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return tO(this.weights)}build(t){this.built=!0}getWeights(){return rO(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){xS((()=>{const e=this.weights;if(e.length!==t.length)throw new b_('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=rO(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!Qb(s.shape,i.shape))throw new b_("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}aO(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new b_("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():JD("zeros"));const l=r.apply(e,n),c=new nO(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=N_(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const r=this.computeMask(t,n),a=N_(e),s=N_(r);if(a.length!==s.length)throw new Error("".concat(this.name," outputs ").concat(a.length," tensors ")+"but ".concat(a.length," masks for those tensors"));for(let o=0;o<a.length;o++)a[o].kerasMask=s[o]}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=N_(t);e=N_(e),n=N_(n),r=N_(r),a=ZD(a),s=ZD(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new lO({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function hO(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=hO(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class dO extends uO{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:G_("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new b_("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new b_("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new b_("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new oO(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new lO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new b_("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}dO.className="InputLayer",NI(dO);class pO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof pO)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new b_("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return uI(e,t.dtype)}catch(i1){throw new b_("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof oO){if(null==this.id2Value[t.id])throw new b_("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new b_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof oO){if(null==this.id2Value[t.id])throw new b_("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new b_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&kS(this.id2Mask)}}const fO=new w_,gO=new w_;function mO(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=fO.get(u);if(null==d){const t=function(t,e){Xb(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=yO(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=yO(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:bO(r)}}(o,e);d=t.sorted,h=t.recipientCounts,fO.put(u,d),gO.put(u,h)}h={},a||Object.assign(h,gO.get(u));const p=new pO(e);for(let f=0;f<d.length;++f){if(null!=r){const t=wS().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof dO)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=N_(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=vO(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||kS(u)}return p.disposeMasks(),s?l:l[0]}function bO(t){const e={};for(const n in t)e[n]=t[n].size;return e}function yO(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function vO(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}function wO(t,e){return xS((()=>mI(bE(gI(t,t),e,!0))))}Ty().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=fO&&fO.setMaxEntries(t),null!=gO&&gO.setMaxEntries(t)}));class xO extends SI{getConfig(){return{}}}class kO extends xO{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return xS((()=>{const e=wO(t,this.axis),n=VN(e,0,this.maxValue);return gI(t,fI(n,dI(hD(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}kO.className="MaxNorm",NI(kO);class SO extends xO{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return xS((()=>fI(t,dI(hD(),wO(t,this.axis)))))}getConfig(){return{axis:this.axis}}}SO.className="UnitNorm",NI(SO);class IO extends xO{apply(t){return JE(t)}}IO.className="NonNeg",NI(IO);class NO extends xO{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return xS((()=>{const e=wO(t,this.axis),n=dI(gI(this.rate,VN(e,this.minValue,this.maxValue)),gI(1-this.rate,e));return gI(t,fI(n,dI(hD(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}NO.className="MinMaxNorm",NI(NO);const EO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function CO(t){return A_(t)}function TO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return F_(t,II.getMap().classNameMap,e,"constraint")}function AO(t){if(null==t)return null;if("string"===typeof t){return TO({className:t in EO?EO[t]:t,config:{}})}return t instanceof xO?t:TO(t)}async function RO(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];kS(r)}}function FO(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var _O;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(_O||(_O={}));class DO{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class OO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class zO extends DO{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=xS((()=>dI(this.totals[r],gI(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:xS((()=>{const t=gI(fI(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),SS(e[n])})))}}class LO extends DO{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class MO extends DO{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||ST,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");hy(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():mk();return function(){const s=null!=n?n():mk();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await RO(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await RO(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await RO(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await RO(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await RO(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):hy(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await RO(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await RO(t),await this.trainEnd(t))}}function PO(t,e){if(null==t&&(t={}),t instanceof DO)return[t];if(Array.isArray(t)&&t[0]instanceof DO)return t;return N_(t).map((t=>new MO(t,e)))}class BO{constructor(){}static registerCallbackConstructor(t,e){Xb(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),BO.checkForDuplicate(e),null==BO.constructors[t]&&(BO.constructors[t]=[]),BO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in BO.constructors){BO.constructors[+e].forEach((e=>{if(e===t)throw new b_("Duplicate callback constructor.")}))}}static clear(){BO.constructors={}}static createCallbacks(t){const e=[];for(const n in BO.constructors){const r=+n;t>=r&&e.push(...BO.constructors[r])}return e.map((t=>new t))}}function WO(t,e,n,r,a,s,o,i,l){const c=new LO,u=[new zO,...BO.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new OO(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function UO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return F_(t,II.getMap().classNameMap,e,"layer",n)}function VO(t,e){return xS((()=>{"float32"!==t.dtype&&(t=uI(t,"float32"));const n=bE(SD(t),e,!0),r=TI(n.shape,hD()),a=mI(MI(n,r));return fI(t,a)}))}function GO(t,e){return xS((()=>_E(SD(FI(e,t)),-1)))}function jO(t,e){return xS((()=>_E(DI(FI(e,t)),-1)))}function HO(t,e){return xS((()=>{const n=FI(t,e),r=VN(DI(t),hD(),Number.MAX_VALUE),a=DI(fI(n,r));return gI(100,_E(a,-1))}))}function KO(t,e){return xS((()=>{const n=VN(e,hD(),Number.MAX_VALUE),r=fE(dI(1,n)),a=VN(t,hD(),Number.MAX_VALUE),s=fE(dI(1,a));return _E(SD(FI(r,s)),-1)}))}function qO(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return xS((()=>{if(n)e=sC(e);else{const t=bE(e,e.shape.length-1,!0);e=fI(e,t)}return e=VN(e,hD(),1-hD()),LE(bE(gI(uI(t,"float32"),fE(e)),e.shape.length-1))}))}function XO(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return xS((()=>{const r=uI(cE(function(t){const e=[oD(t.shape)];return ON(t,e)}(t)),"int32"),a=(e=VN(e,hD(),1-hD())).shape;return qO(ON(PE(r,a[a.length-1]),a),e,n)}))}function JO(t,e){return xS((()=>{let n;return n=VN(e,hD(),1-hD()),n=fE(fI(n,FI(1,n))),_E(function(t,e){if(!Qb(t.shape,e.shape))throw new b_("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return xS((()=>{const n=JE(e),r=LE(DI(e));return dI(FI(n,gI(e,t)),gE(sE(r)))}))}(t,n),-1)}))}function YO(t,e){return xS((()=>{const n=VN(t,hD(),1),r=VN(e,hD(),1);return bE(gI(t,fE(fI(n,r))),-1)}))}function ZO(t,e){return xS((()=>{const n=VO(t,-1),r=VO(e,-1),a=gI(n,r);return LE(bE(a,-1))}))}BO.constructors={};const QO={meanSquaredError:GO,meanAbsoluteError:jO,meanAbsolutePercentageError:HO,meanSquaredLogarithmicError:KO,squaredHinge:function(t,e){return xS((()=>{const n=MI(0,FI(1,gI(t,e)));return _E(SD(n),-1)}))},hinge:function(t,e){return xS((()=>{const n=MI(0,FI(1,gI(t,e)));return _E(n,-1)}))},categoricalHinge:function(t,e){return xS((()=>{const n=bE(gI(t,e),-1),r=mE(gI(FI(1,t),e),-1);return MI(0,dI(1,FI(r,n)))}))},logcosh:function(t,e){return xS((()=>{const n=Math.log(2),r=FI(e,t),a=FI(dI(r,oC(gI(-2,r))),n);return _E(a,-1)}))},categoricalCrossentropy:qO,sparseCategoricalCrossentropy:XO,binaryCrossentropy:JO,kullbackLeiblerDivergence:YO,poisson:function(t,e){return xS((()=>{const n=fE(dI(hD(),e));return _E(FI(e,gI(t,n)),-1)}))},cosineProximity:ZO};function $O(t){if("string"===typeof t){if(t in QO)return QO[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new b_(e)}return t}function tz(t,e){return xS((()=>{const n=gI(.5,UE(e)),r=dD(hE(e,n),t.dtype);return _E(aE(t,r),-1)}))}function ez(t,e){return xS((()=>dD(aE(yN(t,-1),yN(e,-1)),"float32")))}function nz(t,e){return xS((()=>uI(bE(TE(aE(t,1),aE(e,1))),"float32")))}function rz(t,e){return JO(t,e)}function az(t,e){return t.rank===e.rank&&(t=lC(t,[t.rank-1])),(e=yN(e,-1)).dtype!==t.dtype&&(e=uI(e,t.dtype)),uI(aE(t,e),"float32")}const sz=qO,oz=XO,iz={binaryAccuracy:tz,categoricalAccuracy:ez,precision:function(t,e){return xS((()=>{const n=nz(t,e),r=function(t,e){return xS((()=>uI(bE(TE(aE(t,0),aE(e,1))),"float32")))}(t,e),a=dI(n,r);return uI(gC(hE(a,0),fI(n,a),0),"float32")}))},categoricalCrossentropy:sz,sparseCategoricalCrossentropy:oz,mse:GO,MSE:GO,mae:jO,MAE:jO,mape:HO,MAPE:HO,cosine:ZO};function lz(t){if("string"===typeof t&&t in iz)return iz[t];if("string"!==typeof t&&null!=t)return t;throw new b_("Unknown metric ".concat(t))}function cz(t){if(k_(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys(QO))if(QO[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(iz))if(iz[n]===t){e=n;break}return void 0!==e?e:t.name}}const uz=1048576;function hz(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!dz(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>uz&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(uz,"."))}}function dz(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!dz(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!dz(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function pz(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),fz(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?gz(i[u],n,r):mz(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?tO(t.collectedTrainableWeights):tO(t.trainableWeights);return e}(t),c=tO(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function fz(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function gz(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(i1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(i1){r="multiple"}const s=t.name,o=t.getClassName();fz(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function mz(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(i1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(i1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];fz(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)fz(["","","","",o[u]],e,r)}function bz(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function yz(t,e){if(null===t)return null;if("string"===typeof t)return C_(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];bz(e,a,r)?n.push(r):n.push(yz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=C_(n);e[t]=yz(r,t)}}return e}}function vz(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return E_(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];bz(e,a,r)?n.push(r):n.push(vz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=E_(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?vz(r,n):r}return e}}const wz="4.17.0";class xz extends uO{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=G_(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],D_(this.inputs).length!==this.inputs.length)throw new b_("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));D_(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;k_(0===e,"input layer has >1 nodes"),k_(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof dO))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new m_("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(xz.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(__);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof xz&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(__);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new m_("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new m_('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new lO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new b_("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(t=>{const e=Object.keys(t);if(0===e.length)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[t,e]of o.weights.entries()){const s=a?"".concat(e.name.split("/").slice(0,-1).join("/")+"/").concat(t):e.originalName;if(null!=n[s])throw new b_("Duplicate weight name: ".concat(s));n[s]=e,r++}const s=[];for(const o in t){let r=o;if(null==n[o]){const t=o.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[o]]);else if(e)throw new b_("Provided weight data has no target variable: ".concat(o));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new b_("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}aO(s)}parseWeights(t){for(const e in Object.keys(t)){const n=e.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((t=>t.startsWith("_")?t.slice(1):t)).filter((t=>!r.includes(t))).join("/");a!==e&&(t[a]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(wz),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=vz(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return xS((()=>{t=N_(t);const n=new pO;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return mO(this.outputs,n,e)}))}computeMask(t,e){return xS((()=>{let n;return t=N_(t),n=null==e?x_(null,t.length):N_(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=ZD(t);if(e.length!==this.inputLayers.length)throw new b_("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(__);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=ZD(t.computeOutputShape(I_(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];k_(t in n),a.push(n[t])}return I_(a)}runInternalGraph(t,e){null==e&&(e=x_(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(__);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=N_(t.call(e,c)),l=N_(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=N_(t.call(r,c)),l=N_(t.computeMask(r,o));if(t.activityRegularizer)throw new y_("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){k_(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof xz?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=xz.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new b_("Provide either a layer name or layer index");if("number"===typeof t)return this.findLayer(t);for(const n of this.layers)if(n.name===t)return n;throw new b_("No such layer: ".concat(t))}findLayer(t){if(this.layers.length<=t)throw new b_("Was asked to retrieve layer at index ".concat(t,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[t]}calculateLosses(){return xS((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=xz.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=xz.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(i1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[xz.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=xz.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=xz.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(I_(n),a)}function i(t){const a=t.name,o=UO(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new b_("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!O_(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];k_(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];k_(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new b_("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){xS((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function kz(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Sz(t,e){return kz(t,e,"classWeight")}async function Iz(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=xS((()=>{if(1===t.shape.length)return hI(t);if(2===t.shape.length){if(t.shape[1]>1){return yN(t,1)}if(1===t.shape[1])return ON(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());kS(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),hC(a,"float32")}return null}function Nz(t,e){return gI(t,e)}function Ez(t,e){let n,r;const a=e;n=a.xs,r=a.ys,Xb(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=Cz("input",t.inputNames,n),o=Cz("output",t.outputNames,r),i=s[0].shape[0];Xb(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),Xb(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)Xb(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)Xb(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function Cz(t,e,n){if(n instanceof Lk)return[n];if(Array.isArray(n))return Xb(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new b_("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function Tz(t,e,n){const r=null!=n.batchesPerEpoch;if(Xb(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Xb(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Xb(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Xb(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Xb(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(Az(n.validationData))Xb(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new y_("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=PO(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=WO(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=Ez(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Sz(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Iz(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);kS(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,SS(n)}await d.onBatchEnd(h,s),FO(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=Az(n.validationData)?N_(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):N_(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Az(t){return"function"===typeof t.iterator}function Rz(t){Xb(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function Fz(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>fD(t,e,n-e))):fD(t,e,n-e)}function _z(t,e){return xS((()=>null==t?null:Array.isArray(t)?t.map((t=>_z(t,e))):kD(t,"int32"===e.dtype?e:uI(e,"int32"))))}function Dz(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}function Oz(t){const e=[];t instanceof Lk&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(pD(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function zz(t,e){if(null==t)return;const n=[];if(e instanceof Lk)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Lk)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Lz(t){return Array.isArray(t)}function Mz(t){return!function(t){return t instanceof Lk}(t)&&!Lz(t)}function Pz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Lz(t)&&t.length>0)e=!0;else if(Mz(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new b_("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(Mz(t)){r=[];for(const n of e){if(null==t[n])throw new b_('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Lz(t)){if(t.length!==e.length)throw new b_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new b_("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=Oz(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new b_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new b_("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function Bz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new b_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new b_("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new b_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new b_("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class Wz extends xz{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new b_("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");pz(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>xT.adagrad(.01),Adadelta:()=>xT.adadelta(1,.95,hD()),Adam:()=>xT.adam(.001,.9,.999,hD()),Adamax:()=>xT.adamax(.002,.9,.999,hD(),0),RMSProp:()=>xT.rmsprop(.001,.9,0,hD()),SGD:()=>xT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new b_("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof EI))throw new b_("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new b_("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>$O(t)))}else{const n=$O(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new b_('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push($O(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],eD("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};eD("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===JO?-1!==["accuracy","acc"].indexOf(o)?r=tz:-1!==["crossentropy","ce"].indexOf(o)&&(r=rz):this.lossFunctions[t]===XO?-1!==["accuracy","acc"].indexOf(o)?r=az:-1!==["crossentropy","ce"].indexOf(o)&&(r=oz):-1!==["accuracy","acc"].indexOf(o)?r=ez:-1!==["crossentropy","ce"].indexOf(o)&&(r=sz),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=lz(o);s=t,n=""+cz(o)}let e;eD(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Rz(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return I_(this.testLoop(e,t,r,n.verbose,n.steps))}finally{zz(a[0],t),zz(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new y_("Verbose mode is not implemented yet.");Xb(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=xS((()=>{if(e.value){const{xs:n,ys:r}=Ez(t,e.value),o=n.concat(r),c=xS((()=>a(o)));if(kS(o),0===l)for(let t=0;t<c.length;++t)s.push(wI(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=xS((()=>dI(s[t],gI(u,e)))),l>0&&kS(n)}kS(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=fI(s[c],i),kS(t)}return I_(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new b_("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new b_("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new b_("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new pO;if(t instanceof Lk&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new b_("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new b_("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=mO(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=x_(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new b_("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return xS((()=>{const r=this.checkNumSamples(t);if(n)throw new y_("Verbose predictLoop() is not implemented yet.");const a=Dz(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){xS((()=>{const n=a[e][0],r=a[e][1],s=Fz(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new pO(o);return mO(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return I_(s.map((t=>GN(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Oz(t);Bz(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return Rz(t),this.predictLoop(n,t)}finally{zz(n,t)}}predictOnBatch(t){Bz(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new m_("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===XO?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=D_(t.map((t=>t.shape[0])));r.sort();const a=D_(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new b_("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new b_("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!Qb(r,a))throw new b_("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=Pz(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Pz(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[GO,JO,qO];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===qO&&1===s.shape[s.shape.length-1])throw new b_("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new b_("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new b_("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Sz(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Iz(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return xS((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new y_("Verbose mode is not implemented yet.");if(null!=a)throw new y_("steps mode in testLoop() is not implemented yet");{const r=Dz(s,n),a=hC(cD(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=fD(a,s,i-s),c=_z(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(wI(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=dI(o[t],gI(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=fI(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(S_(t,r)>1){const e=S_(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new pO(t),i=mO(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=Nz(t,a[n]));const s=_E(t);e.push(s),l=0===n?t:dI(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=_E(e(r[a],i[a]))}SS(t),s.push(t)}return l=_E(l),this.calculateLosses().forEach((t=>{l=dI(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>xS((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new pO(s),i=mO(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=_E(r(a[t],i[t]));n=0===t?s:dI(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=_E(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){let n,r,a,s,o,i,l,c,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;Rz(d);const p=!1,f=await this.standardizeUserData(t,e,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],u=f[2];let g,m=!1;if(null!=h.validationData&&h.validationData.length>0){if(m=!0,2!==h.validationData.length)throw 3===h.validationData.length?new y_("validationData including sample weights is not supported yet."):new b_("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));o=h.validationData[0],i=h.validationData[1];const t=!0,e=await this.standardizeUserData(o,i,null,null,t,d);l=e[0],c=e[1],g=l.concat(c)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){m=!0;const t=Math.floor(n[0].shape[0]*(1-h.validationSplit)),e=n[0].shape[0];l=Fz(n,t,e),a=n,n=Fz(n,0,t),c=Fz(r,t,e),s=r,r=Fz(r,0,t),g=l.concat(c)}else null!=h.validationSteps&&(m=!0);const b=n.concat(r).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,x;m?(this.makeTestFunction(),w=this.testFunction,x=v.slice().concat(v.map((t=>"val_"+t)))):(w=null,g=[],x=v.slice());const k=PO(h.callbacks,h.yieldEvery);return await this.fitLoop(y,b,v,d,h.epochs,h.verbose,k,w,g,h.shuffle,x,h.initialEpoch,null,null)}finally{this.isTraining=!1,zz(n,t),zz(r,e),zz(a,t),zz(s,e),zz(l,o),zz(c,i),null!=u&&kS(u)}}async fitLoop(t,e,n,r,a,s,o,i,l,c,u,h,d,p){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0);let f=!1;if(null!=i&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new b_("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(e,r,d,"steps_per_epoch");let m;null!=g&&(m=cD(0,g)),null==s&&(s=1);const{callbackList:b,history:y}=WO(o,s,a,h,g,d,r,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<a;++v){await b.onEpochBegin(v);const a={};if(null!=d)throw new y_("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new y_("batch shuffling is not implemneted yet");c&&jb(m);const s=hC(m),o=Dz(g,r);for(let c=0;c<o.length;++c){const u={};if(await b.onBatchBegin(c,u),xS((()=>{const h=o[c][0],d=o[c][1],p=fD(s,h,d-h);u.batch=c,u.size=d-h;const g=_z(e,p),m=t(g);for(let t=0;t<n.length;++t){const e=n[t],r=m[t];u[e]=r,SS(r)}if(c===o.length-1&&f){const t=this.testLoop(i,l,r);for(let e=0;e<n.length;++e){const r=n[e],s=t[e];SS(s),a["val_"+r]=s}}})),await b.onBatchEnd(c,u),FO(u),this.stopTraining_)break}s.dispose()}if(await b.onEpochEnd(v,a),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Tz(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return kS(s),zz(n[0],t),zz(n[1],e),I_(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=wS().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-wS().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=E_(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>E_(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=E_(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[E_(cz(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>E_(cz(t))));{const t={};for(const e in this.metrics)t[e]=E_(cz(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=UO(yz(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=C_(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>C_(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=C_(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>C_(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=C_(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,zS.getSaveHandlers(n));if(0===e.length)throw new b_("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new b_("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new b_("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await CS(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(wz),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await CS(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=(s=[r.data,e],yS.join(s))}var s;if(null!=this.userDefinedMetadata){const t=!0;hz(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){hz(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Wz.className="Model",NI(Wz);class Uz extends Wz{}Uz.className="Functional",NI(Uz);class Vz extends Wz{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:G_("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new b_("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof Vz||t instanceof Wz;let n;if(e){if(n=t,1!==n.outputs.length)throw new b_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new b_("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new b_("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new b_("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new dO({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new b_("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new b_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=hO(this.outputs[0])}this.inboundNodes=[],new lO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:x_(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if($D(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Wz({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new m_("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new m_("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new m_("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new m_("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new b_("Legacy serialization format not supported yet.");n=e}else Xb(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof Vz))throw new y_("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=UO(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new b_("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new b_("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}Vz.className="Sequential",NI(Vz);class Gz extends SI{getConfig(){return{}}}class jz extends Gz{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new y_("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return rE(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}jz.className="elu",NI(jz);class Hz extends Gz{apply(t){return ZE(t)}}Hz.className="selu",NI(Hz);class Kz extends Gz{apply(t){return JE(t)}}Kz.className="relu",NI(Kz);class qz extends Gz{apply(t){return xS((()=>OE(6,JE(t))))}}qz.className="relu6",NI(qz);class Xz extends Gz{apply(t){return t}}Xz.className="linear",NI(Xz);class Jz extends Gz{apply(t){return $E(t)}}Jz.className="sigmoid",NI(Jz);class Yz extends Gz{apply(t){return function(t){return xS((()=>{const e=dI(.5,gI(.2,t));return VN(e,0,1)}))}(t)}}Yz.className="hardSigmoid",NI(Yz);class Zz extends Gz{apply(t){return oC(t)}}Zz.className="softplus",NI(Zz);class Qz extends Gz{apply(t){return function(t){return xS((()=>fI(t,dI(DI(t),1))))}(t)}}Qz.className="softsign",NI(Qz);class $z extends Gz{apply(t){return uC(t)}}$z.className="tanh",NI($z);class tL extends Gz{apply(t){return sC(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}tL.className="softmax",NI(tL);class eL extends Gz{apply(t){return yE(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}eL.className="logSoftmax",NI(eL);class nL extends Gz{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return xS((()=>gI($E(gI(t,e)),t)))}}nL.className="swish",NI(nL);class rL extends Gz{apply(t){return xS((()=>gI(t,uC(oC(t)))))}}function aL(t){return t.getClassName()}function sL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return F_(t,II.getMap().classNameMap,e,"activation")}function oL(t){if(null==t){const t={className:"linear",config:{}};return sL(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},sL(e)}return t instanceof Gz?t:sL(t)}function iL(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}rL.className="mish",NI(rL);class lL extends SI{}class cL extends lL{constructor(t){super(),iL(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return xS((()=>{let e=BE([1]);return this.hasL1&&(e=dI(e,bE(gI(this.l1,DI(t))))),this.hasL2&&(e=dI(e,bE(gI(this.l2,SD(t))))),ON(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}cL.className="L1L2",NI(cL);const uL={l1l2:"L1L2"};function hL(t){return A_(t)}function dL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return F_(t,II.getMap().classNameMap,e,"regularizer")}function pL(t){if(null==t)return null;if("string"===typeof t){return dL({className:t in uL?uL[t]:t,config:{}})}return t instanceof lL?t:dL(t)}class fL extends uO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=QD(t);let n=JE(t);return null!=this.maxValue&&(n=VN(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}fL.className="ReLU",NI(fL);class gL extends uO{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=QD(t);return pE(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}gL.className="LeakyReLU",NI(gL);class mL extends uO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=JD(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=pL(t.alphaRegularizer),this.alphaConstraint=AO(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new b_("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=$D(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new sO({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=QD(t),GE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:XD(this.alphaInitializer),alphaRegularizer:hL(this.alphaRegularizer),alphaConstraint:CO(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}mL.className="PReLU",NI(mL);class bL extends uO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new y_("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=QD(t);return rE(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}bL.className="ELU",NI(bL);class yL extends uO{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=QD(t);return gI(n,uI(hE(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}yL.className="ThresholdedReLU",NI(yL);class vL extends uO{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new tL).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){return xS((()=>{let n=QD(t);const r=e.mask;if(null!=r){const t=gI(FI(WE(n.shape),uI(r,n.dtype)),wI(-1e9));n=dI(n,t)}return this.axis instanceof Array?this.axis.length>1?sE(FI(n,CE(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function wL(t,e,n){if("number"===typeof t)return x_(t,e);if(t.length!==e)throw new b_("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new b_("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function xL(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function kL(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+lD([n-e,0]);else{if("same"!==r)throw new b_("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function SL(t,e){return xS((()=>(Y_(e),"channelsFirst"===e?yC(t,[0,2,3,1]):t)))}function IL(t,e){return xS((()=>(Y_(e),"channelsFirst"===e?yC(t,[0,2,3,4,1]):t)))}function NL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return xS((()=>{if(null==s&&(s="channelsLast"),Y_(s),3!==t.shape.length)throw new b_("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new b_("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new b_("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=yC(t,[0,2,1])),"causal"===a)throw new y_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=JN(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=ND(i,n)),i}))}function EL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return xS((()=>{if(null==s&&(s="channelsLast"),Y_(s),3!==t.rank&&4!==t.rank)throw new b_("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new b_("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=SL(t,s);if("causal"===a)throw new y_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=FC({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=yC(l,[0,3,1,2])),l}))}function CL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return xS((()=>{if(null==s&&(s="channelsLast"),Y_(s),4!==t.rank&&5!==t.rank)throw new b_("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new b_("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=IL(t,s);if("causal"===a)throw new y_("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=QN(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=ND(i,n)),"channelsFirst"===s&&(i=yC(i,[0,4,1,2,3])),i}))}vL.className="Softmax",NI(vL);class TL extends uO{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",TL.verifyArgs(e),this.rank=t,M_(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new y_("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=wL(e.kernelSize,t,"kernelSize"),this.strides=wL(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Z_(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Y_(this.dataFormat),this.activation=oL(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=JD(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=AO(e.biasConstraint),this.biasRegularizer=pL(e.biasRegularizer),this.activityRegularizer=pL(e.activityRegularizer),this.dilationRate=wL(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new b_("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new b_("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new b_("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(k_("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!L_(t.kernelSize,"number",1,3))throw new b_("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:aL(this.activation),useBias:this.useBias,biasInitializer:XD(this.biasInitializer),biasRegularizer:hL(this.biasRegularizer),activityRegularizer:hL(this.activityRegularizer),biasConstraint:CO(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class AL extends TL{constructor(t,e){super(t,e),this.kernel=null,AL.verifyArgs(e),this.filters=e.filters,M_(this.filters,"filters"),this.kernelInitializer=JD(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=AO(e.kernelConstraint),this.kernelRegularizer=pL(e.kernelRegularizer)}build(t){t=$D(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new b_("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return xS((()=>{let e;t=QD(t);const n=null==this.bias?null:this.bias.read(),r=B_(this.activation.getClassName());if(null!=r&&2===this.rank)e=EL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=NL(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=EL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new y_("convolutions greater than 3D are not implemented yet.");e=CL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=$D(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=xL(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:XD(this.kernelInitializer),kernelRegularizer:hL(this.kernelRegularizer),kernelConstraint:CO(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new b_("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class RL extends AL{constructor(t){super(2,t),RL.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!L_(t.kernelSize,"number",1,2))throw new b_("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}RL.className="Conv2D",NI(RL);class FL extends AL{constructor(t){super(3,t),FL.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new b_("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}FL.className="Conv3D",NI(FL);class _L extends RL{constructor(t){if(super(t),this.inputSpec=[new sO({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new b_("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=$D(t)).length)throw new b_("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new b_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sO({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return xS((()=>{let e=QD(t);if(4!==e.shape.length)throw new b_("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,kL(o,u,l,this.padding),kL(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=yC(e,[0,2,3,1]));let p=ZN(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=yC(p,[0,3,1,2])),null!=this.bias&&(p=ND(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=$D(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=kL(e[r],i,s,this.padding),e[a]=kL(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}_L.className="Conv2DTranspose",NI(_L);class DL extends FL{constructor(t){if(super(t),this.inputSpec=[new sO({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new b_("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=$D(t)).length)throw new b_("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new b_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sO({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return xS((()=>{let e=QD(t);if(5!==e.shape.length)throw new b_("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,kL(i,p,u,this.padding),kL(l,f,h,this.padding),kL(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=yC(e,[0,2,3,4,1]));let b=tE(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=yC(b,[0,4,1,2,3])),null!==this.bias&&(b=ND(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=$D(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=kL(e[r],c,o,this.padding),e[a]=kL(e[a],u,i,this.padding),e[s]=kL(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}DL.className="Conv3DTranspose",NI(DL);class OL extends AL{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new b_("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new b_("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new b_("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=JD(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=pL(e.depthwiseRegularizer),this.depthwiseConstraint=AO(e.depthwiseConstraint),this.pointwiseInitializer=JD(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=pL(e.pointwiseRegularizer),this.pointwiseConstraint=AO(e.pointwiseConstraint)}build(t){if((t=$D(t)).length<this.rank+2)throw new b_("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new b_("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new sO({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return xS((()=>{let e;if(t=QD(t),1===this.rank)throw new y_("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=yC(t,[0,2,3,1])),e=QE(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=ND(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=yC(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=XD(this.depthwiseInitializer),t.pointwiseInitializer=XD(this.pointwiseInitializer),t.depthwiseRegularizer=hL(this.depthwiseRegularizer),t.pointwiseRegularizer=hL(this.pointwiseRegularizer),t.depthwiseConstraint=CO(this.depthwiseConstraint),t.pointwiseConstraint=CO(this.pointwiseConstraint),t}}OL.className="SeparableConv";class zL extends OL{constructor(t){super(2,t)}}zL.className="SeparableConv2D",NI(zL);class LL extends AL{constructor(t){super(1,t),LL.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!L_(t.kernelSize,"number",1,1))throw new b_("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}LL.className="Conv1D",NI(LL);class ML extends uO{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return xS((()=>{if(t=QD(t),"channelsLast"===this.dataFormat){const e=mD(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return mD(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=mD(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return mD(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ML.className="Cropping2D",NI(ML);class PL extends uO{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Y_(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,z_(H_,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return xS((()=>{let e=QD(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=yC(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?vT.resizeNearestNeighbor(e,[t,r]):vT.resizeBilinear(e,[t,r]);return yC(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?vT.resizeNearestNeighbor(e,[t,r]):vT.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}PL.className="UpSampling2D",NI(PL);class BL extends TL{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=JD(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=AO(t.depthwiseConstraint),this.depthwiseRegularizer=pL(t.depthwiseRegularizer)}build(t){if((t=$D(t)).length<4)throw new b_("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new b_("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xS((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return xS((()=>{null==a&&(a="channelsLast"),Y_(a);let o=SL(t,a);if(4!==t.rank)throw new b_("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new b_("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=nE(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=yC(o,[0,3,1,2])),o}))}(t=QD(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=ND(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=$D(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=xL(e,this.kernelSize[0],this.padding,this.strides[0]),s=xL(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=XD(this.depthwiseInitializer),t.depthwiseRegularizer=hL(this.depthwiseRegularizer),t.depthwiseConstraint=CO(this.depthwiseRegularizer),t}}function WL(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new b_("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function UL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return xS((()=>{const l=e.shape.length;if(l<3)throw new b_("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(cD(2,l));if(e=yC(e,c),null!=s)throw new y_("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=uI(uI(a,"bool"),"float32"),a.rank===l-1&&(a=oE(a,-1)),a=yC(a,c)),r&&(e=YE(e,0),null!=a&&(a=YE(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=fC(e);let g,m;null!=a&&(g=fC(a));for(let e=0;e<p;++e){const n=f[e],r=xS((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=xS((()=>{const t=g[e],n=FI(UE(t),t);return{output:dI(gI(r[0],t),gI(d[0],n)),newStates:d.map(((e,a)=>dI(gI(r[1][a],t),gI(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=cC(u,1)}return[h,m,d]}))}BL.className="DepthwiseConv2D",NI(BL);class VL extends uO{constructor(t){let e;if(super(t),null==t.cell)throw new b_("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new YL({cells:t.cell}):t.cell,null==e.stateSize)throw new b_("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new sO({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return cD(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){YD(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return xS((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new y_("Constants support is not implemented in RNN yet.");YD(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new sO({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Qb(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new b_("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new sO({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];xS((()=>{if(!this.stateful)throw new g_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new b_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>BE([n,t]))):this.states_=[BE([n,this.cell.stateSize])];else if(null==t)kS(this.states_),null!=this.keptStates&&(kS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>BE([n,t]))):this.states_[0]=BE([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new b_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):kS(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!Qb(r.shape,s))throw new b_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>SS(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=WL(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new sO({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof oO){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return xS((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=QD(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new b_("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=UL(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return xS((()=>{let e=BE(t.shape);return e=bE(e,[1,2]),e=pD(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?vD(e,[1,t]):e)):this.cell.stateSize>1?[vD(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===VL.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=UO(e.cell,n);return new t(Object.assign(e,{cell:r}))}}VL.className="RNN",NI(VL);class GL extends uO{}class jL extends GL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,M_(this.units,"units"),this.activation=oL(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=JD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=JD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=JD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=pL(t.kernelRegularizer),this.recurrentRegularizer=pL(t.recurrentRegularizer),this.biasRegularizer=pL(t.biasRegularizer),this.kernelConstraint=AO(t.kernelConstraint),this.recurrentConstraint=AO(t.recurrentConstraint),this.biasConstraint=AO(t.biasConstraint),this.dropout=iD([1,lD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=iD([1,lD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=$D(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xS((()=>{if(2!==t.length)throw new b_("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ZL({ones:()=>UE(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ZL({ones:()=>UE(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=xD(null!=s?gI(t,s):t,this.kernel.read()),null!=this.bias&&(a=ND(a,this.bias.read())),null!=o&&(n=gI(n,o));let i=dI(a,xD(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:aL(this.activation),useBias:this.useBias,kernelInitializer:XD(this.kernelInitializer),recurrentInitializer:XD(this.recurrentInitializer),biasInitializer:XD(this.biasInitializer),kernelRegularizer:hL(this.kernelRegularizer),recurrentRegularizer:hL(this.recurrentRegularizer),biasRegularizer:hL(this.biasRegularizer),activityRegularizer:hL(this.activityRegularizer),kernelConstraint:CO(this.kernelConstraint),recurrentConstraint:CO(this.recurrentConstraint),biasConstraint:CO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}jL.className="SimpleRNNCell",NI(jL);class HL extends VL{constructor(t){t.cell=new jL(t),super(t)}call(t,e){return xS((()=>{null!=this.cell.dropoutMask&&(kS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(kS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}HL.className="SimpleRNN",NI(HL);class KL extends GL{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new b_("GRUCell does not support reset_after parameter set to true.");this.units=t.units,M_(this.units,"units"),this.activation=oL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=oL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=JD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=JD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=JD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=pL(t.kernelRegularizer),this.recurrentRegularizer=pL(t.recurrentRegularizer),this.biasRegularizer=pL(t.biasRegularizer),this.kernelConstraint=AO(t.kernelConstraint),this.recurrentConstraint=AO(t.recurrentConstraint),this.biasConstraint=AO(t.biasConstraint),this.dropout=iD([1,lD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=iD([1,lD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=$D(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xS((()=>{if(2!==t.length)throw new b_("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ZL({ones:()=>UE(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ZL({ones:()=>UE(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=gI(t,a[0]));let c=xD(t,this.kernel.read());this.useBias&&(c=ND(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=gI(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=iC(u,[2*this.units,this.units],u.rank-1),p=xD(r,h),[f,g,m]=iC(c,3,c.rank-1),[b,y]=iC(p,2,p.rank-1);o=this.recurrentActivation.apply(dI(f,b)),i=this.recurrentActivation.apply(dI(g,y));const v=xD(gI(i,r),d);l=this.activation.apply(dI(m,v));const w=dI(gI(o,r),gI(dI(1,LE(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:aL(this.activation),recurrentActivation:aL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:XD(this.kernelInitializer),recurrentInitializer:XD(this.recurrentInitializer),biasInitializer:XD(this.biasInitializer),kernelRegularizer:hL(this.kernelRegularizer),recurrentRegularizer:hL(this.recurrentRegularizer),biasRegularizer:hL(this.biasRegularizer),activityRegularizer:hL(this.activityRegularizer),kernelConstraint:CO(this.kernelConstraint),recurrentConstraint:CO(this.recurrentConstraint),biasConstraint:CO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}KL.className="GRUCell",NI(KL);class qL extends VL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new KL(t),super(t)}call(t,e){return xS((()=>{null!=this.cell.dropoutMask&&(kS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(kS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}qL.className="GRU",NI(qL);class XL extends GL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,M_(this.units,"units"),this.activation=oL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=oL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=JD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=JD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=JD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=pL(t.kernelRegularizer),this.recurrentRegularizer=pL(t.recurrentRegularizer),this.biasRegularizer=pL(t.biasRegularizer),this.kernelConstraint=AO(t.kernelConstraint),this.recurrentConstraint=AO(t.recurrentConstraint),this.biasConstraint=AO(t.biasConstraint),this.dropout=iD([1,lD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=iD([1,lD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=$D(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends RD{apply(e,r){const a=t.apply([n]),s=(new _D).apply([n]),o=t.apply([2*n]);return yD(yD(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return xS((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new b_("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ZL({ones:()=>UE(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ZL({ones:()=>UE(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=gI(t,s[0]));let h=xD(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=gI(r,o[0])),h=dI(h,xD(r,this.recurrentKernel.read())),this.useBias&&(h=ND(h,this.bias.read()));const[d,p,f,g]=iC(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=dI(gI(l,a),gI(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=gI(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:aL(this.activation),recurrentActivation:aL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:XD(this.kernelInitializer),recurrentInitializer:XD(this.recurrentInitializer),biasInitializer:XD(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:hL(this.kernelRegularizer),recurrentRegularizer:hL(this.recurrentRegularizer),biasRegularizer:hL(this.biasRegularizer),activityRegularizer:hL(this.activityRegularizer),kernelConstraint:CO(this.kernelConstraint),recurrentConstraint:CO(this.recurrentConstraint),biasConstraint:CO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}XL.className="LSTMCell",NI(XL);class JL extends VL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new XL(t),super(t)}call(t,e){return xS((()=>{null!=this.cell.dropoutMask&&(kS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(kS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}JL.className="LSTM",NI(JL);class YL extends GL{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return xS((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;YD(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{eD("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(UO(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return rO(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}aO(e)}}function ZL(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):ED(e(),n),i=()=>CD(o,e,r);if(!a||a<=1)return SS(i().clone());return Array(a).fill(void 0).map(i).map((t=>SS(t.clone())))}YL.className="StackedRNNCells",NI(YL);var QL=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class $L extends VL{constructor(t){if(t.unroll)throw new y_("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new y_("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new sO({ndim:5})]}call(t,e){return xS((()=>{if(null!=this.cell.dropoutMask&&(kS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(kS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new b_("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return xS((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=BE([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];xS((()=>{if(!this.stateful)throw new g_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new b_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>BE(a))):this.states_=[BE(a)];else if(null==t)kS(this.states_),null!=this.keptStates&&(kS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>BE(a))):this.states_[0]=BE(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new b_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):kS(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!Qb(n.shape,r))throw new b_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>SS(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=xL(l,r[0],a,s[0],o[0]),h=xL(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}$L.className="ConvRNN2D";class tM extends XL{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,M_(this.filters,"filters"),this.kernelSize=wL(n,2,"kernelSize"),this.kernelSize.forEach((t=>M_(t,"kernelSize"))),this.strides=wL(r||1,2,"strides"),this.strides.forEach((t=>M_(t,"strides"))),this.padding=a||"valid",Z_(this.padding),this.dataFormat=s||"channelsLast",Y_(this.dataFormat),this.dilationRate=wL(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>M_(t,"dilationRate")))}build(t){var e;t=$D(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new b_("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends RD{apply(t,e){return bD([n.apply([r]),WE([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return xS((()=>{if(3!==t.length)throw new b_("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ZL({ones:()=>UE(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?gI(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ZL({ones:()=>UE(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=iC(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?iC(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,E,C,T]=iC(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,E),g=this.recurrentConv(g,C),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(dI(l,p)),R=this.recurrentActivation.apply(dI(c,f)),F=dI(gI(R,s),gI(A,this.activation.apply(dI(u,g)))),_=gI(this.recurrentActivation.apply(dI(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=QL(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,e,n,r){const a=XN(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?ND(a,n,this.dataFormat):a}recurrentConv(t,e){return XN(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}tM.className="ConvLSTM2DCell",NI(tM);class eM extends $L{constructor(t){const e=new tM(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}eM.className="ConvLSTM2D",NI(eM);class nM extends uO{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return CD((()=>ED(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}nM.className="Dropout",NI(nM);class rM extends nM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}rM.className="SpatialDropout1D",NI(rM);class aM extends uO{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,M_(this.units,"units"),this.activation=oL(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=JD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=JD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=AO(t.kernelConstraint),this.biasConstraint=AO(t.biasConstraint),this.kernelRegularizer=pL(t.kernelRegularizer),this.biasRegularizer=pL(t.biasRegularizer),this.activityRegularizer=pL(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=$D(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=$D(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t),r=B_(this.activation.getClassName());let a;return null!=r?a=xD(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=xD(n,this.kernel.read()),null!=this.bias&&(a=ND(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:aL(this.activation),useBias:this.useBias,kernelInitializer:XD(this.kernelInitializer),biasInitializer:XD(this.biasInitializer),kernelRegularizer:hL(this.kernelRegularizer),biasRegularizer:hL(this.biasRegularizer),activityRegularizer:hL(this.activityRegularizer),kernelConstraint:CO(this.kernelConstraint),biasConstraint:CO(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}aM.className="Dense",NI(aM);class sM extends uO{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=$D(t);for(const e of t.slice(1))if(null==e)throw new b_('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],oD(t,1)]}call(t,e){return xS((()=>{this.invokeCallHook(t,e);let n=QD(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=yC(n,t)}return function(t){if(t.rank<=1)throw new b_("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],oD(t.shape,1)];return ON(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}sM.className="Flatten",NI(sM);class oM extends uO{constructor(t){super(t),this.supportsMasking=!0,this.activation=oL(t.activation)}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t);return this.activation.apply(n)}))}getConfig(){const t={activation:aL(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}oM.className="Activation",NI(oM);class iM extends uO{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return xS((()=>{return t=QD(t),e=t,n=this.n,xS((()=>{if(2!==e.shape.length)throw new b_("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return vD(pD(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}iM.className="RepeatVector",NI(iM);class lM extends uO{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new b_("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=oD(t);if(null!==s){if(0===a||o%a!==0)throw new b_(n);r[s]=o/a}else if(o!==a)throw new b_(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ON(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}lM.className="Reshape",NI(lM);class cM extends uO{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=cD(1,t.dims.length+1);if(!Qb(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new sO({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=$D(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return yC(QD(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}cM.className="Permute",NI(cM);class uM extends uO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=QD(t);return bN(ME(n,this.maskValue),-1)}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t),r=bN(ME(n,this.maskValue),-1,!0);return gI(n,uI(r,n.dtype))}))}}uM.className="Masking",NI(uM);class hM extends uO{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(N_(t.inputLength))}this.inputDim=t.inputDim,M_(this.inputDim,"inputDim"),this.outputDim=t.outputDim,M_(this.outputDim,"outputDim"),this.embeddingsInitializer=JD(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=pL(t.embeddingsRegularizer),this.activityRegularizer=pL(t.activityRegularizer),this.embeddingsConstraint=AO(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return xS((()=>this.maskZero?(t=QD(t),ME(t,yI(t))):null))}computeOutputShape(t){if(t=$D(t),null==this.inputLength)return[...t,this.outputDim];const e=N_(this.inputLength);if(e.length!==t.length-1)throw new b_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new b_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return xS((()=>{this.invokeCallHook(t,e);let n=QD(t);"int32"!==n.dtype&&(n=dD(n,"int32"));const r=kD(this.embeddings.read(),ON(n,[n.size]));return ON(r,$D(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:XD(this.embeddingsInitializer),embeddingsRegularizer:hL(this.embeddingsRegularizer),activityRegularizer:hL(this.activityRegularizer),embeddingsConstraint:CO(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}hM.className="Embedding",NI(hM);class dM extends uO{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new y_}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new b_("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[$D(t)]),t.length<2)throw new b_("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=D_(e),e.length>1)throw new b_("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===D_(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return xS((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=lD(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=pD(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=ON(s,[r].concat(oD(t.slice(1))));o=yC(o,[1,0]),o=ON(o,a),e.push(o),n=!0}else if(t>1){const r=cD(1,t).concat([0]);e.push(yC(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=ON(yC(ON(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(cD(0,a-1));r=yC(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=D_(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return xS((()=>{if(null==e)return null;if(!Array.isArray(e))throw new b_("`mask` should be an Array");if(!Array.isArray(t))throw new b_("`inputs` should be an Array");if(e.length!==t.length)throw new b_("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:oE(t,0))))[0];for(let t=1;t<e.length-1;++t)n=TE(n,e[t]);return n}))}}class pM extends dM{constructor(t){super(t)}mergeFunction(t){return xS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=dI(e,t[n]);return e}))}}pM.className="Add",NI(pM);class fM extends dM{constructor(t){super(t)}mergeFunction(t){return xS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=gI(e,t[n]);return e}))}}fM.className="Multiply",NI(fM);class gM extends dM{constructor(t){super(t)}mergeFunction(t){return xS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=dI(e,t[n]);return gI(1/t.length,e)}))}}gM.className="Average",NI(gM);class mM extends dM{constructor(t){super(t)}mergeFunction(t){return xS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=MI(e,t[n]);return e}))}}mM.className="Maximum",NI(mM);class bM extends dM{constructor(t){super(t)}mergeFunction(t){return xS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=OE(e,t[n]);return e}))}}bM.className="Minimum",NI(bM);class yM extends dM{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new b_("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if(Qb(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new b_("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return xS((()=>bD(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new b_("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new b_("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new b_("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new b_("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return xS((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(uI(UE(t[s]),"bool")):e[s].rank<t[s].rank?r.push(oE(e[s],-1)):r.push(e[s]);const a=GN(r,this.axis);return mN(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function vM(t,e){for(;t<0;)t+=e;return t}yM.className="Concatenate",NI(yM);class wM extends dM{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Xb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new y_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new b_("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new b_("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>vM(e,t[n].shape.length))):[vM(this.axes,n.shape.length),vM(this.axes,r.shape.length)],this.normalize&&(n=VO(n,e[0]),r=VO(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new y_("batchDot is not implemented for tensors of 4D or higher rank yet");if(Xb(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),Xb(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new y_("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return xS((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=ON(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=ON(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?bE(gI(t,e),s[0]):bE(gI(yC(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=AE(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=lC(o,e)}return 1===o.shape.length&&(o=oE(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[vM(this.axes,t.length),vM(this.axes,e.length)],n}computeOutputShape(t){Xb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new y_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}wM.className="Dot",NI(wM);class xM extends uO{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t);return CD((()=>dI(wD(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}xM.className="GaussianNoise",NI(xM);class kM extends uO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return xS((()=>{this.invokeCallHook(t,e);const n=QD(t);if(this.rate>0&&this.rate<1){return CD((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return gI(n,wD(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}kM.className="GaussianDropout",NI(kM);class SM extends uO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||QD(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return xS((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=QD(t),r=-1.7580993408473766;let a=dE(qE(n),this.rate);a=dD(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=dI(gI(e,a),gI(dI(a,-1),r));return dI(gI(i,s),o)};return CD(r,(()=>QD(t)),e.training||!1)}return t}))}}function IM(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=PN(t,e,n,r,a,o);else if(3===t.rank)s=BN(t,e,n,r,a,o);else{if(4!==t.rank)throw new y_("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=WN(t,e,n,r,a,o)}return s}function NM(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Qb(r.slice().sort(),cD(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return xS((()=>{const s=zE(t,r),o=s.mean,i=s.variance;return[IM(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return xS((()=>{const s=zE(t,r),o=s.mean,i=s.variance,l=[];for(const e of cD(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=ON(o,l),u=ON(i,l),h=null==e?null:ON(e,l),d=null==n?null:ON(n,l);return[IM(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}SM.className="AlphaDropout",NI(SM);class EM extends uO{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=JD(t.betaInitializer||"zeros"),this.gammaInitializer=JD(t.gammaInitializer||"ones"),this.movingMeanInitializer=JD(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=JD(t.movingVarianceInitializer||"ones"),this.betaConstraint=AO(t.betaConstraint),this.gammaConstraint=AO(t.gammaConstraint),this.betaRegularizer=pL(t.betaRegularizer),this.gammaRegularizer=pL(t.gammaRegularizer)}build(t){t=$D(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new b_("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new sO({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return xS((()=>{const n=null!=e.training&&e.training,r=QD(t),a=r.shape,s=a.length,o=cD(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=x_(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!Qb(c,cD(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=ON(this.movingMean.read(),l),e=ON(this.movingVariance.read(),l),n=this.center?ON(this.beta.read(),l):null,a=this.scale?ON(this.gamma.read(),l):null;return IM(r,t,e,n,a,this.epsilon)}return IM(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=NM(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{xS((()=>{const r=1-n,a=t.read(),s=gI(FI(a,e),r);t.write(FI(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:XD(this.betaInitializer),gammaInitializer:XD(this.gammaInitializer),movingMeanInitializer:XD(this.movingMeanInitializer),movingVarianceInitializer:XD(this.movingVarianceInitializer),betaRegularizer:hL(this.betaRegularizer),gammaRegularizer:hL(this.gammaRegularizer),betaConstraint:CO(this.betaConstraint),gammaConstraint:CO(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}EM.className="BatchNormalization",NI(EM);class CM extends uO{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=JD(t.betaInitializer||"zeros"),this.gammaInitializer=JD(t.gammaInitializer||"ones"),this.betaRegularizer=pL(t.betaRegularizer),this.gammaRegularizer=pL(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=$D(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==D_(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=QD(t),r=n.shape,a=r.length;return xS((()=>{let{mean:t,variance:e}=zE(n,this.axis,!0);const s=x_(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?ON(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=iE(t,c),e=iE(e,c),null!=i&&(i=iE(i,u)),null!=l&&(l=iE(l,u)),IM(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:XD(this.betaInitializer),gammaInitializer:XD(this.gammaInitializer),betaRegularizer:hL(this.betaRegularizer),gammaRegularizer:hL(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}CM.className="LayerNormalization",NI(CM);class TM extends uO{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new b_("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new b_("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new b_("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new sO({ndim:4})]}computeOutputShape(t){let e,n;return t=$D(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return xS((()=>{return e=QD(t),n=this.padding,r=this.dataFormat,xS((()=>{if(4!==e.rank)throw new b_("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new b_("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new b_("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],VE(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function AM(t,e,n,r,a,s){return xS((()=>{let o;Y_(a),Q_(s),Z_(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=SL(t,a);const i="same"===r?"same":"valid";return o="max"===s?RE(t,e,n,i):zN(t,e,n,i),"channelsFirst"===a&&(o=yC(o,[0,3,1,2])),o}))}function RM(t,e,n,r,a,s){return xS((()=>{let o;Y_(a),Q_(s),Z_(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=IL(t,a);const i="same"===r?"same":"valid";return o="max"===s?FE(t,e,n,i):LN(t,e,n,i),"channelsFirst"===a&&(o=yC(o,[0,4,1,2,3])),o}))}TM.className="ZeroPadding2D",NI(TM);class FM extends uO{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new b_("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(M_(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new b_("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}M_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Z_(this.padding),this.inputSpec=[new sO({ndim:3})]}computeOutputShape(t){const e=xL((t=$D(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return xS((()=>{this.invokeCallHook(t,e),t=pD(QD(t),2);const n=this.poolingFunction(QD(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return lC(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class _M extends FM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),AM(t,e,n,r,a,"max")}}_M.className="MaxPooling1D",NI(_M);class DM extends FM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),AM(t,e,n,r,a,"avg")}}DM.className="AveragePooling1D",NI(DM);class OM extends uO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new b_("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];M_(this.poolSize,"poolSize"),M_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Y_(this.dataFormat),Z_(this.padding),this.inputSpec=[new sO({ndim:4})]}computeOutputShape(t){t=$D(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=xL(e,this.poolSize[0],this.padding,this.strides[0]),n=xL(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return xS((()=>(this.invokeCallHook(t,e),this.poolingFunction(QD(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class zM extends OM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),AM(t,e,n,r,a,"max")}}zM.className="MaxPooling2D",NI(zM);class LM extends OM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),AM(t,e,n,r,a,"avg")}}LM.className="AveragePooling2D",NI(LM);class MM extends uO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new b_("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];M_(this.poolSize,"poolSize"),M_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Y_(this.dataFormat),Z_(this.padding),this.inputSpec=[new sO({ndim:5})]}computeOutputShape(t){t=$D(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=xL(e,this.poolSize[0],this.padding,this.strides[0]),n=xL(n,this.poolSize[1],this.padding,this.strides[1]),r=xL(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return xS((()=>(this.invokeCallHook(t,e),this.poolingFunction(QD(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class PM extends MM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),RM(t,e,n,r,a,"max")}}PM.className="MaxPooling3D",NI(PM);class BM extends MM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Y_(a),Z_(r),RM(t,e,n,r,a,"avg")}}BM.className="AveragePooling3D",NI(BM);class WM extends uO{constructor(t){super(t),this.inputSpec=[new sO({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new y_}}class UM extends WM{constructor(t){super(t||{})}call(t,e){return xS((()=>{const e=QD(t);return _E(e,1)}))}}UM.className="GlobalAveragePooling1D",NI(UM);class VM extends WM{constructor(t){super(t||{})}call(t,e){return xS((()=>{const e=QD(t);return mE(e,1)}))}}VM.className="GlobalMaxPooling1D",NI(VM);class GM extends uO{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Y_(this.dataFormat),this.inputSpec=[new sO({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new y_}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class jM extends GM{call(t,e){return xS((()=>{const e=QD(t);return"channelsLast"===this.dataFormat?_E(e,[1,2]):_E(e,[2,3])}))}}jM.className="GlobalAveragePooling2D",NI(jM);class HM extends GM{call(t,e){return xS((()=>{const e=QD(t);return"channelsLast"===this.dataFormat?mE(e,[1,2]):mE(e,[2,3])}))}}HM.className="GlobalMaxPooling2D",NI(HM);class KM extends uO{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=UO(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class qM extends KM{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=$D(t)).length<3)throw new b_("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=$D(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return xS((()=>UL(((t,n)=>[QD(this.layer.call(t,e)),[]]),t=QD(t),[],!1,null,null,!1,!0)[1]))}}qM.className="TimeDistributed",NI(qM);class XM extends KM{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=UO(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=UO(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,z_(X_,"BidirectionalMergeMode",a),t.weights)throw new y_("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):I_(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=WL(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new b_("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new sO({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new y_("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof oO;for(const l of s)if(l instanceof oO!==i)throw new b_("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return xS((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=YE(a,1)),"concat"===this.mergeMode?o=bD([r,a]):"sum"===this.mergeMode?o=dI(r,a):"ave"===this.mergeMode?o=gI(.5,dI(r,a)):"mul"===this.mergeMode?o=gI(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){eD(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),eD(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=UO(e.layer);if(delete e.layer,null!=e.numConstants)throw new y_("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}XM.className="Bidirectional",NI(XM);class JM extends uO{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return xS((()=>("float32"!==(t=QD(t)).dtype&&(t=dD(t,"float32")),dI(gI(t,this.scale),this.offset))))}}JM.className="Rescaling",NI(JM);const{resizeBilinear:YM,cropAndResize:ZM}=vT;class QM extends uO{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,r,a,s,o,i){return xS((()=>{let l,c=!1;const u=[e/s,n/o,(r+e)/s,(a+n)/o],h=[];3===t.rank?(c=!0,l=cC([t])):l=t;for(let t=0;t<l.shape[0];t++)h.push(u);const d=bS(h,[h.length,4]),p=XE(0,h.length,1,"int32"),f=ZM(l,d,p,[r,a],"nearest");return dD(c?QD(fC(f)):f,i)}))}upsize(t,e,n,r){return xS((()=>dD(YM(t,[e,n]),r)))}call(t,e){return xS((()=>{const e=QD(t),n=e.dtype,r=e.shape,a=r[r.length-3],s=r[r.length-2];let o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let i=0;return s!==this.width&&(i=Math.floor((s-this.width)/2),0===i&&(i=1)),o>=0&&i>=0?this.centerCrop(e,o,i,this.height,this.width,a,s,n):this.upsize(t,this.height,this.width,n)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=$D(t)).length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}}QM.className="CenterCrop",NI(QM);class $M extends uO{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=$D(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return xS((()=>{let n;if("int32"!==(t=QD(t)).dtype&&(t=dD(t,"int32")),"undefined"!==typeof e.countWeights){if("count"!==this.outputMode)throw new b_("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(e.countWeights));n=QD(e.countWeights)}const r=mE(t),a=DE(t),s=hE(this.numTokens,r).bufferSync().get(0),o=dE(a,0).bufferSync().get(0);if(!s||!o)throw new b_("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(t,e,n,r){let a=QD(t);if("int32"!==a.dtype&&(a=dD(a,"int32")),"int"===e)return a;const s=a.shape;if(0===a.rank&&(a=oE(a,-1)),"oneHot"===e&&1!==a.shape[a.shape.length-1]&&(a=oE(a,-1)),a.rank>2)throw new b_("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(e," and input shape ").concat(s)+" which would result in output rank ".concat(a.rank,"."));const o=["multiHot","oneHot"].includes(e),i=a;let l;if(l=eE(i,"undefined"!==typeof r&&"count"===e?r:[],n,o),"tfIdf"!==e)return l;if(r)return gI(l,r);throw new b_("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,n)}))}}$M.className="CategoryEncoding",NI($M);const tP=new Set(["bilinear","nearest"]);class eP extends uO{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!tP.has(t.interpolation))throw new b_("Invalid interpolation parameter: ".concat(t.interpolation," is not implemented"));this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=$D(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return xS((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return vT.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return vT.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...tP]," are supported"))}))}}eP.className="Resizing",NI(eP);class nP{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}nP.className="RandomSeed";class rP extends uO{constructor(t){super(t),this.randomGenerator=new nP(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}rP.className="BaseRandomLayer";const aP=new Set(["bilinear","nearest"]);class sP extends rP{constructor(t){super(t);const{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new b_("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new b_("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new b_("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!aP.has(n))throw new b_("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=$D(t))[2];return[this.imgHeight,-1,e]}call(t,e){return xS((()=>{const e=QD(t);this.imgHeight=e.shape[e.shape.length-3];const n=e.shape[e.shape.length-2];this.widthFactor=qE([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return vT.resizeBilinear(t,a);case"nearest":return vT.resizeNearestNeighbor(t,a);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...aP]," are supported"))}}))}}sP.className="RandomWidth",NI(sP);var oP,iP;Ty().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(oP||(oP={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(iP||(iP={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function lP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(dP(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=lP(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function cP(t){return uP(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:hP)}function uP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(dP(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=uP(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function hP(t){return null===t?null:dP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function dP(t){let e=!1;if(Ty().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(4222);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Lk)&&!(t instanceof Promise)&&!e)}function pP(t){return function(t,e){return lP(t,e)}(t,fP)}function fP(t){return t instanceof Lk?{value:t.clone(),recurse:!1}:dP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class gP{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class mP extends gP{constructor(){super(mP.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function bP(t){return new xP(t)}function yP(t,e){return new _P(t,e)}mP.INITIAL_CAPACITY=32;class vP{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new TP(this,t)}filter(t){return new EP(this,t)}map(t){return new CP(this,t)}mapAsync(t){return new AP(this,t)}serialMapAsync(t){return new AP(this,t).serial()}flatmap(t){return new FP(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new NP(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:hP;return this.rowMajorBatch(t,e).map((t=>cP(t,n)))}concatenate(t,e){return new _P(new wP([this,t]),e)}take(t){return t<0||null==t?this:new IP(this,t)}skip(t){return t<0||null==t?this:new SP(this,t)}prefetch(t){return new OP(this,t)}shuffle(t,e){return new zP(this,t,e)}serial(){return new kP(this)}}class wP extends vP{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:pP(t),done:!1}}}class xP extends vP{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(o1){throw o1.message="Error thrown while iterating through a dataset: ".concat(o1.message),o1}}}class kP extends vP{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class SP extends vP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;kS(t.value)}return this.upstream.next()}}class IP extends vP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class NP extends vP{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class EP extends vP{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;kS(t.value)}}}class CP extends vP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Zk(t.value),n=this.transform(t.value),r=Zk(n);for(const a of e)Yk(a,r)||a.dispose();return{value:n,done:!1}}}class TP extends vP{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(o1){if(!this.handler(o1))return{value:null,done:!0}}}}class AP extends vP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Zk(t.value),n=await this.transform(t.value),r=Zk(n);for(const a of e)Yk(a,r)||a.dispose();return{value:n,done:!1}}}class RP extends vP{constructor(){super(),this.outputQueue=new mP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class FP extends RP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Zk(t.value),n=this.transform(t.value),r=Zk(n);this.outputQueue.pushAll(n);for(const a of e)Yk(a,r)||a.dispose();return!0}}class _P extends vP{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var DP;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(DP||(DP={}));class OP extends vP{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new gP(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class zP extends OP{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Uo.alea(n||mk().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class LP{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Xb(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),MP((async()=>(await n.iterator()).columnMajorBatch(t,e,PP)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,MP((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,MP((async()=>(await e.iterator()).filter((e=>xS((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return MP((async()=>(await e.iterator()).map((e=>xS((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return MP((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return MP((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,MP((async()=>yP(bP((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,MP((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Uo.alea(e||mk().toString());return MP((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,MP((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function MP(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends LP{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function PP(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Lk||vk(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Lk?cC(t):bS(t)}(t),recurse:!1}}return{value:null,recurse:!0}}LP.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function BP(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Xb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors in the CPU backend.")))}))}const WP=DA;class UP extends Vb{nextDataId(){return UP.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ub(this,vS())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Ty().get("IS_NODE")&&jx("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&uy(n[0])){const a=n.map((t=>bk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){if(this.data.has(t)){return this.data.get(t).refCount}return 0}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,n,r,a){this.data.set(t,{values:e,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){return ZT(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(t,e){if(Array.isArray(t))return t;if("float32"===e)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===e)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===e||"string"===e)return Uint8Array.from(new Int32Array(t));throw new Error("Unknown dtype ".concat(e))}(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>yk(t)));return cI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return cI(t.shape,t.dtype,e)}makeOutput(t,e,n){return vS().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=mk();t();return{kernelMs:mk()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){BP([t],"where");const e=this.readSync(t.dataId);return WP(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}UP.nextDataId=0;function VP(t){return(e,n,r)=>{const a=iy(n,e.length);for(let s=0;s<e.length;++s)a[s]=t(e[s],r);return a}}function GP(t,e,n){return jP(t,VP(e),n)}function jP(t,e,n){return r=>{let{inputs:a,attrs:s,backend:o}=r;const{x:i}=a;BP(i,t);const l=o,c=l.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=FA(c)}else u=c;const h=n||i.dtype,d=e(u,h,s);return l.makeTensorInfo(i.shape,h,d)}}IS("cpu",(()=>new UP),1);const HP=GP(Fv,(t=>t>=0?t:Math.exp(t)-1)),KP={kernelName:Fv,backendName:"cpu",kernelFunc:HP};function qP(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const XP={kernelName:Xv,backendName:"cpu",kernelFunc:qP};function JP(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r;BP([a],"leakyRelu");const o=Zb(a.shape),i=n.data.get(a.dataId).values,l=oy("float32",o);for(let c=0;c<i.length;c++)l[c]=i[c]<0?s*i[c]:i[c];return n.makeTensorInfo(a.shape,"float32",l)}const YP={kernelName:tw,backendName:"cpu",kernelFunc:JP};function ZP(t){return(e,n,r,a,s)=>{const o=LI(e,n),i=o.length,l=gy(o),c=oy(s,Zb(o)),u=e.length,h=n.length,d=gy(e),p=gy(n),f=OI(e,o),g=OI(n,o);if(f.length+g.length===0)for(let m=0;m<c.length;++m)c[m]=t(r[m%r.length],a[m%a.length]);else for(let m=0;m<c.length;++m){const e=Sy(m,i,l),n=e.slice(-u);f.forEach((t=>n[t]=0));const s=ky(n,u,d),o=e.slice(-h);g.forEach((t=>o[t]=0));const b=ky(o,h,p);c[m]=t(r[s],a[b])}return[c,o]}}const QP=ZP(((t,e)=>t<0?e*t:t));function $P(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e;BP([r,a],"prelu");const s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[i,l]=QP(r.shape,a.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",i)}const tB={kernelName:zw,backendName:"cpu",kernelFunc:$P},eB=GP(Gw,(t=>Math.max(0,t))),nB={kernelName:Gw,backendName:"cpu",kernelFunc:eB},rB=GP(Jw,(t=>Math.min(Math.max(0,t),6))),aB={kernelName:Jw,backendName:"cpu",kernelFunc:rB},sB=VP((t=>1/(1+Math.exp(-t)))),oB=GP(lx,(t=>1/(1+Math.exp(-t)))),iB={kernelName:lx,backendName:"cpu",kernelFunc:oB};function lB(t,e,n,r,a){if("linear"===n)return qP({inputs:{x:e},backend:t});if("relu"===n)return eB({inputs:{x:e},backend:t});if("elu"===n)return HP({inputs:{x:e},backend:t});if("relu6"===n)return rB({inputs:{x:e},backend:t});if("prelu"===n)return $P({inputs:{x:e,alpha:r},backend:t});if("leakyrelu"===n)return JP({inputs:{x:e},backend:t,attrs:{alpha:a}});if("sigmoid"===n)return oB({inputs:{x:e},backend:t});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function cB(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}const uB={kernelName:sv,backendName:"cpu",kernelFunc:cB};function hB(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return cB({inputs:{real:hB(t,e,"float32"),imag:hB(t,e,"float32")},backend:t})}const r=vy(Zb(e),n);return t.makeTensorInfo(e,n,r)}function dB(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const pB={kernelName:Uw,backendName:"cpu",kernelFunc:dB};function fB(t,e,n,r){if("int32"===r){return[e,"int32",Int32Array.from(t)]}if("bool"===r){const r=gk([0],n),[a,s]=ZP(((t,e)=>t!==e?1:0))(e,[],t,r,"bool");return[s,"bool",a]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(r))}function gB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return qP({inputs:{x:a},backend:n});const t=hB(n,a.shape,a.dtype),e=gB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=cB({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),r}if("complex64"===a.dtype){const t=dB({inputs:{input:a},backend:n}),e=gB({inputs:{x:t},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(t),e}if(!ly(a.dtype,s)){const t=qP({inputs:{x:a},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:s}}const o=n.data.get(a.dataId).values,[i,l,c]=fB(o,a.shape,a.dtype,s);return n.makeTensorInfo(i,l,c)}const mB={kernelName:nv,backendName:"cpu",kernelFunc:gB};function bB(t,e,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:o,b:i}=a,l=s;BP([o,i],t);const c=l.data.get(o.dataId).values,u=l.data.get(i.dataId).values,h="string"===o.dtype?FA(c):c,d="string"===o.dtype?FA(u):u,p=r||o.dtype,[f,g]=e(o.shape,i.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:t=>{let{inputs:a,backend:s}=t;const{a:o,b:i}=a,l=s;if("complex64"===o.dtype||"complex64"===i.dtype){const t=gB({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),e=l.data.get(t.dataId),r=e.complexTensorInfos.real,a=e.complexTensorInfos.imag,s=l.data.get(r.dataId).values,c=l.data.get(a.dataId).values,u=gB({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,[m,b,y]=n(o.shape,i.shape,s,c,f,g),v=l.makeTensorInfo(y,"float32",m),w=l.makeTensorInfo(y,"float32",b),x=cB({inputs:{real:v,imag:w},backend:l});return l.disposeIntermediateTensorInfo(t),l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(w),x}{const t=l.data.get(o.dataId).values,n=l.data.get(i.dataId).values,a=r||o.dtype,[s,c]=e(o.shape,i.shape,t,n,a);return l.makeTensorInfo(c,a,s)}}}function yB(t){return(e,n,r,a,s,o)=>{const i=LI(e,n),l=Zb(i),c=i.length,u=gy(i),h=oy("float32",l),d=oy("float32",l),p=OI(e,i),f=OI(n,i),g=ZT(r,a),m=ZT(s,o),b=e.length,y=gy(e),v=n.length,w=gy(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const e=x%g.length,n=x%m.length,r=t(g[2*e],g[2*e+1],m[2*n],m[2*n+1]);h[x]=r.real,d[x]=r.imag}else for(let x=0;x<h.length;x++){const e=Sy(x,c,u),n=e.slice(-b);p.forEach((t=>n[t]=0));const r=ky(n,b,y),a=e.slice(-v);f.forEach((t=>a[t]=0));const s=ky(a,v,w),o=t(g[2*r],g[2*r+1],m[2*s],m[2*s+1]);h[x]=o.real,d[x]=o.imag}return[h,d,i]}}const vB=ZP(((t,e)=>t+e)),wB=yB(((t,e,n,r)=>({real:t+n,imag:e+r}))),xB=bB(Ly,vB,wB),kB={kernelName:Ly,backendName:"cpu",kernelFunc:xB};function SB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=Zb(a.shape),i=ry(s,o),l=Zb(i);Xb(o===l,(()=>"The new shape (".concat(i,") has ").concat(l," elements and the old ")+"shape (".concat(a.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(a.dataId);const c=n.data.get(a.dataId);if(null!=c.complexTensorInfos){const t=c.complexTensorInfos.real,e=c.complexTensorInfos.imag;t.shape=i,e.shape=i}return{dataId:a.dataId,shape:i,dtype:a.dtype}}const IB={kernelName:jw,backendName:"cpu",kernelFunc:SB};function NB(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;BP([a,s],"matMul");const l=a.shape.length,c=s.shape.length,u=o?a.shape[l-2]:a.shape[l-1],h=i?s.shape[c-1]:s.shape[c-2],d=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[c-2]:s.shape[c-1],f=a.shape.slice(0,-2),g=s.shape.slice(0,-2),m=Zb(f),b=Zb(g),y=LI(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);Xb(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(a.shape," and ")+"".concat(s.shape," and transposeA=").concat(o)+" and transposeB=".concat(i," must match.")));const v=i?[b,p,h]:[b,h,p],w=SB({inputs:{x:a},backend:n,attrs:{shape:o?[m,u,d]:[m,d,u]}}),x=SB({inputs:{x:s},backend:n,attrs:{shape:v}}),k=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],I=i?x.shape[1]:x.shape[2],N=Math.max(m,b),E=n.data.get(w.dataId).values,C=n.data.get(x.dataId).values,T=gy(w.shape),A=gy(x.shape),[R,F,_]=o?[T[0],1,T[1]]:[T[0],T[1],1],[D,O,z]=i?[1,A[1],A[0]]:[A[1],1,A[0]],L=S*I,M=cI([N,S,I],w.dtype),P=M.values,B=n.blockSize;for(let W=0;W<N;W++){const t=W%m,e=W%b;for(let n=0;n<S;n+=B){const r=Math.min(n+B,S);for(let a=0;a<I;a+=B){const s=Math.min(a+B,I);for(let o=0;o<k;o+=B){const i=Math.min(o+B,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=o;a<i;a++){r+=E[t*R+l*F+a*_]*C[a*D+n*O+e*z]}P[W*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(y,M.dtype,M.values)}const EB={kernelName:Zy,backendName:"cpu",kernelFunc:NB};const CB={kernelName:Ux,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let d,p,f;const g=[];d=NB({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=xB({inputs:{a:d,b:o},backend:n}),g.push(d),d=p),u&&(f=lB(n,d,u,i,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}};function TB(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const AB={kernelName:Dy,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;BP(e,"abs");let r=new Float32Array(Zb(e.shape));return r=TB(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,e.dtype)}},RB=GP(Oy,(t=>Math.acos(t))),FB={kernelName:Oy,backendName:"cpu",kernelFunc:RB},_B=GP(zy,(t=>Math.acosh(t))),DB={kernelName:zy,backendName:"cpu",kernelFunc:_B};const OB={kernelName:My,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,r=e;BP(e,"addN");const a=r.map((t=>n.data.get(t.dataId).values)),s=cI(r[0].shape,r[0].dtype),o=s.values;for(let i=0;i<r.length;i++){const t=a[i];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function zB(t,e,n,r,a){const s=e.length,o=Zb(e),i=gy(e),l=gy(a),c=oy(n,Zb(a));for(let u=0;u<o;++u){const e=Sy(u,s,i),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];c[ky(n,s,l)]=t[u]}return c}function LB(t){const{inputs:e,attrs:n,backend:r}=t,{x:a}=e,{perm:s}=n;BP(a,"transpose");const o=a.shape.length,i=new Array(o);for(let c=0;c<i.length;c++)i[c]=a.shape[s[c]];const l=zB(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:r.write(l,i,a.dtype),shape:i,dtype:a.dtype}}const MB={kernelName:Dx,backendName:"cpu",kernelFunc:LB};const PB={kernelName:Py,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;BP(a,"all");const i=ay(s,a.shape);let l=i;const c=IE(l,a.shape.length);let u=a;null!=c&&(u=LB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=EE(l.length,a.shape.length)),SE("all",l,u.shape.length);const[h,d]=xE(u.shape,l),p=Zb(d),f=vy(Zb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e&&r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=SB({inputs:{x:m},backend:n,attrs:{shape:kE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const BB={kernelName:By,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;BP(a,"any");const i=ay(s,a.shape);let l=i;const c=IE(l,a.shape.length);let u=a;null!=c&&(u=LB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=EE(l.length,a.shape.length)),SE("any",l,u.shape.length);const[h,d]=xE(u.shape,l),p=Zb(d),f=vy(Zb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e||r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=SB({inputs:{x:m},backend:n,attrs:{shape:kE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const WB={kernelName:Wy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;BP(a,"argMax");let o=ay(s,a.shape);const i=IE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=LB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=EE(o.length,l.shape.length)),o=[o[0]],SE("argMax",o,l.shape.length);const[u,h]=xE(l.shape,o),d=vy(Zb(u),"int32"),p=Zb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a>e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}};const UB={kernelName:Uy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;BP(a,"argMin");let o=ay(s,a.shape);const i=IE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=LB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=EE(o.length,l.shape.length)),o=[o[0]],SE("argMin",o,l.shape.length);const[u,h]=xE(l.shape,o),d=vy(Zb(u),"int32"),p=Zb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a<e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}},VB=GP(Vy,(t=>Math.asin(t))),GB={kernelName:Vy,backendName:"cpu",kernelFunc:VB},jB=GP(Gy,(t=>Math.asinh(t))),HB={kernelName:Gy,backendName:"cpu",kernelFunc:jB},KB=GP(jy,(t=>Math.atan(t))),qB={kernelName:jy,backendName:"cpu",kernelFunc:KB},XB=ZP(((t,e)=>Math.atan2(t,e))),JB=bB(Ky,XB),YB={kernelName:Ky,backendName:"cpu",kernelFunc:JB},ZB=GP(Hy,(t=>Math.atanh(t))),QB={kernelName:Hy,backendName:"cpu",kernelFunc:ZB};function $B(t,e,n,r,a,s){const o=a.strideHeight,i=a.strideWidth,l=a.dilationHeight,c=a.dilationWidth,u=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=cI(a.outShape,n),m=g.values,b=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let w=0;w<a.batchSize;++w){const e=w*b,n=w*r[0];for(let g=0;g<a.inChannels;++g)for(let b=0;b<a.outHeight;++b){const w=b*o-d,x=Math.max(0,w),k=Math.min(a.inHeight,u+w),S=e+b*y;for(let e=0;e<a.outWidth;++e){const o=e*i-p,u=Math.max(0,o),d=Math.min(a.inWidth,h+o);let b=f,y=0,w=0;for(let e=x;e<k;e+=l){const a=n+e*r[1];for(let e=u;e<d;e+=c){const n=t[a+e*r[2]+g];"max"===s&&n>b?b=n:"avg"===s&&(y+=n,w++)}if(isNaN(b))break}m[S+e*v+g]="avg"===s?y/w:b}}}return g}function tW(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=cI(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=cI(e,n,t);for(let m=0;m<r.batchSize;++m)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*i-p;let b=n;for(;b<0;)b+=c;const y=Math.min(r.inHeight,h+n);for(let i=0;i<r.outWidth;++i){const h=i*l-f;let p=h;for(;p<0;)p+=u;const v=Math.min(r.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let e=b;e<y;e+=c){const o=e-n;for(let n=p;n<v;n+=u){const i=n-h,l=g.get(m,e,n,t);l>w&&(w=l,x=a?s?((m*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+i)}}o.set(x,m,e,i,t)}}return o}function eW(t,e,n,r,a,s){const o=a.strideDepth,i=a.strideHeight,l=a.strideWidth,c=a.dilationDepth,u=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,g=a.padInfo.front,m=a.padInfo.top,b=a.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=cI(a.outShape,n),w=v.values,x=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){const e=N*x,n=N*r[0];for(let v=0;v<a.inChannels;++v)for(let x=0;x<a.outDepth;++x){const N=x*o-g;let E=N;for(;E<0;)E+=c;const C=Math.min(a.inDepth,d+N),T=e+x*k;for(let e=0;e<a.outHeight;++e){const o=e*i-m;let d=o;for(;d<0;)d+=u;const g=Math.min(a.inHeight,p+o),x=T+e*S;for(let e=0;e<a.outWidth;++e){const o=e*l-b;let i=o;for(;i<0;)i+=h;const p=Math.min(a.inWidth,f+o),m=x+e*I;let k=y,S=0,N=0;for(let e=E;e<C;e+=c){const a=n+e*r[1];for(let e=d;e<g;e+=u){const n=a+e*r[2];for(let e=i;e<p;e+=h){const a=t[n+e*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[m+v]="avg"===s?S/Math.max(N,1):k}}}}return v}const nW={kernelName:qy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;BP(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Xb(RN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=wN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&Qb(c.inShape,c.outShape))u=qP({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=gy(a.shape),r=$B(t,a.shape,a.dtype,e,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const rW={kernelName:Jy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;BP(a,"avgPool3d");const u=xN(a.shape,s,o,1,i,l,c),h=eW(n.data.get(a.dataId).values,a.shape,a.dtype,gy(a.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const aW={kernelName:Yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;BP([a,s],"avgPool3DGrad");const u=xN(s.shape,o,i,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,w=u.effectiveFilterDepth,x=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=w-1-u.padInfo.front,I=k-1-u.padInfo.left,N=x-1-u.padInfo.top,E=cI(s.shape,"float32"),C=1/(f*g*m),T=n.bufferSync(a);for(let A=0;A<u.batchSize;++A)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-S,s=n-N,o=r-I;let i=0;for(let e=0;e<w;e+=b){const n=(a+e)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let e=0;e<x;e+=y){const r=(s+e)/d;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let e=0;e<k;e+=v){const a=(o+e)/p;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;i+=T.get(A,n,r,a,t)}}}E.set(i*C,A,e,n,r,t)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}};const sW={kernelName:Xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;BP([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=wN(o.shape,i,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,w=b-1-u.padInfo.top,x=cI(o.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=cI(a.shape,"float32",S);for(let N=0;N<u.batchSize;++N)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inHeight;++e)for(let n=0;n<u.inWidth;++n){const r=e-w,a=n-v;let s=0;for(let e=0;e<b;e+=g){const n=(r+e)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let e=0;e<y;e+=m){const r=(a+e)/d;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;s+=I.get(N,n,r,t)}}x.set(s*k,N,e,n,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const oW={kernelName:Gv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,scale:s,offset:o,mean:i,variance:l}=e;Xb(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Xb(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Xb(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),BP([a,i,l,s,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,b=p.length,y=d.length,v=h.length;let w=0,x=0,k=0,S=0;for(let I=0;I<u.length;++I)g[I]=f[w++]+(u[I]-h[x++])*p[k++]/Math.sqrt(d[S++]+c),w>=m&&(w=0),x>=v&&(x=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,g)}};function iW(t,e,n,r,a){const s=hN(r,e,n),o=Zb(n),i=gy(r);if(s){const n=dN(e,i);return"string"===a?t.slice(n,n+o):t.subarray(n,n+o)}const l=cI(r,a,"string"===a?FA(t):t),c=cI(n,a);for(let u=0;u<c.size;++u){const t=c.indexToLoc(u),n=t.map(((t,n)=>t+e[n]));c.set(l.get(...n),...t)}return"string"===a?_A(c.values):c.values}function lW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r;BP(a,"slice");const[i,l]=pN(a,s,o);$I(a,i,l);const c=iW(n.data.get(a.dataId).values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}const cW={kernelName:ax,backendName:"cpu",kernelFunc:lW};const uW={kernelName:Qy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;BP([a],"batchToSpaceND");const i=s.reduce(((t,e)=>t*e)),l=OT(a.shape,s,i),c=zT(l.length,s.length),u=LT(a.shape,s,i),h=MT(o,s.length),d=PT(u,o,s.length),p=SB({inputs:{x:a},backend:n,attrs:{shape:l}}),f=LB({inputs:{x:p},backend:n,attrs:{perm:c}}),g=SB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=lW({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function hW(t,e,n,r,a){const s=Zb(r),o=vy(a,n);for(let i=0;i<t.length;i++){const n=t[i];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(o[n]+=s>0?e[i]:1)}return o}function dW(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=t.shape[0],s=t.shape[1],o=cI([a,n],e.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=t.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):e.size>0?o.set(o.get(i,s)+e.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}const pW={kernelName:$y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=hW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}},fW=ZP(((t,e)=>t&e)),gW={kernelName:tv,backendName:"cpu",kernelFunc:bB(tv,fW)};const mW={kernelName:ev,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=LI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},bW=VP((t=>Math.ceil(t))),yW=jP(rv,bW),vW={kernelName:rv,backendName:"cpu",kernelFunc:yW},wW=GP(av,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),xW={kernelName:av,backendName:"cpu",kernelFunc:wW},kW={kernelName:ov,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Zb(e.shape)),a=n.data.get(e.dataId),s=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let c=0;c<i.length;c++){const t=i[c],e=l[c];r[c]=Math.hypot(t,e)}return n.makeOutput(r,e.shape,"float32")}};function SW(t,e,n,r){const a=iy(n,Zb(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=Zb(t.shape);a.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const s="string"===n?FA(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const i=n*e[1]+r;for(let e=0;e<t.shape[1];++e)a[i+e]=s[o++]}r+=t.shape[1]}))}return a}function IW(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const NW={kernelName:Yv,backendName:"cpu",kernelFunc:IW};function EW(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=ay(a,e[0].shape)[0];IT(e.map((t=>t.shape)),s);let o=NT(e.map((t=>t.shape)),s);if(0===Zb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Zb(t.shape)>0));if(1===i.length)return qP({inputs:{x:i[0]},backend:n});if("complex64"===i[0].dtype){const t=i.map((t=>dB({inputs:{input:t},backend:n}))),e=i.map((t=>IW({inputs:{input:t},backend:n}))),r=EW({inputs:t,backend:n,attrs:{axis:s}}),a=EW({inputs:e,backend:n,attrs:{axis:s}}),o=cB({inputs:{real:r,imag:a},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}const l=i.map((t=>{const e=Zb(t.shape.slice(s));return SB({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),c=l.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));o=NT(l.map((t=>t.shape)),1);const u=1===l[0].shape[0],h=SW(c,o,e[0].dtype,u),d=NT(i.map((t=>t.shape)),s),p=n.makeTensorInfo(d,e[0].dtype,h);return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}const CW={kernelName:iv,backendName:"cpu",kernelFunc:EW};function TW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r;BP([a,s],"conv2d");const h=_N(l),d=kN(a.shape,s.shape,o,c,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new _k(d.outShape,a.dtype),x=gy(a.shape),k=gy(s.shape),S=x[0],I=v?x[1]:x[2],N=v?x[2]:1,E=v?1:x[1],C=w.strides[0],T=v?w.strides[1]:w.strides[2],A=v?w.strides[2]:1,R=v?1:w.strides[1],F=n.data.get(a.dataId).values,_=n.data.get(s.dataId).values,D=w.values;for(let O=0;O<d.batchSize;++O){const t=O*S,e=O*C;for(let n=0;n<d.outHeight;++n){const r=e+n*T,a=n*d.strideHeight-y;for(let e=0;e<p;++e){const n=a+e*g;if(n<0||n>=d.inHeight)continue;const s=e*k[0],o=t+n*I;for(let t=0;t<d.outWidth;++t){const e=r+t*A,n=t*d.strideWidth-b;for(let t=0;t<f;++t){const r=n+t*m;if(r<0||r>=d.inWidth)continue;const a=o+r*N;let i=s+t*k[1];for(let t=0;t<d.inChannels;++t){const n=F[a+t*E];for(let t=0;t<d.outChannels;++t)D[e+t*R]+=n*_[i+t];i+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,D)}const AW={kernelName:lv,backendName:"cpu",kernelFunc:TW};const RW={kernelName:cv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;BP([a,s],"conv2dBackpropFilter");const h=_N(l),d=kN(a.shape,u,o,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,y=new _k(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new _k(a.shape,a.dtype,x),I=new _k(s.shape,s.dtype,k);for(let N=0;N<g;++N){const t=Math.max(0,Math.ceil((w-N)/p)),e=Math.min(d.outHeight,(d.inHeight+w-N)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let s=0;s<d.inChannels;++s)for(let o=0;o<d.outChannels;++o){let i=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<e;++c){const t=N+c*p-w;for(let e=r;e<a;++e){const r=n+e*f-v;i+=b?S.get(l,t,r,s)*I.get(l,c,e,o):S.get(l,s,t,r)*I.get(l,o,c,e)}}y.set(i,N,n,s,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const FW={kernelName:uv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r;BP([a,s],"conv2dBackpropInput");const h=gy(s.shape),d=gy(a.shape);let p=_N(c);const f=kN(o,s.shape,i,1,l,u,!1,p),g=new _k(f.inShape,"float32"),m=g.values,b=n.data.get(a.dataId).values,y=n.data.get(s.dataId).values,[v,w,x]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:E,inWidth:C,outChannels:T,outHeight:A,outWidth:R,strideHeight:F,strideWidth:_}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,O=I-1-f.padInfo.left,z="channelsLast"===p,L=g.strides[0],M=z?g.strides[1]:g.strides[2],P=z?g.strides[2]:1,B=z?1:g.strides[1],W=d[0],U=z?d[1]:d[2],V=z?d[2]:1,G=z?1:d[1];for(let j=0;j<k;++j)for(let t=0;t<N;++t)for(let e=0;e<E;++e){const n=e-D,r=Math.max(0,Math.ceil(n/F)),a=Math.min(A,(S+n)/F);for(let s=0;s<C;++s){const o=s-O,i=Math.max(0,Math.ceil(o/_)),l=Math.min(R,(I+o)/_);let c=0;for(let e=r;e<a;++e){const r=e*F-n;for(let n=i;n<l;++n){const a=W*j+U*e+V*n,s=v*(S-1-r)+w*(I-1-(n*_-o))+x*t;for(let t=0;t<T;++t){c+=b[a+G*t]*y[s+t]}}}m[L*j+M*e+P*s+B*t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const _W={kernelName:hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r;BP([a,s],"conv3d");const c=SN(a.shape,s.shape,o,l,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,b=m.front,y=m.left,v=m.top,w=new _k(c.outShape,a.dtype),x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=w.values,I=gy(a.shape),N=gy(s.shape);for(let E=0;E<c.batchSize;++E){const t=E*I[0],e=E*w.strides[0];for(let n=0;n<c.outDepth;++n){const r=e+n*w.strides[1],a=n*c.strideDepth-b;for(let e=0;e<u;++e){const n=a+e*p;if(n<0||n>=c.inDepth)continue;const s=e*N[0],o=t+n*I[1];for(let t=0;t<c.outHeight;++t){const e=r+t*w.strides[2],n=t*c.strideHeight-v;for(let t=0;t<h;++t){const r=n+t*f;if(r<0||r>=c.inHeight)continue;const a=s+t*N[1],i=o+r*I[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,r=t*c.strideWidth-y;for(let t=0;t<d;++t){const e=r+t*g;if(e<0||e>=c.inWidth)continue;const s=a+t*N[2],o=i+e*c.inChannels;let l=s;for(let t=0;t<c.inChannels;++t){const e=x[o+t];for(let t=0;t<c.outChannels;++t)S[n+t]+=e*k[l+t];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const DW={kernelName:dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r;BP([a,s],"conv3dBackpropFilterV2");const c=gy(a.shape),u=gy(s.shape),h=SN(a.shape,l,o,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,y=new _k(h.filterShape,"float32"),v=y.values,[w,x,k,S]=y.strides,I=n.data.get(s.dataId).values,[N,E,C,T]=u,A=n.data.get(a.dataId).values,[R,F,_,D]=c,O=h.padInfo.front,z=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<g;++M){const t=Math.max(0,Math.ceil((O-M)/d)),e=Math.min(h.outDepth,(h.inDepth+O-M)/d),n=M*w;for(let r=0;r<m;++r){const a=Math.max(0,Math.ceil((L-r)/p)),s=Math.min(h.outHeight,(h.inHeight+L-r)/p),o=r*x+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((z-n)/f)),l=Math.min(h.outWidth,(h.inWidth+z-n)/f),c=n*k+o;for(let o=0;o<h.inChannels;++o){const u=o*S+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let u=0;u<h.batchSize;++u){const h=u*R,m=u*N;for(let u=t;u<e;++u){const t=(M+u*d-O)*F+h,e=u*E+m;for(let u=a;u<s;++u){const a=(r+u*p-L)*_+t,s=u*C+e;for(let t=i;t<l;++t){const e=t*T+s;g+=A[(n+t*f-z)*D+a+o]*I[e+c]}}}}v[u+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const OW={kernelName:pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r;BP([a],"conv3dBackpropInputV2");const c=gy(a.shape),u=gy(s.shape),h=SN(l,s.shape,i,1,o),d=new _k(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,y=n.data.get(a.dataId).values,[v,w,x,k]=c,S=n.data.get(s.dataId).values,[I,N,E,C]=u,{batchSize:T,filterDepth:A,filterHeight:R,filterWidth:F,inChannels:_,inDepth:D,inHeight:O,inWidth:z,outChannels:L,outDepth:M,outHeight:P,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,G=A-1-h.padInfo.front,j=R-1-h.padInfo.top,H=F-1-h.padInfo.left;for(let K=0;K<T;++K)for(let t=0;t<_;++t)for(let e=0;e<D;++e){const n=e-G,r=Math.max(0,Math.ceil(n/W)),a=Math.min(M,(A+n)/W);for(let s=0;s<O;++s){const o=s-j,i=Math.max(0,Math.ceil(o/U)),l=Math.min(P,(R+o)/U);for(let c=0;c<z;++c){const u=c-H,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(F+u)/V);let T=0;for(let e=r;e<a;++e){const r=e*W-n;for(let n=i;n<l;++n){const a=n*U-o;for(let s=h;s<d;++s){const o=v*K+w*e+x*n+k*s,i=I*(A-1-r)+N*(R-1-a)+E*(F-1-(s*V-u))+C*t;for(let t=0;t<L;++t){T+=y[o+t]*S[i+t]}}}}p[f*K+g*e+m*s+b*c+t]=T}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},zW=GP(fv,(t=>Math.cos(t))),LW={kernelName:fv,backendName:"cpu",kernelFunc:zW},MW=GP(gv,(t=>Math.cosh(t))),PW={kernelName:gv,backendName:"cpu",kernelFunc:MW};const BW={kernelName:yv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,[u,h,d,p]=a.shape,f=s.shape[0],[g,m]=i,b=cI([f,g,m,p],"float32"),y=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(a.dataId).values,x=gy(a.shape),k=gy(b.shape);for(let S=0;S<f;S++){const t=4*S,e=y[t],n=y[t+1],r=y[t+2],a=y[t+3],s=v[S];if(s>=u)continue;const o=g>1?(r-e)*(h-1)/(g-1):0,i=m>1?(a-n)*(d-1)/(m-1):0;for(let u=0;u<g;u++){const t=g>1?e*(h-1)+u*o:.5*(e+r)*(h-1);if(t<0||t>h-1)for(let e=0;e<m;e++)for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}else if("bilinear"===l){const e=Math.floor(t),r=Math.ceil(t),o=t-e;for(let t=0;t<m;t++){const l=m>1?n*(d-1)+t*i:.5*(n+a)*(d-1);if(l<0||l>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let a=n+h*x[2]+e*x[1]+s*x[0];const i=w[a];a=n+f*x[2]+e*x[1]+s*x[0];const l=w[a];a=n+h*x[2]+r*x[1]+s*x[0];const c=w[a];a=n+f*x[2]+r*x[1]+s*x[0];const d=i+(l-i)*g,p=c+(w[a]-c)*g;a=n+t*k[2]+u*k[1]+S*k[0],b.values[a]=d+(p-d)*o}}}else for(let e=0;e<m;++e){const r=m>1?n*(d-1)+e*i:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const o=Math.round(r),l=Math.round(t);for(let t=0;t<p;t++){const n=t+o*x[2]+l*x[1]+s*x[0],r=t+e*k[2]+u*k[1]+S*k[0];b.values[r]=w[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const WW={kernelName:mv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;BP(a,"cumprod");const l=IE([s],a.shape.length);let c=a;null!=l&&(c=LB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=EE(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Hk(c.dtype,"int32"),d=yy(Zb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?1:p[e];else{const n=g(b,t-1);d[e]=o?p[n]*d[n]:p[e]*d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=LB({inputs:{x:m},backend:n,attrs:{perm:NE(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const UW={kernelName:bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;BP(a,"cumsum");const l=IE([s],a.shape.length);let c=a;null!=l&&(c=LB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=EE(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Hk(c.dtype,"int32"),d=vy(Zb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?0:p[e];else{const n=g(b,t-1);d[e]=o?p[n]+d[n]:p[e]+d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=LB({inputs:{x:m},backend:n,attrs:{perm:NE(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const VW={kernelName:vv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=hW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,t)}if(2===a.shape.length){const t=dW(n.bufferSync(a),n.bufferSync(s),o,i);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};const GW={kernelName:wv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r;Xb("NHWC"===o,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)));const i=a.shape[0],l=a.shape[1],c=a.shape[2],u=a.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(a.dataId).values,g=new Float32Array(i*h*d*p);let m=0;for(let b=0;b<i;++b)for(let t=0;t<h;++t){const e=Math.floor(t/s),n=t%s;for(let t=0;t<d;++t){const r=Math.floor(t/s),a=(n*s+t%s)*p;for(let t=0;t<p;++t){const n=t+a+u*(r+c*(e+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],a.dtype,g)}};function jW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;BP([a,s],"depthwiseConv2DNative");const u=gy(a.shape),h=gy(s.shape);let d=l;null==d&&(d=[1,1]),Xb(RN(o,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'")));const p=kN(a.shape,s.shape,o,d,i,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:y}=p,v=y.left,w=y.top,x=p.outChannels/p.inChannels,k=new _k(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let E=0;E<p.batchSize;++E){const t=E*u[0],e=E*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=e+n*k.strides[1],a=n*p.strideHeight-w;for(let e=0;e<f;++e){const n=a+e*m;if(n<0||n>=p.inHeight)continue;const s=e*h[0],o=t+n*u[1];for(let t=0;t<p.outWidth;++t){const e=r+t*k.strides[2],n=t*p.strideWidth-v;for(let t=0;t<g;++t){const r=n+t*b;if(r<0||r>=p.inWidth)continue;const a=s+t*h[1],i=o+r*p.inChannels;let l=e,c=a;for(let t=0;t<p.inChannels;++t){const e=S[i+t];for(let t=0;t<x;++t)N[l+t]+=e*I[c+t];l+=x,c+=x}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const HW={kernelName:xv,backendName:"cpu",kernelFunc:jW};const KW={kernelName:kv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r;BP([a,s],"depthwiseConv2dNativeBackpropFilter");const h=kN(a.shape,u,o,i,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new _k(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(a.dataId).values,x=new _k(a.shape,a.dtype,w),k=n.data.get(s.dataId).values,S=new _k(s.shape,s.dtype,k);for(let I=0;I<f;++I){const t=Math.max(0,Math.ceil((y-I)/d)),e=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((b-n)/p)),a=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/v),i=s%v;let l=0;for(let c=0;c<h.batchSize;++c)for(let i=t;i<e;++i){const t=I+i*d-y;for(let e=r;e<a;++e){const r=n+e*p-b;l+=x.get(c,t,r,o)*S.get(c,i,e,s)}}m.set(l,I,n,o,i)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const qW={kernelName:Sv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r;BP([a,s],"depthwiseConv2DNativeBackpropInput");const h=gy(a.shape),d=gy(s.shape),p=kN(u,s.shape,o,i,l,c,!0),f=new _k(p.inShape,"float32"),g=f.values,[m,b,y]=f.strides,v=n.data.get(a.dataId).values,[w,x,k]=h,S=n.data.get(s.dataId).values,[I,N,E]=d,{batchSize:C,filterHeight:T,filterWidth:A,inChannels:R,inHeight:F,inWidth:_,outChannels:D,outHeight:O,outWidth:z,strideHeight:L,strideWidth:M}=p,P=T-1-p.padInfo.top,B=A-1-p.padInfo.left,W=D/R;for(let U=0;U<C;++U)for(let t=0;t<R;++t)for(let e=0;e<F;++e){const n=e-P,r=Math.max(0,Math.ceil(n/L)),a=Math.min(O,(T+n)/L);for(let s=0;s<_;++s){const o=s-B,i=Math.max(0,Math.ceil(o/M)),l=Math.min(z,(A+o)/M);let c=0;for(let e=r;e<a;++e){const r=e*L-n;for(let n=i;n<l;++n){const a=w*U+x*e+k*n,s=I*(T-1-r)+N*(A-1-(n*M-o))+E*t;for(let e=0;e<W;++e){c+=v[a+(t*W+e)]*S[s+e]}}}g[m*U+b*e+y*s+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const XW={kernelName:Iv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=Zb(r.shape),s=n.data.get(r.dataId).values,o=cI([a,a],r.dtype),i=o.values;for(let c=0;c<s.length;c++)i[c*a+c]=s[c];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},JW={kernelName:Nv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=n,u=c.data.get(a.dataId).values,h=a.shape.length,d=c.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:b,outHeight:y,outWidth:v,padInfo:w,strideHeight:x,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:E,outShape:C}=vN(a.shape,s.shape,o,i,"NHWC",l),T=Zb(C),A=C.length,R=iy(a.dtype,T);for(let F=0;F<f;++F)for(let t=0;t<y;++t){const e=t*x-w.top;for(let n=0;n<v;++n){const r=n*k-w.left;for(let o=0;o<b;++o){let i=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*N;if(n>=0&&n<g)for(let e=0;e<I;++e){const l=r+e*E;if(l>=0&&l<m){const r=ky([F,n,l,o],h,gy(a.shape)),c=ky([t,e,o],p,gy(s.shape)),f=u[r]+d[c];f>i&&(i=f)}}}R[ky([F,t,n,o],A,gy(C))]=i}}}return{dataId:c.write(gk(R,a.dtype),C,a.dtype),shape:C,dtype:a.dtype}}},YW={kernelName:Cv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=by(a.shape,u.data.get(a.dataId).values),d=by(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:E}=vN(a.shape,s.shape,i,l,"NHWC",c);Xb(o.rank===E.length,(()=>"Error in ".concat(Cv,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(o.rank)));const C=by(E,u.data.get(o.dataId).values),T=wy(s.shape,s.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=t,i=e)}}}T[o][i][a]+=C[A][t][n][a]}}}return{dataId:u.write(gk(T,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},ZW={kernelName:Ev,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=by(a.shape,u.data.get(a.dataId).values),d=by(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:E}=vN(a.shape,s.shape,i,l,"NHWC",c);Xb(o.rank===E.length,(()=>"Error in ".concat(Ev,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(o.rank)));const C=by(E,u.data.get(o.dataId).values),T=wy(a.shape,a.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=e<0?0:e,i=r<0?0:r;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=n,i=l)}}}T[A][o][i][a]+=C[A][t][n][a]}}}return{dataId:u.write(gk(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const QW={kernelName:Tv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a}=e,{canvas:s,options:o}=r,{contextOptions:i,imageOptions:l}=o||{},c=(null===l||void 0===l?void 0:l.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const h=s.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],g=n.data.get(a.dataId).values,m="float32"===a.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const t=[0,0,0,255*c];for(let n=0;n<f;n++){const e=g[v*f+n];if("float32"===a.dtype){if(e<0||e>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(e,"."))}else if("int32"===a.dtype&&(e<0||e>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(e,"."));1===f?(t[0]=e*m,t[1]=e*m,t[2]=e*m):t[n]=e*m}const e=4*v;b[e+0]=Math.round(t[0]),b[e+1]=Math.round(t[1]),b[e+2]=Math.round(t[2]),b[e+3]=Math.round(t[3])}s.width=p,s.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),a}},$W=ZP(((t,e)=>t*e)),tU=yB(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),eU=bB(Iw,$W,tU),nU={kernelName:Iw,backendName:"cpu",kernelFunc:eU};function rU(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;let i;BP(a,"sum"),i="bool"===a.dtype?gB({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):qP({inputs:{x:a},backend:n});const l=i.shape.length,c=ay(s,i.shape),u=IE(c,l);let h=c,d=i;null!=u&&(d=LB({inputs:{x:i},backend:n,attrs:{perm:u}}),h=EE(h.length,l)),SE("sum",h,d.shape.length);const[p,f]=xE(d.shape,h);let g=hB(n,p,Hk(d.dtype,"int32"));const m=Zb(f),b=n.data.get(g.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const t=v*m;let e=0;for(let n=0;n<m;++n)e+=y[t+n];b[v]=e}if(o){const t=g;g=SB({inputs:{x:g},backend:n,attrs:{shape:kE(g.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),g}const aU={kernelName:hx,backendName:"cpu",kernelFunc:rU};const sU={kernelName:Rv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=cA(a,s.length);hA(o.length,l,s);const{path:c,steps:u}=dA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=uA(p,l[t]);let a;pA(e)?a=s[t]:(a=LB({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);Qb(a.shape,o)||(a=SB({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=eU({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=rU({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}};const oU={kernelName:_v,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:a}=e;BP([r,a],"eluGrad");const s=new Float32Array(Zb(a.shape)),o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const t=o[l];s[l]=t>=0?i[l]:i[l]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},iU=ZP(((t,e)=>t===e?1:0)),lU=bB(Ov,iU,null,"bool"),cU={kernelName:Ov,backendName:"cpu",kernelFunc:lU},uU=HT,hU=KT,dU=qT,pU=XT,fU=JT,gU=YT,mU=GP(Dv,(t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+uU*n);return e*(1-((((gU*r+fU)*r+pU)*r+dU)*r+hU)*r*Math.exp(-n*n))})),bU={kernelName:Dv,backendName:"cpu",kernelFunc:mU},yU=VP((t=>Math.exp(t))),vU=jP(zv,yU,"float32"),wU={kernelName:zv,backendName:"cpu",kernelFunc:vU};function xU(t){const{inputs:e,backend:n,attrs:r}=t,{input:a}=e,{dim:s}=r,o=a.shape.length,i=a.shape.slice();let l=s;return s<0&&(Xb(-(o+1)<=s,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+s+1),i.splice(l,0,1),SB({inputs:{x:a},backend:n,attrs:{shape:i}})}const kU={kernelName:Lv,backendName:"cpu",kernelFunc:xU},SU=VP((t=>Math.expm1(t))),IU=jP(Mv,SU),NU={kernelName:Mv,backendName:"cpu",kernelFunc:IU},EU=ZP(((t,e)=>t/e)),CU=bB(Av,EU),TU={kernelName:Av,backendName:"cpu",kernelFunc:CU},AU=ZP(((t,e)=>t-e)),RU=yB(((t,e,n,r)=>({real:t-n,imag:e-r}))),FU=bB(Cx,AU,RU),_U={kernelName:Cx,backendName:"cpu",kernelFunc:FU};function DU(t,e,n){const r=t.shape,a=r[0],s=r[1],o=n.data.get(t.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[a,s],u=Zb(c),h=oy("float32",u),d=oy("float32",u);for(let m=0;m<a;m++){const t=lW({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,s]}}),r=lW({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,s]}}),a=cB({inputs:{real:t,imag:r},backend:n}),{real:o,imag:c}=OU(a,e,n),u=ZT(o,c);for(let e=0;e<s;e++){const t=eA(u,e);h[m*s+e]=t.real,d[m*s+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),g=cB({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function OU(t,e,n){const r=Zb(t.shape),a=n.data.get(t.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((i=r)&i-1)){const a=zU(s,o,r,e,n),i=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(i,"float32",a.real),e=n.makeTensorInfo(i,"float32",a.imag),s=n.makeTensorInfo([],"float32",fk(r,"float32")),o=qP({inputs:{x:s},backend:n}),l=TU.kernelFunc({inputs:{a:t,b:s},backend:n}),c=TU.kernelFunc({inputs:{a:e,b:o},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return a}{const t=function(t,e,n){const r=new Float32Array(2*e);for(let a=0;a<e;a++){let s=0,o=0;for(let r=0;r<e;r++){const i=aA(a*r,e,n),l=eA(t,r);s+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(s/=e,o/=e),nA(r,s,o,a)}return r}(ZT(s,o),r,e);return QT(t)}var i}function zU(t,e,n,r,a){if(1===n)return{real:t,imag:e};const s=ZT(t,e),o=n/2,i=$T(s),l=i.real,c=i.imag,u=[l.length],h=a.makeTensorInfo(u,"float32",l),d=a.makeTensorInfo(u,"float32",c),p=cB({inputs:{real:h,imag:d},backend:a}),f=tA(s),g=f.real,m=f.imag,b=[g.length],y=a.makeTensorInfo(b,"float32",g),v=a.makeTensorInfo(b,"float32",m),w=cB({inputs:{real:y,imag:v},backend:a}),x=zU(l,c,o,r,a),k=x.real,S=x.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),E=a.makeTensorInfo(I,"float32",S),C=cB({inputs:{real:N,imag:E},backend:a}),T=zU(g,m,o,r,a),A=T.real,R=T.imag,F=[A.length],_=a.makeTensorInfo(F,"float32",A),D=a.makeTensorInfo(F,"float32",R),O=cB({inputs:{real:_,imag:D},backend:a}),z=rA(n,r),L=[z.real.length],M=a.makeTensorInfo(L,"float32",z.real),P=a.makeTensorInfo(L,"float32",z.imag),B=cB({inputs:{real:M,imag:P},backend:a}),W=eU({inputs:{a:B,b:O},backend:a}),U=xB({inputs:{a:C,b:W},backend:a}),V=FU({inputs:{a:C,b:W},backend:a}),G=dB({inputs:{input:U},backend:a}),j=dB({inputs:{input:V},backend:a}),H=IW({inputs:{input:U},backend:a}),K=IW({inputs:{input:V},backend:a}),q=EW({inputs:[G,j],backend:a,attrs:{axis:0}}),X=EW({inputs:[H,K],backend:a,attrs:{axis:0}}),J=a.data.get(q.dataId).values,Y=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(O),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(X),{real:J,imag:Y}}const LU={kernelName:Pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Zb(r.shape),s=r.shape[r.shape.length-1],o=SB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=DU(o,!1,n),l=SB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}};function MU(t){const{backend:e,attrs:n}=t,{shape:r,value:a,dtype:s}=n,o=s||dy(a),i=iy(o,Zb(r));return function(t,e,n){t.fill(e)}(i,a),e.makeTensorInfo(r,o,i)}const PU={kernelName:Bv,backendName:"cpu",kernelFunc:MU};const BU={kernelName:Wv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,s=r,o=oy(a.dtype,Zb(a.shape)),[i,l,c,u]=a.shape,h=s.data.get(a.dataId).values;for(let d=0;d<i;d++){const t=d*c*l*u;for(let e=0;e<l;e++){const n=e*(c*u);for(let e=0;e<c;e++){const r=e*u;for(let a=0;a<u;a++){const s=Math.round(c-e-1),i=t+n+r+a;let l=h[i];if(s>=0&&s<c){l=h[t+n+s*u+a]}o[i]=l}}}}return{dataId:s.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},WU=VP((t=>Math.floor(t))),UU=jP(Uv,WU),VU={kernelName:Uv,backendName:"cpu",kernelFunc:UU},GU=ZP(((t,e)=>Math.floor(t/e))),jU=bB(Vv,GU,null,"int32"),HU={kernelName:Vv,backendName:"cpu",kernelFunc:jU};const KU={kernelName:Vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=TW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const t=SB({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=xB({inputs:{a:g,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else g=xB({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=g;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const t=SB({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=lB(n,g,p,t,f),n.disposeIntermediateTensorInfo(t)}else g=lB(n,g,p,i,f);n.disposeIntermediateTensorInfo(t)}return g}};const qU={kernelName:Gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=jW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;g=xB({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=g;g=lB(n,g,p,i,f),n.disposeIntermediateTensorInfo(t)}return g}};function XU(t,e,n,r,a,s,o,i,l){const c=cI([r,s],n);for(let u=0;u<r;u++){const n=[];let r=0;for(let e=0;e<a;e++){const s=t[u*a+e];r+=s*o[e],n.push(s)}if(r<0||r>=l/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let t=0;t<s;t++)c.values[u*s+t]=e.get(...e.indexToLoc(r*s+t))}return c}const JU={kernelName:Hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=Zb(r.shape),o=a.shape,i=o[o.length-1],[l,c,u,h]=BT(r,a);if(0===c)return n.makeTensorInfo(l,r.dtype,[]);const d=XU(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,c,i,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}};function YU(t,e,n){const r=cI(n,t.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],o=n[2],i=e.locToIndex([s,o]);n[2]=e.values[i];const l=t.locToIndex(n);0<=l&&l<t.values.length&&(r.values[a]=t.values[l])}return r}const ZU={kernelName:jv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r;BP([a,s],"gatherV2");const l=ay(o,a.shape)[0],c=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<c.length;++v){const t=c[v];Xb(t<=u-1&&t>=0,(()=>"GatherV2: the index value ".concat(t," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=Zb(s.shape),p=RA(a,s,l,h),f=SB({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=SB({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),y=YU(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},QU=ZP(((t,e)=>t>e?1:0)),$U=bB(Kv,QU,null,"bool"),tV={kernelName:Kv,backendName:"cpu",kernelFunc:$U},eV=ZP(((t,e)=>t>=e?1:0)),nV=bB(qv,eV,null,"bool"),rV={kernelName:qv,backendName:"cpu",kernelFunc:nV};const aV={kernelName:Jv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Zb(r.shape),s=r.shape[r.shape.length-1],o=SB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=DU(o,!0,n),l=SB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}},sV=GP(Zv,(t=>Number.isFinite(t)?1:0),"bool"),oV={kernelName:Zv,backendName:"cpu",kernelFunc:sV},iV=GP(Qv,(t=>Math.abs(t)===1/0?1:0),"bool"),lV={kernelName:Qv,backendName:"cpu",kernelFunc:iV},cV=GP($v,(t=>Number.isNaN(t)?1:0),"bool"),uV={kernelName:$v,backendName:"cpu",kernelFunc:cV},hV=ZP(((t,e)=>t<e?1:0)),dV=bB(ew,hV,null,"bool"),pV={kernelName:ew,backendName:"cpu",kernelFunc:dV},fV=ZP(((t,e)=>t<=e?1:0)),gV=bB(nw,fV,null,"bool"),mV={kernelName:nw,backendName:"cpu",kernelFunc:gV};function bV(t,e,n){const r=(e-t)/(n-1),a=vy(n,"float32");a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const yV={kernelName:rw,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=bV(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},vV=VP((t=>Math.log(t))),wV=jP(aw,vV),xV={kernelName:aw,backendName:"cpu",kernelFunc:wV},kV=GP(sw,(t=>Math.log1p(t))),SV={kernelName:sw,backendName:"cpu",kernelFunc:kV},IV=ZP(((t,e)=>t&&e)),NV=bB(ow,IV,null,"bool"),EV={kernelName:ow,backendName:"cpu",kernelFunc:NV},CV=GP(iw,(t=>t?0:1),"bool"),TV={kernelName:iw,backendName:"cpu",kernelFunc:CV},AV=ZP(((t,e)=>t||e)),RV=bB(lw,AV,null,"bool"),FV={kernelName:lw,backendName:"cpu",kernelFunc:RV};const _V={kernelName:cw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r;BP(a,"LRN");const c=a.shape[3],u=c-1,h=n.data.get(a.dataId).values,d=Zb(a.shape),p=new Float32Array(d);function f(t){const e=t%c;let n=t-e+Math.max(0,e-s);const r=t-e+Math.min(e+s,u);let a=0;for(;n<=r;n++){const t=h[n];a+=t*t}return a}for(let g=0;g<d;g++){const t=f(g),e=h[g]*Math.pow(o+i*t,-l);p[g]=e}return n.makeTensorInfo(a.shape,a.dtype,p)}};const DV={kernelName:uw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r;BP(o,"LRNGrad");const h=Zb(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(a.dataId).values,g=n.data.get(s.dataId).values,m=new Float32Array(h),b=h;for(let y=0;y<b;y++){const t=y%d,e=y-t+Math.max(0,t-i),n=y-t+Math.min(d,t+i+1);let r=0;for(let a=e;a<n;a++)r+=Math.pow(f[a],2);r=c*r+l;for(let a=e;a<n;a++){let t=-2*c*u*f[a]*g[y]/r;y===a&&(t+=Math.pow(r,-u)),t*=p[y],m[a]+=t}}return n.makeTensorInfo(o.shape,a.dtype,m)}};function OV(t,e,n,r){const a=oy(r,Zb(n));for(let s=0;s<a.length;++s){const n=s*e;let r=t[n];for(let a=0;a<e;++a){const e=t[n+a];(Number.isNaN(e)||e>r)&&(r=e)}a[s]=r}return a}function zV(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=n;let l=a.shape;const c=l.length,u=ay(s,l);let h=u;const d=IE(h,c);let p=i.data.get(a.dataId).values;if(null!=d){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=zB(p,l,a.dtype,d,t),h=EE(h.length,c),l=t}BP(a,"max"),SE("max",h,c);const[f,g]=xE(l,h),m=OV(p,Zb(g),f,a.dtype),b=i.write(m,f,a.dtype);let y=f;if(o){y=kE(f,u)}return{dataId:b,shape:y,dtype:a.dtype}}const LV={kernelName:hw,backendName:"cpu",kernelFunc:zV},MV=ZP(((t,e)=>Math.max(t,e))),PV=bB(dw,MV),BV={kernelName:dw,backendName:"cpu",kernelFunc:PV};const WV={kernelName:pw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;BP(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Xb(RN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=wN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&Qb(c.inShape,c.outShape))u=qP({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=gy(a.shape),r=$B(t,a.shape,a.dtype,e,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const UV={kernelName:gw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;BP(a,"maxPool3d");const u=xN(a.shape,s,o,1,i,l,c),h=eW(n.data.get(a.dataId).values,a.shape,a.dtype,gy(a.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const VV={kernelName:mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;BP([a,s],"maxPool3DGrad");const u=xN(s.shape,o,i,1,l,c),h=function(t,e){const n=cI(e.outShape,"int32"),r=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let b=0;b<e.outDepth;++b){const y=b*r-d;let v=y;for(;v<0;)v+=o;const w=Math.min(e.inDepth,c+y);for(let r=0;r<e.outHeight;++r){const c=r*a-p;let d=c;for(;d<0;)d+=i;const x=Math.min(e.inHeight,u+c);for(let a=0;a<e.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(e.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let e=v;e<w;e+=o){const n=e-y;for(let r=d;r<x;r+=i){const a=r-c;for(let s=k;s<S;s+=l){const o=s-p,i=t.get(g,e,r,s,m);i>=I&&(I=i,N=n*u*h+a*u+o)}}}n.set(N,g,b,r,a,m)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,m=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,x=y-1-u.padInfo.front,k=w-1-u.padInfo.left,S=v-1-u.padInfo.top,I=cI(s.shape,"float32"),N=n.bufferSync(a);for(let E=0;E<u.batchSize;++E)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-x,s=n-S,o=r-k;let i=0;for(let e=0;e<y;e+=g){const n=(a+e)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=m){const a=(s+r)/p;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let s=0;s<w;s+=b){const l=(o+s)/f;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const c=y*v*w-1-h.get(E,n,a,l,t)===e*v*w+r*w+s?1:0;if(0===c)continue;i+=N.get(E,n,a,l,t)*c}}}I.set(i,E,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const GV={kernelName:fw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;BP([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=wN(i.shape,l,c,1,u,h),p=n.data.get(i.dataId).values,f=cI(d.outShape,i.dtype,tW(p,i.shape,i.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,k=v-1-d.padInfo.top,S=cI(i.shape,"float32"),I=n.data.get(a.dataId).values,N=cI(a.shape,"float32",I);for(let E=0;E<d.batchSize;++E)for(let t=0;t<d.inChannels;++t)for(let e=0;e<d.inHeight;++e)for(let n=0;n<d.inWidth;++n){const r=e-k,a=n-x;let s=0;for(let e=0;e<v;e+=b){const n=(r+e)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<w;r+=y){const o=(a+r)/m;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const i=v*w-1-f.get(E,n,o,t)===e*w+r?1:0;if(0===i)continue;s+=N.get(E,n,o,t)*i}}S.set(s,E,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const jV={kernelName:bw,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;BP(a,"MaxPoolWithArgmax");const u=c.data.get(a.dataId).values,h=wN(a.shape,s,o,[1,1],i),[d,p]=function(t,e,n,r,a){const s=$B(t,0,n,gy(e),a,"max"),o=tW(t,e,n,a,!0,r);return[s.values,o.values]}(u,a.shape,a.dtype,l,h),f=c.write(d,h.outShape,a.dtype),g=c.write(p,h.outShape,a.dtype);return[{dataId:f,shape:h.outShape,dtype:a.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const HV={kernelName:yw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=ay(s,a.shape),l=Zb(xE(a.shape,i)[1]),c=[],u=n.makeTensorInfo([],"float32",new Float32Array([l]));c.push(u);const h=gB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const d=CU({inputs:{a:h,b:u},backend:n});c.push(d);const p=rU({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}};const KV={kernelName:vw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;BP(a,"min");const i=ay(s,a.shape);let l=i;const c=IE(l,a.shape.length);let u=a;null!=c&&(u=LB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=EE(l.length,a.shape.length)),SE("min",l,u.shape.length);const[h,d]=xE(u.shape,l),p=Zb(d),f=vy(Zb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];(Number.isNaN(r)||r<e)&&(e=r)}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=SB({inputs:{x:m},backend:n,attrs:{shape:kE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}},qV=ZP(((t,e)=>Math.min(t,e))),XV=bB(ww,qV),JV={kernelName:ww,backendName:"cpu",kernelFunc:XV};const YV={kernelName:xw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,mode:o}=r;BP(a,"mirrorPad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=s.map(((t,e)=>t[0]+a.shape[e])),u="reflect"===o?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=gy(a.shape),f=Zb(i),g=i.length,m=gy(i),b=oy(a.dtype,f);for(let y=0;y<f;y++){let t=Sy(y,g,m);for(let n=0;n<g;n++)t[n]<l[n]?t[n]=2*l[n]-t[n]-u:t[n]>=c[n]&&(t[n]=2*(c[n]-1)-t[n]+u);t=t.map(((t,e)=>t-l[e]));const e=ky(t,d,p);b[y]=h[e]}return{dataId:n.write(b,i,a.dtype),shape:i,dtype:a.dtype}}},ZV=ZP(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),QV=bB(kw,ZV),$V={kernelName:kw,backendName:"cpu",kernelFunc:QV};function tG(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=a.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(i));const l=ay([i],a.shape),c=zV({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=kE(c.shape,l),h=SB({inputs:{x:c},backend:n,attrs:{shape:u}}),d=FU({inputs:{a:a,b:h},backend:n}),p=vU({inputs:{x:d},backend:n}),f=rU({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=SB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=CU({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const eG={kernelName:fx,backendName:"cpu",kernelFunc:tG};const nG={kernelName:Sw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r;BP(a,"multinomial");const l=i?a:tG({inputs:{logits:a},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=vy(Zb(d),"int32");for(let f=0;f<c;++f){const t=f*u,e=new Float32Array(u-1);e[0]=h[t];for(let a=1;a<e.length;++a)e[a]=e[a-1]+h[t+a];const n=Uo.alea(o.toString()),r=f*s;for(let a=0;a<s;++a){const t=n();p[r+a]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){p[r+a]=n;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function rG(t,e,n){const r=fk(-1,n);return $W([],e,r,t,n)}const aG={kernelName:Nw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;BP(r,"neg");const a=n.data.get(r.dataId).values,[s,o]=rG(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}},sG=HC;const oG={kernelName:Cw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r;BP(a,"NonMaxSuppression");const c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=sG(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},iG=KC;const lG={kernelName:Tw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r;BP(a,"NonMaxSuppressionPadded");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=iG(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},cG=qC;const uG={kernelName:Aw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r;BP(a,"NonMaxSuppressionWithScore");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=cG(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},hG=ZP(((t,e)=>t!==e?1:0)),dG=bB(Ew,hG,null,"bool"),pG={kernelName:Ew,backendName:"cpu",kernelFunc:dG};const fG={kernelName:Fw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r;BP(a,"oneHot");const c=Zb(a.shape),u=new Float32Array(c*o);u.fill(l);const h=n.data.get(a.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=i);return n.makeTensorInfo([...a.shape,o],s,u)}};function gG(t){const{inputs:e,backend:n}=t,{x:r}=e;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const t=dB({inputs:{input:r},backend:n}),e=gG({inputs:{x:t},backend:n}),a=IW({inputs:{input:r},backend:n}),s=gG({inputs:{x:a},backend:n}),o=cB({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return MU({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const mG={kernelName:Mx,backendName:"cpu",kernelFunc:gG};const bG={kernelName:Rw,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const e=dB({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=IW({inputs:{input:a},backend:r}),o=gG({inputs:{x:s},backend:r}),i=cB({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return MU({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function yG(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return xU({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Jb(s,t.shape,"All tensors passed to stack must have matching shapes"),Xb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=EW({inputs:e.map((t=>{const e=xU({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}const vG={kernelName:_w,backendName:"cpu",kernelFunc:yG};const wG={kernelName:Dw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;BP(a,"pad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=n.data.get(a.dataId).values,u=Zb(a.shape),h=a.shape.length,d=gy(a.shape),p=Zb(i),f=i.length,g=gy(i),m=oy(a.dtype,p);0!==o&&m.fill(o);for(let b=0;b<u;b++){m[ky(Sy(b,h,d).map(((t,e)=>t+l[e])),f,g)]=c[b]}return{dataId:n.write(m,i,a.dtype),shape:i,dtype:a.dtype}}},xG=ZP(((t,e)=>Math.pow(t,e))),kG=bB(Ow,xG),SG={kernelName:Ow,backendName:"cpu",kernelFunc:kG};function IG(t,e,n,r){const[a,s]=xE(t,r),o=Hk(e,"int32"),i=vy(Zb(a),o),l=Zb(s);for(let c=0;c<i.length;++c){const t=c*l;let e=1;for(let r=0;r<l;++r)e*=n[t+r];i[c]=e}return{outVals:i,outShape:a,outDtype:o}}const NG={kernelName:Lw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;BP(a,"prod");const i=a.shape.length,l=ay(s,a.shape),c=IE(l,i);let u=l,h=a;const d=[];null!=c&&(h=LB({inputs:{x:a},backend:n,attrs:{perm:c}}),d.push(h),u=EE(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=IG(h.shape,h.dtype,p,u);let b=g;return o&&(b=kE(g,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(b,m,f)}};function EG(t,e,n,r){const a=[];let s=0;const o=e.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const r=t[n],a=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const t=e[c+1];for(let e=1;e<l+1;++e)i[c].push(e*t)}for(let c=0;c<t.length;++c){let r=t[c],o=t[c]+1;for(let t=0;t<n.length;++t){const a=n[t],s=t+e.length-1;if(s>=0){const t=i[s],e=t[t.length-1]-a[r];for(let n=r;n<o;++n)i[s].push(a[n+1]+e)}r=a[r],o=a[o]}o!==r&&(a.push([r,o]),s+=o-r)}return{outSplits:i,valueSlices:a,numValues:s}}function CG(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function TG(t,e,n,r,a){const s=e.slice();s[0]=a;const o=iy(n,Zb(s)),i=t.length;return function(t,e,n,r,a,s){const o=CG(e,2)[1],i=CG(s,2)[1];let l=0;for(const c of n)for(let e=c[0];e<c[1];++e){for(let n=0;n<r;++n)a[l*i+n]=t[e*o+n];++l}}(t,e,r,0===i?0:i/e[0],o,s),[o,s]}function AG(t,e,n,r,a,s,o,i){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,r)=>{if(t<0||t>=n){const a=Sy(r,e.length,gy(e)).join(",");throw new Error("indices[".concat(a,"] = ").concat(t," is not in [0, ").concat(n,")"))}}))}(s,o,e[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:u,numValues:h}=EG(s,o,t,l),d=function(t){const e=[];for(let n=0;n<t.length;++n){const r=iy("int32",t[n].length);e.push(r),t[n].forEach(((t,e)=>r[e]=t))}return e}(c),p=TG(n,r,a,u,h);return[d,p[0],p[1]]}const RG={kernelName:Mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.data.get(t.dataId).values)),c=a.map((t=>t.shape)),u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,[d,p,f]=AG(l,c,u,s.shape,s.dtype,h,o.shape),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}},FG=2147483647;function _G(t,e,n,r,a,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=0===e.length,l=0===a.length,c=0===o.length,u=[];i||u.push(e[0]),l||u.push(a[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=iy("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const e=i?t[0]:t[g],n=l?r[0]:r[g],a=c?s[0]:s[g];if(0===a)throw new Error("Requires delta != 0");let o;if(a>0&&n<e||a<0&&n>e)o=0;else if(o=Math.ceil(Math.abs((n-e)/a)),o>FG)throw new Error("Requires ((limit - start) / delta) <= ".concat(FG));d[g+1]=d[g]+o}const p=iy(n,d[h]);let f=0;for(let g=0;g<h;++g){const e=d[g+1]-d[g];let n=i?t[0]:t[g];const r=c?s[0]:s[g];for(let t=0;t<e;++t)p[f++]=n,n+=r}return[d,p]}const DG={kernelName:Pw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=_G(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};var OG=ET;class zG{constructor(t,e,n,r,a,s,o,i,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=TT(c),this.raggedRank=AT(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===OG.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===OG.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case OG.VALUE_ROWIDS:return zG.getMaxWidthValueRowID(e);case OG.ROW_SPLITS:return zG.getMaxWidthRowSplit(e);default:throw new Error("Cannot handle partition type ".concat(OG[this.getRowPartitionTypeByDimension(t-1)]))}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let r=0;r<e-1;++r){const e=t[r+1]-t[r];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,r=t[0],a=0;for(let s=1;s<e;++s){const e=t[s];e!==r&&(r=e,a=Math.max(s-n,a),n=s)}return Math.max(e-n,a)}tensorShapeFromTensor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return MG(t,n)}calculateOutputSize(t){const e=this.valuesShape;RT(this.defaultValueShape,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=CT(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(t,e,n){const r=Math.min(t,n),a=[];let s=0;for(let o=0;o<r;++o,s+=e)a.push(s);for(let o=r;o<t;++o)a.push(-1);return Xb(a.length===t,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(t,e,n,r){const a=t.length,s=[];for(let o=0;o<a-1;++o){const a=t[o+1]-t[o];let i=Math.min(r,a),l=e[o];-1===l&&(i=0);for(let t=0;t<i;++t)s.push(l),l+=n;for(let t=0;t<a-i;++t)s.push(-1)}if(a>0&&s.length!==t[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,r){const a=t.length,s=[];if(0===a)return[];let o=0,i=t[0];if(i>=e.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(e.length));let l=e[i];s.push(l);for(let c=1;c<a;++c){const a=t[c];if(a===i)l>=0&&(++o,o<r?l+=n:l=-1);else{if(o=0,i=a,a>=e.length)throw new Error("Got nextValueRowId=".concat(a," which is not less than ").concat(e.length));l=e[a]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,r){const a=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case OG.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,e,n,r);case OG.ROW_SPLITS:if(a.length-1>e.length)throw new Error("Row partition size is greater than output size: ".concat(a.length-1," > ").concat(e.length));return this.calculateOutputIndexRowSplit(a,e,n,r);default:throw new Error("Unsupported partition type: ".concat(OG[s]))}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case OG.FIRST_DIM_SIZE:return t[0];case OG.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case OG.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(OG[e]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*e[s+1];const r=MG(e,!1),a=iy(this.valuesDType,Zb(r));if(n[0]*e[0]>0){let s=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t){s=this.calculateOutputIndex(t-1,s,n[t],e[t])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(t,e,n,r){if(0===n.length)return;const a=this.values,s=n;let o=r.slice();o=o.slice(t+1);const i=Zb(o),l=e.length;let c=this.defaultValue;if(c.length!==i&&1!==c.length){const t=this.defaultValueShape;xS((()=>{const e=ON(c,t),n=UN(e,o);c=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=l;++p){let t=p<l?e[p]:-1;if(t!==d){if(h<d){const t=a.subarray(u*i);LG(s.subarray(h*i),t,(d-h)*i)}if(p>=l){const e=n.length;t=Math.floor(e/i)}if(t>d)if(1===this.defaultValue.length)s.subarray(d*i,t*i).fill(this.defaultValue[0]),d=t;else for(;t>d;){LG(s.slice(d*i),c,i),++d}t<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function LG(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function MG(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error("Dimension ".concat(r," must be >= 0"));if(r<-1)throw new Error("Dimension ".concat(r," must be >= -1"));r=-1}n.push(r)}return n}function PG(t,e,n,r,a,s,o,i,l,c){return new zG(t,e,n,r,a,s,o,i,l,c).compute()}const BG={kernelName:Bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=i.map((t=>n.data.get(t.dataId).values)),p=i.map((t=>t.shape)),[f,g]=PG(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}};function WG(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return vy(0,r);const a=vy(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const UG={kernelName:Ww,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,dtype:s,step:o}=n,i=WG(r,a,o,s);return e.makeTensorInfo([i.length],s,i)}},VG=GP(Vw,(t=>1/t)),GG={kernelName:Vw,backendName:"cpu",kernelFunc:VG};const jG={kernelName:qw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;BP(a,"resizeBilinear");const l=gy(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(Zb([h,c,u,f])),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u];let v=0;const w=b[0]/y[0],x=b[1]/y[1];for(let k=0;k<h;k++)for(let t=0;t<c;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,a=Math.min(d-1,Math.ceil(e)),s=k*l[0]+n*l[1],i=k*l[0]+a*l[1];for(let t=0;t<u;t++){let e;e=o?x*(t+.5)-.5:x*t;const n=Math.max(0,Math.floor(e)),a=e-n,c=Math.min(p-1,Math.ceil(e)),u=s+n*l[2],h=i+n*l[2],d=s+c*l[2],b=i+c*l[2];for(let t=0;t<f;t++){const e=g[u+t],n=g[h+t],s=e+(g[d+t]-e)*a,o=s+(n+(g[b+t]-n)*a-s)*r;m[v++]=o}}}return n.makeTensorInfo([h,c,u,f],"float32",m)}};const HG={kernelName:Xw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;BP([s,a],"resizeBilinearGrad");const i=gy(a.shape),[l,c,u,h]=a.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),g=[o&&d>1?c-1:c,o&&p>1?u-1:u],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],b=g[0]/m[0],y=g[1]/m[1],v=n.data.get(s.dataId).values;let w=0;for(let x=0;x<l;x++){const t=x*i[0];for(let e=0;e<d;e++){const n=e*b,r=Math.floor(n),a=Math.min(Math.ceil(n),c-1),s=t+r*i[1],o=t+a*i[1],l=n-r,d=1-l;for(let t=0;t<p;t++){const e=t*y,n=Math.floor(e),r=Math.min(Math.ceil(e),u-1),a=e-n,c=1-a,p=s+n*i[2],g=s+r*i[2],m=o+n*i[2],b=o+r*i[2],x=d*c,k=d*a,S=l*c,I=l*a;for(let t=0;t<h;t++){const e=v[w++];f[p+t]+=e*x,f[g+t]+=e*k,f[m+t]+=e*S,f[b+t]+=e*I}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}};const KG={kernelName:Hw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;BP(a,"resizeNearestNeighbor");const l=gy(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(h*c*u*f),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u],v=b[0]/y[0],w=b[1]/y[1];let x=0;for(let k=0;k<h;k++){const t=k*l[0];for(let e=0;e<c;e++){const n=o?v*(e+.5):v*e;let r=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));const a=t+r*l[1];for(let t=0;t<u;t++){const e=o?w*(t+.5):w*t;let n=Math.min(p-1,s?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const r=a+n*l[2];for(let t=0;t<f;t++){const e=g[r+t];m[x++]=e}}}}return n.makeTensorInfo([h,c,u,f],a.dtype,m)}};const qG={kernelName:Kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;BP([s,a],"resizeNearestNeighborGrad");const i=gy(a.shape),l=gy(s.shape),[c,u,h,d]=a.shape,[,p,f]=s.shape,g=new Float32Array(c*u*h*d),m=n.data.get(s.dataId).values,b=[o&&p>1?u-1:u,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=b[0]/y[0],w=b[1]/y[1],x=1/v,k=1/w,S=2*Math.ceil(x)+2,I=2*Math.ceil(k)+2;for(let N=0;N<c;N++){const t=N*i[0];for(let e=0;e<u;e++){const n=t+e*i[1],r=Math.floor(e*x),a=Math.floor(r-S/2);for(let s=0;s<h;s++){const r=n+s*i[2],c=Math.floor(s*k),b=Math.floor(c-I/2);for(let n=0;n<d;n++){let i=0;for(let r=0;r<S;r++){const c=r+a;if(c<0||c>=p)continue;const d=t+c*l[1],g=c*v;if(e===Math.min(u-1,o?Math.round(g):Math.floor(g)))for(let t=0;t<I;t++){const e=t+b;if(e<0||e>=f)continue;const r=d+e*l[2],a=e*w;s===Math.min(h-1,o?Math.round(a):Math.floor(a))&&(i+=m[r+n])}}g[r+n]=i}}}}return n.makeTensorInfo(a.shape,a.dtype,g)}};const XG={kernelName:Yw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r;BP(a,"reverse");const o=a.shape.length,i=ay(s,a.shape);if(0===o)return qP({inputs:{x:a},backend:n});const l=new _k(a.shape,a.dtype),c=n.bufferSync(a);for(let u=0;u<l.size;u++){const t=l.indexToLoc(u),e=t.slice();i.forEach((t=>e[t]=a.shape[t]-1-e[t])),l.set(c.get(...e),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},JG={kernelName:Wx,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=oy(a.dtype,Zb(a.shape)),[u,h,d,p]=a.shape,[f,g]=DT(i,h,d),m=Math.sin(s),b=Math.cos(s),y=l.data.get(a.dataId).values;for(let v=0;v<u;v++){const t=v*d*h*p;for(let e=0;e<h;e++){const n=e*(d*p);for(let r=0;r<d;r++){const a=r*p;for(let s=0;s<p;s++){const i=[u,e,r,s],l=i[2],v=i[1];let w=(l-f)*b-(v-g)*m,x=(l-f)*m+(v-g)*b;w=Math.round(w+f),x=Math.round(x+g);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),w>=0&&w<d&&x>=0&&x<h){k=y[t+x*(d*p)+w*p+s]}c[t+n+a+s]=k}}}}return{dataId:l.write(c,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},YG=GP(Zw,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1})),ZG={kernelName:Zw,backendName:"cpu",kernelFunc:YG},QG=VP((t=>1/Math.sqrt(t))),$G=jP(Qw,QG),tj={kernelName:Qw,backendName:"cpu",kernelFunc:$G};function ej(t,e,n,r,a,s,o,i,l,c){const u=[r/a,a],h=t.values,d=e.values;if(0===r)return cI(n,e.dtype);const p=l instanceof _k?l:cI(u,e.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const t=[];let s=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),s+=n*i[e]}if(s<0||s>=r/a)throw new Error("Invalid indices: ".concat(t," does not index into ").concat(n));for(let n=0;n<a;n++)c?p.values[s*a+n]+=d[f*a+n]:p.values[s*a+n]=0===e.rank?d[0]:d[f*a+n]}return p}const nj={kernelName:$w,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=VT(0,a,o),d=ej(n.bufferSync(a),n.bufferSync(s),o,h,c,l,i,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};function rj(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<e?n=a+1:r=a;return r}function aj(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<=e?n=a+1:r=a;return r}const sj={kernelName:ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=function(t,e,n,r,a,s){const o=iy("int32",n*a);for(let i=0;i<n;++i){const n=t.slice(i*r,(i+1)*r),l=i*a;for(let t=0;t<a;++t)o[l+t]="left"===s?rj(n,e[t+l]):aj(n,e[t+l])}return o}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};const oj={kernelName:nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e;BP([r,a,s],"select");const o=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=Hk(a.dtype,s.dtype),h=vy(Zb(a.shape),u);let d=0;const p=0===o||o>1||1===a.shape.length?1:Zb(a.shape.slice(1));for(let f=0;f<i.length;f++)for(let t=0;t<p;t++)1===i[f]?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(a.shape,u,h)}},ij=GT,lj=jT,cj=GP(rx,(t=>t>=0?lj*t:ij*(Math.exp(t)-1))),uj={kernelName:rx,backendName:"cpu",kernelFunc:cj},hj=GP(ix,(t=>t<0?-1:t>0?1:0)),dj={kernelName:ix,backendName:"cpu",kernelFunc:hj},pj=GP(sx,(t=>Math.sin(t))),fj={kernelName:sx,backendName:"cpu",kernelFunc:pj},gj=GP(ox,(t=>Math.sinh(t))),mj={kernelName:ox,backendName:"cpu",kernelFunc:gj},bj=Math.log(1.1920928955078125e-7)+2,yj=GP(cx,(t=>{const e=t>-bj,n=t<bj,r=Math.exp(t);let a;return a=n?r:e?t:Math.log(1+r),a})),vj={kernelName:cx,backendName:"cpu",kernelFunc:yj};const wj={kernelName:dx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;BP([a],"spaceToBatchND");const i=Zb(s),l=[[0,0]];l.push(...o);for(let m=1+s.length;m<a.shape.length;++m)l.push([0,0]);const c=wG.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=OT(c.shape,s,i,!1),h=zT(u.length,s.length,!1),d=LT(c.shape,s,i,!1),p=SB({inputs:{x:c},backend:n,attrs:{shape:u}}),f=LB({inputs:{x:p},backend:n,attrs:{perm:h}}),g=SB({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function xj(t,e,n,r,a,s,o){const i=e[0],l=s[0],c=new Array(l),u=new Array(i),h=e[1];if(0===l){if(0!==i)throw new Error(mA(i));return[iy(n,0),[0,h],iy(a,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<i;++m){const e=t[m*h];if(e<0)throw new Error(bA(m,e));if(e>=l)throw new Error(yA(m,e,l));++f[e],d=d&&e>=p,p=e}let g=!0;for(let m=0;m<l;++m){const t=0===f[m];c[m]=t,g=g&&!t,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const e=t,n=r;for(let t=0;t<i;++t)u[t]=t;return[e,[i,h],n,c,u]}{const e=f[l-1],s=iy(n,e*h),d=iy(a,e),p=new Array(l).fill(0);for(let n=0;n<i;++n){const e=t[n*h],a=p[e],o=(0===e?0:f[e-1])+a;p[e]++;for(let r=0;r<h;++r)s[o*h+r]=t[n*h+r];d[o]=r[n],u[n]=o}for(let t=0;t<l;++t){if(0===p[t]){const e=0===t?0:f[t-1];s[e*h+0]=t;for(let t=1;t<h;++t)s[e*h+t]=0;d[e]=o}}return[s,[e,h],d,c,u]}}const kj={kernelName:gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,g]=xj(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function Sj(t,e,n,r,a){const s=Zb(r),o=e[0],i=a.length,l=[];let c=1,u=-1;for(let g=0;g<i;++g){const t=a[g];if(-1===t){if(-1!==u)throw new Error(vA(u,g));u=g,l.push(1)}else{if(t<0)throw new Error(wA(g,t));c*=t,l.push(t)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(s/c);if(c*t!==s)throw new Error(kA(r,l));l[u]=t}if(Zb(l)!==s)throw new Error(SA(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t)d[t]=d[t+1]*r[t+1]}const p=[];if(i>0){p[i-1]=1;for(let t=i-2;t>=0;--t)p[t]=p[t+1]*l[t+1]}const f=iy(n,o*i);for(let g=0;g<o;++g){let e=0;for(let n=0;n<h;++n)e+=t[g*h+n]*d[n];for(let t=0;t<i;++t)f[g*i+t]=Math.trunc(e/p[t]),e%=p[t]}return[f,[o,i],l]}const Ij={kernelName:mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.data.get(a.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=Sj(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function Nj(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=r.length,l=[e[0],t.length/e[0]],c=l[1],u=i>0?a[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=u;const d=iy(n,h.reduce(((t,e)=>t*e),1));if(0===i)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=a[p];for(;;){let e=0;if(f<i){if(e=a[f],m===e){++f;continue}if(m>=e)throw new Error("segment ids are not increasing")}if(m<0||m>=u)throw new Error(EA(m,u));m>g&&d.fill(o,g*c,m*c);for(let n=p;n<f;++n){const e=r[n];if(e<0||e>=l[0])throw new Error(CA(n,r[n],l[0]));for(let n=0;n<c;n++)d[m*c+n]+=t[e*c+n]}if(s)for(let t=0;t<c;t++)d[m*c+t]/=f-p;if(p=f,++f,g=m+1,m=e,f>i)break}return g<u&&d.fill(o,g*c,u*c),[d,h]}const Ej={kernelName:bx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=Nj(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const Cj={kernelName:yx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=Nj(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const Tj={kernelName:vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=VT(0,a,i),p=!1,f=n.bufferSync(a);let g;switch(s.dtype){case"bool":g=ej(f,n.bufferSync(s),i,d,u,c,l,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":g=ej(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"int32":g=ej(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"string":g=ej(f,n.bufferSync(s),i,d,u,c,l,h,yk(n.data.get(o.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(s.dtype))}return n.makeTensorInfo(i,g.dtype,g.values)}};const Aj={kernelName:px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=ay(o,a.shape)[0],l=gA(a,s,i),c=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map((t=>{const e=[...u];e[i]=t;const r=lW({inputs:{x:a},backend:n,attrs:{begin:c,size:e}});return c[i]+=t,r}))}},Rj=VP((t=>Math.sqrt(t))),Fj=GP(ux,(t=>Math.sqrt(t))),_j={kernelName:ux,backendName:"cpu",kernelFunc:Fj},Dj={kernelName:xx,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{x:r}=e,a=n;BP(r,"square");const s=a.data.get(r.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const t=s[i];o[i]=t*t}return{dataId:a.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Oj=ZP(((t,e)=>{const n=t-e;return n*n})),zj=bB(wx,Oj),Lj={kernelName:wx,backendName:"cpu",kernelFunc:zj},Mj=VP(((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=e;return t.replace(new RegExp(n,r?"g":""),a)})),Pj=jP(kx,Mj),Bj={kernelName:kx,backendName:"cpu",kernelFunc:Pj},Wj=GP(Px,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),Uj={kernelName:Px,backendName:"cpu",kernelFunc:Wj};function Vj(t,e,n,r){const a=cI(t,e.dtype);for(let s=0;s<a.size;s++){const t=a.indexToLoc(s),o=new Array(t.length);for(let e=0;e<o.length;e++)o[e]=t[e]*n[e]+r[e];a.set(e.get(...o),...t)}return a}const Gj={kernelName:Sx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;BP(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=fN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=SB({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Xb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=eN(y,v,w),e=lW({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=SB({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{const t=Vj(p,n.bufferSync(a),w,y);x=n.makeTensorInfo(f,t.dtype,t.values)}return x}};class jj{constructor(t,e,n,r,a,s){this.separator=bk(t),this.nGramWidths=e,this.leftPad=bk(n),this.rightPad=bk(r),this.padWidth=a,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),l=Math.max(0,i-o),c=Math.max(0,i-(a-(o+1))),u=s-(l+c),h=e+(l>0?0:o-i);let d=0;d+=l*this.leftPad.length;for(let e=0;e<u;++e)d+=t[h+e].length;d+=c*this.rightPad.length;d+=(l+c+u-1)*this.separator.length,n[r+o]=new Uint8Array(d);const p=n[r+o];let f=0;const g=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)g(this.leftPad),g(this.separator);for(let e=0;e<u-1;++e)g(t[h+e]),g(this.separator);if(u>0){g(t[h+u-1]);for(let t=0;t<c;++t)g(this.separator),g(this.rightPad)}else{for(let t=0;t<c-1;++t)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error("First split value must be 0, got ".concat(t));for(let a=1;a<r;++a){let r=e[a]>=t;if(r=r&&e[a]<=n,!r)throw new Error("Invalid split value ".concat(e[a],", must be in [").concat(t,", ").concat(n,"]"));t=e[a]}if(t!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(t))}const a=r-1,s=iy("int32",r);if(0===n||0===r){const t=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[t,s]}s[0]=0;for(let i=1;i<=a;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach((e=>{n+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[a]);for(let i=0;i<a;++i){const n=e[i];let r=s[i];if(this.nGramWidths.forEach((a=>{const s=e[i+1]-e[i],l=this.getNumNGrams(s,a);this.createNGrams(t,n,o,r,l,a),r+=l})),this.preserveShort&&r===s[i]){const a=e[i+1]-e[i];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(t,n,o,r,l,s)}}return[o,s]}}function Hj(t,e,n,r,a,s,o,i){return new jj(n,r,a,s,o,i).compute(t,e)}const Kj={kernelName:Ix,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,g]=Hj(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};function qj(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const a=e[0];let s=t.indexOf(a);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(a)}return void(n&&0===t.length||r.push(t))}let a=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(a,s);n&&0===e.length||r.push(e),a=s+1}}function Xj(t,e,n){const r=t.length,a=[];let s=0,o=0;const i=new Array(r);for(let d=0;d<r;++d){const r=a.length;qj(t[d],e,n,a);const l=a.length-r;i[d]=l,s+=l,o=Math.max(o,l)}const l=iy("int32",2*s),c=new Array(s),u=[r,o];let h=0;for(let d=0;d<r;++d)for(let t=0;t<i[d];++t)l[2*h]=d,l[2*h+1]=t,c[h]=a[h],++h;return[l,c,u]}const Jj={kernelName:Nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[c,u,h]=Xj(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function Yj(t,e){const n=iy("int32",t.length);for(let r=0;r<t.length;++r)n[r]=pk(t[r]).modulo(e).getLowBitsUnsigned();return n}const Zj={kernelName:Ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=Yj(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",o)}},Qj=GP(Tx,(t=>Math.tan(t))),$j={kernelName:Tx,backendName:"cpu",kernelFunc:Qj},tH=GP(Ax,(t=>Math.tanh(t)));const eH={kernelName:tx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{tensor:r,indices:a,updates:s}=e,{sliceRank:o,numUpdates:i,sliceSize:l,strides:c,outputSize:u}=VT(0,a,r.shape),h=n.bufferSync(a),d=n.bufferSync(s),p=n.bufferSync(r),f=ej(h,d,r.shape,u,l,i,o,c,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function nH(t,e){const n=new Array(t.rank);for(let a=0;a<n.length;a++)n[a]=t.shape[a]*e[a];const r=cI(n,t.dtype);for(let a=0;a<r.values.length;++a){const e=r.indexToLoc(a),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const s=t.locToIndex(n);r.values[a]=t.values[s]}return r}const rH={kernelName:Rx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;BP(a,"tile");const o=nH(n.bufferSync(a),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},aH=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function sH(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=e-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2);sH(t,e,Math.max(n,Math.floor(e-s*i/a+l)),Math.min(r,Math.floor(e+(a-s)*i/a+l)))}const a=t[e];let s=n,o=r;for(qb(t,n,e),aH(t[r],a)>0&&qb(t,n,r);s<o;){for(qb(t,s,o),s++,o--;aH(t[s],a)<0;)s+=1;for(;aH(t[o],a)>0;)o-=1}0===aH(t[n],a)?qb(t,n,o):(o+=1,qb(t,o,r)),o<=e&&(n=o+1),e<=o&&(r=o-1)}}function oH(t,e,n,r,a){const s=e[e.length-1],[o,i]=[t.length/s,s],l=oy(n,o*r),c=oy("int32",o*r);for(let h=0;h<o;h++){const e=h*i,n=t.subarray(e,e+i);let s=new Array(n.length);n.forEach(((t,e)=>s[e]={value:t,index:e})),r<s.length&&(sH(s,r),s=s.slice(0,r)),a&&s.sort(aH);const o=h*r,u=l.subarray(o,o+r),d=c.subarray(o,o+r);for(let t=0;t<r;t++)u[t]=s[t].value,d[t]=s[t].index}const u=e.slice();return u[u.length-1]=r,[cI(u,n,l),cI(u,"int32",c)]}const iH={kernelName:Fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r;BP(a,"topk");const i=n.data.get(a.dataId).values,[l,c]=oH(i,a.shape,a.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const lH={kernelName:_x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=n,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=[u,f,g,p],b=gy(a.shape),y=b[0],v=b[1],w=b[2],x=gy(m),k=x[0],S=x[1],I=x[2],N=oy(a.dtype,Zb(m));N.fill(l);const E=r.data.get(a.dataId).values,C=r.data.get(s.dataId).values;for(let T=0;T<u;++T){const t=1===s.shape[0]?C:C.subarray(8*T,8*T+8);for(let e=0;e<f;++e)for(let n=0;n<g;++n)for(let r=0;r<p;++r){let a;const s=t[6]*n+t[7]*e+1;if(0===s)continue;const c=(t[0]*n+t[1]*e+t[2])/s,u=(t[3]*n+t[4]*e+t[5])/s,p=cH(c,d,i),f=cH(u,h,i);switch(o){case"nearest":a=hH(E,h,d,y,v,w,T,f,p,r,l);break;case"bilinear":a=dH(E,h,d,y,v,w,T,f,p,r,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}N[T*k+e*S+n*I+r]=a}return r.makeTensorInfo(m,a.dtype,N)}return{dataId:r.write(N,m,a.dtype),shape:a.shape,dtype:a.dtype}}};function cH(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return Hb(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return Hb(0,n,e-1)}(t,e);case"nearest":return function(t,e){return Hb(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function uH(t,e,n,r,a,s,o,i,l,c,u){return 0<=i&&i<e&&0<=l&&l<n?t[o*r+i*a+l*s+c]:u}function hH(t,e,n,r,a,s,o,i,l,c,u){return uH(t,e,n,r,a,s,o,Math.round(i),Math.round(l),c,u)}function dH(t,e,n,r,a,s,o,i,l,c,u){const h=Math.floor(i),d=Math.floor(l),p=h+1,f=d+1;return(p-i)*((f-l)*uH(t,e,n,r,a,s,o,h,d,c,u)+(l-d)*uH(t,e,n,r,a,s,o,h,f,c,u))+(i-h)*((f-l)*uH(t,e,n,r,a,s,o,p,d,c,u)+(l-d)*uH(t,e,n,r,a,s,o,p,f,c,u))}function pH(t,e,n,r){const a=ay(e,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const o=new Map,i=new Int32Array(n[a]),l=new _k(s,r,t),c=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let e;if(u)e=t[f].toString();else{const t=[];for(let e=0;e<s[0];e++)for(let n=0;n<s[2];n++)t.push(l.get(e,f,n));e=t.join(",")}const n=o.get(e);if(null!=n)i[f]=n;else{const t=o.size;o.set(e,t),i[f]=t,c.push(f)}}const h=s.slice();h[1]=o.size;const d=new _k(h,r);c.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,t,r),n,e,r)}));const p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const fH={kernelName:Ox,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;BP(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:c}=pH(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const gH={kernelName:zx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape.length,i=a.shape[s],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=a.shape[p]);const u=new Array(o).fill(0),h=a.shape.slice();h[s]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[s]=p;const t=lW({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});d[p]=SB({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}};const mH={kernelName:Lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r;BP(a,"unsortedSegmentSum");const i=[],l=[],c=a.shape.length-s.shape.length;let u=s;for(let d=0;d<c;++d){const t=xU({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=t,l.push(t)}for(let d=0;d<o;++d){const t=fk(d,"int32"),e=n.makeTensorInfo([],"int32",t),r=lU({inputs:{a:e,b:u},backend:n}),s=gB({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=eU({inputs:{a:s,b:a},backend:n}),c=rU({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(c),l.push(e),l.push(r),l.push(s),l.push(o),l.push(c)}const h=yG({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},bH=[CB,AB,FB,DB,kB,OB,PB,BB,WB,UB,GB,HB,qB,YB,QB,nW,rW,aW,sW,EB,oW,uW,pW,gW,mW,mB,vW,xW,uB,kW,CW,AW,RW,FW,_W,DW,OW,LW,PW,BW,WW,UW,VW,GW,HW,KW,qW,XW,JW,YW,ZW,QW,sU,KP,oU,cU,bU,wU,kU,NU,LU,PU,BU,VU,HU,KU,qU,JU,ZU,tV,rV,XP,aV,NW,oV,lV,uV,YP,pV,mV,yV,xV,SV,EV,TV,FV,_V,DV,LV,BV,WV,UV,VV,GV,jV,HV,KV,JV,YV,$V,nG,nU,aG,oG,lG,uG,pG,fG,bG,vG,wG,SG,tB,NG,RG,DG,BG,UG,pB,TU,GG,nB,aB,IB,jG,HG,KG,qG,XG,JG,ZG,tj,nj,sj,oj,uj,iB,dj,fj,mj,cW,eG,vj,wj,kj,Ij,Ej,Cj,Tj,Aj,_j,Dj,Lj,Bj,Uj,Gj,Kj,Jj,Zj,_U,aU,$j,{kernelName:Ax,backendName:"cpu",kernelFunc:tH},eH,rH,iH,lH,MB,fH,gH,mH,mG];for(const n of bH)Zx(n);const yH={},vH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function wH(t,e){if(!(t in yH)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if(Ty().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==t){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(t):e;n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete yH[t]}),!1),Ty().getBool("SOFTWARE_WEBGL_ENABLED")&&(vH.failIfMajorPerformanceCaveat=!1);if(1===t)return n.getContext("webgl",vH)||n.getContext("experimental-webgl",vH);return n.getContext("webgl2",vH)}(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;yH[t]=n}const n=yH[t];return null==n||n.isContextLost()?(delete yH[t],wH(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),yH[t])}var xH,kH,SH;function IH(t,e){return[e,t]}function NH(t){const e=Zb(t);return ty(Math.ceil(e/4))}function EH(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function CH(t,e){const n=t;let r,a,s,o,i,l,c,u,h,d;return 2===Ty().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,a=t.RGBA,s=t.RGBA,o=n.RGBA,i=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function TH(t,e){const n=e();return Ty().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(e)}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(xH||(xH={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(kH||(kH={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(SH||(SH={}));function AH(t){return!!(Ty().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function RH(t,e){return BH(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}const FH=/ERROR: [0-9]+:([0-9]+):/g;function _H(t,e){const n=FH.exec(e);if(null==n)return console.log("Couldn't parse line number in error: ".concat(e)),void console.log(t);const r=+n[1],a=t.split("\n"),s=a.length.toString().length+2,o=a.map(((t,e)=>ey((e+1).toString(),s)+t));let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c ".concat(ey(c[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function DH(t,e){if(TH(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function OH(t,e,n,r,a,s,o){const i=t.getAttribLocation(e,n);return-1!==i&&(TH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),TH(t,(()=>t.vertexAttribPointer(i,a,t.FLOAT,!1,s,o))),TH(t,(()=>t.enableVertexAttribArray(i))),!0)}function zH(t,e,n,r){TH(t,(()=>function(t,e,n){WH(t,n),TH(t,(()=>t.activeTexture(t.TEXTURE0+n))),TH(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),TH(t,(()=>t.uniform1i(n,r)))}function LH(t,e,n){TH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),TH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function MH(t,e){TH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),TH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function PH(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(e)}}(t,e))}function BH(t,e,n){const r=TH(t,(()=>e()));if(null==r)throw new Error(n);return r}function WH(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const t="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(t,"."))}}function UH(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Zb(t.slice(0,t.length-e))}function VH(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function GH(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[UH(t),...VH(t)]),e}function jH(t){return t%2===0}function HH(t,e){if(Qb(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r)return!0;if(jH(n)&&jH(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&jH(t[0])&&jH(e[0])}let KH,qH;function XH(t,e){return null!=t.getExtension(e)}function JH(t){try{if(null!=wH(t))return!0}catch(o1){return console.log("Error when getting WebGL context: ",o1),!1}return!1}function YH(t){if(0===t)return!1;const e=wH(t);if(1!==t){if(XH(e,"EXT_color_buffer_float"))return ZH(e);const t="EXT_color_buffer_half_float";if(XH(e,t)){const n=e.getExtension(t);return function(t,e){const n=CH(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);const a=1,s=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),i}(e,n)}return!1}if(!XH(e,"OES_texture_float"))return!1;if(!XH(e,"WEBGL_color_buffer_float"))return!1;return ZH(e)}function ZH(t){const e=CH(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),a}function QH(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Xb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors ")+"in the WebGL backend."))}))}const $H=Ty();function tK(){let t,e,n,r,a,s,o,i,l,c;return 2===Ty().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=Ty().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}function eK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=gy(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(e),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(e):"index -= ".concat(t[a]," * ").concat(e);return"".concat(s,"; ").concat(o,";")})).join("")}function nK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=gy(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / outShapeStrides[").concat(a,"]"),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * outShapeStrides[").concat(a,"]"):"index -= ".concat(t[a]," * outShapeStrides[").concat(a,"]");return"".concat(s,"; ").concat(o,";")})).join("")}function rK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(t,e){const n=t.length,r=t.map((t=>"".concat(e,"[").concat(t,"]"))),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]="(".concat(a[s+1]," * ").concat(r[s+1],")");return a}(t.map(((t,e)=>e)),e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(r[a]),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(r[a]):"index -= ".concat(t[a]," * ").concat(r[a]);return"".concat(s,"; ").concat(o,";")})).join("")}function aK(t){const e=gy(t).map((t=>t.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(e[0]," + coords.y * ").concat(e[1]," + coords.z;\n  }\n")}$H.registerFlag("HAS_WEBGL",(()=>$H.getNumber("WEBGL_VERSION")>0)),$H.registerFlag("WEBGL_VERSION",(()=>JH(2)?2:JH(1)?1:0)),$H.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),$H.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===$H.get("WEBGL_VERSION"))),$H.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),$H.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),$H.registerFlag("WEBGL_PACK",(()=>$H.getBool("HAS_WEBGL"))),$H.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_CLIP",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_REDUCE",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_LAZILY_UNPACK",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_CONV_IM2COL",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>$H.getBool("WEBGL_PACK"))),$H.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==KH){const e=wH(t);KH=e.getParameter(e.MAX_TEXTURE_SIZE)}return KH}($H.getNumber("WEBGL_VERSION")))),$H.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==qH){const e=wH(t);qH=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qH)}($H.getNumber("WEBGL_VERSION")))),$H.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=$H.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=wH(t);return e=XH(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:XH(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),$H.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>$H.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!oS())),$H.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=wH(t);if(1===t){if(!XH(e,"OES_texture_float"))return!1}else if(!XH(e,"EXT_color_buffer_float"))return!1;return ZH(e)}($H.getNumber("WEBGL_VERSION")))),$H.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!$H.getBool("WEBGL_FORCE_F16_TEXTURES")&&$H.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),$H.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>YH($H.getNumber("WEBGL_VERSION")))),$H.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=$H.getNumber("WEBGL_VERSION"))&&null!=wH(t).fenceSync;var t})),$H.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>$H.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),$H.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(t,"."))})),$H.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>oS()?1:-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(t,"."))})),$H.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),$H.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),$H.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),$H.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),$H.registerFlag("WEBGL_EXP_CONV",(()=>!1)),$H.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>$H.getBool("IS_TEST"))),$H.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),$H.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),$H.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),$H.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const sK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:oK}=r;function iK(t,e,n){const r=[];if(t.forEach((t=>{const e=Zb(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push("uniform float ".concat(t.name).concat(e>1?"[".concat(e,"]"):"",";")):(r.push("uniform sampler2D ".concat(t.name,";")),r.push("uniform int offset".concat(t.name,";"))),n.enableShapeUniforms){const{uniformShape:e}=bK(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push("uniform int ".concat(t.name,"Shape;"));break;case 2:r.push("uniform ivec2 ".concat(t.name,"Shape;"));break;case 3:r.push("uniform ivec3 ".concat(t.name,"Shape;"));break;case 4:r.push("uniform ivec4 ".concat(t.name,"Shape;"))}r.push("uniform ivec2 ".concat(t.name,"TexShape;"))}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{r.push("uniform ".concat(t.type," ").concat(t.name).concat(t.arrayIndex?"[".concat(t.arrayIndex,"]"):"",";"))}));const a=r.join("\n"),s=t.map((t=>function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?cK(t,r):lK(t,r);const s=t.shapeInfo.logicalShape,o=e.logicalShape;s.length<=o.length&&(a+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=oK(t.shapeInfo.logicalShape,e.logicalShape),l=mK(o),c=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((t=>"coords.".concat(h[t+c]," = 0;"))).join("\n");let d="";d=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(h[e+c]))).join(", ");let p="return outputValue;";const f=1===Zb(t.shapeInfo.logicalShape),g=Zb(e.logicalShape),m=1===g;if(1!==s||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const t=s-2,e=s-1;i.indexOf(t)>-1&&i.indexOf(e)>-1?p="return vec4(outputValue.x);":i.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(a,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(r,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.texShape,o=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&null==t.shapeInfo.flatOffset&&Qb(o,s))return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const c=mK(l),u=oK(t.shapeInfo.logicalShape,e.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":l<2&&u.length>=1?"coords = 0;":u.map((t=>"coords.".concat(p[t+h]," = 0;"))).join("\n");let f="";f=l<2&&i>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(p[e+h]))).join(", ");return"\n    float ".concat(a,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(r,"(").concat(f,");\n    }\n  ")}(t,e));return a}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=e.texShape,i=tK(),l=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(t.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let c,u,h=function(t){const e="".concat(t.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(t.varyingFs," vec2 resultUV;\n    ").concat(t.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(t.defineSpecialNaN,"\n    ").concat(t.defineSpecialInf,"\n    ").concat(t.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(uK,"\n    ").concat(hK,"\n    ").concat(dK,"\n  ");return e}(i);e.isPacked?(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1],".0);\n      }\n    ");if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      return 2 * (resTexRC.x * ").concat(r[1]," + resTexRC.y);\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Qb(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0],", ").concat(r[1],"));\n      }\n    ");const a=Math.ceil(t[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[2]/2),s=a*Math.ceil(t[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[t.length-1]/2),s=a*Math.ceil(t[t.length-2]/2);let o=s,i="",l="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],i="\n      int b".concat(c," = index / ").concat(o,";\n      index -= b").concat(c," * ").concat(o,";\n    ")+i,l="b".concat(c,", ")+l;return"\n    ivec".concat(t.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(t.length,"(").concat(l,");\n    }\n  ")}(t,e,n)}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(vec4 val) {\n      ".concat(t.output," = val;\n    }\n  ")}(i)):(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){if(1===e[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(e[1],".0);\n      }\n    ");if(1===e[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(e[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      return resTexRC.x * ").concat(e[1]," + resTexRC.y;\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){if(Qb(t,e))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(e[0],", ").concat(e[1],"));\n      }\n    ");if(1===t[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===t[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      int r = index / ").concat(t[1],";\n      int c = index - r * ").concat(t[1],";\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n){const e=nK(["r","c","d"],t);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(e,"\n    return ivec3(r, c, d);\n  }\n")}const r=eK(["r","c","d"],t);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,e,n);case 4:return function(t,e,n){if(n){const e=nK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(e,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const r=eK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(t,e,n);case 5:return function(t,e){const n=eK(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(e[0],",\n                             ").concat(e[1],"));\n\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(t,e);case 6:return function(t,e){const n=eK(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(t,e);default:throw new Error("".concat(t.length,"-D output sampling is not yet supported"))}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(float val) {\n      ".concat(t.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=pK);return[h,l,u,a,c,s,n.userCode].join("\n")}function lK(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"float ".concat(r,"() {return ").concat(n,";}");const[a,s]=t.shapeInfo.texShape;if(1===a&&1===s)return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=fK(n);if(e)return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,l]=t.shapeInfo.texShape;return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(l,", ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int index) {\n        ").concat(gK(t),"\n      }\n    ");const a=t.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return"\n      float ".concat(r,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=fK(n);if(1===o)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===s)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(e)return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&Qb(n,s)){if(e)return"\n      float ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const t=s[0],n=s[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(t,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}const{newShape:o,keptDims:i}=sy(n),l=o;if(l.length<n.length){const n=yK(t,l),r=["row","col"];return"\n      ".concat(lK(n,e),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(vK(r,i),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(gK(t),"\n      }\n    ");const c=s[0],u=s[1],h=fK(r);if(1===u)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r,"TexShape[0]));\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(c,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(1===c)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(e)return"\n      float ".concat(a,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(c,", ").concat(u,", index);\n    return sampleTexture(").concat(r,", uv);\n  }\n")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:l}=sy(n),c=i;if(c.length<n.length){const n=yK(t,c),r=["row","col","depth"];return"\n        ".concat(lK(n,e),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(vK(r,l),");\n        }\n      ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(o,", 1)));\n        ").concat(gK(t),"\n      }\n    ");const u=t.shapeInfo.texShape,h=u[0],d=u[1],p=t.shapeInfo.flatOffset;if(d===s&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        int stride1 = ").concat(r,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(r,", uv);\n        }\n      ");if(d===o&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");const f=fK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r,"Shape[1] * ").concat(r,"Shape[2];\n      int stride1 = ").concat(r,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n      return sampleTexture(").concat(r,", uv);\n    }\n    ");return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(o," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(r,", uv);\n      }\n  ")}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:l,keptDims:c}=sy(n);if(l.length<n.length){const n=yK(t,l),r=["row","col","depth","depth2"];return"\n      ".concat(lK(n,e),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(vK(r,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(o,", ").concat(s,", 1)));\n        ").concat(gK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(r,"Shape[3];"),g="int stride1 = ".concat(r,"Shape[2] * stride2;"),m="int stride0 = ".concat(r,"Shape[1] * stride1;");if(p===i&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");if(p===s&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r,"Shape[1] * ").concat(r,"Shape[2], ").concat(r,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const b=fK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(g,"\n      ").concat(m,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e[4],s=e[3]*a,o=e[2]*s,i=e[1]*o,{newShape:l,keptDims:c}=sy(e);if(l.length<e.length){const e=yK(t,l),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(lK(e),"\n      float ").concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r,"(").concat(vK(n,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(o,", ").concat(s,", ").concat(a,")) +\n          depth3;\n        ").concat(gK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(s,", ").concat(a,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===a&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3],",\n               ").concat(e[2]*e[3],", ").concat(e[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=fK(n);return"\n    float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," + depth * ").concat(s," +\n          depth2 * ").concat(a," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=sy(e);if(a.length<e.length){const e=yK(t,a),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(lK(e),"\n      float ").concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r,"(").concat(vK(n,s),");\n      }\n    ")}const o=e[5],i=e[4]*o,l=e[3]*i,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(c,", ").concat(l,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(gK(t),"\n      }\n    ");const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(c,", ").concat(l,", ").concat(i,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===o&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3]*e[4],",\n               ").concat(e[2]*e[3]*e[4],",\n               ").concat(e[3]*e[4],",\n               ").concat(e[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=fK(n);return"\n    float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(c," + depth * ").concat(l," +\n          depth2 * ").concat(i," + depth3 * ").concat(o," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function cK(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=tK();return"\n    vec4 ".concat(n,"() {\n      return ").concat(r.texture2D,"(").concat(e,", halfCR);\n    }\n  ")}(t);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t.shapeInfo.texShape,s=tK();if(e)return"\n    vec4 ".concat(r,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(r,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0],", ").concat(o[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],i=s[1],l=tK();if(null!=s&&Qb(n,s))return e?"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    "):"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(o,".0);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    ");if(e)return"\n    vec4 ".concat(a,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ");const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(c[0],", ").concat(c[1],", row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=yK(t,n.slice(1)),o=["b","row","col"];return"\n        ".concat(cK(s,e),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(vK(o,r),");\n        }\n      ")}const i=tK();if(e)return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ");const l=o[0],c=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l,", ").concat(c,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);default:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=tK();if(e)return"\n    vec4 ".concat(r,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=t.shapeInfo.logicalShape,o=s.length,i=t.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let g=2;g<o-1;g++)p="int b".concat(g,", ")+p,d*=s[o-g-1],f="b".concat(g," * ").concat(d," + ")+f;return"\n    vec4 ".concat(r,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(c,");\n      return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e)}}const uK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",hK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",dK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",pK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function fK(t){return"offset".concat(t)}function gK(t){const e=t.name,n=Zb(t.shapeInfo.logicalShape);return n<2?"return ".concat(e,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(e,"[i];\n      }\n    }\n  ")}function mK(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank ".concat(t," is not yet supported"))}function bK(t,e,n){const{newShape:r,keptDims:a}=sy(e),s=e.length,o=t&&3===s&&1===e[0],i=o?e.slice(1):r,l=!t&&s>1&&!Qb(e,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:a}}function yK(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function vK(t,e){return e.map((e=>t[e])).join(", ")}function wK(t,e,n,r){const a=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=a.map((t=>t.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=iK(a,o,e),l=function(t,e){const n=BH(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(TH(t,(()=>t.shaderSource(n,e))),TH(t,(()=>t.compileShader(n))),Ty().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw _H(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,i),c=t.createProgram(l);return Ty().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},xK(t,e,c)))}function xK(t,e,n){const r=[],a=[];let s,o,i,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),1===Ty().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const a={name:h,uniform:t.getUniformLocation(n,h,u),offset:t.getUniformLocation(n,"offset".concat(h),u)};e.enableShapeUniforms&&(a.shape=t.getUniformLocation(n,"".concat(h,"Shape"),u),a.texShape=t.getUniformLocation(n,"".concat(h,"TexShape"),u)),r.push(a)}if(e.enableShapeUniforms&&(s=t.getUniformLocation(n,"outShape",u),i=t.getUniformLocation(n,"outShapeStrides",u),o=t.getUniformLocation(n,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)a.push(t.getUniformLocation(n,h.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}}function kK(t,e){if(t.length!==e.length)throw Error("Binary was compiled with ".concat(t.length," inputs, but ")+"was executed with ".concat(e.length," inputs"));t.forEach(((t,n)=>{const r=t.logicalShape,a=e[n],s=a.shape;if(!Qb(r,s))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(r," and ").concat(s," must match"));if(t.isUniform&&a.isUniform)return;const o=t.texShape,i=a.isUniform?null:a.texData.texShape;if(!Qb(o,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(i," must match"))}))}function SK(t){return Ty().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class IK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=xH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=tK();this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?nK(["r","c","d"],t):eK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class NK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=xH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=tK();this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?nK(["r","c","d"],t):eK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class EK{constructor(t){this.variableNames=["A"],this.outTexUsage=kH.DOWNLOAD;const e=tK();this.outputShape=t,this.userCode="\n      ".concat(sK,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}class CK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=kH.DOWNLOAD;const e=tK();this.outputShape=t,this.userCode="\n      ".concat(sK,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}const TK={R:0,G:1,B:2,A:3};class AK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=tK();this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length);let a="result";e&&(a="floor(result * 255. + 0.5)");let s="";for(let o=0;o<n.length;o++){const t=n[o];s+="\n          if(offset == ".concat(o,") {\n            result = values[").concat(TK[t],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":aK(t),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(r.texture2D,"(A, uv);\n          ").concat(s,"\n        }\n        ").concat(r.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class RK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=tK();this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length);let r="",a="result";e&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let e=0;e<=1;e++){const a=2*s+e;r+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(e," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(t[2]),") {\n          localCoords[2] += ").concat(e,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(t[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(a,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(a,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(a,"] = values[2];\n            } else {\n              result[").concat(a,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":aK(t),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(r,"\n\n          ").concat(n.output," = ").concat(a,";\n        }\n    ")}}function FK(t){const e=tK();return function(t,e){const n=BH(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(TH(t,(()=>t.shaderSource(n,e))),TH(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,"".concat(e.version,"\n    precision highp float;\n    ").concat(e.attribute," vec3 clipSpacePos;\n    ").concat(e.attribute," vec2 uv;\n    ").concat(e.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function _K(t){return function(t,e){const n=BH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return TH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),TH(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function DK(t){return function(t,e){const n=BH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return TH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),TH(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}function OK(t,e,n,r,a,s){!function(t,e){const n=Ty().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const n="[".concat(t,"x").concat(e,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(t>n||e>n){const r="[".concat(t,"x").concat(e,"]"),a="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}(e,n);const o=function(t){return BH(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),i=t.TEXTURE_2D;return TH(t,(()=>t.bindTexture(i,o))),TH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),TH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),TH(t,(()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST))),TH(t,(()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Ty().getNumber("WEBGL_VERSION")?TH(t,(()=>t.texImage2D(i,0,r,e,n,0,a,s,null))):TH(t,(()=>t.texStorage2D(i,1,r,e,n))),TH(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:o,texShape:[n,e]}}function zK(t){return t.internalFormatFloat}function LK(t){return t.internalFormatHalfFloat}function MK(t){return t.downloadTextureFormat}function PK(t){return t.internalFormatPackedFloat}function BK(t){return t.internalFormatPackedHalfFloat}function WK(t,e,n,r,a,s,o,i){const l=t,c=new Float32Array(function(t,e){const[n,r]=EH(t,e);return n*r*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}class UK{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Ty().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function(t,e){yH[t]=e}(e,t)):this.gl=wH(e),t=this.gl,2===Ty().getNumber("WEBGL_VERSION")){const e=t;this.createVertexArray=()=>TH(e,(()=>e.createVertexArray())),this.bindVertexArray=t=>TH(e,(()=>e.bindVertexArray(t))),this.deleteVertexArray=t=>TH(e,(()=>e.deleteVertexArray(t))),this.getVertexArray=()=>TH(e,(()=>e.getParameter(e.VERTEX_ARRAY_BINDING)))}else if(null!=t){const e=t.getExtension("OES_vertex_array_object");if(null==e)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>TH(t,(()=>e.createVertexArrayOES())),this.bindVertexArray=n=>TH(t,(()=>e.bindVertexArrayOES(n))),this.deleteVertexArray=n=>TH(t,(()=>e.deleteVertexArrayOES(n))),this.getVertexArray=()=>TH(t,(()=>t.getParameter(e.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ty().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=RH(this.gl,t),XH(this.gl,e))this.textureHalfFloatExtension=RH(this.gl,e);else if(Ty().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),XH(this.gl,r))this.colorBufferHalfFloatExtension=RH(this.gl,r);else if(Ty().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",XH(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!XH(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=_K(this.gl),this.indexBuffer=DK(this.gl),this.framebuffer=function(t){return BH(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=CH(this.gl,this.textureHalfFloatExtension)}get debug(){return Ty().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;TH(t,(()=>t.finish())),TH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),TH(t,(()=>t.deleteFramebuffer(this.framebuffer))),TH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),TH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),TH(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=IH(e,n);return OK(t,a,s,zK(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=IH(e,n);return OK(t,a,s,LK(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=IH(e,n);return OK(t,a,s,MK(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){TH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Ty().getNumber("WEBGL_VERSION")?TH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):TH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Ty().getNumber("WEBGL_VERSION")?TH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):TH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),TH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,a,s){let o,i,l;TH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),i=t.FLOAT,l=s.internalFormatPackedFloat),o.set(a),2===Ty().getNumber("WEBGL_VERSION")?TH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,i,o))):TH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,i,o))),TH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=EH(e,n);return OK(t,a,s,BK(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=EH(e,n);return OK(t,a,s,PK(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(MH(this.gl,this.framebuffer),this.outputTexture=null),TH(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[a,s]=IH(e,n),o=new Uint8Array(e*n*4);return TH(t,(()=>t.readPixels(0,0,a,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,a,s){return WK(this.gl,t,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const a=t.createBuffer();TH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,a)));const s=16*e*n;return TH(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),TH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),TH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),a}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Ty().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(a,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=a}else Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return TH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=FK(e));const n=function(t){return BH(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);TH(e,(()=>e.attachShader(n,this.vertexShader))),TH(e,(()=>e.attachShader(n,t))),function(t,e){if(TH(t,(()=>t.linkProgram(e))),!Ty().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&DH(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;TH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(t,e,n){TH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),OH(t,e,"clipSpacePos",n,3,20,0)&&OH(t,e,"uv",n,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(TH(this.gl,(()=>this.gl.deleteProgram(t))),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&DH(this.gl,this.program),TH(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(t,e,n){return BH(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),TH(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),zH(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,a]=EH(e,n);this.setOutputMatrixTextureDriver(t,r,a)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&DH(this.gl,this.program),PH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}TH(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),TH(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=RH(this.gl,2===Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await ny((()=>this.disposed||this.isQueryAvailable(t,Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ty().platform&&(n=Ty().platform.setTimeoutCustom.bind(Ty().platform)),ny((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),LH(this.gl,t,this.framebuffer),this.debug&&PH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(LH(this.gl,this.outputTexture,this.framebuffer),this.debug&&PH(this.gl)):MH(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;LH(r,t,this.framebuffer),this.debug&&PH(r),this.outputTexture=t,TH(r,(()=>r.viewport(0,0,e,n))),TH(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),TH(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:VK,bincountImpl:GK,bincountReduceImpl:jK,bitwiseAndImpl:HK,castImpl:KK,ceilImpl:qK,concatImpl:XK,equalImpl:JK,expImpl:YK,expm1Impl:ZK,floorImpl:QK,gatherNdImpl:$K,gatherV2Impl:tq,greaterImpl:eq,greaterEqualImpl:nq,lessImpl:rq,lessEqualImpl:aq,linSpaceImpl:sq,logImpl:oq,maxImpl:iq,maximumImpl:lq,minimumImpl:cq,multiplyImpl:uq,negImpl:hq,notEqualImpl:dq,prodImpl:pq,raggedGatherImpl:fq,raggedRangeImpl:gq,raggedTensorToTensorImpl:mq,rangeImpl:bq,rsqrtImpl:yq,scatterImpl:vq,sigmoidImpl:wq,simpleAbsImpl:xq,sliceImpl:kq,sparseFillEmptyRowsImpl:Sq,sparseReshapeImpl:Iq,sparseSegmentReductionImpl:Nq,sqrtImpl:Eq,staticRegexReplaceImpl:Cq,stridedSliceImpl:Tq,stringNGramsImpl:Aq,stringSplitImpl:Rq,stringToHashBucketFastImpl:Fq,subImpl:_q,tileImpl:Dq,topKImpl:Oq,transposeImpl:zq,uniqueImpl:Lq}=a;function Mq(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>"".concat(t,".").concat(e)))}function Pq(t,e){return 1===e?[t]:Mq(t,e)}class Bq{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=SK(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=Pq("rc",this.rank),e=mK(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode="\n        void main() {\n          ".concat(e," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(a,"));\n          }\n        }\n      ")}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a="".concat(0===n?"r":"rp1",", ").concat(0===r?"c":"cp1");for(let e=2;e<this.rank;e++)a="".concat(t[t.length-1-e],",")+a;e.push(a)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let e="";for(let n=this.rank-2;n<this.rank;n++)e+="".concat(t[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],r=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(e[0],";\n      int c = ").concat(e[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(r,";\n    ")}getOutput(t){const e=this.getSourceCoordsArr(t);if(1===this.rank){const t=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(t," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(e[0],"),\n            cEdge ? 0. : getA(").concat(e[1],"),\n            rEdge ? 0. : getA(").concat(e[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(e[3],")")}}class Wq{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length);let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2===1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+="\n        ".concat(t,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(t,e){const n=e?rK(["r","c","d"],"inputShape"):eK(["r","c","d"],t);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":aK(t),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":t[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":t[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class Uq{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const r=Gq(e,n),a=jq(t,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=Vq(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[a].pop();return this.usedTextures[a].push(t),t}let o;return r===SH.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===SH.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===SH.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===SH.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===SH.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const a=Gq(n,r),s=jq(e,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=Vq(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=Ty().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l&&l.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(t,")"));const e=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*e),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Vq(t,e,n,r,a){const s=function(t,e){switch(t){case SH.PACKED_2X2_FLOAT32:return PK(e);case SH.PACKED_2X2_FLOAT16:return BK(e);case SH.UNPACKED_FLOAT32:return zK(e);case SH.UNPACKED_FLOAT16:return LK(e);case SH.PACKED_4X1_UNSIGNED_BYTE:return MK(e);default:throw new Error("Unknown physical texture type ".concat(t))}}(e,r);let o;if(a){const[e,n]=EH(t[0],t[1]);o=e*n}else{const[e,n]=IH(t[0],t[1]);o=e*n}const i=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(e))}(n,s);return o*i}function Gq(t,e){if(t===kH.UPLOAD)return SH.PACKED_2X2_FLOAT32;if(t===kH.RENDER||null==t)return function(t){return Ty().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?SH.PACKED_2X2_FLOAT32:SH.UNPACKED_FLOAT32:t?SH.PACKED_2X2_FLOAT16:SH.UNPACKED_FLOAT16}(e);if(t===kH.DOWNLOAD||t===kH.PIXELS)return SH.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(t))}function jq(t,e,n){return"".concat(t[0],"_").concat(t[1],"_").concat(e,"_").concat(n)}class Hq{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const Kq="if (isnan(x)) return x;",qq="return x;",Xq="return abs(x);";const Jq="return (x >= 0.0) ? x : (exp(x) - 1.0);",Yq=Kq+"\n  return (x < 0.0) ? 0.0 : x;\n",Zq=Kq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Qq="return x;",$q="return 1.0 / (1.0 + exp(-1.0 * x));",tX="return x;",eX="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",nX="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",rX="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",aX="return 1.0 / (1.0 + exp(-1.0 * x));";class sX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class oX{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length);const e=t.length,n=Pq("rc",e),r=mK(e),a=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(a,");\n\n        setOutput(getChannel(packedInput, ").concat(o,"));\n      }\n    ")}}const iX=DA,lX={};const cX=Ty().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class uX extends Vb{nextDataId(){return uX.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ty().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(null!=t){if(t instanceof UK)e=t;else{const n=wH(Ty().getNumber("WEBGL_VERSION"),t);e=new UK(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=wH(Ty().getNumber("WEBGL_VERSION"));e=new UK(t),this.binaryCache=((n=Ty().getNumber("WEBGL_VERSION"))in lX||(lX[n]={}),lX[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Uq(this.gpgpu),this.numMBBeforeWarning=null==Ty().global.screen?1024:Ty().global.screen.height*Ty().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Ub(this,vS())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,n,r,a,s){const o=this.makeTensorInfo(e,n),i=this.texData.get(o.dataId);i.isPacked=!1,i.texture={texture:t,texShape:[r,a]},i.texShape=[r,a];const l=GH(e),c=new AK(l,!1,s),u=this.runWebGLProgram(c,[o],n,[[r,a]]);return u.shape=e,i.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(t,e,n){if((Ty().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ty().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:kH.UPLOAD,refCount:1}),r}refCount(t){if(this.texData.has(t)){return this.texData.get(t).refCount}return 0}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,r,a){if(Ty().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:kH.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=e;if(null!=s){let e;e=i?new sX(o,Qq):new Hq(o,Qq);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=mk()),"complex64"===r){u=ZT(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else u=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=mk()-c),this.convertAndCacheOnCPU(t,u)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=e;if(null!=a){let e;e=i?new sX(r,Qq):new Hq(r,Qq);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if(Ty().getBool("DEBUG")&&!Ty().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ty().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==s&&Ty().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(e.texture.texture,...NH(r))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=ZT(t[0],t[1])}else if(null==u)c=this.getValuesFromTexture(t);else{const t=Zb(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const t=this.gpgpu.gl;TH(t,(()=>t.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(t,c),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&vS().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new sX(a,Qq):new Hq(a,Qq);const r=this.runWebGLProgram(n,[{dataId:t,shape:a,dtype:o}],o),s=this.readToGPU(r,e);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,e.customTexShape),u=vS().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>yk(t)));return cI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return cI(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!AH(n)){if(Ty().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),a=Zb(e);if(Ty().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...NH(e)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=Ty().getBool("WEBGL_PACK")&&!0===r,o=s?GH(e):e,i=s?new CK(o):new EK(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const a=wk(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=wk(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(a);o.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),o.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>"".concat(t.name,": ").concat(t.ms))).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:mk(),endMs:null}}endTimer(t){return Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=mk(),t)}async getQueryTime(t){if(Ty().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(t),i=o&&o.origDataId||t,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,a,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:cX;return Ty().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&Zb(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){jx("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return iX(t.shape,e)}packedUnaryOp(t,e,n){const r=new sX(t.shape,e),a=this.compileAndRun(r,[t],n);return vS().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=xq(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Ty().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Xq,t.dtype);const e=new Hq(t.shape,Xq),n=this.compileAndRun(e,[t]);return vS().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&uy(n[0])){const a=n.map((t=>bk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return vS().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new oX(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Bq(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[UH(t.shape),...VH(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},a=[UH(e),...VH(e)],s=new Wq(a,n),o=[n],i=this.runWebGLProgram(s,[r],t.dtype,o,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:a,dtype:s}=n;if(null!=e){Xb(Zb(a)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=GH(a);let i;i=r?new NK(o):new IK(o);const l=[null!=e?e:NH(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:t}],s,l,!0,e).dataId}}runWebGLProgram(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(t.outputShape,n),i=this.texData.get(o.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===xH.DENSE){const e=null!=s?s:NH(t.outputShape);i.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(i.usage=t.outTexUsage),0===Zb(o.shape))return i.values=oy(o.dtype,0),o;const l=[],c=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&Zb(e.shape)<=Ty().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!==!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!HH(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((e=>{const a=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const s=e.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:l}=bK(t.packedInputs,e.shape,s);let c="",u="",h="";if(1===i.length&&t.packedInputs){const t=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c="".concat(t[0]>1,"_").concat(t[1]>1)}else if(2!==i.length||t.packedInputs){if(i.length>2&&!t.packedInputs){const t=gy(i);h="".concat(t[0]===s[1],"_").concat(t[t.length-1]===s[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=e.shape.length,p=2===i.length&&Qb(e.shape,s),f=1===Zb(e.shape),g=OI(e.shape,n.shape),m=!t.packedInputs&&d===n.shape.length&&Qb(s,n.texData.texShape),b=t.packedInputs||i.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);r+="".concat(d,"_").concat(m,"_").concat(o?l:"","_").concat(i.length,"_").concat(f,"_").concat(g,"_").concat(p,"_").concat(c,"_").concat(u,"_").concat(h,"_").concat(b,"_").concat(a)}else{const t=e.isUniform?"uniform":e.texData.texShape;r+="".concat(e.shape,"_").concat(t,"_").concat(a)}}));const a=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+a+"".concat(Ty().getNumber("WEBGL_VERSION")),s}(t,c,u),d=this.getAndSaveBinary(h,(()=>wK(this.gpgpu,t,c,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Ty().get("ENGINE_COMPILE_ONLY")||function(t,e,n,r,a){e.program.enableShapeUniforms||(kK(e.inShapeInfos,n),kK([e.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),1===Ty().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:o,texShape:i}=e.variablesLocations[l];if(o){const{uniformShape:n}=bK(e.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:t.gl.uniform1iv(o,new Int32Array(n));break;case 2:t.gl.uniform2iv(o,new Int32Array(n));break;case 3:t.gl.uniform3iv(o,new Int32Array(n));break;case 4:t.gl.uniform4iv(o,new Int32Array(n))}}if(i&&t.gl.uniform2i(i,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Zb(r.shape)<2)t.gl.uniform1f(a,r.uniformValues[0]);else{let e=r.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=r.texData.slice&&null!=s&&t.gl.uniform1i(s,r.texData.slice.flatOffset),t.setInputMatrixTexture(r.texData.texture.texture,a,l)}const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:t.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(i,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=gy(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&a)for(let l=0;l<e.program.customUniforms.length;++l){const n=e.program.customUniforms[l],r=e.customUniformLocations[l],s=a[l];if("float"===n.type)t.gl.uniform1fv(r,s);else if("vec2"===n.type)t.gl.uniform2fv(r,s);else if("vec3"===n.type)t.gl.uniform3fv(r,s);else if("vec4"===n.type)t.gl.uniform4fv(r,s);else if("int"===n.type)t.gl.uniform1iv(r,s);else if("ivec2"===n.type)t.gl.uniform2iv(r,s);else if("ivec3"===n.type)t.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));t.gl.uniform4iv(r,s)}}t.executeProgram()}(this.gpgpu,d,c,u,r),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const g=Ty().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const t=mk();t-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Ty().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===a){const t=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),t}return o}compileAndRun(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||e[0].dtype;return this.runWebGLProgram(t,e,n,r,a)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Ty().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=xS((()=>{if(!Ty().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ty().getBool("DEBUG");Ty().set("DEBUG",!1);const e=this.abs(wI(1e-8)).dataSync()[0];if(Ty().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=e;if(null!=s)return;const l=null!=this.activeTimers;let c;l&&(c=mk());let u=e.texShape;if(null==u&&(u=function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Ty().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ty().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Ty().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n*=2,r*=2,1===(t=t.map(((e,n)=>n>=t.length-2?Kb(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=sy(t);t=e.newShape}let a=Zb(t),s=null;t.length<=1&&a<=n?s=[1,a]:2===t.length&&t[0]<=n&&t[1]<=n?s=t:3===t.length&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(null==s||o)if(e){const e=UH(t);let n=2,r=2;t.length&&([n,r]=VH(t)),a=e*(n/2)*(r/2),s=ty(a).map((t=>2*t))}else s=ty(a);return s}(n,i),e.texShape=u),null!=a){const t=GH(n);let s,o=u[1],h=u[0];const d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!i&&d||([o,h]=EH(u[0],u[1])),s=i?new RK(t,d):new AK(t,d);const p=d?[h,o]:u,f=this.makeTensorInfo(p,r),g=this.texData.get(f.dataId);g.usage=d?kH.PIXELS:kH.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,h,a);const m=[[h,o]],b=!0,y=this.runWebGLProgram(s,[f],r,m,b),v=this.texData.get(y.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Ty().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=mk()-c)}else{const t=this.acquireTexture(u,o,r,i);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype ".concat(e))}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(t," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*cy(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(n){throw n}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await ST(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw _H(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}=xK(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=a,t.outShapeLocation=s,t.outShapeStridesLocation=o,t.outTexShapeLocation=i}}createTensorFromGPUData(t,e,n){t.channels=t.channels||"RGBA";const{texture:r,height:a,width:s,channels:o}=t,i=vS().backend;if(!i.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=i.writeTexture(r,e,n,a,s,o);return vS().makeTensorFromDataId(l,e,n,i)}}uX.nextDataId=0;iS()&&IS("webgl",(()=>new uX),2);const hX="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class dX{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=LI(e,n),this.enableShapeUniforms=SK(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const pX="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class fX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=LI(e,n);const a=this.outputShape.length;this.enableShapeUniforms=SK(a);let s="";if(r)if(0===a||1===Zb(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const t=mK(a);if(s="\n          ".concat(t," coords = getOutputCoords();\n        "),1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const t=Pq("coords",a);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= outShape[").concat(a," - 2];\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= outShape[").concat(a," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= ").concat(this.outputShape[a-2],";\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= ").concat(this.outputShape[a-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}}function gX(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const mX={kernelName:Xv,backendName:"webgl",kernelFunc:gX};function bX(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=gX({inputs:{x:r},backend:n}),l=gX({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:l},s}const yX={kernelName:sv,backendName:"webgl",kernelFunc:bX},vX="return (a < 0.) ? b * a : a;",wX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const xX={kernelName:tw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r,o=n.makeTensorInfo([],"float32",fk(s,"float32")),i=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fX(wX,a.shape,o.shape):new dX(vX,a.shape,o.shape),l=n.runWebGLProgram(i,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},kX="return (a < 0.) ? b * a : a;",SX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const IX={kernelName:zw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e,s=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fX(SX,r.shape,a.shape):new dX(kX,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},NX="if (isnan(x)) return x;";function EX(t){let{opSnippet:e,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=t;return t=>{let{inputs:s,backend:o}=t;const{x:i}=s,l=o,c=a||i.dtype;if(l.shouldExecuteOnCPU([i])&&null!=r){const t=l.texData.get(i.dataId),e=r(t.values,c);return l.makeTensorInfo(i.shape,c,e)}let u;return u=Ty().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new sX(i.shape,n):new Hq(i.shape,e),l.runWebGLProgram(u,[i],c)}}function CX(t){let{opSnippet:e,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:o}=t;return t=>{let{inputs:i,backend:l}=t;const{a:c,b:u}=i,h=l;if(a&&"complex64"===c.dtype){const t=h.texData.get(c.dataId),n=h.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:c.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},o=new dX(e,c.shape,u.shape);return h.runWebGLProgram(o,[a,s],Hk(n.dtype,r.dtype))})),s=bX({inputs:{real:r,imag:a},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(a),s}const d=o||Hk(c.dtype,u.dtype);if(("string"===c.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([c,u]))&&null!=s){const t=h.texData.get(c.dataId).values,e=h.texData.get(u.dataId).values,n="string"===c.dtype?FA(t):t,r="string"===c.dtype?FA(e):e,[a,o]=s(c.shape,u.shape,n,r,d),i=h.makeTensorInfo(o,d);return h.texData.get(i.dataId).values=a,i}let p;return p=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new fX(n,c.shape,u.shape,r):new dX(e,c.shape,u.shape),h.runWebGLProgram(p,[c,u],d)}}function TX(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===t)return e?tX:qq;if("relu"===t)return e?nX:Yq;if("elu"===t)return e?eX:Jq;if("relu6"===t)return e?rX:Zq;if("prelu"===t)return e?SX:kX;if("leakyrelu"===t)return e?wX:vX;if("sigmoid"===t)return e?aX:$q;throw new Error("Activation ".concat(t," has not been implemented for the WebGL backend."))}class AX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=SK(this.outputShape.length);const c=r?t[1]:t[2],u=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";o&&(g=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(o,"\n        }"):l?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(o,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(o,"\n        }"),m="result = activation(result);");const b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y="imod(rc.x, ".concat(t[0],")"):e[0]<t[0]&&(v="imod(rc.x, ".concat(e[0],")")),this.userCode="\n      ".concat(g,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(m,"\n\n        setOutput(result);\n      }\n    ")}}const RX={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class FX{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=LI(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const _X="return a * b;";function DX(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Hk(r.dtype,a.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),s=new FX(RX.REAL,r.shape,a.shape),o=new FX(RX.IMAG,r.shape,a.shape),i=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,i,"float32"),c=n.runWebGLProgram(o,i,"float32"),u=bX({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([r,a])){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),[o,i]=uq(r.shape,a.shape,t.values,e.values,s),l=n.makeTensorInfo(i,s);return n.texData.get(l.dataId).values=o,l}let o;return o=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fX(_X,r.shape,a.shape):new dX(_X,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const OX={kernelName:Iw,backendName:"webgl",kernelFunc:DX};function zX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=n,i=Zb(a.shape),l=ry(s,i),c=Zb(l);Xb(i===c,(()=>"The new shape (".concat(l,") has ").concat(c," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=o.texData.get(a.dataId);return!u.isPacked||HH(a.shape,l)||null!==u.texture&&HH(u.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(t,e,n){const r=[UH(t.shape),...VH(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[UH(e),...VH(e)],o=new Wq(s,r),i=[r],l=n.runWebGLProgram(o,[a],t.dtype,i,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(a,l,o)}const LX={kernelName:jw,backendName:"webgl",kernelFunc:zX};class MX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l="sumValue += dot(values * ".concat($b(t)?t.toPrecision(2):t,", ones);")}let c="";a%n>0&&(c="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class PX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];let o="0.0",i="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",i="min"):"max"===e&&(o="-1.0 / 1e-20",i="max");let l="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===e,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===e,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===e," || ").concat("max"===e,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";a%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(o,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(o,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(l,");\n      }\n    ")}}function BX(t,e,n,r){const a=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=_T(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let s=t;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:l,outSize:c}=a[o];let u,h;u="mean"===n?0===o?new MX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},i):new MX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c}):new PX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},n),h=s,s=r.runWebGLProgram(u,[s],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return s}class WX{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;const r=mK(this.rank),a=function(t){const e=t.length;if(e>6)throw Error("Transpose for rank ".concat(e," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let a=0;a<t.length;a++)r[t[a]]=n[a];return r.join()}(e);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(a,"));\n    }\n    ")}}class UX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const r=mK(this.rank),a=Mq("rc",this.rank),s=new Array(this.rank);for(let c=0;c<e.length;c++)s[e[c]]=a[c];const o="vec2(".concat(s.slice(-2).join(),")"),i="++".concat(a[this.rank-1]," < ").concat(n[this.rank-1]),l="getChannel(getA(".concat(s.join(),"), ").concat(o,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l,";\n      if(").concat(i,") {\n        result[1] = ").concat(l,";\n      }\n      --").concat(a[this.rank-1],";\n      if(++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(l,";\n        if(").concat(i,") {\n          result[3] = ").concat(l,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function VX(t,e,n){const r=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UX(t.shape,e):new WX(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function GX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;return function(t,e,n,r){const a=e,s=t.shape.length,o=ay(a,t.shape);let i=o;const l=IE(i,s),c=null!=l;let u=t;c&&(u=VX(t,l,r),i=EE(i.length,s)),SE("sum",i,s);const[h,d]=xE(u.shape,i);let p=h;n&&(p=kE(h,o));const f=Zb(d),g=zX({inputs:{x:u},attrs:{shape:[Zb(t.shape)/f,f]},backend:r}),m=BX(g,Kk(t.dtype),"sum",r),b=zX({inputs:{x:m},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(m),c&&r.disposeIntermediateTensorInfo(u),b}(a,s,o,n)}const jX={kernelName:hx,backendName:"webgl",kernelFunc:GX};function HX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{perm:s}=r,o=n,i=a.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let c;if(o.shouldExecuteOnCPU([a])){const t=o.texData.get(a.dataId).values,e=zq(t,a.shape,a.dtype,s,l);c=o.makeTensorInfo(l,a.dtype);o.texData.get(c.dataId).values=e}else c=VX(a,s,o);return c}const KX={kernelName:Dx,backendName:"webgl",kernelFunc:HX},qX=1e3;function XX(t){let{a:e,b:n,transposeA:r,transposeB:a,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:c=null}=t;const u=e.shape.length,h=n.shape.length,d=r?e.shape[u-2]:e.shape[u-1],p=a?n.shape[h-1]:n.shape[h-2],f=r?e.shape[u-1]:e.shape[u-2],g=a?n.shape[h-2]:n.shape[h-1],m=e.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Zb(m),v=Zb(b),w=LI(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);Xb(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(e.shape," and ")+"".concat(n.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const x=r?[y,d,f]:[y,f,d],k=a?[v,g,p]:[v,p,g],S=zX({inputs:{x:e},backend:s,attrs:{shape:x}}),I=zX({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],E=Math.max(y,v),C=r?S.shape[1]:S.shape[2],T=null!=o,A=null!=i,R="leakyrelu"===c,F=null!=c?TX(c,!0):null;let _;if((1===f||1===g)&&C>qX&&!1===(T||A||R||null!=F)){let t=S,e=I;r&&(t=HX({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(t)),a&&(e=HX({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e));const n=1===g;let o=t;1!==g&&(o=zX({inputs:{x:t},backend:s,attrs:{shape:[E,C,1]}}),N.push(o));const i=1===g?2:1;let l=e;n&&(l=zX({inputs:{x:e},backend:s,attrs:{shape:[E,1,C]}}),N.push(l));const c=DX({inputs:{a:o,b:l},backend:s});_=GX({inputs:{x:c},backend:s,attrs:{axis:i,keepDims:!0}}),N.push(c)}else{const t=Hk(e.dtype,n.dtype),c=new AX(x,k,[E,f,g],r,a,T,F,A,R),u=[S,I];if(null!=o&&u.push(o),A&&u.push(i),R){const t=s.makeTensorInfo([],"float32",fk(l,"float32"));u.push(t),N.push(t)}_=s.runWebGLProgram(c,u,t)}const D=zX({inputs:{x:_},backend:s,attrs:{shape:w}});N.push(_);for(const O of N)s.disposeIntermediateTensorInfo(O);return D}const JX={kernelName:Ux,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return XX({a:a,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},YX="return abs(x);";const ZX={kernelName:Dy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const t=n.texData.get(r.dataId),e=xq(t.values);return n.makeTensorInfo(r.shape,r.dtype,e)}let a;return a=Ty().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new sX(r.shape,YX):new Hq(r.shape,YX),n.runWebGLProgram(a,[r],r.dtype)}},QX=EX({opSnippet:Kq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),$X={kernelName:Oy,backendName:"webgl",kernelFunc:QX},tJ=EX({opSnippet:Kq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),eJ={kernelName:zy,backendName:"webgl",kernelFunc:tJ},nJ="return a + b;",rJ=CX({opSnippet:nJ,packedOpSnippet:nJ,supportsComplex:!0,cpuKernelImpl:VK}),aJ={kernelName:Ly,backendName:"webgl",kernelFunc:rJ};class sJ{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("float v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}class oJ{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("vec4 v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}const iJ={kernelName:My,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,a=n;if(1===a.length)return gX({inputs:{x:a[0]},backend:r});if(a.length>Ty().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(a.length/2),n=t({inputs:a.slice(0,e),backend:r}),s=t({inputs:a.slice(e),backend:r});return t({inputs:[n,s],backend:r})}const s=a.map((t=>t.dtype)).reduce(((t,e)=>Hk(t,e))),o=a.map((t=>t.shape)),i=Ty().getBool("WEBGL_PACK")?new oJ(a[0].shape,o):new sJ(a[0].shape,o);return r.runWebGLProgram(i,a,s)}};const lJ={kernelName:Py,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=ay(s,a.shape);let c=l;const u=IE(c,i);let h=a;null!=u&&(h=HX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=EE(c.length,i)),SE("all",c,i);const[d,p]=xE(h.shape,c),f=zX({inputs:{x:h},backend:n,attrs:{shape:[-1,Zb(p)]}}),g=BX(f,f.dtype,"all",n);let m;if(o){m=zX({inputs:{x:g},backend:n,attrs:{shape:kE(d,l)}})}else m=zX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};const cJ={kernelName:By,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=ay(s,a.shape);let c=l;const u=IE(c,i);let h=a;null!=u&&(h=HX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=EE(c.length,i)),SE("any",c,i);const[d,p]=xE(h.shape,c),f=zX({inputs:{x:h},backend:n,attrs:{shape:[-1,Zb(p)]}}),g=BX(f,f.dtype,"any",n);let m;if(o){m=zX({inputs:{x:g},backend:n,attrs:{shape:kE(d,l)}})}else m=zX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};class uJ{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===e?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(o," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class hJ{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Xb(t.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const a=t[t.length-1],s=Math.ceil(a/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=mK(i),c=Pq("coords",i);let u,h;if(1===s){h=i+1;const t=mK(h);u="\n        ".concat(t," sourceLocR = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-1],";\n        ").concat(t," sourceLocG = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-2],";\n        ").concat(t," sourceLocA = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-1],";\n        ").concat(t," sourceLocB = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-2],";")}else h=i,u="\n        ".concat(l," sourceLocR = coords;\n        ++").concat(c[i-1],";\n        ").concat(l," sourceLocG = coords;\n        ++").concat(c[i-2],";\n        ").concat(l," sourceLocA = coords;\n        --").concat(c[i-1],";\n        ").concat(l," sourceLocB = coords;\n        --").concat(c[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((t=>"int "+t)),g=Pq("sourceLocR",h-1).concat("inIdx.r"),m=Pq("sourceLocG",h-1).concat("inIdx.g"),b=Pq("sourceLocB",h-1).concat("inIdx.b"),y=Pq("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",w=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),x="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(m.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=r?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(l," coords = getOutputCoords();\n        bool hasNextCol = ").concat(c[i-1]," < ").concat(o[i-1]-1,";\n        bool hasNextRow = ").concat(c[i-2]," < ").concat(o[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(e,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(x,";\n\n        for (int i = 0; i < ").concat(e,"; i++) {\n          inIdx = srcIdx;\n          ").concat(w,"\n          vec4 candidate = ").concat(x,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function dJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=e.shape[0],s=e.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=_T(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},l=new uJ(i,n,null==r),c=[e];null!=r&&c.push(r);const u=t.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=dJ(t,e,n,u);return t.disposeIntermediateTensorInfo(u),h}function pJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:e.shape,s=_T(a[a.length-1]),o=new hJ(a,s,n,null==r),i=null==r?[e]:[e,r],l=t.runWebGLProgram(o,i,"int32");if(l.shape.length===e.shape.length){const r=pJ(t,e,n,l);return t.disposeIntermediateTensorInfo(l),r}return l}function fJ(t,e,n,r){const a=[n];if(SE("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,e.shape.length),!Ty().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],s=t.texData.get(e.dataId);let o=e;null!==s&&s.isPacked&&(o=t.unpackTensor(e),n.push(o));const[i,l]=xE(o.shape,a),c=Zb(l),u=zX({inputs:{x:o},backend:t,attrs:{shape:[-1,c]}});n.push(u);const h=dJ(t,u,r);n.push(h);const d=zX({inputs:{x:h},backend:t,attrs:{shape:i}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),d}return pJ(t,e,r)}const gJ={kernelName:Wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=ay(s,a.shape);const i=IE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=HX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=EE(o.length,l.shape.length)),SE("argMax",[o[0]],l.shape.length);const u=fJ(n,l,o[0],"max");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}};const mJ={kernelName:Uy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=ay(s,a.shape);const i=IE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=HX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=EE(o.length,l.shape.length)),SE("argMin",[o[0]],l.shape.length);const u=fJ(n,l,o[0],"min");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}},bJ=EX({opSnippet:Kq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),yJ={kernelName:Vy,backendName:"webgl",kernelFunc:bJ},vJ=EX({opSnippet:Kq+"return log(x + sqrt(x * x + 1.0));"}),wJ={kernelName:Gy,backendName:"webgl",kernelFunc:vJ},xJ=EX({opSnippet:Kq+"\n  return atan(x);\n"}),kJ={kernelName:jy,backendName:"webgl",kernelFunc:xJ},SJ=CX({opSnippet:hX+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pX+"\n  return result;\n"}),IJ={kernelName:Ky,backendName:"webgl",kernelFunc:SJ},NJ=EX({opSnippet:Kq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),EJ={kernelName:Hy,backendName:"webgl",kernelFunc:NJ};class CJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,g="((batch  * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + d"),m="(xR * ".concat(t.inWidth," + xC) * ").concat(t.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(c,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(e," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?a?g:m:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(y="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),w=s%4,x="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(l,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(c,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              getValue(batch, xR, xC + 3 * ").concat(c,", d)\n            );\n\n            ").concat(x,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(2===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(3===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              initializationValue\n            );\n\n            ").concat(x,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class TJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,i=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=t.padInfo.front,m=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(c,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(e," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?a?"(((batch * ".concat(t.inDepth," + xD) * ").concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"((xD * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let w="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(s/4),k=s%4,S="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(c,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(x,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(w,");\n      }\n    ")}}const AJ={kernelName:qy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;QH(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Xb(RN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=wN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Qb(c.inShape,c.outShape))return gX({inputs:{x:a},backend:n});const u=new CJ(c,"avg",!1);return n.runWebGLProgram(u,[a],"float32")}};const RJ={kernelName:Jy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r,u=xN(a.shape,s,o,[1,1,1],i,l,c),h=new TJ(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}};class FJ{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=i-1-t.padInfo.top,u=l-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(l,";\n            wC+= ").concat(o,") {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class _J{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=u-1-t.padInfo.front,f=h-1-t.padInfo.top,g=d-1-t.padInfo.left,m=1/(e*n*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(g,");\n      const float avgMultiplier = float(").concat(m,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(a,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(l,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const DJ={kernelName:Yy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=xN(o.shape,i,l,[1,1,1],c,u),d=new _J(h);return n.runWebGLProgram(d,[a],o.dtype)}};const OJ={kernelName:Xy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;QH([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=wN(o.shape,i,l,1,c),h=new FJ(u);return n.runWebGLProgram(h,[a],o.dtype)}};const zJ={kernelName:Zy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;return XX({a:a,b:s,transposeA:o,transposeB:i,backend:n})}};class LJ{constructor(t,e,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],LI(t,e),LI(t,n);let o="0.0";null!=r&&(LI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(LI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class MJ{constructor(t,e,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],LI(t,e),LI(t,n);let o="vec4(0.0)";null!=r&&(LI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(LI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const PJ={kernelName:Gv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,mean:s,variance:o,offset:i,scale:l}=e;Xb(s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Xb(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Xb(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=[a,s,o];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=l&&(d=l.shape,u.push(l));const p=Ty().getBool("WEBGL_PACK_NORMALIZATION")?new MJ(a.shape,s.shape,o.shape,h,d,c):new LJ(a.shape,s.shape,o.shape,h,d,c);return n.runWebGLProgram(p,u,u[0].dtype)}};class BJ{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=mK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return WJ.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error("Slicing for rank ".concat(t," is not yet supported"))}(this.rank);let r;const a=t.map(((t,e)=>"sourceLoc.".concat(WJ[e]," = start[").concat(e,"] + coords.").concat(WJ[e],";")));r="\n        ".concat(e," sourceLoc;\n        ").concat(e," coords = getOutputCoords();\n        ").concat(a.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(r,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const WJ=["x","y","z","w","u","v"];class UJ{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=mK(this.rank),n=Pq("coords",this.rank),r=Pq("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),s="getChannel(getSource(".concat(r.join(),"), ").concat(a,")"),o="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(r[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(t[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),l=this.rank<=4?"sourceLoc = coords +\n            ".concat(e,"(").concat(t.map(((t,e)=>"start[".concat(e,"]"))).join(),");"):t.map(((t,e)=>"".concat(r[e]," = ").concat(n[e]," + start[").concat(e,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(e," coords = getOutputCoords();\n        ").concat(e," sourceLoc;\n        ").concat(l,"\n        vec4 result = vec4(0.);\n        ").concat(o,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function VJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r,[i,l]=pN(a,s,o);if($I(a,i,l),0===Zb(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const t=n.texData.get(a.dataId),e=kq(t.values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,e)}const{isPacked:c}=n.texData.get(a.dataId),u=hN(a.shape,i,l);if(c||!u){const t=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UJ(l):new BJ(l),e=[i];return n.runWebGLProgram(t,[a],a.dtype,e)}return n.uploadToGPU(a.dataId),function(t,e,n,r){const a=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=t.dtype;let i=dN(e,gy(t.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||t.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}(a,i,l,n)}const GJ={kernelName:ax,backendName:"webgl",kernelFunc:VJ},jJ={kernelName:Qy,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;Xb(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=OT(a.shape,s,i),c=zT(l.length,s.length),u=LT(a.shape,s,i),h=MT(o,s.length),d=PT(u,o,s.length),p=[],f=zX({inputs:{x:a},backend:n,attrs:{shape:l}}),g=HX({inputs:{x:f},backend:n,attrs:{perm:c}}),m=zX({inputs:{x:g},backend:n,attrs:{shape:u}}),b=VJ({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}};const HJ={kernelName:$y,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=n.readSync(a.dataId),l=n.readSync(s.dataId),c=GK(i,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}};const KJ={kernelName:tv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ty().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===o){const t=n.texData.get(r.dataId).values,e=n.texData.get(a.dataId).values,[s,o]=HK(r.shape,a.shape,t,e,r.dtype),i=n.makeTensorInfo(o,r.dtype);return n.texData.get(i.dataId).values=s,i}let i;return i=s?new fX("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new dX("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(i,[r,a],r.dtype)}};const qJ={kernelName:ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.readSync(r.dataId),o=n.readSync(a.dataId),i=LI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},XJ=CX({opSnippet:"return float(a != b);",cpuKernelImpl:dq,dtype:"bool"}),JJ={kernelName:Ew,backendName:"webgl",kernelFunc:XJ};function YJ(t){const{inputs:e,backend:n}=t,{input:r}=e;return gX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const ZJ={kernelName:Uw,backendName:"webgl",kernelFunc:YJ},QJ="return float(int(x));";const $J={kernelName:nv,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return gX({inputs:{x:s},backend:r});const e=BE(s.shape),n=t({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=bX({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const e=YJ({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),n}if(!ly(s.dtype,o)){const t=gX({inputs:{x:s},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const t=r.texData.get(s.dataId).values,[e,n,a]=KK(t,s.shape,s.dtype,o);return r.makeTensorInfo(e,n,a)}if("int32"===o)return function(t,e){const n=new Hq(t.shape,QJ),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const t=r.makeTensorInfo([],"bool",oy("bool",1)),e=XJ({inputs:{a:s,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(o))}},tY="return ceil(x);",eY=EX({opSnippet:tY,packedOpSnippet:tY,cpuKernelImpl:qK}),nY={kernelName:rv,backendName:"webgl",kernelFunc:eY};class rY{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class aY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const sY={kernelName:av,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{clipValueMin:s,clipValueMax:o}=r;let i;i=Ty().getBool("WEBGL_PACK_CLIP")?new aY(a.shape):new rY(a.shape);const l=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,l)}};class oY{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function iY(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const lY={kernelName:ov,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=n.texData.get(r.dataId),s=new oY(r.shape),o=[iY(r,a.complexTensorInfos.real),iY(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class cY{constructor(t){this.outputShape=[],this.outputShape=NT(t,1),this.variableNames=t.map(((t,e)=>"T".concat(e)));const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=["if (yC < ".concat(e[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<e.length;s++){const t=e[s-1];n.push("else if (yC < ".concat(e[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(t,"));"))}const r=e.length,a=e[e.length-1];n.push("else setOutput(getT".concat(r,"(yR, yC-").concat(a,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class uY{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=NT(t,e);const n=this.outputShape,r=n.length,a=mK(r),s=Pq("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>"T".concat(e)));const i=new Array(t.length-1);i[0]=t[0][e];for(let f=1;f<i.length;f++)i[f]=i[f-1]+t[f][e];const l=o[e],c=o.slice(-2),u=o.join();let h="if (".concat(l," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(c.join(),"));\n        }");for(let f=1;f<i.length;f++){const t=i[f-1];h+="\n        if (".concat(l," < ").concat(i[f],"  && ").concat(l," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(hY(o,l,t),"),\n            vec2(").concat(hY(c,l,t),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(hY(o,l,p),"),\n          vec2(").concat(hY(c,l,p),"));"),this.userCode="\n      float getValue(".concat(o.map((t=>"int "+t)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(a," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," + 1;\n        if (").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-2]," = ").concat(s[r-2]," + 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," - 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2]," &&\n            ").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}function hY(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?"".concat(t," - ").concat(n):t)).join()}function dY(t){const{inputs:e,backend:n}=t,{input:r}=e;return gX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const pY={kernelName:Yv,backendName:"webgl",kernelFunc:dY};function fY(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>YJ({inputs:{input:t},backend:n}))),a=t.map((t=>dY({inputs:{input:t},backend:n}))),s=fY(r,e,n),o=fY(a,e,n),i=bX({inputs:{real:s,imag:o},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),a.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(t);if("string"===r&&(a=!0),a){const a=t.map((t=>{const r=Zb(t.shape.slice(e));return zX({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),o=NT(a.map((t=>t.shape)),1),i=1===a[0].shape[0],l=XK(s,o,r,i),c=NT(t.map((t=>t.shape)),e),u=n.makeTensorInfo(c,r,l);return a.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}const s=t.filter((t=>Zb(t.shape)>0)),o=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const e=o?new Hq(t[0].shape,Qq):new sX(t[0].shape,Qq);return n.runWebGLProgram(e,t,r)}const i=Ty().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){const t=[];for(let a=0;a<s.length;a+=i){const r=s.slice(a,a+i);t.push(fY(r,e,n))}const r=fY(t,e,n);for(const e of t)n.disposeIntermediateTensorInfo(e);return r}if(o){const t=new uY(s.map((t=>t.shape)),e);return n.runWebGLProgram(t,s,r)}const{tensors2D:l,outShape:c}=function(t,e,n){const r=NT(t.map((t=>t.shape)),e),a=t.map((t=>zX({inputs:{x:t},attrs:{shape:[-1,Zb(t.shape.slice(e))]},backend:n})));return{tensors2D:a,outShape:r}}(s,e,n),u=new cY(l.map((t=>t.shape))),h=n.runWebGLProgram(u,l,r);l.forEach((t=>n.disposeIntermediateTensorInfo(t)));const d=zX({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function gY(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=ay(a,e[0].shape)[0];IT(e.map((t=>t.shape)),s);const o=NT(e.map((t=>t.shape)),s);if(0===Zb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Zb(t.shape)>0));return 1===i.length?gX({inputs:{x:i[0]},backend:n}):fY(i,s,n)}const mY={kernelName:iv,backendName:"webgl",kernelFunc:gY};class bY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,o=t.padInfo.left,i=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,g="channelsLast"===t.dataFormat,m=g?1:2,b=g?2:3,y=g?3:1;let v="",w="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),w="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(l,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(c,";\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(t.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(x,"\n        ").concat(w,"\n        setOutput(result);\n      }\n    ")}}class yY{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(a,", ").concat(s,", ").concat(o,");\n      const ivec3 pads = ivec3(").concat(e,", ").concat(n,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(l,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(c,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class vY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=SK(this.outputShape.length);const s=t.padInfo.left,o=t.strideWidth,i=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,u=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+="\n           vec4 xTexelC".concat(2*g,";\n           int xTexelC").concat(2*g,"Ready;\n           vec4 xTexelC").concat(2*g+1,";\n           int xTexelC").concat(2*g+1,"Ready;\n           vec4 xC").concat(g,";");h+="\n     for (int r = 0; r < ".concat(l,"; r++) {\n      for (int d1 = 0; d1 < ").concat(t.inChannels,"; d1 += 2) {\n       ");for(let g=0;g<c;g++)h+="\n           xTexelC".concat(2*g," = vec4(0.0);\n           xTexelC").concat(2*g,"Ready = 0;\n           xTexelC").concat(2*g+1," = vec4(0.0);\n           xTexelC").concat(2*g+1,"Ready = 0;\n           xC").concat(g," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const e=2*g;if(h+="\n           xC = xCCorner + ".concat(e*i,";\n           "),1===o){if(e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n               "),h+=1===i&&e>0?"\n                 xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                   } else {\n                     xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xC").concat(e," = xTexelC").concat(e,";\n                 "),e+1<c)){const t=s%2===0?Kb(i):i;i%2===0&&s%2===1||i%2!==0&&s%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                     xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(e+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(e+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                     } else {\n                      xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                     }\n                     "):"\n                     xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                     ")):h+=1===t?"\n                     xC".concat(e+1," = xTexelC").concat(e,";\n                     "):"\n                     xCOffset = xC + ".concat(t,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                       xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(e+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(e+1,"Ready = 1;\n                     }\n\n                     xC").concat(e+1," = xTexelC").concat(e+1,";\n                     ")}}else e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n               "),e+1<c&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(\n                   xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n               "),e+1<c&&(h+="\n                   xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                 "))));e<c&&(h+="\n             wTexel = getW(r, ".concat(e,", d1, d2);\n             dotProd += xC").concat(e,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(t.inChannels,") {\n               dotProd += xC").concat(e,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),e+1<c&&(h+="\n               wTexel = getW(r, ".concat(e+1,", d1, d2);\n               dotProd += xC").concat(e+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(t.inChannels,") {\n                 dotProd += xC").concat(e+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):a?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class wY{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=SK(this.outputShape.length);const{dataFormat:n}=e,r=tK(),a="channelsLast"===n,s=a?1:2,o=a?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(t[2]," && pos < ").concat(t[1],") {");let l="";for(let c=0;c<=1;c++)for(let t=0;t<=1;t++)l+="\n          blockIndex = rc.z + ".concat(t,";\n          pos = rc.y + ").concat(c,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(o,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(a,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(l,"\n\n        ").concat(r.output," = result;\n      }\n    ")}}function xY(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function kY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const c=e.shape,u=a.texData.get(e.dataId),h=r.inChannels,d=c[0]*c[1]*c[2],p=r.outChannels,f="channelsLast"===r.dataFormat;let g;const m=[];if(null!=o){const t=xY(o.shape,f);null!=t&&(o=zX({inputs:{x:o},backend:a,attrs:{shape:t}}),m.push(o))}if(null!=s){const t=xY(s.shape,f);null!=t&&(s=zX({inputs:{x:s},backend:a,attrs:{shape:t}}),m.push(s))}if(!((1===d||1===p)&&h>qX)&&u.isPacked&&f&&null!=u.texture&&c[2]%2!==0&&Qb(u.shape.slice(-3),c.slice(-3))){const t=c[0]*c[1]*(c[2]+1),h={dataId:e.dataId,shape:[1,t,r.inChannels],dtype:e.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Xb(HH(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=zX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});m.push(p);const f=XX({a:h,b:p,backend:a,transposeA:false,transposeB:false,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i}),b=a.texData.get(f.dataId);Xb(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,b.shape=r.outShape,g=gX({inputs:{x:f},backend:a}),g.shape=r.outShape,m.push(f)}else{const t=r.outHeight*r.outWidth,c=zX({inputs:{x:e},backend:a,attrs:{shape:f?[r.batchSize,t,r.inChannels]:[r.batchSize,r.inChannels,t]}}),u=zX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=XX({a:f?c:u,b:f?u:c,transposeA:!f,transposeB:false,backend:a,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i});g=zX({inputs:{x:h},backend:a,attrs:{shape:r.outShape}}),m.push(c),m.push(u),m.push(h)}for(const b of m)a.disposeIntermediateTensorInfo(b);return g}function SY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const{filterWidth:c,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,g="channelsLast"===f,m=c*u*h,b=p*d,y=[r.batchSize,m,b],v=[];if(null!=o){const t=xY(o.shape,g);null!=t&&(o=zX({inputs:{x:o},backend:a,attrs:{shape:t}}),v.push(o))}if(null!=s){const t=xY(s.shape,g);null!=t&&(s=zX({inputs:{x:s},backend:a,attrs:{shape:t}}),v.push(s))}const w=zX({inputs:{x:n},backend:a,attrs:{shape:[1,m,Zb(n.shape)/m]}});v.push(w);const x=new wY(y,r),k=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(x,[e],"float32",k),I=zX({inputs:{x:S},backend:a,attrs:{shape:y}});v.push(S),v.push(I);const N=null!=s,E=null!=o,C="leakyrelu"===l,T=l?TX(l,!0):null,A=new AX(g?I.shape:w.shape,g?w.shape:I.shape,g?[r.batchSize,b,r.outChannels]:[r.batchSize,r.outChannels,b],!0,!1,N,T,E,C),R=g?[I,w]:[w,I];if(s&&R.push(s),E&&R.push(o),C){const t=a.makeTensorInfo([],"float32",fk(i,"float32"));R.push(t),v.push(t)}const F=a.runWebGLProgram(A,R,"float32"),_=zX({inputs:{x:F},backend:a,attrs:{shape:r.outShape}});v.push(F);for(const D of v)a.disposeIntermediateTensorInfo(D);return _}const IY={kernelName:lv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=_N(l),d=kN(a.shape,s.shape,o,c,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Ty().getBool("WEBGL_EXP_CONV")){const t=new vY(d),e=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(t,[a,s],"float32",e)}else if(Ty().getBool("WEBGL_CONV_IM2COL"))p=SY({x:a,filter:s,convInfo:d,backend:n});else{const t=new bY(d);p=n.runWebGLProgram(t,[a,s],"float32")}else p=kY({x:a,filter:s,convInfo:d,backend:n});const f=zX({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class NY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              ").concat(s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class EY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s="channelsLast"===t.dataFormat,o=e-1-t.padInfo.top,i=n-1-t.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(l,"], coords[").concat(c,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class CY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.padInfo.front,s=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(t.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(e," - ").concat(a,";\n\n            if (xF < 0 || xF >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(o,";\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class TY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(l,", ").concat(c,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(e,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(a,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(t.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(e," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const AY={kernelName:cv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=_N(l),d=kN(a.shape,u,o,1,i,c,!1,h),p=new NY(d);return n.runWebGLProgram(p,[a,s],"float32")}};class RY{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=SK(this.outputShape.length);const e=t.filterHeight,n=t.filterWidth,r=e-1-t.padInfo.top,a=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(a,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(t.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(t.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const FY={kernelName:uv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=_N(c),d=kN(o,s.shape,i,1,l,u,!1,h);if(Ty().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const t=[[d.strideHeight,d.strideWidth]],e=new RY(d);return n.runWebGLProgram(e,[a,s],"float32",t)}{const t=new EY(d);return n.runWebGLProgram(t,[a,s],"float32")}}};const _Y={kernelName:hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=SN(a.shape,s.shape,o,l,i),u=new yY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const DY={kernelName:dv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r,c=SN(a.shape,l,o,1,i),u=new CY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const OY={kernelName:pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r,c=SN(l,s.shape,i,1,o),u=new TY(c);return n.runWebGLProgram(u,[a,s],"float32")}},zY=EX({opSnippet:NX+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(pX,"\n  return result;\n")}),LY={kernelName:fv,backendName:"webgl",kernelFunc:zY},MY=EX({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),PY={kernelName:gv,backendName:"webgl",kernelFunc:MY};class BY{constructor(t,e,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===r?1:0,[p,f]=["".concat(o-1,".0"),"".concat(i-1,".0")],[g,m,b]=u>1?["".concat((o-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,w]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(g,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(m,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n        float in_x = ").concat(w,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const WY={kernelName:yv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,u=new BY(a.shape,s.shape,i,l,c);return n.runWebGLProgram(u,[a,s,o],"float32")}};var UY;!function(t){t.Prod="*",t.Sum="+"}(UY||(UY={}));class VY{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===UY.Prod?"1.0":"0.0",o=n?s:"getX(".concat(GY(a,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=r?"end != ".concat(i-1):"end != 0",c=r?"end + 1":"end - 1"):(l=r?"end + pow2 < ".concat(i):"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(mK(a)," coords = getOutputCoords();\n        int end = ").concat(jY(a,"coords",this.op),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(l,") {\n          int idx = ").concat(c,";\n          ").concat(jY(a,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(GY(a,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function GY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".x, ").concat(e,".y");if(3===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z");if(4===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z, ").concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function jY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".y");if(3===t)return"".concat(e,".z");if(4===t)return"".concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function HY(t,e,n,r,a,s){const o=e.shape.length,i=IE([r],o);let l=e;null!=i&&(l=HX({inputs:{x:e},backend:n,attrs:{perm:i}}));const c=EE(1,o)[0];if(c!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(e.shape.length-1," ")+"but got axis=".concat(r));const u=l.shape[c];let h=gX({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const e=new VY(t,l.shape,!1,s),r=[[d]],a=h;h=n.runWebGLProgram(e,[h],h.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const e=new VY(t,l.shape,a,s),r=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=i){const t=HX({inputs:{x:h},backend:n,attrs:{perm:NE(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}const KY={kernelName:mv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return HY(UY.Prod,a,n,s,o,i)}};const qY={kernelName:bv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return HY(UY.Sum,a,n,s,o,i)}};const XY={kernelName:vv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=n.readSync(a.dataId),e=n.readSync(s.dataId),r=GK(t,e,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const t=n.bufferSync(a),e=n.bufferSync(s),r=jK(t,e,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};class JY{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(e,";\n      int offset_h = imod(h, ").concat(e,");\n      int in_w = w / ").concat(e,";\n      int offset_w = imod(w, ").concat(e,");\n      int offset_d = (offset_h * ").concat(e," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const YY={kernelName:wv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,c=("NHWC"===o?a.shape[2]:a.shape[3])*s,u=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),h=new JY("NHWC"===o?[i,l,c,u]:[i,u,l,c],s,o);return n.runWebGLProgram(h,[a],a.dtype)}};class ZY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=SK(this.outputShape.length);const s=t.filterHeight,o=t.filterWidth,i=t.outChannels/t.inChannels;let l="",c="";n&&(l=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),c="result = activation(result);");const u=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(l,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")}}class QY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=SK(this.outputShape.length);const s=t.outChannels/t.inChannels,o=t.padInfo.left,i=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+="\n          vec4 xTexelC".concat(2*m,";\n          int xTexelC").concat(2*m,"Ready;\n          vec4 xTexelC").concat(2*m+1,";\n          int xTexelC").concat(2*m+1,"Ready;\n          vec4 xC").concat(m,";");d+="\n    for (int r = 0; r < ".concat(c,"; r++) {\n      ");for(let m=0;m<u;m++)d+="\n          xTexelC".concat(2*m," = vec4(0.0);\n          xTexelC").concat(2*m,"Ready = 0;\n          xTexelC").concat(2*m+1," = vec4(0.0);\n          xTexelC").concat(2*m+1,"Ready = 0;\n          xC").concat(m," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const t=2*m;if(d+="\n          xC = xCCorner + ".concat(t*l,";\n          "),1===i){if(t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n              "),d+=1===l&&t>0?"\n                xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                  } else {\n                    xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xC").concat(t," = xTexelC").concat(t,";\n                "),t+1<u)){const e=o%2===0?Kb(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                    xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(t+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(t+1,"Ready = 1;\n                  }\n                  "),d+=l>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                    } else {\n                     xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                    }\n                    "):"\n                    xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                    ")):d+=1===e?"\n                    xC".concat(t+1," = xTexelC").concat(t,";\n                    "):"\n                    xCOffset = xC + ".concat(e,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                      xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(t+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(t+1,"Ready = 1;\n                    }\n\n                    xC").concat(t+1," = xTexelC").concat(t+1,";\n                    ")}}else t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n              "),t+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(\n                  xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n              "),t+1<u&&(d+="\n                  xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                "))));t<u&&(d+="\n            wTexel = getW(r, ".concat(t,", d1, q);\n            dotProd += xC").concat(t," * vec4(wTexel.xz, wTexel.xz);\n          "),t+1<u&&(d+="\n              wTexel = getW(r, ".concat(t+1,", d1, q);\n              dotProd += xC").concat(t+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const $Y={kernelName:xv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),Xb(RN(o,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(u,"'")));const h=kN(a.shape,s.shape,o,u,i,c,!0);let d;d=Ty().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new QY(h):new ZY(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}};class tZ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class eZ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=e-1-t.padInfo.top,o=n-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const nZ={kernelName:kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r,h=kN(a.shape,u,o,i,l,c,!0),d=new tZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};const rZ={kernelName:Sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r,h=kN(u,s.shape,o,i,l,c,!0),d=new eZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};class aZ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const sZ={kernelName:Iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=[...r.shape,...r.shape],s=Zb(r.shape),o=zX({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new aZ(s),l=n.runWebGLProgram(i,[o],o.dtype),c=zX({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}};class oZ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:l,dilationWidth:c}=t,{top:u,left:h}=r;this.userCode="\n      const ivec2 strides = ivec2(".concat(a,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(o,"; h++) {\n          int hIn = hBeg + h * ").concat(l,";\n\n          if (hIn >= 0 && hIn < ").concat(e,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(c,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const iZ={kernelName:Nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=vN(a.shape,s.shape,o,i,"NHWC",l);let u;const h=new oZ(c);u=n.runWebGLProgram(h,[a,s],"float32");const d=zX({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const lZ={kernelName:Rv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=cA(a,s.length);hA(o.length,l,s);const{path:c,steps:u}=dA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=uA(p,l[t]);let a;pA(e)?a=s[t]:(a=HX({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);Qb(a.shape,o)||(a=zX({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=DX({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=GX({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},cZ=EX({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),uZ={kernelName:Fv,backendName:"webgl",kernelFunc:cZ},hZ={kernelName:_v,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:r,y:a}=e,s=Ty().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fX("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new dX("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},dZ=CX({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:JK}),pZ={kernelName:Ov,backendName:"webgl",kernelFunc:dZ},fZ=EX({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(HT,";\n  float a1 = ").concat(KT,";\n  float a2 = ").concat(qT,";\n  float a3 = ").concat(XT,";\n  float a4 = ").concat(JT,";\n  float a5 = ").concat(YT,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),gZ={kernelName:Dv,backendName:"webgl",kernelFunc:fZ},mZ=EX({opSnippet:NX+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:YK,dtype:"float32"}),bZ={kernelName:zv,backendName:"webgl",kernelFunc:mZ};function yZ(t){const{inputs:e,attrs:n,backend:r}=t,{dim:a}=n,{input:s}=e,o=s.shape.length,i=s.shape.slice();let l=a;return a<0&&(Xb(-(o+1)<=a,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+a+1),i.splice(l,0,1),zX({inputs:{x:s},backend:r,attrs:{shape:i}})}const vZ={kernelName:Lv,backendName:"webgl",kernelFunc:yZ},wZ="return exp(x) - 1.0;",xZ=EX({opSnippet:wZ,packedOpSnippet:wZ,cpuKernelImpl:ZK}),kZ={kernelName:Mv,backendName:"webgl",kernelFunc:xZ};class SZ{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const a=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(r,".0"):"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error('FFT component must be either "real" or "imag", got '.concat(t,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(a,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function IZ(t,e,n){const r=n.texData.get(t.dataId),a=Zb(t.shape),s=t.shape[t.shape.length-1],o=zX({inputs:{x:t},backend:n,attrs:{shape:[a/s,s]}}),i=o.shape,l=new SZ("real",i,e),c=new SZ("imag",i,e),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(l,u,"float32"),d=n.runWebGLProgram(c,u,"float32"),p=bX({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=zX({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const NZ={kernelName:Pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return IZ(r,!1,n)}};class EZ{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function CZ(t){const{backend:e,attrs:n}=t,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||dy(a),"string"===s){const t=iy(s,Zb(r));return t.fill(a),e.makeTensorInfo(r,s,t)}{const t=new EZ(r,a),n=[[a]];return e.runWebGLProgram(t,[],s,n)}}const TZ={kernelName:Bv,backendName:"webgl",kernelFunc:CZ};class AZ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(e," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(e,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const RZ={kernelName:Wv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{image:r}=e,a=n,s=new AZ(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},FZ="return floor(x);",_Z=EX({opSnippet:FZ,packedOpSnippet:FZ,cpuKernelImpl:QK}),DZ={kernelName:Uv,backendName:"webgl",kernelFunc:_Z},OZ=CX({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),zZ={kernelName:Vv,backendName:"webgl",kernelFunc:OZ};class LZ{constructor(t){this.variableNames=["A"];const e=tK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(e.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class MZ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=tK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(n,".0);\n            vec4 values = ").concat(e.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}const PZ={kernelName:Bx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:a}=e;const{numChannels:s}=r,o="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,c]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[c,l],h=[c,l,s];if(i||o){const t=Ty().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=BZ&&t===WZ||(WZ=t,BZ=document.createElement("canvas").getContext("2d",{willReadFrequently:WZ})),BZ.canvas.width=l,BZ.canvas.height=c,BZ.drawImage(a,0,0,l,c),a=BZ.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=kH.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);const p=Ty().getBool("WEBGL_PACK")?new MZ(h):new LZ(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let BZ,WZ=Ty().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const UZ={kernelName:Vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,g=_N(u),m=kN(a.shape,s.shape,l,h,c,d,!1,g);let b;const y=[],v=null!=o,w=null!=i,x="leakyrelu"===p,k=()=>{const t=[a,s],e=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=zX({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return y.push(e),e}return t};if(v&&t.push(e(o,u)),w&&t.push(e(i,u)),x){const e=n.makeTensorInfo([],"float32",fk(f,"float32"));t.push(e),y.push(e)}return t};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&Ty().getBool("WEBGL_EXP_CONV")){const t=p?TX(p,!0):null,e=new vY(m,v,t,w,x),r=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],a=k();b=n.runWebGLProgram(e,a,"float32",r)}else if(Ty().getBool("WEBGL_CONV_IM2COL"))b=SY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const t=p?TX(p,!1):null,e=new bY(m,v,t,w,x),r=k();b=n.runWebGLProgram(e,r,"float32")}else b=kY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=zX({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return y.push(b),y.forEach((t=>n.disposeIntermediateTensorInfo(t))),S}};const VZ={kernelName:Gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let g=u;null==g&&(g=[1,1]),Xb(RN(l,g),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(l," and dilations '").concat(g,"'")));const m=kN(a.shape,s.shape,l,g,c,h,!0),b=Ty().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,y=d?TX(d,b):null,v=[a,s],w=null!=o,x=null!=i,k="leakyrelu"===d;if(w&&v.push(o),x&&v.push(i),k){const t=n.makeTensorInfo([],"float32",fk(p,"float32"));v.push(t),f.push(t)}let S;S=b?new QY(m,w,y,x,k):new ZY(m,w,y,x,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((t=>n.disposeIntermediateTensorInfo(t))),N}};class GZ{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=mK(n.length);let s="\n    int index;";for(let o=0;o<this.sliceDim;o++)s+="\n          index = round(getIndices(coords[0], ".concat(o,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[o],";\n          flattenIndex += index * ").concat(this.strides[o],";");this.userCode="\n         void main() {\n          ".concat(a," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const jZ={kernelName:Hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=a.shape,o=s[s.length-1],i=Zb(r.shape),[l,c,u,h]=BT(r,a),d=zX({inputs:{x:a},backend:n,attrs:{shape:[c,o]}}),p=zX({inputs:{x:r},backend:n,attrs:{shape:[Zb(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const t=n.readSync(a.dataId),e=n.bufferSync(r),s=$K(t,e,r.dtype,c,o,u,h,r.shape,i);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new GZ(o,h,[c,u],r.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=zX({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class HZ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=mK(this.rank),r=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<t.length;a++)2===a?r.push("index"):r.push("".concat(n[a]));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(t[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(r,"));\n      }\n    ")}}function KZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r,l=ay(o,a.shape)[0];if(Ty().get("DEBUG")){const t=n.readSync(s.dataId),e=a.shape[l];for(let n=0;n<t.length;++n){const r=t[n];Xb(r<=e-1&&r>=0,(()=>"GatherV2: the index value ".concat(r," is not in [0, ").concat(e-1,"]")))}}const c=RA(a,s,l,i),u=Zb(s.shape),h=[],d=zX({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=zX({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const t=n.bufferSync(p),e=n.bufferSync(d),r=tq(e,t,f);return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const g=new HZ(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=zX({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}const qZ={kernelName:jv,backendName:"webgl",kernelFunc:KZ},XZ=CX({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:eq,dtype:"bool"}),JZ={kernelName:Kv,backendName:"webgl",kernelFunc:XZ},YZ=CX({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:nq}),ZZ={kernelName:qv,backendName:"webgl",kernelFunc:YZ};const QZ={kernelName:Jv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return IZ(r,!0,n)}},$Z=EX({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),tQ={kernelName:Zv,backendName:"webgl",kernelFunc:$Z},eQ=EX({opSnippet:"return float(isinf(x));",dtype:"bool"}),nQ={kernelName:Qv,backendName:"webgl",kernelFunc:eQ},rQ=EX({opSnippet:"return float(isnan(x));",dtype:"bool"}),aQ={kernelName:$v,backendName:"webgl",kernelFunc:rQ},sQ=CX({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:rq,dtype:"bool"}),oQ={kernelName:ew,backendName:"webgl",kernelFunc:sQ},iQ=CX({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:aq,dtype:"bool"}),lQ={kernelName:nw,backendName:"webgl",kernelFunc:iQ};const cQ={kernelName:rw,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=sq(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},uQ=EX({opSnippet:NX+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:oq}),hQ={kernelName:aw,backendName:"webgl",kernelFunc:uQ},dQ=EX({opSnippet:NX+"\n  return log(1.0 + x);\n"}),pQ={kernelName:sw,backendName:"webgl",kernelFunc:dQ},fQ=CX({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),gQ={kernelName:ow,backendName:"webgl",kernelFunc:fQ},mQ=EX({opSnippet:"return float(!(x >= 1.0));"}),bQ={kernelName:iw,backendName:"webgl",kernelFunc:mQ},yQ=CX({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),vQ={kernelName:lw,backendName:"webgl",kernelFunc:yQ};class wQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(o,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class xQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(o,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const kQ={kernelName:cw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r,c=Ty().getBool("WEBGL_PACK_NORMALIZATION")?new xQ(a.shape,s,o,i,l):new wQ(a.shape,s,o,i,l);return n.runWebGLProgram(c,[a],a.dtype)}};class SQ{constructor(t,e,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(e,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(e," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(a,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(a,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const IQ={kernelName:uw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r,h=new SQ(a.shape,i,l,c,u);return n.runWebGLProgram(h,[a,s,o],a.dtype)}};function NQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,l=ay(s,a.shape);let c=l;const u=IE(c,i),h=null!=u,d=n.shouldExecuteOnCPU([a]);let p=a;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(i);for(let n=0;n<e.length;n++)e[n]=a.shape[u[n]];const r=zq(t,a.shape,a.dtype,u,e);p=n.makeTensorInfo(e,a.dtype);n.texData.get(p.dataId).values=r}else p=VX(a,u,n);c=EE(c.length,i)}SE("max",c,i);const[f,g]=xE(p.shape,c);let m,b=f;if(o&&(b=kE(f,l)),d){const t=n.texData.get(p.dataId).values,e=iq(t,Zb(g),b,a.dtype);m=n.makeTensorInfo(b,a.dtype);n.texData.get(m.dataId).values=e}else m=function(t,e,n,r){const a=Zb(e),s=zX({inputs:{x:t},attrs:{shape:[Zb(t.shape)/a,a]},backend:r}),o=BX(s,t.dtype,"max",r),i=zX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const EQ={kernelName:hw,backendName:"webgl",kernelFunc:NQ},CQ=CX({opSnippet:hX+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pX+"\n  return result;\n",cpuKernelImpl:lq}),TQ={kernelName:dw,backendName:"webgl",kernelFunc:CQ};const AQ={kernelName:pw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;QH(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Xb(RN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=wN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Qb(c.inShape,c.outShape))return gX({inputs:{x:a},backend:n});const u=new CJ(c,"max",!1);return n.runWebGLProgram(u,[a],a.dtype)}};const RQ={kernelName:gw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dataFormat:l,dimRoundingMode:c}=r,u=xN(a.shape,s,o,[1,1,1],i,c,l),h=new TJ(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}};class FQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,a=t.effectiveFilterHeight,s=t.effectiveFilterWidth,o=a-1-t.padInfo.top,i=s-1-t.padInfo.left,l=a*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(a,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(e,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(l," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class _Q{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.dilationDepth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=i-1-t.padInfo.front,h=l-1-t.padInfo.top,d=c-1-t.padInfo.left,p=i*l*c-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(a,") {\n          float dyD = float(dyDCorner + wD) / ").concat(e,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(c,";\n                wC += ").concat(o,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(l," * ").concat(c," +\n                  wR * ").concat(c," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const DQ={kernelName:mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=xN(o.shape,i,l,[1,1,1],c,u),d=new TJ(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new _Q(h),g=n.runWebGLProgram(f,[a,p],o.dtype);return n.disposeIntermediateTensorInfo(p),g}};const OQ={kernelName:fw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;QH([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=wN(i.shape,l,c,1,u,h),p=new CJ(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),g=new FQ(d),m=n.runWebGLProgram(g,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),m}};const zQ={kernelName:bw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;Xb(4===a.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length,".")));const u=[1,1];Xb(RN(o,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(u,"'")));const h=wN(a.shape,s,o,u,i),[d,p]=function(t,e,n,r){let a=new CJ(n,"max",!1);const s=r.runWebGLProgram(a,[t],"float32");return a=new CJ(n,"max",!0,!0,e),[s,r.runWebGLProgram(a,[t],"float32")]}(a,l,h,c);return[d,p]}};const LQ={kernelName:yw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{keepDims:s,axis:o}=n,i=r,l=a.shape.length,c=ay(o,a.shape);let u=c;const h=IE(u,l),d=null!=h,p=i.shouldExecuteOnCPU([a]),f=[];let g=a;if(d){if(p){const t=i.texData.get(g.dataId).values,e=new Array(l);for(let r=0;r<e.length;r++)e[r]=a.shape[h[r]];const n=zq(t,a.shape,a.dtype,h,e);g=i.makeTensorInfo(e,a.dtype);i.texData.get(g.dataId).values=n}else g=VX(a,h,i);f.push(g),u=EE(u.length,l)}SE("sum",u,l);const[m,b]=xE(g.shape,u);let y=m;s&&(y=kE(m,c));const v=function(t,e,n,r){const a=Zb(e),s=zX({inputs:{x:t},attrs:{shape:[Zb(t.shape)/a,a]},backend:r}),o=BX(s,"float32","mean",r),i=zX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(g,b,y,i);for(const w of f)i.disposeIntermediateTensorInfo(w);return v}};const MQ={kernelName:vw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=ay(s,a.shape);let c=l;const u=IE(c,i);let h=a;null!=u&&(h=HX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=EE(c.length,a.shape.length)),SE("min",c,i);const[d,p]=xE(h.shape,c),f=zX({inputs:{x:h},backend:n,attrs:{shape:[-1,Zb(p)]}}),g=BX(f,f.dtype,"min",n);let m;if(o){m=zX({inputs:{x:g},backend:n,attrs:{shape:kE(d,l)}})}else m=zX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}},PQ=CX({opSnippet:hX+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+pX+"\n  return result;\n",cpuKernelImpl:cq}),BQ={kernelName:ww,backendName:"webgl",kernelFunc:PQ};class WQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=mK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l,";\n          }\n        }\n        ").concat(a," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class UQ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=mK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Pq("rc",r),l=Pq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===r){const t="\n        ".concat(a," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ")}else{const t="\n        ".concat(a," source = rc;\n        ").concat(a," lt = ").concat(a,"(lessThan(source, start));\n        ").concat(a," gte = ").concat(a,"(greaterThanEqual(source, end));\n        ").concat(a," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[r-2]," += 1;\n        if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(t,"\n          result[2] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          ").concat(i[r-1]," += 1;\n          if(").concat(c,") {\n            ").concat(t,"\n            result[3] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const VQ={kernelName:xw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a}=e,{paddings:s,mode:o}=r,i=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UQ(a.shape,s,o):new WQ(a.shape,s,o);return n.runWebGLProgram(i,[a],a.dtype)}},GQ=CX({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+pX+"\n  return result;\n"}),jQ={kernelName:kw,backendName:"webgl",kernelFunc:GQ};class HQ{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(e-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(e-1,"));\n      }\n    ")}}const KQ=CX({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),qQ={kernelName:Av,backendName:"webgl",kernelFunc:KQ},XQ="return a - b;",JQ=CX({opSnippet:XQ,packedOpSnippet:XQ,supportsComplex:!0,cpuKernelImpl:_q}),YQ={kernelName:Cx,backendName:"webgl",kernelFunc:JQ};function ZQ(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=ay([s],a.shape),i=NQ({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=kE(i.shape,o),c=zX({inputs:{x:i},backend:n,attrs:{shape:l}}),u=JQ({inputs:{a:a,b:c},backend:n}),h=mZ({inputs:{x:u},backend:n}),d=GX({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=zX({inputs:{x:d},backend:n,attrs:{shape:l}}),f=KQ({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const QQ={kernelName:fx,backendName:"webgl",kernelFunc:ZQ};const $Q={kernelName:Sw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r,l=i?a:ZQ({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new HQ(c,u,s),d=[[o]],p=n.runWebGLProgram(h,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),p}},t$=Kq+"\n  return -x;\n";const e$={kernelName:Nw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const t=n.texData.get(r.dataId),[e,a]=hq(t.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,e)}let a;return a=Ty().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new sX(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Hq(r.shape,t$),n.runWebGLProgram(a,[r],r.dtype)}},n$=HC;const r$={kernelName:Cw,backendName:"webgl",kernelFunc:function(t){jx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=n$(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},a$=KC;const s$={kernelName:Tw,backendName:"webgl",kernelFunc:function(t){jx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=a$(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},o$=qC;const i$={kernelName:Aw,backendName:"webgl",kernelFunc:function(t){jx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=o$(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class l${constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const c$={kernelName:Fw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r,c=Zb(a.shape),u=new l$(c,o,i,l),h=zX({inputs:{x:a},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const p=zX({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function u$(t){const{inputs:e,backend:n}=t,{x:r}=e;if("complex64"===r.dtype){const t=YJ({inputs:{input:r},backend:n}),e=u$({inputs:{x:t},backend:n}),a=dY({inputs:{input:r},backend:n}),s=u$({inputs:{x:a},backend:n}),o=bX({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return CZ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const h$={kernelName:Mx,backendName:"webgl",kernelFunc:u$};const d$={kernelName:Rw,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const e=YJ({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=dY({inputs:{input:a},backend:r}),o=u$({inputs:{x:s},backend:r}),i=bX({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return CZ({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const p$={kernelName:_w,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return yZ({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Jb(s,t.shape,"All tensors passed to stack must have matching shapes"),Xb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=gY({inputs:e.map((t=>{const e=yZ({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}};class f${constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=mK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(a," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class g${constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=mK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Pq("rc",r),l=Pq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h=["".concat(a," rc = outputLoc;"),"".concat(i[r-1]," += 1;\n       if(").concat(c,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(i[r-2]," += 1;\n       if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(i[r-1]," += 1;\n         if(").concat(c,") {")],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===r?2:4;f<g;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(a," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ");p+=1===r?"} ":"}}",this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const m$=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;if(0===Zb(a.shape)){const t=s.map(((t,e)=>t[0]+a.shape[e]+t[1]));return CZ({backend:n,attrs:{shape:t,value:o,dtype:a.dtype}})}const i=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new g$(a.shape,s,o):new f$(a.shape,s,o),l=[[o]];return n.runWebGLProgram(i,[a],a.dtype,l)},b$={kernelName:Dw,backendName:"webgl",kernelFunc:m$},y$=CX({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+pX+"\n  return result;\n"}),v$={kernelName:Ow,backendName:"webgl",kernelFunc:y$};const w$={kernelName:Lw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=[],c=ay(s,a.shape);let u=c;const h=IE(u,i);let d,p=a;if(null!=h&&(p=HX({inputs:{x:a},backend:n,attrs:{perm:h}}),u=EE(u.length,i),l.push(p)),SE("prod",u,i),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:r,outDtype:a}=pq(p.shape,p.dtype,t,u);d=n.makeTensorInfo(r,a,e)}else{const[t,e]=xE(p.shape,u),r=Zb(e),s=zX({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),o=BX(s,Kk(a.dtype),"prod",n);d=zX({inputs:{x:o},backend:n,attrs:{shape:t}}),l.push(s),l.push(o)}if(o){l.push(d);const t=kE(d.shape,c);d=zX({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),d}};const x$={kernelName:Mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.readSync(t.dataId))),c=a.map((t=>t.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=fq(l,c,u,s.shape,s.dtype,h,o.shape,i),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}};const k$={kernelName:Pw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=gq(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};const S$={kernelName:Bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i.map((t=>n.readSync(t.dataId))),p=i.map((t=>t.shape)),[f,g]=mq(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}},I$=t=>{const{backend:e,attrs:n}=t,{start:r,stop:a,step:s,dtype:o}=n,i=bq(r,a,s,o);return e.makeTensorInfo([i.length],o,i)},N$={kernelName:Ww,backendName:"webgl",kernelFunc:I$},E$=EX({opSnippet:"return 1.0 / x;"}),C$={kernelName:Vw,backendName:"webgl",kernelFunc:E$},T$=EX({opSnippet:Kq+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),A$={kernelName:Gw,backendName:"webgl",kernelFunc:T$},R$=EX({opSnippet:Kq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),F$={kernelName:Jw,backendName:"webgl",kernelFunc:R$};class _${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class D${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const O$={kernelName:qw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ty().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new D$(a.shape,l,c,s,o):new _$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],"float32")}};class z${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(a-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const L$={kernelName:Xw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new z$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class M${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class P${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const B$={kernelName:Hw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ty().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new P$(a.shape,l,c,s,o):new M$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],a.dtype)}};class W${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(l[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(l[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const U$={kernelName:Kw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new W$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class V${constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=t,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(t[0]," - coord - 1));\n        }\n      "));const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(r))).join(","),a=mK(n);this.userCode="\n      void main() {\n        ".concat(a," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}}class G${constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=t;const r=Pq("rc",n),a="".concat(r[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(r[n-2]," + 1 < ").concat(this.outputShape[n-2]),o=mK(n);function i(n){const r=t.map(((r,a)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - ").concat(r[n]," - 1"):"".concat(r[n])}(a,n))),a=r.join(","),s=r.slice(-2).join(",");return"getChannel(getX(".concat(a,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(t[0]," - rc - 1),\n            ").concat(t[0]," - rc - 1);\n          if(").concat(a,"){\n              result.g = getChannel(getX(").concat(t[0]," - (rc  + 1) - 1),\n                ").concat(t[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(o," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(t){return i(t)}(r.slice()),";\n          if(").concat(a,"){\n            result.g = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",i(t)}(r.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(t){return t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            if(").concat(a,") {\n              result.a = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const j$={kernelName:Yw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r,o=a.shape.length,i=ay(s,a.shape);if(0===o)return gX({inputs:{x:a},backend:n});const l=Ty().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G$(a.shape,i):new V$(a.shape,i);return n.runWebGLProgram(l,[a],a.dtype)}};class H${constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let a="";a="number"===typeof e?"float outputValue = ".concat(e.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(e.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(a,"\n          if(coordX >= 0 && coordX < ").concat(r," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const K$={kernelName:Wx,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=new H$(a.shape,o),[u,h]=DT(i,a.shape[1],a.shape[2]),d=[[u,h,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(c,[a],a.dtype,d)}},q$=EX({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),X$={kernelName:Zw,backendName:"webgl",kernelFunc:q$},J$=EX({opSnippet:"return inversesqrt(x);",cpuKernelImpl:yq}),Y$={kernelName:Qw,backendName:"webgl",kernelFunc:J$};class Z${constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=mK(a.length),l=mK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(t,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(e,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(g,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class Q${constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const i=mK(a.length),l=mK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides",m=e>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(t,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(e,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(g,";\n              if (j + 1 < ").concat(e,") {\n                flattenedIndex += index.yw * ").concat(m,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const $$={kernelName:$w,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=VT(0,a,o),d=[h/c,c];if(0===h)return n.makeTensorInfo(o,a.dtype);const p=zX({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),f=zX({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=Ty().getBool("WEBGL_PACK")?new Q$(l,i,p.shape.length,f.shape.length,u,d):new Z$(l,i,p.shape.length,f.shape.length,u,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),y=zX({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class t0{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const a="for (int i = 0; i < ".concat(Math.ceil(Math.log2(e+1)),"; ++i) { if (left >= right) break;"),s=2===Ty().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const e0={kernelName:ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=new t0(a.shape[0],a.shape[1],s.shape[1],o),l=[[a.shape[1]]];return n.runWebGLProgram(i,[a,s],"int32",l)}};class n0{constructor(t,e,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<e.length;r++)o.push("".concat(n[r])),r<t&&s.push("".concat(n[r]));r=s.join(),a=o.join()}const s=mK(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(a,"));\n        } else {\n          setOutput(getB(").concat(a,"));\n        }\n      }\n    ")}}const r0={kernelName:nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e,o=new n0(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],Hk(a.dtype,s.dtype))}},a0=EX({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(GT,";\n  float scale = ").concat(jT,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),s0={kernelName:rx,backendName:"webgl",kernelFunc:a0},o0=EX({opSnippet:NX+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:wq}),i0={kernelName:lx,backendName:"webgl",kernelFunc:o0},l0=EX({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),c0={kernelName:ix,backendName:"webgl",kernelFunc:l0},u0=EX({opSnippet:NX+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(pX,"\n  return result;\n")}),h0={kernelName:sx,backendName:"webgl",kernelFunc:u0},d0=EX({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),p0={kernelName:ox,backendName:"webgl",kernelFunc:d0},f0=EX({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),g0={kernelName:cx,backendName:"webgl",kernelFunc:f0},m0={kernelName:dx,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;Xb(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...o);for(let b=1+s.length;b<a.shape.length;++b)l.push([0,0]);const c=[],u=m$({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=OT(u.shape,s,i,!1),d=zT(h.length,s.length,!1),p=LT(u.shape,s,i,!1),f=zX({inputs:{x:u},backend:n,attrs:{shape:h}}),g=HX({inputs:{x:f},backend:n,attrs:{perm:d}}),m=zX({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(g),c.forEach((t=>n.disposeIntermediateTensorInfo(t))),m}};const b0={kernelName:gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,g]=Sq(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const y0={kernelName:mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=Iq(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};const v0={kernelName:bx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Nq(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const w0={kernelName:yx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Nq(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const x0={kernelName:vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=VT(0,a,i);if("string"===s.dtype){const t=n.bufferSync(a),e=n.bufferSync(s),r=yk(n.readSync(o.dataId)[0]),p=vq(t,e,i,d,u,c,l,h,r,false);return n.makeTensorInfo(i,p.dtype,p.values)}const p=new Z$(c,l,a.shape.length,s.shape.length,h,[d,1],false),f=n.runWebGLProgram(p,[s,a,o],s.dtype),g=zX({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),g}};const k0={kernelName:px,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=ay(o,a.shape)[0],l=gA(a,s,i),c=a.shape.length,u=new Array(c).fill(0),h=a.shape.slice();return l.map((t=>{const e=[...h];e[i]=t;const r=VJ({inputs:{x:a},backend:n,attrs:{begin:u,size:e}});return u[i]+=t,r}))}},S0="return sqrt(x);",I0=EX({opSnippet:S0,packedOpSnippet:S0,cpuKernelImpl:Eq}),N0={kernelName:ux,backendName:"webgl",kernelFunc:I0},E0={kernelName:xx,backendName:"webgl",kernelFunc:EX({opSnippet:"return x * x;"})},C0="return (a - b) * (a - b);",T0=CX({opSnippet:C0,packedOpSnippet:C0}),A0={kernelName:wx,backendName:"webgl",kernelFunc:T0};const R0={kernelName:kx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=FA(n.readSync(a.dataId)),o=Cq(s,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};const F0={kernelName:Px,backendName:"webgl",kernelFunc:function(t){let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,s=Kq+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),o=new Hq(a.shape,s);return r.runWebGLProgram(o,[a],a.dtype)}};class _0{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=mK(n.length),s=mK(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map(((e,r)=>(t++,1===n.length?"coords * strides[".concat(r,"] + begin[").concat(r,"]"):"coords[".concat(t-1,"] * strides[").concat(r,"] + begin[").concat(r,"]")))).join(",")}this.userCode="\n      ".concat(a," begin = ").concat(a,"(").concat(t,");\n      ").concat(a," strides = ").concat(a,"(").concat(e,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(o,"));\n      }\n    ")}}const D0={kernelName:Sx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=fN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=zX({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Xb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=eN(y,v,w),e=VJ({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=zX({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{if(n.shouldExecuteOnCPU([a])){const t=n.readSync(a.dataId),e=cI(a.shape,a.dtype,t),r=Tq(p,e,w,y);x=n.makeTensorInfo(f,a.dtype,r.values)}else{const t=new _0(y,w,p);x=n.runWebGLProgram(t,[a],a.dtype)}}const k=zX({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),k}};const O0={kernelName:Ix,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,g]=Aq(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};const z0={kernelName:Nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,h]=Rq(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const L0={kernelName:Ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=Fq(o,a);return n.makeTensorInfo(s.shape,"int32",i)}},M0=EX({opSnippet:"return tan(x);"}),P0={kernelName:Tx,backendName:"webgl",kernelFunc:M0},B0=EX({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),W0={kernelName:Ax,backendName:"webgl",kernelFunc:B0};const U0={kernelName:tx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:a,indices:s,updates:o}=e,{}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=VT(0,s,a.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,s.dtype);const p=zX({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),f=zX({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=zX({inputs:{x:a},backend:n,attrs:{shape:d}}),m=new Z$(l,i,p.shape.length,f.shape.length,u,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),y=zX({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class V0{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;const r=mK(this.rank),a=function(t){const e=t.length;if(e>5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"imod(resRC, ".concat(t[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<t.length;a++)r.push("imod(".concat(n[a],", ").concat(t[a],")"));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(a,"));\n      }\n    ")}}function G0(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const t=n.readSync(a.dataId),e="string"===a.dtype?t.map((t=>yk(t))):t,r=cI(a.shape,a.dtype,e),o=Dq(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new V0(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}const j0={kernelName:Rx,backendName:"webgl",kernelFunc:G0};class H0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class K0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function q0(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function X0(t){let e=1;for(;e<t;)e*=2;return e}const J0={kernelName:Fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r,i=Ty().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ty().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([a])||u<i||s>l){const t=n.readSync(a.dataId),[e,r]=Oq(t,c,a.dtype,s,o);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[a,CZ({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(a.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(a):a,f=Zb(c)/u,g=zX({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&q0(n,p);const m=X0(s),b=X0(u);let y=null;const v=()=>null===y?[g,g]:[g,y],w=(t,e,r)=>{const a=v(),s=new H0(r),o=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],i=y;y=n.runWebGLProgram(s,a,"int32",o),q0(n,i)};for(let N=1;N<m;N*=2){const t=2*N;for(let e=N;e>=1;e/=2)w(t,e,[f,b])}for(let N=b;N>m;N/=2){const t=v(),e=new K0([f,N/2]),r=[[u],[null===y?1:0],[m]],a=y;y=n.runWebGLProgram(e,t,"int32",r),q0(n,a);const s=m/2,o=2*s;for(let n=s;n>=1;n/=2)w(o,n,y.shape)}let x=y;y=VJ({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),q0(n,x);let k=KZ({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});q0(n,g);const S=c.slice(0,-1);S.push(s),x=y,y=zX({inputs:{x:y},attrs:{shape:S},backend:n}),q0(n,x);const I=k;return k=zX({inputs:{x:k},attrs:{shape:S},backend:n}),q0(n,I),[k,y]}};class Y0{constructor(t,e,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(t," && 0 <= coordX && coordX < ").concat(e,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(a,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(a,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(e,"));\n                float mapY = mapCoord(inY, float(").concat(t,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const Z0={kernelName:_x,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=r,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=new Y0(h,d,o,i,l,[u,f,g,p]);return n.runWebGLProgram(m,[a,s],"float32")}};const Q0={kernelName:Ox,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;QH(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:l,indices:c}=Lq(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const $0={kernelName:zx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,l=a.shape[s],c=new Array(i-1);let u=0;for(let g=0;g<i;g++)g!==s&&(c[u++]=o.shape[g]);const h=[],d=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[s]=g;const t=VJ({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),e=zX({inputs:{x:t},backend:n,attrs:{shape:c}});f[g]=e,h.push(t)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};class t1{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,a=t.inSize,s=t.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";a%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      "));let h="";a%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(c,"\n        } else if (").concat(2===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(c,"\n        } else if (").concat(3===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(c,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const e1={kernelName:Lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r,i=a.shape.length,l=[];let c=0;const u=IE([c],i);let h=a;null!=u&&(h=HX({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(h),c=EE(1,i)[0]);const d=AA(h.shape,c,o),p=Zb([h.shape[c]]),f=zX({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=Kk(a.dtype),m=(t,e,r,a,s)=>{const o=t.shape[0],i=t.shape[1],c=TA(i,s),u=new t1({windowSize:c,inSize:i,batchSize:o,numSegments:s},e),h=n.compileAndRun(u,[t,r],a);if(l.push(h),h.shape[1]===s)return h;const d=I$({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=G0({inputs:{x:d},backend:n,attrs:{reps:[i/c]}});l.push(d),l.push(p);return m(h,e,p,a,s)},b=zX({inputs:{x:m(f,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:d}});let y=b;if(null!=u){l.push(b);const t=NE(u);y=HX({inputs:{x:y},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}},n1=[JX,ZX,$X,eJ,aJ,iJ,lJ,cJ,gJ,mJ,yJ,wJ,kJ,IJ,EJ,AJ,RJ,DJ,OJ,zJ,PJ,jJ,HJ,KJ,qJ,$J,nY,sY,yX,lY,mY,IY,AY,FY,_Y,DY,OY,LY,PY,WY,KY,qY,XY,YY,$Y,nZ,rZ,sZ,iZ,lZ,uZ,hZ,pZ,gZ,bZ,vZ,kZ,NZ,TZ,RZ,DZ,zZ,PZ,UZ,VZ,jZ,qZ,JZ,ZZ,mX,QZ,pY,tQ,nQ,aQ,xX,oQ,lQ,cQ,hQ,pQ,gQ,bQ,vQ,kQ,IQ,EQ,TQ,AQ,RQ,DQ,OQ,zQ,LQ,MQ,BQ,VQ,jQ,$Q,OX,e$,r$,s$,i$,JJ,c$,d$,p$,b$,v$,IX,w$,x$,k$,S$,N$,ZJ,qQ,C$,A$,F$,LX,O$,L$,B$,U$,j$,K$,X$,Y$,$$,e0,r0,s0,i0,c0,h0,p0,GJ,QQ,g0,m0,b0,y0,v0,w0,x0,k0,N0,E0,A0,R0,F0,D0,O0,z0,L0,YQ,jX,P0,W0,U0,j0,J0,Z0,KX,Q0,$0,e1,h$];for(const n of n1)Zx(n);const r1=function(){const[t,e]=(0,o.useState)(null),[n,r]=(0,o.useState)(null),[a,s]=(0,o.useState)(null),i=window.innerWidth;new Vz(l);var l,c=360;i>=360&&(c=720),i>720&&(c=1280);var u=.55*c,h=c/2,d=(u+240)/2;const p=Math.floor(201*Math.random())-100,f=Math.floor(201*Math.random())-100,[g,m]=(0,o.useState)(!1),[b,y]=(0,o.useState)(h),[v,w]=(0,o.useState)(d);function x(t){return t.map(((t,e)=>[t,e])).reduce(((t,e)=>e[0]>t[0]?e:t))[1]}(0,o.useEffect)((()=>{k();const t=setInterval((()=>{g&&(b>=0&&b<=c&&v>=240&&v<=u?(y(b+p),w(v+f)):(y(h),w(d)))}),1e3);return()=>clearInterval(t)}),[b,v,g]);const k=async()=>{const t=function(t,e,n,r){if(re(null==n&&null==r||null!=n&&null!=r,(function(){return"customModelURL and customMetadataURL must be both provided or both not provided."})),null!=n&&re(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided."})),"BROWSER_FFT"===t)return new Pb(e,n,r);throw"SOFT_FFT"===t?new Error("SOFT_FFT SpeechCommandRecognizer has not been implemented yet."):new Error("Invalid fftType: '"+t+"'")}("BROWSER_FFT",void 0);console.log("Model Loaded"),await t.ensureModelLoaded(),console.log(t.wordLabels()),s(t.wordLabels()),e(t)},S=async()=>{console.log("listening. . . .. "),t.listen((t=>{console.log(a[x(Object.values(t.scores))]),"go"==a[x(Object.values(t.scores))]?(m(!0),console.log("----------------GO---------------------------"),console.log(n)):"stop"==a[x(Object.values(t.scores))]&&(m(!1),console.log("----------------STOP---------------------------"),console.log(n))}),{includeSpectrogram:!0,probabilityThreshold:.75})};return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsx)("div",{className:"img-container",children:(0,Ht.jsx)("img",{src:"/supercircle/images/white-bear-img.png",alt:"white-bear",className:"img-component",style:{position:"absolute",left:"".concat(b,"px"),top:"".concat(v,"px")}})}),(0,Ht.jsxs)("div",{className:"btn-container",children:[(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STARTED. . ."),S()},children:"Start Listening"})}),(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STOPPED"),t.stopListening()},children:"Stop Listening"})})]})]})};const a1=function(){return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsxs)("div",{style:{"text-align":"center"},children:[(0,Ht.jsx)("h1",{children:"Press the start button to start"}),(0,Ht.jsx)("h2",{children:'Control the bear by saying "GO" and "STOP"'})]}),(0,Ht.jsx)(r1,{})]})};const s1=function(){return(0,Ht.jsx)("div",{className:"App",children:(0,Ht.jsxs)(Nt,{children:[(0,Ht.jsx)(Kt,{}),(0,Ht.jsxs)(vt,{children:[(0,Ht.jsx)(bt,{path:"/supercircle",exact:!0,element:(0,Ht.jsx)(Qt,{})}),(0,Ht.jsx)(bt,{path:"/",exact:!0,element:(0,Ht.jsx)(Qt,{})}),(0,Ht.jsx)(bt,{path:"/projects",exact:!0,element:(0,Ht.jsx)(a1,{})}),(0,Ht.jsx)(bt,{path:"/contact",exact:!0,element:(0,Ht.jsx)(Jt,{})})]})]})})};l.createRoot(document.getElementById("root")).render((0,Ht.jsx)(o.StrictMode,{children:(0,Ht.jsx)(s1,{})}))})()})();
//# sourceMappingURL=main.05eba9bf.js.map