/*! For license information please see main.1aa86f55.js.LICENSE.txt */
(()=>{var t={2028:(t,e,n)=>{"use strict";var r=n(2),a=n(1712),s=a(r("String.prototype.indexOf"));t.exports=function(t,e){var n=r(t,!!e);return"function"===typeof n&&s(t,".prototype.")>-1?a(n):n}},1712:(t,e,n)=>{"use strict";var r=n(3864),a=n(2),s=n(5438),o=n(4902),i=a("%Function.prototype.apply%"),l=a("%Function.prototype.call%"),c=a("%Reflect.apply%",!0)||r.call(l,i),u=n(2090),h=a("%Math.max%");t.exports=function(t){if("function"!==typeof t)throw new o("a function is required");var e=c(r,l,arguments);return s(e,1+h(0,t.length-(arguments.length-1)),!0)};var d=function(){return c(r,i,arguments)};u?u(t.exports,"apply",{value:d}):t.exports.apply=d},4992:(t,e,n)=>{"use strict";var r=n(2090),a=n(2557),s=n(4902),o=n(5558);t.exports=function(t,e,n){if(!t||"object"!==typeof t&&"function"!==typeof t)throw new s("`obj` must be an object or a function`");if("string"!==typeof e&&"symbol"!==typeof e)throw new s("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!==typeof arguments[3]&&null!==arguments[3])throw new s("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!==typeof arguments[4]&&null!==arguments[4])throw new s("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!==typeof arguments[5]&&null!==arguments[5])throw new s("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!==typeof arguments[6])throw new s("`loose`, if provided, must be a boolean");var i=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,u=arguments.length>6&&arguments[6],h=!!o&&o(t,e);if(r)r(t,e,{configurable:null===c&&h?h.configurable:!c,enumerable:null===i&&h?h.enumerable:!i,value:n,writable:null===l&&h?h.writable:!l});else{if(!u&&(i||l||c))throw new a("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");t[e]=n}}},2090:(t,e,n)=>{"use strict";var r=n(2)("%Object.defineProperty%",!0)||!1;if(r)try{r({},"a",{value:1})}catch(a){r=!1}t.exports=r},9820:t=>{"use strict";t.exports=EvalError},9304:t=>{"use strict";t.exports=Error},1725:t=>{"use strict";t.exports=RangeError},5077:t=>{"use strict";t.exports=ReferenceError},2557:t=>{"use strict";t.exports=SyntaxError},4902:t=>{"use strict";t.exports=TypeError},3094:t=>{"use strict";t.exports=URIError},1903:(t,e,n)=>{"use strict";var r=n(8799),a=Object.prototype.toString,s=Object.prototype.hasOwnProperty;t.exports=function(t,e,n){if(!r(e))throw new TypeError("iterator must be a function");var o;arguments.length>=3&&(o=n),"[object Array]"===a.call(t)?function(t,e,n){for(var r=0,a=t.length;r<a;r++)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o):"string"===typeof t?function(t,e,n){for(var r=0,a=t.length;r<a;r++)null==n?e(t.charAt(r),r,t):e.call(n,t.charAt(r),r,t)}(t,e,o):function(t,e,n){for(var r in t)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o)}},7724:t=>{"use strict";var e=Object.prototype.toString,n=Math.max,r=function(t,e){for(var n=[],r=0;r<t.length;r+=1)n[r]=t[r];for(var a=0;a<e.length;a+=1)n[a+t.length]=e[a];return n};t.exports=function(t){var a=this;if("function"!==typeof a||"[object Function]"!==e.apply(a))throw new TypeError("Function.prototype.bind called on incompatible "+a);for(var s,o=function(t,e){for(var n=[],r=e||0,a=0;r<t.length;r+=1,a+=1)n[a]=t[r];return n}(arguments,1),i=n(0,a.length-o.length),l=[],c=0;c<i;c++)l[c]="$"+c;if(s=Function("binder","return function ("+function(t,e){for(var n="",r=0;r<t.length;r+=1)n+=t[r],r+1<t.length&&(n+=e);return n}(l,",")+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof s){var e=a.apply(this,r(o,arguments));return Object(e)===e?e:this}return a.apply(t,r(o,arguments))})),a.prototype){var u=function(){};u.prototype=a.prototype,s.prototype=new u,u.prototype=null}return s}},3864:(t,e,n)=>{"use strict";var r=n(7724);t.exports=Function.prototype.bind||r},2:(t,e,n)=>{"use strict";var r,a=n(9304),s=n(9820),o=n(1725),i=n(5077),l=n(2557),c=n(4902),u=n(3094),h=Function,d=function(t){try{return h('"use strict"; return ('+t+").constructor;")()}catch(e){}},p=Object.getOwnPropertyDescriptor;if(p)try{p({},"")}catch(z){p=null}var f=function(){throw new c},g=p?function(){try{return f}catch(t){try{return p(arguments,"callee").get}catch(e){return f}}}():f,m=n(2108)(),b=n(951)(),y=Object.getPrototypeOf||(b?function(t){return t.__proto__}:null),v={},w="undefined"!==typeof Uint8Array&&y?y(Uint8Array):r,x={__proto__:null,"%AggregateError%":"undefined"===typeof AggregateError?r:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"===typeof ArrayBuffer?r:ArrayBuffer,"%ArrayIteratorPrototype%":m&&y?y([][Symbol.iterator]()):r,"%AsyncFromSyncIteratorPrototype%":r,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"===typeof Atomics?r:Atomics,"%BigInt%":"undefined"===typeof BigInt?r:BigInt,"%BigInt64Array%":"undefined"===typeof BigInt64Array?r:BigInt64Array,"%BigUint64Array%":"undefined"===typeof BigUint64Array?r:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"===typeof DataView?r:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":a,"%eval%":eval,"%EvalError%":s,"%Float32Array%":"undefined"===typeof Float32Array?r:Float32Array,"%Float64Array%":"undefined"===typeof Float64Array?r:Float64Array,"%FinalizationRegistry%":"undefined"===typeof FinalizationRegistry?r:FinalizationRegistry,"%Function%":h,"%GeneratorFunction%":v,"%Int8Array%":"undefined"===typeof Int8Array?r:Int8Array,"%Int16Array%":"undefined"===typeof Int16Array?r:Int16Array,"%Int32Array%":"undefined"===typeof Int32Array?r:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":m&&y?y(y([][Symbol.iterator]())):r,"%JSON%":"object"===typeof JSON?JSON:r,"%Map%":"undefined"===typeof Map?r:Map,"%MapIteratorPrototype%":"undefined"!==typeof Map&&m&&y?y((new Map)[Symbol.iterator]()):r,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"===typeof Promise?r:Promise,"%Proxy%":"undefined"===typeof Proxy?r:Proxy,"%RangeError%":o,"%ReferenceError%":i,"%Reflect%":"undefined"===typeof Reflect?r:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"===typeof Set?r:Set,"%SetIteratorPrototype%":"undefined"!==typeof Set&&m&&y?y((new Set)[Symbol.iterator]()):r,"%SharedArrayBuffer%":"undefined"===typeof SharedArrayBuffer?r:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":m&&y?y(""[Symbol.iterator]()):r,"%Symbol%":m?Symbol:r,"%SyntaxError%":l,"%ThrowTypeError%":g,"%TypedArray%":w,"%TypeError%":c,"%Uint8Array%":"undefined"===typeof Uint8Array?r:Uint8Array,"%Uint8ClampedArray%":"undefined"===typeof Uint8ClampedArray?r:Uint8ClampedArray,"%Uint16Array%":"undefined"===typeof Uint16Array?r:Uint16Array,"%Uint32Array%":"undefined"===typeof Uint32Array?r:Uint32Array,"%URIError%":u,"%WeakMap%":"undefined"===typeof WeakMap?r:WeakMap,"%WeakRef%":"undefined"===typeof WeakRef?r:WeakRef,"%WeakSet%":"undefined"===typeof WeakSet?r:WeakSet};if(y)try{null.error}catch(z){var k=y(y(z));x["%Error.prototype%"]=k}var S=function t(e){var n;if("%AsyncFunction%"===e)n=d("async function () {}");else if("%GeneratorFunction%"===e)n=d("function* () {}");else if("%AsyncGeneratorFunction%"===e)n=d("async function* () {}");else if("%AsyncGenerator%"===e){var r=t("%AsyncGeneratorFunction%");r&&(n=r.prototype)}else if("%AsyncIteratorPrototype%"===e){var a=t("%AsyncGenerator%");a&&y&&(n=y(a.prototype))}return x[e]=n,n},I={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},N=n(3864),E=n(4384),C=N.call(Function.call,Array.prototype.concat),T=N.call(Function.apply,Array.prototype.splice),A=N.call(Function.call,String.prototype.replace),R=N.call(Function.call,String.prototype.slice),F=N.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,D=/\\(\\)?/g,O=function(t,e){var n,r=t;if(E(I,r)&&(r="%"+(n=I[r])[0]+"%"),E(x,r)){var a=x[r];if(a===v&&(a=S(r)),"undefined"===typeof a&&!e)throw new c("intrinsic "+t+" exists, but is not available. Please file an issue!");return{alias:n,name:r,value:a}}throw new l("intrinsic "+t+" does not exist!")};t.exports=function(t,e){if("string"!==typeof t||0===t.length)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!==typeof e)throw new c('"allowMissing" argument must be a boolean');if(null===F(/^%?[^%]*%?$/,t))throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var n=function(t){var e=R(t,0,1),n=R(t,-1);if("%"===e&&"%"!==n)throw new l("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==e)throw new l("invalid intrinsic syntax, expected opening `%`");var r=[];return A(t,_,(function(t,e,n,a){r[r.length]=n?A(a,D,"$1"):e||t})),r}(t),r=n.length>0?n[0]:"",a=O("%"+r+"%",e),s=a.name,o=a.value,i=!1,u=a.alias;u&&(r=u[0],T(n,C([0,1],u)));for(var h=1,d=!0;h<n.length;h+=1){var f=n[h],g=R(f,0,1),m=R(f,-1);if(('"'===g||"'"===g||"`"===g||'"'===m||"'"===m||"`"===m)&&g!==m)throw new l("property names with quotes must have matching quotes");if("constructor"!==f&&d||(i=!0),E(x,s="%"+(r+="."+f)+"%"))o=x[s];else if(null!=o){if(!(f in o)){if(!e)throw new c("base intrinsic for "+t+" exists, but the property is not available.");return}if(p&&h+1>=n.length){var b=p(o,f);o=(d=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:o[f]}else d=E(o,f),o=o[f];d&&!i&&(x[s]=o)}}return o}},5558:(t,e,n)=>{"use strict";var r=n(2)("%Object.getOwnPropertyDescriptor%",!0);if(r)try{r([],"length")}catch(a){r=null}t.exports=r},2101:(t,e,n)=>{"use strict";var r=n(2090),a=function(){return!!r};a.hasArrayLengthDefineBug=function(){if(!r)return null;try{return 1!==r([],"length",{value:1}).length}catch(t){return!0}},t.exports=a},951:t=>{"use strict";var e={__proto__:null,foo:{}},n=Object;t.exports=function(){return{__proto__:e}.foo===e.foo&&!(e instanceof n)}},2108:(t,e,n)=>{"use strict";var r="undefined"!==typeof Symbol&&Symbol,a=n(9534);t.exports=function(){return"function"===typeof r&&("function"===typeof Symbol&&("symbol"===typeof r("foo")&&("symbol"===typeof Symbol("bar")&&a())))}},9534:t=>{"use strict";t.exports=function(){if("function"!==typeof Symbol||"function"!==typeof Object.getOwnPropertySymbols)return!1;if("symbol"===typeof Symbol.iterator)return!0;var t={},e=Symbol("test"),n=Object(e);if("string"===typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(e in t[e]=42,t)return!1;if("function"===typeof Object.keys&&0!==Object.keys(t).length)return!1;if("function"===typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(t).length)return!1;var r=Object.getOwnPropertySymbols(t);if(1!==r.length||r[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(t,e))return!1;if("function"===typeof Object.getOwnPropertyDescriptor){var a=Object.getOwnPropertyDescriptor(t,e);if(42!==a.value||!0!==a.enumerable)return!1}return!0}},4635:(t,e,n)=>{"use strict";var r=n(9534);t.exports=function(){return r()&&!!Symbol.toStringTag}},4384:(t,e,n)=>{"use strict";var r=Function.prototype.call,a=Object.prototype.hasOwnProperty,s=n(3864);t.exports=s.call(r,a)},6329:t=>{"function"===typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}}},8317:(t,e,n)=>{"use strict";var r=n(4635)(),a=n(2028)("Object.prototype.toString"),s=function(t){return!(r&&t&&"object"===typeof t&&Symbol.toStringTag in t)&&"[object Arguments]"===a(t)},o=function(t){return!!s(t)||null!==t&&"object"===typeof t&&"number"===typeof t.length&&t.length>=0&&"[object Array]"!==a(t)&&"[object Function]"===a(t.callee)},i=function(){return s(arguments)}();s.isLegacyArguments=o,t.exports=i?s:o},8799:t=>{"use strict";var e,n,r=Function.prototype.toString,a="object"===typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"===typeof a&&"function"===typeof Object.defineProperty)try{e=Object.defineProperty({},"length",{get:function(){throw n}}),n={},a((function(){throw 42}),null,e)}catch(p){p!==n&&(a=null)}else a=null;var s=/^\s*class\b/,o=function(t){try{var e=r.call(t);return s.test(e)}catch(n){return!1}},i=function(t){try{return!o(t)&&(r.call(t),!0)}catch(e){return!1}},l=Object.prototype.toString,c="function"===typeof Symbol&&!!Symbol.toStringTag,u=!(0 in[,]),h=function(){return!1};if("object"===typeof document){var d=document.all;l.call(d)===l.call(document.all)&&(h=function(t){if((u||!t)&&("undefined"===typeof t||"object"===typeof t))try{var e=l.call(t);return("[object HTMLAllCollection]"===e||"[object HTML document.all class]"===e||"[object HTMLCollection]"===e||"[object Object]"===e)&&null==t("")}catch(n){}return!1})}t.exports=a?function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;try{a(t,null,e)}catch(r){if(r!==n)return!1}return!o(t)&&i(t)}:function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;if(c)return i(t);if(o(t))return!1;var e=l.call(t);return!("[object Function]"!==e&&"[object GeneratorFunction]"!==e&&!/^\[object HTML/.test(e))&&i(t)}},1583:(t,e,n)=>{"use strict";var r,a=Object.prototype.toString,s=Function.prototype.toString,o=/^\s*(?:function)?\*/,i=n(4635)(),l=Object.getPrototypeOf;t.exports=function(t){if("function"!==typeof t)return!1;if(o.test(s.call(t)))return!0;if(!i)return"[object GeneratorFunction]"===a.call(t);if(!l)return!1;if("undefined"===typeof r){var e=function(){if(!i)return!1;try{return Function("return function*() {}")()}catch(t){}}();r=!!e&&l(e)}return l(t)===r}},9849:(t,e,n)=>{"use strict";var r=n(8004);t.exports=function(t){return!!r(t)}},7353:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function o(t,e){var n,r,o;return e?(o=0<=(t>>>=0)&&t<256)&&(r=s[t])?r:(n=l(t,(0|t)<0?-1:0,!0),o&&(s[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(r=a[t])?r:(n=l(t,t<0?-1:0,!1),o&&(a[t]=n),n)}function i(t,e){if(isNaN(t))return e?b:m;if(e){if(t<0)return b;if(t>=p)return k}else{if(t<=-f)return S;if(t+1>=f)return x}return t<0?i(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=o,n.fromNumber=i,n.fromBits=l;var c=Math.pow;function u(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return m;if("number"===typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(t.substring(1),e,n).neg();for(var a=i(c(n,8)),s=m,o=0;o<t.length;o+=8){var l=Math.min(8,t.length-o),h=parseInt(t.substring(o,o+l),n);if(l<8){var d=i(c(n,l));s=s.mul(d).add(i(h))}else s=(s=s.mul(a)).add(i(h))}return s.unsigned=e,s}function h(t,e){return"number"===typeof t?i(t,e):"string"===typeof t?u(t,e):l(t.low,t.high,"boolean"===typeof e?e:t.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=o(1<<24),m=o(0);n.ZERO=m;var b=o(0,!0);n.UZERO=b;var y=o(1);n.ONE=y;var v=o(1,!0);n.UONE=v;var w=o(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var e=i(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var a=i(c(t,6),this.unsigned),s=this,o="";;){var l=s.div(a),u=(s.sub(l.mul(a)).toInt()>>>0).toString(t);if((s=l).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!==1||t.high>>>31!==1)&&(this.high===t.high&&this.low===t.low)},I.eq=I.equals,I.notEquals=function(t){return!this.eq(t)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(t){return this.comp(t)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(t){return this.comp(t)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(t){return this.comp(t)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(t){return this.comp(t)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(y)},I.neg=I.negate,I.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,c=t.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&t.low))>>>16,d+=(p+=a+c)>>>16,u+=(d+=n+i)>>>16,u+=e+o,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},I.sub=I.subtract,I.multiply=function(t){if(this.isZero())return m;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return m;if(this.eq(S))return t.isOdd()?S:m;if(t.eq(S))return this.isOdd()?S:m;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return i(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,c=t.high>>>16,u=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,b=0,y=0,v=0;return y+=(v+=o*p)>>>16,b+=(y+=s*p)>>>16,y&=65535,b+=(y+=o*d)>>>16,f+=(b+=a*p)>>>16,b&=65535,f+=(b+=s*d)>>>16,b&=65535,f+=(b+=o*u)>>>16,f+=n*p+a*d+s*u+o*c,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,a,s;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return b;if(t.gt(this.shru(1)))return v;s=b}else{if(this.eq(S))return t.eq(y)||t.eq(w)?S:t.eq(S)?y:(n=this.shr(1).div(t).shl(1)).eq(m)?t.isNegative()?y:w:(a=this.sub(t.mul(n)),s=n.add(a.div(t)));if(t.eq(S))return this.unsigned?b:m;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=m}for(a=this;a.gte(t);){n=Math.max(1,Math.floor(a.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),u=o<=48?1:c(2,o-48),d=i(n),p=d.mul(t);p.isNegative()||p.gt(a);)p=(d=i(n-=u,this.unsigned)).mul(t);d.isZero()&&(d=y),s=s.add(d),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},I.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},I.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},I.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0===(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},I.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},7163:t=>{"use strict";t.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},2730:(t,e,n)=>{"use strict";var r=n(5043),a=n(8853);function s(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=new Set,i={};function l(t,e){c(t,e),c(t+"Capture",e)}function c(t,e){for(i[t]=e,t=0;t<e.length;t++)o.add(e[t])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function g(t,e,n,r,a,s,o){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t){m[t]=new g(t,0,!1,t,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(t){var e=t[0];m[e]=new g(e,1,!1,t[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(t){m[t]=new g(t,2,!1,t.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(t){m[t]=new g(t,2,!1,t,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t){m[t]=new g(t,3,!1,t.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(t){m[t]=new g(t,3,!0,t,null,!1,!1)})),["capture","download"].forEach((function(t){m[t]=new g(t,4,!1,t,null,!1,!1)})),["cols","rows","size","span"].forEach((function(t){m[t]=new g(t,6,!1,t,null,!1,!1)})),["rowSpan","start"].forEach((function(t){m[t]=new g(t,5,!1,t.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(t){return t[1].toUpperCase()}function v(t,e,n,r){var a=m.hasOwnProperty(e)?m[e]:null;(null!==a?0!==a.type:r||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(t,e,n,r){if(null===e||"undefined"===typeof e||function(t,e,n,r){if(null!==n&&0===n.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(t=t.toLowerCase().slice(0,5))&&"aria-"!==t);default:return!1}}(t,e,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,n,a,r)&&(n=null),r||null===a?function(t){return!!h.call(f,t)||!h.call(p,t)&&(d.test(t)?f[t]=!0:(p[t]=!0,!1))}(e)&&(null===n?t.removeAttribute(e):t.setAttribute(e,""+n)):a.mustUseProperty?t[a.propertyName]=null===n?3!==a.type&&"":n:(e=a.attributeName,r=a.attributeNamespace,null===n?t.removeAttribute(e):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!1,!1)})),m.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!0,!0)}));var w=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),E=Symbol.for("react.provider"),C=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),_=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function z(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=O&&t[O]||t["@@iterator"])?t:null}var L,M=Object.assign;function P(t){if(void 0===L)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);L=e&&e[1]||""}return"\n"+L+t}var B=!1;function W(t,e){if(!t||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var r=c}Reflect.construct(t,[],e)}else{try{e.call()}catch(c){r=c}t.call(e.prototype)}else{try{throw Error()}catch(c){r=c}t()}}catch(c){if(c&&r&&"string"===typeof c.stack){for(var a=c.stack.split("\n"),s=r.stack.split("\n"),o=a.length-1,i=s.length-1;1<=o&&0<=i&&a[o]!==s[i];)i--;for(;1<=o&&0<=i;o--,i--)if(a[o]!==s[i]){if(1!==o||1!==i)do{if(o--,0>--i||a[o]!==s[i]){var l="\n"+a[o].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}}while(1<=o&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?P(t):""}function U(t){switch(t.tag){case 5:return P(t.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return t=W(t.type,!1);case 11:return t=W(t.type.render,!1);case 1:return t=W(t.type,!0);default:return""}}function V(t){if(null==t)return null;if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t;switch(t){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case A:return"Suspense";case R:return"SuspenseList"}if("object"===typeof t)switch(t.$$typeof){case C:return(t.displayName||"Context")+".Consumer";case E:return(t._context.displayName||"Context")+".Provider";case T:var e=t.render;return(t=t.displayName)||(t=""!==(t=e.displayName||e.name||"")?"ForwardRef("+t+")":"ForwardRef"),t;case F:return null!==(e=t.displayName||null)?e:V(t.type)||"Memo";case _:e=t._payload,t=t._init;try{return V(t(e))}catch(n){}}return null}function j(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=(t=e.render).displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(e);case 8:return e===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function G(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":case"object":return t;default:return""}}function H(t){var e=t.type;return(t=t.nodeName)&&"input"===t.toLowerCase()&&("checkbox"===e||"radio"===e)}function K(t){t._valueTracker||(t._valueTracker=function(t){var e=H(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return a.call(this)},set:function(t){r=""+t,s.call(this,t)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(t){r=""+t},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}(t))}function q(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=H(t)?t.checked?"true":"false":t.value),(t=r)!==n&&(e.setValue(t),!0)}function X(t){if("undefined"===typeof(t=t||("undefined"!==typeof document?document:void 0)))return null;try{return t.activeElement||t.body}catch(e){return t.body}}function J(t,e){var n=e.checked;return M({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:t._wrapperState.initialChecked})}function Y(t,e){var n=null==e.defaultValue?"":e.defaultValue,r=null!=e.checked?e.checked:e.defaultChecked;n=G(null!=e.value?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function Z(t,e){null!=(e=e.checked)&&v(t,"checked",e,!1)}function Q(t,e){Z(t,e);var n=G(e.value),r=e.type;if(null!=n)"number"===r?(0===n&&""===t.value||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if("submit"===r||"reset"===r)return void t.removeAttribute("value");e.hasOwnProperty("value")?tt(t,e.type,n):e.hasOwnProperty("defaultValue")&&tt(t,e.type,G(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(t.defaultChecked=!!e.defaultChecked)}function $(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!("submit"!==r&&"reset"!==r||void 0!==e.value&&null!==e.value))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}""!==(n=t.name)&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,""!==n&&(t.name=n)}function tt(t,e,n){"number"===e&&X(t.ownerDocument)===t||(null==n?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var et=Array.isArray;function nt(t,e,n,r){if(t=t.options,e){e={};for(var a=0;a<n.length;a++)e["$"+n[a]]=!0;for(n=0;n<t.length;n++)a=e.hasOwnProperty("$"+t[n].value),t[n].selected!==a&&(t[n].selected=a),a&&r&&(t[n].defaultSelected=!0)}else{for(n=""+G(n),e=null,a=0;a<t.length;a++){if(t[a].value===n)return t[a].selected=!0,void(r&&(t[a].defaultSelected=!0));null!==e||t[a].disabled||(e=t[a])}null!==e&&(e.selected=!0)}}function rt(t,e){if(null!=e.dangerouslySetInnerHTML)throw Error(s(91));return M({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function at(t,e){var n=e.value;if(null==n){if(n=e.children,e=e.defaultValue,null!=n){if(null!=e)throw Error(s(92));if(et(n)){if(1<n.length)throw Error(s(93));n=n[0]}e=n}null==e&&(e=""),n=e}t._wrapperState={initialValue:G(n)}}function st(t,e){var n=G(e.value),r=G(e.defaultValue);null!=n&&((n=""+n)!==t.value&&(t.value=n),null==e.defaultValue&&t.defaultValue!==n&&(t.defaultValue=n)),null!=r&&(t.defaultValue=""+r)}function ot(t){var e=t.textContent;e===t._wrapperState.initialValue&&""!==e&&null!==e&&(t.value=e)}function it(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lt(t,e){return null==t||"http://www.w3.org/1999/xhtml"===t?it(e):"http://www.w3.org/2000/svg"===t&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":t}var ct,ut,ht=(ut=function(t,e){if("http://www.w3.org/2000/svg"!==t.namespaceURI||"innerHTML"in t)t.innerHTML=e;else{for((ct=ct||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ct.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(t,e,n,r){MSApp.execUnsafeLocalFunction((function(){return ut(t,e)}))}:ut);function dt(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&3===n.nodeType)return void(n.nodeValue=e)}t.textContent=e}var pt={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ft=["Webkit","ms","Moz","O"];function gt(t,e,n){return null==e||"boolean"===typeof e||""===e?"":n||"number"!==typeof e||0===e||pt.hasOwnProperty(t)&&pt[t]?(""+e).trim():e+"px"}function mt(t,e){for(var n in t=t.style,e)if(e.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=gt(n,e[n],r);"float"===n&&(n="cssFloat"),r?t.setProperty(n,a):t[n]=a}}Object.keys(pt).forEach((function(t){ft.forEach((function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),pt[e]=pt[t]}))}));var bt=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function yt(t,e){if(e){if(bt[t]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(s(137,t));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(s(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(s(62))}}function vt(t,e){if(-1===t.indexOf("-"))return"string"===typeof e.is;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wt=null;function xt(t){return(t=t.target||t.srcElement||window).correspondingUseElement&&(t=t.correspondingUseElement),3===t.nodeType?t.parentNode:t}var kt=null,St=null,It=null;function Nt(t){if(t=va(t)){if("function"!==typeof kt)throw Error(s(280));var e=t.stateNode;e&&(e=xa(e),kt(t.stateNode,t.type,e))}}function Et(t){St?It?It.push(t):It=[t]:St=t}function Ct(){if(St){var t=St,e=It;if(It=St=null,Nt(t),e)for(t=0;t<e.length;t++)Nt(e[t])}}function Tt(t,e){return t(e)}function At(){}var Rt=!1;function Ft(t,e,n){if(Rt)return t(e,n);Rt=!0;try{return Tt(t,e,n)}finally{Rt=!1,(null!==St||null!==It)&&(At(),Ct())}}function _t(t,e){var n=t.stateNode;if(null===n)return null;var r=xa(n);if(null===r)return null;n=r[e];t:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(t=t.type)||"input"===t||"select"===t||"textarea"===t)),t=!r;break t;default:t=!1}if(t)return null;if(n&&"function"!==typeof n)throw Error(s(231,e,typeof n));return n}var Dt=!1;if(u)try{var Ot={};Object.defineProperty(Ot,"passive",{get:function(){Dt=!0}}),window.addEventListener("test",Ot,Ot),window.removeEventListener("test",Ot,Ot)}catch(ut){Dt=!1}function zt(t,e,n,r,a,s,o,i,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var Lt=!1,Mt=null,Pt=!1,Bt=null,Wt={onError:function(t){Lt=!0,Mt=t}};function Ut(t,e,n,r,a,s,o,i,l){Lt=!1,Mt=null,zt.apply(Wt,arguments)}function Vt(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do{0!==(4098&(e=t).flags)&&(n=e.return),t=e.return}while(t)}return 3===e.tag?n:null}function jt(t){if(13===t.tag){var e=t.memoizedState;if(null===e&&(null!==(t=t.alternate)&&(e=t.memoizedState)),null!==e)return e.dehydrated}return null}function Gt(t){if(Vt(t)!==t)throw Error(s(188))}function Ht(t){return null!==(t=function(t){var e=t.alternate;if(!e){if(null===(e=Vt(t)))throw Error(s(188));return e!==t?null:t}for(var n=t,r=e;;){var a=n.return;if(null===a)break;var o=a.alternate;if(null===o){if(null!==(r=a.return)){n=r;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===n)return Gt(a),t;if(o===r)return Gt(a),e;o=o.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=o;else{for(var i=!1,l=a.child;l;){if(l===n){i=!0,n=a,r=o;break}if(l===r){i=!0,r=a,n=o;break}l=l.sibling}if(!i){for(l=o.child;l;){if(l===n){i=!0,n=o,r=a;break}if(l===r){i=!0,r=o,n=a;break}l=l.sibling}if(!i)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?t:e}(t))?Kt(t):null}function Kt(t){if(5===t.tag||6===t.tag)return t;for(t=t.child;null!==t;){var e=Kt(t);if(null!==e)return e;t=t.sibling}return null}var qt=a.unstable_scheduleCallback,Xt=a.unstable_cancelCallback,Jt=a.unstable_shouldYield,Yt=a.unstable_requestPaint,Zt=a.unstable_now,Qt=a.unstable_getCurrentPriorityLevel,$t=a.unstable_ImmediatePriority,te=a.unstable_UserBlockingPriority,ee=a.unstable_NormalPriority,ne=a.unstable_LowPriority,re=a.unstable_IdlePriority,ae=null,se=null;var oe=Math.clz32?Math.clz32:function(t){return t>>>=0,0===t?32:31-(ie(t)/le|0)|0},ie=Math.log,le=Math.LN2;var ce=64,ue=4194304;function he(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&t;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&t;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function de(t,e){var n=t.pendingLanes;if(0===n)return 0;var r=0,a=t.suspendedLanes,s=t.pingedLanes,o=268435455&n;if(0!==o){var i=o&~a;0!==i?r=he(i):0!==(s&=o)&&(r=he(s))}else 0!==(o=n&~a)?r=he(o):0!==s&&(r=he(s));if(0===r)return 0;if(0!==e&&e!==r&&0===(e&a)&&((a=r&-r)>=(s=e&-e)||16===a&&0!==(4194240&s)))return e;if(0!==(4&r)&&(r|=16&n),0!==(e=t.entangledLanes))for(t=t.entanglements,e&=r;0<e;)a=1<<(n=31-oe(e)),r|=t[n],e&=~a;return r}function pe(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function fe(t){return 0!==(t=-1073741825&t.pendingLanes)?t:1073741824&t?1073741824:0}function ge(){var t=ce;return 0===(4194240&(ce<<=1))&&(ce=64),t}function me(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function be(t,e,n){t.pendingLanes|=e,536870912!==e&&(t.suspendedLanes=0,t.pingedLanes=0),(t=t.eventTimes)[e=31-oe(e)]=n}function ye(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-oe(n),a=1<<r;a&e|t[r]&e&&(t[r]|=e),n&=~a}}var ve=0;function we(t){return 1<(t&=-t)?4<t?0!==(268435455&t)?16:536870912:4:1}var xe,ke,Se,Ie,Ne,Ee=!1,Ce=[],Te=null,Ae=null,Re=null,Fe=new Map,_e=new Map,De=[],Oe="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ze(t,e){switch(t){case"focusin":case"focusout":Te=null;break;case"dragenter":case"dragleave":Ae=null;break;case"mouseover":case"mouseout":Re=null;break;case"pointerover":case"pointerout":Fe.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":_e.delete(e.pointerId)}}function Le(t,e,n,r,a,s){return null===t||t.nativeEvent!==s?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==e&&(null!==(e=va(e))&&ke(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,null!==a&&-1===e.indexOf(a)&&e.push(a),t)}function Me(t){var e=ya(t.target);if(null!==e){var n=Vt(e);if(null!==n)if(13===(e=n.tag)){if(null!==(e=jt(n)))return t.blockedOn=e,void Ne(t.priority,(function(){Se(n)}))}else if(3===e&&n.stateNode.current.memoizedState.isDehydrated)return void(t.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}t.blockedOn=null}function Pe(t){if(null!==t.blockedOn)return!1;for(var e=t.targetContainers;0<e.length;){var n=Je(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(null!==n)return null!==(e=va(n))&&ke(e),t.blockedOn=n,!1;var r=new(n=t.nativeEvent).constructor(n.type,n);wt=r,n.target.dispatchEvent(r),wt=null,e.shift()}return!0}function Be(t,e,n){Pe(t)&&n.delete(e)}function We(){Ee=!1,null!==Te&&Pe(Te)&&(Te=null),null!==Ae&&Pe(Ae)&&(Ae=null),null!==Re&&Pe(Re)&&(Re=null),Fe.forEach(Be),_e.forEach(Be)}function Ue(t,e){t.blockedOn===e&&(t.blockedOn=null,Ee||(Ee=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,We)))}function Ve(t){function e(e){return Ue(e,t)}if(0<Ce.length){Ue(Ce[0],t);for(var n=1;n<Ce.length;n++){var r=Ce[n];r.blockedOn===t&&(r.blockedOn=null)}}for(null!==Te&&Ue(Te,t),null!==Ae&&Ue(Ae,t),null!==Re&&Ue(Re,t),Fe.forEach(e),_e.forEach(e),n=0;n<De.length;n++)(r=De[n]).blockedOn===t&&(r.blockedOn=null);for(;0<De.length&&null===(n=De[0]).blockedOn;)Me(n),null===n.blockedOn&&De.shift()}var je=w.ReactCurrentBatchConfig,Ge=!0;function He(t,e,n,r){var a=ve,s=je.transition;je.transition=null;try{ve=1,qe(t,e,n,r)}finally{ve=a,je.transition=s}}function Ke(t,e,n,r){var a=ve,s=je.transition;je.transition=null;try{ve=4,qe(t,e,n,r)}finally{ve=a,je.transition=s}}function qe(t,e,n,r){if(Ge){var a=Je(t,e,n,r);if(null===a)Gr(t,e,r,Xe,n),ze(t,r);else if(function(t,e,n,r,a){switch(e){case"focusin":return Te=Le(Te,t,e,n,r,a),!0;case"dragenter":return Ae=Le(Ae,t,e,n,r,a),!0;case"mouseover":return Re=Le(Re,t,e,n,r,a),!0;case"pointerover":var s=a.pointerId;return Fe.set(s,Le(Fe.get(s)||null,t,e,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,_e.set(s,Le(_e.get(s)||null,t,e,n,r,a)),!0}return!1}(a,t,e,n,r))r.stopPropagation();else if(ze(t,r),4&e&&-1<Oe.indexOf(t)){for(;null!==a;){var s=va(a);if(null!==s&&xe(s),null===(s=Je(t,e,n,r))&&Gr(t,e,r,Xe,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else Gr(t,e,r,null,n)}}var Xe=null;function Je(t,e,n,r){if(Xe=null,null!==(t=ya(t=xt(r))))if(null===(e=Vt(t)))t=null;else if(13===(n=e.tag)){if(null!==(t=jt(e)))return t;t=null}else if(3===n){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return Xe=t,null}function Ye(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qt()){case $t:return 1;case te:return 4;case ee:case ne:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ze=null,Qe=null,$e=null;function tn(){if($e)return $e;var t,e,n=Qe,r=n.length,a="value"in Ze?Ze.value:Ze.textContent,s=a.length;for(t=0;t<r&&n[t]===a[t];t++);var o=r-t;for(e=1;e<=o&&n[r-e]===a[s-e];e++);return $e=a.slice(t,1<e?1-e:void 0)}function en(t){var e=t.keyCode;return"charCode"in t?0===(t=t.charCode)&&13===e&&(t=13):t=e,10===t&&(t=13),32<=t||13===t?t:0}function nn(){return!0}function rn(){return!1}function an(t){function e(e,n,r,a,s){for(var o in this._reactName=e,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,t)t.hasOwnProperty(o)&&(e=t[o],this[o]=e?e(a):a[o]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return M(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():"unknown"!==typeof t.returnValue&&(t.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():"unknown"!==typeof t.cancelBubble&&(t.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),e}var sn,on,ln,cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=an(cn),hn=M({},cn,{view:0,detail:0}),dn=an(hn),pn=M({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(t){return void 0===t.relatedTarget?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==ln&&(ln&&"mousemove"===t.type?(sn=t.screenX-ln.screenX,on=t.screenY-ln.screenY):on=sn=0,ln=t),sn)},movementY:function(t){return"movementY"in t?t.movementY:on}}),fn=an(pn),gn=an(M({},pn,{dataTransfer:0})),mn=an(M({},hn,{relatedTarget:0})),bn=an(M({},cn,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=M({},cn,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),vn=an(yn),wn=an(M({},cn,{data:0})),xn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):!!(t=Sn[t])&&!!e[t]}function Nn(){return In}var En=M({},hn,{key:function(t){if(t.key){var e=xn[t.key]||t.key;if("Unidentified"!==e)return e}return"keypress"===t.type?13===(t=en(t))?"Enter":String.fromCharCode(t):"keydown"===t.type||"keyup"===t.type?kn[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(t){return"keypress"===t.type?en(t):0},keyCode:function(t){return"keydown"===t.type||"keyup"===t.type?t.keyCode:0},which:function(t){return"keypress"===t.type?en(t):"keydown"===t.type||"keyup"===t.type?t.keyCode:0}}),Cn=an(En),Tn=an(M({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),An=an(M({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),Rn=an(M({},cn,{propertyName:0,elapsedTime:0,pseudoElement:0})),Fn=M({},pn,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),_n=an(Fn),Dn=[9,13,27,32],On=u&&"CompositionEvent"in window,zn=null;u&&"documentMode"in document&&(zn=document.documentMode);var Ln=u&&"TextEvent"in window&&!zn,Mn=u&&(!On||zn&&8<zn&&11>=zn),Pn=String.fromCharCode(32),Bn=!1;function Wn(t,e){switch(t){case"keyup":return-1!==Dn.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(t){return"object"===typeof(t=t.detail)&&"data"in t?t.data:null}var Vn=!1;var jn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Gn(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return"input"===e?!!jn[t.type]:"textarea"===e}function Hn(t,e,n,r){Et(r),0<(e=Kr(e,"onChange")).length&&(n=new un("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var Kn=null,qn=null;function Xn(t){Pr(t,0)}function Jn(t){if(q(wa(t)))return t}function Yn(t,e){if("change"===t)return e}var Zn=!1;if(u){var Qn;if(u){var $n="oninput"in document;if(!$n){var tr=document.createElement("div");tr.setAttribute("oninput","return;"),$n="function"===typeof tr.oninput}Qn=$n}else Qn=!1;Zn=Qn&&(!document.documentMode||9<document.documentMode)}function er(){Kn&&(Kn.detachEvent("onpropertychange",nr),qn=Kn=null)}function nr(t){if("value"===t.propertyName&&Jn(qn)){var e=[];Hn(e,qn,t,xt(t)),Ft(Xn,e)}}function rr(t,e,n){"focusin"===t?(er(),qn=n,(Kn=e).attachEvent("onpropertychange",nr)):"focusout"===t&&er()}function ar(t){if("selectionchange"===t||"keyup"===t||"keydown"===t)return Jn(qn)}function sr(t,e){if("click"===t)return Jn(e)}function or(t,e){if("input"===t||"change"===t)return Jn(e)}var ir="function"===typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t===1/e)||t!==t&&e!==e};function lr(t,e){if(ir(t,e))return!0;if("object"!==typeof t||null===t||"object"!==typeof e||null===e)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!h.call(e,a)||!ir(t[a],e[a]))return!1}return!0}function cr(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function ur(t,e){var n,r=cr(t);for(t=0;r;){if(3===r.nodeType){if(n=t+r.textContent.length,t<=e&&n>=e)return{node:r,offset:e-t};t=n}t:{for(;r;){if(r.nextSibling){r=r.nextSibling;break t}r=r.parentNode}r=void 0}r=cr(r)}}function hr(t,e){return!(!t||!e)&&(t===e||(!t||3!==t.nodeType)&&(e&&3===e.nodeType?hr(t,e.parentNode):"contains"in t?t.contains(e):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(e))))}function dr(){for(var t=window,e=X();e instanceof t.HTMLIFrameElement;){try{var n="string"===typeof e.contentWindow.location.href}catch(r){n=!1}if(!n)break;e=X((t=e.contentWindow).document)}return e}function pr(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&("input"===e&&("text"===t.type||"search"===t.type||"tel"===t.type||"url"===t.type||"password"===t.type)||"textarea"===e||"true"===t.contentEditable)}function fr(t){var e=dr(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&hr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(e=r.start,void 0===(t=r.end)&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if((t=(e=n.ownerDocument||document)&&e.defaultView||window).getSelection){t=t.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!t.extend&&s>r&&(a=r,r=s,s=a),a=ur(n,s);var o=ur(n,r);a&&o&&(1!==t.rangeCount||t.anchorNode!==a.node||t.anchorOffset!==a.offset||t.focusNode!==o.node||t.focusOffset!==o.offset)&&((e=e.createRange()).setStart(a.node,a.offset),t.removeAllRanges(),s>r?(t.addRange(e),t.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),t.addRange(e)))}for(e=[],t=n;t=t.parentNode;)1===t.nodeType&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<e.length;n++)(t=e[n]).element.scrollLeft=t.left,t.element.scrollTop=t.top}}var gr=u&&"documentMode"in document&&11>=document.documentMode,mr=null,br=null,yr=null,vr=!1;function wr(t,e,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==mr||mr!==X(r)||("selectionStart"in(r=mr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},yr&&lr(yr,r)||(yr=r,0<(r=Kr(br,"onSelect")).length&&(e=new un("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=mr)))}function xr(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var kr={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},Sr={},Ir={};function Nr(t){if(Sr[t])return Sr[t];if(!kr[t])return t;var e,n=kr[t];for(e in n)if(n.hasOwnProperty(e)&&e in Ir)return Sr[t]=n[e];return t}u&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Er=Nr("animationend"),Cr=Nr("animationiteration"),Tr=Nr("animationstart"),Ar=Nr("transitionend"),Rr=new Map,Fr="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function _r(t,e){Rr.set(t,e),l(e,[t])}for(var Dr=0;Dr<Fr.length;Dr++){var Or=Fr[Dr];_r(Or.toLowerCase(),"on"+(Or[0].toUpperCase()+Or.slice(1)))}_r(Er,"onAnimationEnd"),_r(Cr,"onAnimationIteration"),_r(Tr,"onAnimationStart"),_r("dblclick","onDoubleClick"),_r("focusin","onFocus"),_r("focusout","onBlur"),_r(Ar,"onTransitionEnd"),c("onMouseEnter",["mouseout","mouseover"]),c("onMouseLeave",["mouseout","mouseover"]),c("onPointerEnter",["pointerout","pointerover"]),c("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var zr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Lr=new Set("cancel close invalid load scroll toggle".split(" ").concat(zr));function Mr(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,function(t,e,n,r,a,o,i,l,c){if(Ut.apply(this,arguments),Lt){if(!Lt)throw Error(s(198));var u=Mt;Lt=!1,Mt=null,Pt||(Pt=!0,Bt=u)}}(r,e,void 0,t),t.currentTarget=null}function Pr(t,e){e=0!==(4&e);for(var n=0;n<t.length;n++){var r=t[n],a=r.event;r=r.listeners;t:{var s=void 0;if(e)for(var o=r.length-1;0<=o;o--){var i=r[o],l=i.instance,c=i.currentTarget;if(i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}else for(o=0;o<r.length;o++){if(l=(i=r[o]).instance,c=i.currentTarget,i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}}}if(Pt)throw t=Bt,Pt=!1,Bt=null,t}function Br(t,e){var n=e[ga];void 0===n&&(n=e[ga]=new Set);var r=t+"__bubble";n.has(r)||(jr(e,t,2,!1),n.add(r))}function Wr(t,e,n){var r=0;e&&(r|=4),jr(n,t,r,e)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function Vr(t){if(!t[Ur]){t[Ur]=!0,o.forEach((function(e){"selectionchange"!==e&&(Lr.has(e)||Wr(e,!1,t),Wr(e,!0,t))}));var e=9===t.nodeType?t:t.ownerDocument;null===e||e[Ur]||(e[Ur]=!0,Wr("selectionchange",!1,e))}}function jr(t,e,n,r){switch(Ye(e)){case 1:var a=He;break;case 4:a=Ke;break;default:a=qe}n=a.bind(null,e,n,t),a=void 0,!Dt||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(a=!0),r?void 0!==a?t.addEventListener(e,n,{capture:!0,passive:a}):t.addEventListener(e,n,!0):void 0!==a?t.addEventListener(e,n,{passive:a}):t.addEventListener(e,n,!1)}function Gr(t,e,n,r,a){var s=r;if(0===(1&e)&&0===(2&e)&&null!==r)t:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var i=r.stateNode.containerInfo;if(i===a||8===i.nodeType&&i.parentNode===a)break;if(4===o)for(o=r.return;null!==o;){var l=o.tag;if((3===l||4===l)&&((l=o.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;o=o.return}for(;null!==i;){if(null===(o=ya(i)))return;if(5===(l=o.tag)||6===l){r=s=o;continue t}i=i.parentNode}}r=r.return}Ft((function(){var r=s,a=xt(n),o=[];t:{var i=Rr.get(t);if(void 0!==i){var l=un,c=t;switch(t){case"keypress":if(0===en(n))break t;case"keydown":case"keyup":l=Cn;break;case"focusin":c="focus",l=mn;break;case"focusout":c="blur",l=mn;break;case"beforeblur":case"afterblur":l=mn;break;case"click":if(2===n.button)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=gn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=An;break;case Er:case Cr:case Tr:l=bn;break;case Ar:l=Rn;break;case"scroll":l=dn;break;case"wheel":l=_n;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Tn}var u=0!==(4&e),h=!u&&"scroll"===t,d=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=r;null!==f;){var g=(p=f).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==d&&(null!=(g=_t(f,d))&&u.push(Hr(f,g,p)))),h)break;f=f.return}0<u.length&&(i=new l(i,c,null,n,a),o.push({event:i,listeners:u}))}}if(0===(7&e)){if(l="mouseout"===t||"pointerout"===t,(!(i="mouseover"===t||"pointerover"===t)||n===wt||!(c=n.relatedTarget||n.fromElement)||!ya(c)&&!c[fa])&&(l||i)&&(i=a.window===a?a:(i=a.ownerDocument)?i.defaultView||i.parentWindow:window,l?(l=r,null!==(c=(c=n.relatedTarget||n.toElement)?ya(c):null)&&(c!==(h=Vt(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=r),l!==c)){if(u=fn,g="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==t&&"pointerover"!==t||(u=Tn,g="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==l?i:wa(l),p=null==c?i:wa(c),(i=new u(g,f+"leave",l,n,a)).target=h,i.relatedTarget=p,g=null,ya(a)===r&&((u=new u(d,f+"enter",c,n,a)).target=p,u.relatedTarget=h,g=u),h=g,l&&c)t:{for(d=c,f=0,p=u=l;p;p=qr(p))f++;for(p=0,g=d;g;g=qr(g))p++;for(;0<f-p;)u=qr(u),f--;for(;0<p-f;)d=qr(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break t;u=qr(u),d=qr(d)}u=null}else u=null;null!==l&&Xr(o,i,l,u,!1),null!==c&&null!==h&&Xr(o,h,c,u,!0)}if("select"===(l=(i=r?wa(r):window).nodeName&&i.nodeName.toLowerCase())||"input"===l&&"file"===i.type)var m=Yn;else if(Gn(i))if(Zn)m=or;else{m=ar;var b=rr}else(l=i.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(m=sr);switch(m&&(m=m(t,r))?Hn(o,m,n,a):(b&&b(t,i,r),"focusout"===t&&(b=i._wrapperState)&&b.controlled&&"number"===i.type&&tt(i,"number",i.value)),b=r?wa(r):window,t){case"focusin":(Gn(b)||"true"===b.contentEditable)&&(mr=b,br=r,yr=null);break;case"focusout":yr=br=mr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,wr(o,n,a);break;case"selectionchange":if(gr)break;case"keydown":case"keyup":wr(o,n,a)}var y;if(On)t:{switch(t){case"compositionstart":var v="onCompositionStart";break t;case"compositionend":v="onCompositionEnd";break t;case"compositionupdate":v="onCompositionUpdate";break t}v=void 0}else Vn?Wn(t,n)&&(v="onCompositionEnd"):"keydown"===t&&229===n.keyCode&&(v="onCompositionStart");v&&(Mn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(y=tn()):(Qe="value"in(Ze=a)?Ze.value:Ze.textContent,Vn=!0)),0<(b=Kr(r,v)).length&&(v=new wn(v,t,null,n,a),o.push({event:v,listeners:b}),y?v.data=y:null!==(y=Un(n))&&(v.data=y))),(y=Ln?function(t,e){switch(t){case"compositionend":return Un(e);case"keypress":return 32!==e.which?null:(Bn=!0,Pn);case"textInput":return(t=e.data)===Pn&&Bn?null:t;default:return null}}(t,n):function(t,e){if(Vn)return"compositionend"===t||!On&&Wn(t,e)?(t=tn(),$e=Qe=Ze=null,Vn=!1,t):null;switch(t){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Mn&&"ko"!==e.locale?null:e.data}}(t,n))&&(0<(r=Kr(r,"onBeforeInput")).length&&(a=new wn("onBeforeInput","beforeinput",null,n,a),o.push({event:a,listeners:r}),a.data=y))}Pr(o,e)}))}function Hr(t,e,n){return{instance:t,listener:e,currentTarget:n}}function Kr(t,e){for(var n=e+"Capture",r=[];null!==t;){var a=t,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=_t(t,n))&&r.unshift(Hr(t,s,a)),null!=(s=_t(t,e))&&r.push(Hr(t,s,a))),t=t.return}return r}function qr(t){if(null===t)return null;do{t=t.return}while(t&&5!==t.tag);return t||null}function Xr(t,e,n,r,a){for(var s=e._reactName,o=[];null!==n&&n!==r;){var i=n,l=i.alternate,c=i.stateNode;if(null!==l&&l===r)break;5===i.tag&&null!==c&&(i=c,a?null!=(l=_t(n,s))&&o.unshift(Hr(n,l,i)):a||null!=(l=_t(n,s))&&o.push(Hr(n,l,i))),n=n.return}0!==o.length&&t.push({event:e,listeners:o})}var Jr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Zr(t){return("string"===typeof t?t:""+t).replace(Jr,"\n").replace(Yr,"")}function Qr(t,e,n){if(e=Zr(e),Zr(t)!==e&&n)throw Error(s(425))}function $r(){}var ta=null,ea=null;function na(t,e){return"textarea"===t||"noscript"===t||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,oa="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(t){return sa.resolve(null).then(t).catch(ia)}:ra;function ia(t){setTimeout((function(){throw t}))}function la(t,e){var n=e,r=0;do{var a=n.nextSibling;if(t.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return t.removeChild(a),void Ve(e);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Ve(e)}function ca(t){for(;null!=t;t=t.nextSibling){var e=t.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=t.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return t}function ua(t){t=t.previousSibling;for(var e=0;t;){if(8===t.nodeType){var n=t.data;if("$"===n||"$!"===n||"$?"===n){if(0===e)return t;e--}else"/$"===n&&e++}t=t.previousSibling}return null}var ha=Math.random().toString(36).slice(2),da="__reactFiber$"+ha,pa="__reactProps$"+ha,fa="__reactContainer$"+ha,ga="__reactEvents$"+ha,ma="__reactListeners$"+ha,ba="__reactHandles$"+ha;function ya(t){var e=t[da];if(e)return e;for(var n=t.parentNode;n;){if(e=n[fa]||n[da]){if(n=e.alternate,null!==e.child||null!==n&&null!==n.child)for(t=ua(t);null!==t;){if(n=t[da])return n;t=ua(t)}return e}n=(t=n).parentNode}return null}function va(t){return!(t=t[da]||t[fa])||5!==t.tag&&6!==t.tag&&13!==t.tag&&3!==t.tag?null:t}function wa(t){if(5===t.tag||6===t.tag)return t.stateNode;throw Error(s(33))}function xa(t){return t[pa]||null}var ka=[],Sa=-1;function Ia(t){return{current:t}}function Na(t){0>Sa||(t.current=ka[Sa],ka[Sa]=null,Sa--)}function Ea(t,e){Sa++,ka[Sa]=t.current,t.current=e}var Ca={},Ta=Ia(Ca),Aa=Ia(!1),Ra=Ca;function Fa(t,e){var n=t.type.contextTypes;if(!n)return Ca;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=e[a];return r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=s),s}function _a(t){return null!==(t=t.childContextTypes)&&void 0!==t}function Da(){Na(Aa),Na(Ta)}function Oa(t,e,n){if(Ta.current!==Ca)throw Error(s(168));Ea(Ta,e),Ea(Aa,n)}function za(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in e))throw Error(s(108,j(t)||"Unknown",a));return M({},n,r)}function La(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Ca,Ra=Ta.current,Ea(Ta,t),Ea(Aa,Aa.current),!0}function Ma(t,e,n){var r=t.stateNode;if(!r)throw Error(s(169));n?(t=za(t,e,Ra),r.__reactInternalMemoizedMergedChildContext=t,Na(Aa),Na(Ta),Ea(Ta,t)):Na(Aa),Ea(Aa,n)}var Pa=null,Ba=!1,Wa=!1;function Ua(t){null===Pa?Pa=[t]:Pa.push(t)}function Va(){if(!Wa&&null!==Pa){Wa=!0;var t=0,e=ve;try{var n=Pa;for(ve=1;t<n.length;t++){var r=n[t];do{r=r(!0)}while(null!==r)}Pa=null,Ba=!1}catch(a){throw null!==Pa&&(Pa=Pa.slice(t+1)),qt($t,Va),a}finally{ve=e,Wa=!1}}return null}var ja=[],Ga=0,Ha=null,Ka=0,qa=[],Xa=0,Ja=null,Ya=1,Za="";function Qa(t,e){ja[Ga++]=Ka,ja[Ga++]=Ha,Ha=t,Ka=e}function $a(t,e,n){qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ja=t;var r=Ya;t=Za;var a=32-oe(r)-1;r&=~(1<<a),n+=1;var s=32-oe(e)+a;if(30<s){var o=a-a%5;s=(r&(1<<o)-1).toString(32),r>>=o,a-=o,Ya=1<<32-oe(e)+a|n<<a|r,Za=s+t}else Ya=1<<s|n<<a|r,Za=t}function ts(t){null!==t.return&&(Qa(t,1),$a(t,1,0))}function es(t){for(;t===Ha;)Ha=ja[--Ga],ja[Ga]=null,Ka=ja[--Ga],ja[Ga]=null;for(;t===Ja;)Ja=qa[--Xa],qa[Xa]=null,Za=qa[--Xa],qa[Xa]=null,Ya=qa[--Xa],qa[Xa]=null}var ns=null,rs=null,as=!1,ss=null;function os(t,e){var n=_c(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,null===(e=t.deletions)?(t.deletions=[n],t.flags|=16):e.push(n)}function is(t,e){switch(t.tag){case 5:var n=t.type;return null!==(e=1!==e.nodeType||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(t.stateNode=e,ns=t,rs=ca(e.firstChild),!0);case 6:return null!==(e=""===t.pendingProps||3!==e.nodeType?null:e)&&(t.stateNode=e,ns=t,rs=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(n=null!==Ja?{id:Ya,overflow:Za}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},(n=_c(18,null,null,0)).stateNode=e,n.return=t,t.child=n,ns=t,rs=null,!0);default:return!1}}function ls(t){return 0!==(1&t.mode)&&0===(128&t.flags)}function cs(t){if(as){var e=rs;if(e){var n=e;if(!is(t,e)){if(ls(t))throw Error(s(418));e=ca(n.nextSibling);var r=ns;e&&is(t,e)?os(r,n):(t.flags=-4097&t.flags|2,as=!1,ns=t)}}else{if(ls(t))throw Error(s(418));t.flags=-4097&t.flags|2,as=!1,ns=t}}}function us(t){for(t=t.return;null!==t&&5!==t.tag&&3!==t.tag&&13!==t.tag;)t=t.return;ns=t}function hs(t){if(t!==ns)return!1;if(!as)return us(t),as=!0,!1;var e;if((e=3!==t.tag)&&!(e=5!==t.tag)&&(e="head"!==(e=t.type)&&"body"!==e&&!na(t.type,t.memoizedProps)),e&&(e=rs)){if(ls(t))throw ds(),Error(s(418));for(;e;)os(t,e),e=ca(e.nextSibling)}if(us(t),13===t.tag){if(!(t=null!==(t=t.memoizedState)?t.dehydrated:null))throw Error(s(317));t:{for(t=t.nextSibling,e=0;t;){if(8===t.nodeType){var n=t.data;if("/$"===n){if(0===e){rs=ca(t.nextSibling);break t}e--}else"$"!==n&&"$!"!==n&&"$?"!==n||e++}t=t.nextSibling}rs=null}}else rs=ns?ca(t.stateNode.nextSibling):null;return!0}function ds(){for(var t=rs;t;)t=ca(t.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(t){null===ss?ss=[t]:ss.push(t)}var gs=w.ReactCurrentBatchConfig;function ms(t,e){if(t&&t.defaultProps){for(var n in e=M({},e),t=t.defaultProps)void 0===e[n]&&(e[n]=t[n]);return e}return e}var bs=Ia(null),ys=null,vs=null,ws=null;function xs(){ws=vs=ys=null}function ks(t){var e=bs.current;Na(bs),t._currentValue=e}function Ss(t,e,n){for(;null!==t;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,null!==r&&(r.childLanes|=e)):null!==r&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function Is(t,e){ys=t,ws=vs=null,null!==(t=t.dependencies)&&null!==t.firstContext&&(0!==(t.lanes&e)&&(wi=!0),t.firstContext=null)}function Ns(t){var e=t._currentValue;if(ws!==t)if(t={context:t,memoizedValue:e,next:null},null===vs){if(null===ys)throw Error(s(308));vs=t,ys.dependencies={lanes:0,firstContext:t}}else vs=vs.next=t;return e}var Es=null;function Cs(t){null===Es?Es=[t]:Es.push(t)}function Ts(t,e,n,r){var a=e.interleaved;return null===a?(n.next=n,Cs(e)):(n.next=a.next,a.next=n),e.interleaved=n,As(t,r)}function As(t,e){t.lanes|=e;var n=t.alternate;for(null!==n&&(n.lanes|=e),n=t,t=t.return;null!==t;)t.childLanes|=e,null!==(n=t.alternate)&&(n.childLanes|=e),n=t,t=t.return;return 3===n.tag?n.stateNode:null}var Rs=!1;function Fs(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function _s(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function Ds(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Os(t,e,n){var r=t.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Al)){var a=r.pending;return null===a?e.next=e:(e.next=a.next,a.next=e),r.pending=e,As(t,n)}return null===(a=r.interleaved)?(e.next=e,Cs(r)):(e.next=a.next,a.next=e),r.interleaved=e,As(t,n)}function zs(t,e,n){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&n))){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}function Ls(t,e){var n=t.updateQueue,r=t.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=o:s=s.next=o,n=n.next}while(null!==n);null===s?a=s=e:s=s.next=e}else a=s=e;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(t.updateQueue=n)}null===(t=n.lastBaseUpdate)?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Ms(t,e,n,r){var a=t.updateQueue;Rs=!1;var s=a.firstBaseUpdate,o=a.lastBaseUpdate,i=a.shared.pending;if(null!==i){a.shared.pending=null;var l=i,c=l.next;l.next=null,null===o?s=c:o.next=c,o=l;var u=t.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==o&&(null===i?u.firstBaseUpdate=c:i.next=c,u.lastBaseUpdate=l))}if(null!==s){var h=a.baseState;for(o=0,u=c=l=null,i=s;;){var d=i.lane,p=i.eventTime;if((r&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});t:{var f=t,g=i;switch(d=e,p=n,g.tag){case 1:if("function"===typeof(f=g.payload)){h=f.call(p,h,d);break t}h=f;break t;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=g.payload)?f.call(p,h,d):f)||void 0===d)break t;h=M({},h,d);break t;case 2:Rs=!0}}null!==i.callback&&0!==i.lane&&(t.flags|=64,null===(d=a.effects)?a.effects=[i]:d.push(i))}else p={eventTime:p,lane:d,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(c=u=p,l=h):u=u.next=p,o|=d;if(null===(i=i.next)){if(null===(i=a.shared.pending))break;i=(d=i).next,d.next=null,a.lastBaseUpdate=d,a.shared.pending=null}}if(null===u&&(l=h),a.baseState=l,a.firstBaseUpdate=c,a.lastBaseUpdate=u,null!==(e=a.shared.interleaved)){a=e;do{o|=a.lane,a=a.next}while(a!==e)}else null===s&&(a.shared.lanes=0);Ml|=o,t.lanes=o,t.memoizedState=h}}function Ps(t,e,n){if(t=e.effects,e.effects=null,null!==t)for(e=0;e<t.length;e++){var r=t[e],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var Bs=(new r.Component).refs;function Ws(t,e,n,r){n=null===(n=n(r,e=t.memoizedState))||void 0===n?e:M({},e,n),t.memoizedState=n,0===t.lanes&&(t.updateQueue.baseState=n)}var Us={isMounted:function(t){return!!(t=t._reactInternals)&&Vt(t)===t},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.tag=1,s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=ec(),r=nc(t),a=Ds(n,r);a.tag=2,void 0!==e&&null!==e&&(a.callback=e),null!==(e=Os(t,a,r))&&(rc(e,t,r,n),zs(e,t,r))}};function Vs(t,e,n,r,a,s,o){return"function"===typeof(t=t.stateNode).shouldComponentUpdate?t.shouldComponentUpdate(r,s,o):!e.prototype||!e.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function js(t,e,n){var r=!1,a=Ca,s=e.contextType;return"object"===typeof s&&null!==s?s=Ns(s):(a=_a(e)?Ra:Ta.current,s=(r=null!==(r=e.contextTypes)&&void 0!==r)?Fa(t,a):Ca),e=new e(n,s),t.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=Us,t.stateNode=e,e._reactInternals=t,r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,t.__reactInternalMemoizedMaskedChildContext=s),e}function Gs(t,e,n,r){t=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(n,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&Us.enqueueReplaceState(e,e.state,null)}function Hs(t,e,n,r){var a=t.stateNode;a.props=n,a.state=t.memoizedState,a.refs=Bs,Fs(t);var s=e.contextType;"object"===typeof s&&null!==s?a.context=Ns(s):(s=_a(e)?Ra:Ta.current,a.context=Fa(t,s)),a.state=t.memoizedState,"function"===typeof(s=e.getDerivedStateFromProps)&&(Ws(t,e,s,n),a.state=t.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(e=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),e!==a.state&&Us.enqueueReplaceState(a,a.state,null),Ms(t,n,a,r),a.state=t.memoizedState),"function"===typeof a.componentDidMount&&(t.flags|=4194308)}function Ks(t,e,n){if(null!==(t=n.ref)&&"function"!==typeof t&&"object"!==typeof t){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,t));var a=r,o=""+t;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===o?e.ref:(e=function(t){var e=a.refs;e===Bs&&(e=a.refs={}),null===t?delete e[o]:e[o]=t},e._stringRef=o,e)}if("string"!==typeof t)throw Error(s(284));if(!n._owner)throw Error(s(290,t))}return t}function qs(t,e){throw t=Object.prototype.toString.call(e),Error(s(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function Xs(t){return(0,t._init)(t._payload)}function Js(t){function e(e,n){if(t){var r=e.deletions;null===r?(e.deletions=[n],e.flags|=16):r.push(n)}}function n(n,r){if(!t)return null;for(;null!==r;)e(n,r),r=r.sibling;return null}function r(t,e){for(t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(t,e){return(t=Oc(t,e)).index=0,t.sibling=null,t}function o(e,n,r){return e.index=r,t?null!==(r=e.alternate)?(r=r.index)<n?(e.flags|=2,n):r:(e.flags|=2,n):(e.flags|=1048576,n)}function i(e){return t&&null===e.alternate&&(e.flags|=2),e}function l(t,e,n,r){return null===e||6!==e.tag?((e=Pc(n,t.mode,r)).return=t,e):((e=a(e,n)).return=t,e)}function c(t,e,n,r){var s=n.type;return s===S?h(t,e,n.props.children,r,n.key):null!==e&&(e.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===_&&Xs(s)===e.type)?((r=a(e,n.props)).ref=Ks(t,e,n),r.return=t,r):((r=zc(n.type,n.key,n.props,null,t.mode,r)).ref=Ks(t,e,n),r.return=t,r)}function u(t,e,n,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==n.containerInfo||e.stateNode.implementation!==n.implementation?((e=Bc(n,t.mode,r)).return=t,e):((e=a(e,n.children||[])).return=t,e)}function h(t,e,n,r,s){return null===e||7!==e.tag?((e=Lc(n,t.mode,r,s)).return=t,e):((e=a(e,n)).return=t,e)}function d(t,e,n){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=Pc(""+e,t.mode,n)).return=t,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case x:return(n=zc(e.type,e.key,e.props,null,t.mode,n)).ref=Ks(t,null,e),n.return=t,n;case k:return(e=Bc(e,t.mode,n)).return=t,e;case _:return d(t,(0,e._init)(e._payload),n)}if(et(e)||z(e))return(e=Lc(e,t.mode,n,null)).return=t,e;qs(t,e)}return null}function p(t,e,n,r){var a=null!==e?e.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(t,e,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===a?c(t,e,n,r):null;case k:return n.key===a?u(t,e,n,r):null;case _:return p(t,e,(a=n._init)(n._payload),r)}if(et(n)||z(n))return null!==a?null:h(t,e,n,r,null);qs(t,n)}return null}function f(t,e,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(e,t=t.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case x:return c(e,t=t.get(null===r.key?n:r.key)||null,r,a);case k:return u(e,t=t.get(null===r.key?n:r.key)||null,r,a);case _:return f(t,e,n,(0,r._init)(r._payload),a)}if(et(r)||z(r))return h(e,t=t.get(n)||null,r,a,null);qs(e,r)}return null}function g(a,s,i,l){for(var c=null,u=null,h=s,g=s=0,m=null;null!==h&&g<i.length;g++){h.index>g?(m=h,h=null):m=h.sibling;var b=p(a,h,i[g],l);if(null===b){null===h&&(h=m);break}t&&h&&null===b.alternate&&e(a,h),s=o(b,s,g),null===u?c=b:u.sibling=b,u=b,h=m}if(g===i.length)return n(a,h),as&&Qa(a,g),c;if(null===h){for(;g<i.length;g++)null!==(h=d(a,i[g],l))&&(s=o(h,s,g),null===u?c=h:u.sibling=h,u=h);return as&&Qa(a,g),c}for(h=r(a,h);g<i.length;g++)null!==(m=f(h,a,g,i[g],l))&&(t&&null!==m.alternate&&h.delete(null===m.key?g:m.key),s=o(m,s,g),null===u?c=m:u.sibling=m,u=m);return t&&h.forEach((function(t){return e(a,t)})),as&&Qa(a,g),c}function m(a,i,l,c){var u=z(l);if("function"!==typeof u)throw Error(s(150));if(null==(l=u.call(l)))throw Error(s(151));for(var h=u=null,g=i,m=i=0,b=null,y=l.next();null!==g&&!y.done;m++,y=l.next()){g.index>m?(b=g,g=null):b=g.sibling;var v=p(a,g,y.value,c);if(null===v){null===g&&(g=b);break}t&&g&&null===v.alternate&&e(a,g),i=o(v,i,m),null===h?u=v:h.sibling=v,h=v,g=b}if(y.done)return n(a,g),as&&Qa(a,m),u;if(null===g){for(;!y.done;m++,y=l.next())null!==(y=d(a,y.value,c))&&(i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return as&&Qa(a,m),u}for(g=r(a,g);!y.done;m++,y=l.next())null!==(y=f(g,a,m,y.value,c))&&(t&&null!==y.alternate&&g.delete(null===y.key?m:y.key),i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return t&&g.forEach((function(t){return e(a,t)})),as&&Qa(a,m),u}return function t(r,s,o,l){if("object"===typeof o&&null!==o&&o.type===S&&null===o.key&&(o=o.props.children),"object"===typeof o&&null!==o){switch(o.$$typeof){case x:t:{for(var c=o.key,u=s;null!==u;){if(u.key===c){if((c=o.type)===S){if(7===u.tag){n(r,u.sibling),(s=a(u,o.props.children)).return=r,r=s;break t}}else if(u.elementType===c||"object"===typeof c&&null!==c&&c.$$typeof===_&&Xs(c)===u.type){n(r,u.sibling),(s=a(u,o.props)).ref=Ks(r,u,o),s.return=r,r=s;break t}n(r,u);break}e(r,u),u=u.sibling}o.type===S?((s=Lc(o.props.children,r.mode,l,o.key)).return=r,r=s):((l=zc(o.type,o.key,o.props,null,r.mode,l)).ref=Ks(r,s,o),l.return=r,r=l)}return i(r);case k:t:{for(u=o.key;null!==s;){if(s.key===u){if(4===s.tag&&s.stateNode.containerInfo===o.containerInfo&&s.stateNode.implementation===o.implementation){n(r,s.sibling),(s=a(s,o.children||[])).return=r,r=s;break t}n(r,s);break}e(r,s),s=s.sibling}(s=Bc(o,r.mode,l)).return=r,r=s}return i(r);case _:return t(r,s,(u=o._init)(o._payload),l)}if(et(o))return g(r,s,o,l);if(z(o))return m(r,s,o,l);qs(r,o)}return"string"===typeof o&&""!==o||"number"===typeof o?(o=""+o,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,o)).return=r,r=s):(n(r,s),(s=Pc(o,r.mode,l)).return=r,r=s),i(r)):n(r,s)}}var Ys=Js(!0),Zs=Js(!1),Qs={},$s=Ia(Qs),to=Ia(Qs),eo=Ia(Qs);function no(t){if(t===Qs)throw Error(s(174));return t}function ro(t,e){switch(Ea(eo,e),Ea(to,t),Ea($s,Qs),t=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lt(null,"");break;default:e=lt(e=(t=8===t?e.parentNode:e).namespaceURI||null,t=t.tagName)}Na($s),Ea($s,e)}function ao(){Na($s),Na(to),Na(eo)}function so(t){no(eo.current);var e=no($s.current),n=lt(e,t.type);e!==n&&(Ea(to,t),Ea($s,n))}function oo(t){to.current===t&&(Na($s),Na(to))}var io=Ia(0);function lo(t){for(var e=t;null!==e;){if(13===e.tag){var n=e.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var co=[];function uo(){for(var t=0;t<co.length;t++)co[t]._workInProgressVersionPrimary=null;co.length=0}var ho=w.ReactCurrentDispatcher,po=w.ReactCurrentBatchConfig,fo=0,go=null,mo=null,bo=null,yo=!1,vo=!1,wo=0,xo=0;function ko(){throw Error(s(321))}function So(t,e){if(null===e)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!ir(t[n],e[n]))return!1;return!0}function Io(t,e,n,r,a,o){if(fo=o,go=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ho.current=null===t||null===t.memoizedState?ii:li,t=n(r,a),vo){o=0;do{if(vo=!1,wo=0,25<=o)throw Error(s(301));o+=1,bo=mo=null,e.updateQueue=null,ho.current=ci,t=n(r,a)}while(vo)}if(ho.current=oi,e=null!==mo&&null!==mo.next,fo=0,bo=mo=go=null,yo=!1,e)throw Error(s(300));return t}function No(){var t=0!==wo;return wo=0,t}function Eo(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===bo?go.memoizedState=bo=t:bo=bo.next=t,bo}function Co(){if(null===mo){var t=go.alternate;t=null!==t?t.memoizedState:null}else t=mo.next;var e=null===bo?go.memoizedState:bo.next;if(null!==e)bo=e,mo=t;else{if(null===t)throw Error(s(310));t={memoizedState:(mo=t).memoizedState,baseState:mo.baseState,baseQueue:mo.baseQueue,queue:mo.queue,next:null},null===bo?go.memoizedState=bo=t:bo=bo.next=t}return bo}function To(t,e){return"function"===typeof e?e(t):e}function Ao(t){var e=Co(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=mo,a=r.baseQueue,o=n.pending;if(null!==o){if(null!==a){var i=a.next;a.next=o.next,o.next=i}r.baseQueue=a=o,n.pending=null}if(null!==a){o=a.next,r=r.baseState;var l=i=null,c=null,u=o;do{var h=u.lane;if((fo&h)===h)null!==c&&(c=c.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:t(r,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===c?(l=c=d,i=r):c=c.next=d,go.lanes|=h,Ml|=h}u=u.next}while(null!==u&&u!==o);null===c?i=r:c.next=l,ir(r,e.memoizedState)||(wi=!0),e.memoizedState=r,e.baseState=i,e.baseQueue=c,n.lastRenderedState=r}if(null!==(t=n.interleaved)){a=t;do{o=a.lane,go.lanes|=o,Ml|=o,a=a.next}while(a!==t)}else null===a&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function Ro(t){var e=Co(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=n.dispatch,a=n.pending,o=e.memoizedState;if(null!==a){n.pending=null;var i=a=a.next;do{o=t(o,i.action),i=i.next}while(i!==a);ir(o,e.memoizedState)||(wi=!0),e.memoizedState=o,null===e.baseQueue&&(e.baseState=o),n.lastRenderedState=o}return[o,r]}function Fo(){}function _o(t,e){var n=go,r=Co(),a=e(),o=!ir(r.memoizedState,a);if(o&&(r.memoizedState=a,wi=!0),r=r.queue,Go(zo.bind(null,n,r,t),[t]),r.getSnapshot!==e||o||null!==bo&&1&bo.memoizedState.tag){if(n.flags|=2048,Bo(9,Oo.bind(null,n,r,a,e),void 0,null),null===Rl)throw Error(s(349));0!==(30&fo)||Do(n,e,a)}return a}function Do(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.stores=[t]):null===(n=e.stores)?e.stores=[t]:n.push(t)}function Oo(t,e,n,r){e.value=n,e.getSnapshot=r,Lo(e)&&Mo(t)}function zo(t,e,n){return n((function(){Lo(e)&&Mo(t)}))}function Lo(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ir(t,n)}catch(r){return!0}}function Mo(t){var e=As(t,1);null!==e&&rc(e,t,1,-1)}function Po(t){var e=Eo();return"function"===typeof t&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:To,lastRenderedState:t},e.queue=t,t=t.dispatch=ni.bind(null,go,t),[e.memoizedState,t]}function Bo(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.lastEffect=t.next=t):null===(n=e.lastEffect)?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t),t}function Wo(){return Co().memoizedState}function Uo(t,e,n,r){var a=Eo();go.flags|=t,a.memoizedState=Bo(1|e,n,void 0,void 0===r?null:r)}function Vo(t,e,n,r){var a=Co();r=void 0===r?null:r;var s=void 0;if(null!==mo){var o=mo.memoizedState;if(s=o.destroy,null!==r&&So(r,o.deps))return void(a.memoizedState=Bo(e,n,s,r))}go.flags|=t,a.memoizedState=Bo(1|e,n,s,r)}function jo(t,e){return Uo(8390656,8,t,e)}function Go(t,e){return Vo(2048,8,t,e)}function Ho(t,e){return Vo(4,2,t,e)}function Ko(t,e){return Vo(4,4,t,e)}function qo(t,e){return"function"===typeof e?(t=t(),e(t),function(){e(null)}):null!==e&&void 0!==e?(t=t(),e.current=t,function(){e.current=null}):void 0}function Xo(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Vo(4,4,qo.bind(null,e,t),n)}function Jo(){}function Yo(t,e){var n=Co();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function Zo(t,e){var n=Co();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function Qo(t,e,n){return 0===(21&fo)?(t.baseState&&(t.baseState=!1,wi=!0),t.memoizedState=n):(ir(n,e)||(n=ge(),go.lanes|=n,Ml|=n,t.baseState=!0),e)}function $o(t,e){var n=ve;ve=0!==n&&4>n?n:4,t(!0);var r=po.transition;po.transition={};try{t(!1),e()}finally{ve=n,po.transition=r}}function ti(){return Co().memoizedState}function ei(t,e,n){var r=nc(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},ri(t))ai(e,n);else if(null!==(n=Ts(t,e,n,r))){rc(n,t,r,ec()),si(n,e,r)}}function ni(t,e,n){var r=nc(t),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(ri(t))ai(e,a);else{var s=t.alternate;if(0===t.lanes&&(null===s||0===s.lanes)&&null!==(s=e.lastRenderedReducer))try{var o=e.lastRenderedState,i=s(o,n);if(a.hasEagerState=!0,a.eagerState=i,ir(i,o)){var l=e.interleaved;return null===l?(a.next=a,Cs(e)):(a.next=l.next,l.next=a),void(e.interleaved=a)}}catch(c){}null!==(n=Ts(t,e,a,r))&&(rc(n,t,r,a=ec()),si(n,e,r))}}function ri(t){var e=t.alternate;return t===go||null!==e&&e===go}function ai(t,e){vo=yo=!0;var n=t.pending;null===n?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function si(t,e,n){if(0!==(4194240&n)){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}var oi={readContext:Ns,useCallback:ko,useContext:ko,useEffect:ko,useImperativeHandle:ko,useInsertionEffect:ko,useLayoutEffect:ko,useMemo:ko,useReducer:ko,useRef:ko,useState:ko,useDebugValue:ko,useDeferredValue:ko,useTransition:ko,useMutableSource:ko,useSyncExternalStore:ko,useId:ko,unstable_isNewReconciler:!1},ii={readContext:Ns,useCallback:function(t,e){return Eo().memoizedState=[t,void 0===e?null:e],t},useContext:Ns,useEffect:jo,useImperativeHandle:function(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Uo(4194308,4,qo.bind(null,e,t),n)},useLayoutEffect:function(t,e){return Uo(4194308,4,t,e)},useInsertionEffect:function(t,e){return Uo(4,2,t,e)},useMemo:function(t,e){var n=Eo();return e=void 0===e?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=Eo();return e=void 0!==n?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=ei.bind(null,go,t),[r.memoizedState,t]},useRef:function(t){return t={current:t},Eo().memoizedState=t},useState:Po,useDebugValue:Jo,useDeferredValue:function(t){return Eo().memoizedState=t},useTransition:function(){var t=Po(!1),e=t[0];return t=$o.bind(null,t[1]),Eo().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=go,a=Eo();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=e(),null===Rl)throw Error(s(349));0!==(30&fo)||Do(r,e,n)}a.memoizedState=n;var o={value:n,getSnapshot:e};return a.queue=o,jo(zo.bind(null,r,o,t),[t]),r.flags|=2048,Bo(9,Oo.bind(null,r,o,n,e),void 0,null),n},useId:function(){var t=Eo(),e=Rl.identifierPrefix;if(as){var n=Za;e=":"+e+"R"+(n=(Ya&~(1<<32-oe(Ya)-1)).toString(32)+n),0<(n=wo++)&&(e+="H"+n.toString(32)),e+=":"}else e=":"+e+"r"+(n=xo++).toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},li={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:Go,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ao,useRef:Wo,useState:function(){return Ao(To)},useDebugValue:Jo,useDeferredValue:function(t){return Qo(Co(),mo.memoizedState,t)},useTransition:function(){return[Ao(To)[0],Co().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1},ci={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:Go,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ro,useRef:Wo,useState:function(){return Ro(To)},useDebugValue:Jo,useDeferredValue:function(t){var e=Co();return null===mo?e.memoizedState=t:Qo(e,mo.memoizedState,t)},useTransition:function(){return[Ro(To)[0],Co().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1};function ui(t,e){try{var n="",r=e;do{n+=U(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:t,source:e,stack:a,digest:null}}function hi(t,e,n){return{value:t,source:null,stack:null!=n?n:null,digest:null!=e?e:null}}function di(t,e){try{console.error(e.value)}catch(n){setTimeout((function(){throw n}))}}var pi="function"===typeof WeakMap?WeakMap:Map;function fi(t,e,n){(n=Ds(-1,n)).tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){Hl||(Hl=!0,Kl=r),di(0,e)},n}function gi(t,e,n){(n=Ds(-1,n)).tag=3;var r=t.type.getDerivedStateFromError;if("function"===typeof r){var a=e.value;n.payload=function(){return r(a)},n.callback=function(){di(0,e)}}var s=t.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){di(0,e),"function"!==typeof r&&(null===ql?ql=new Set([this]):ql.add(this));var t=e.stack;this.componentDidCatch(e.value,{componentStack:null!==t?t:""})}),n}function mi(t,e,n){var r=t.pingCache;if(null===r){r=t.pingCache=new pi;var a=new Set;r.set(e,a)}else void 0===(a=r.get(e))&&(a=new Set,r.set(e,a));a.has(n)||(a.add(n),t=Ec.bind(null,t,e,n),e.then(t,t))}function bi(t){do{var e;if((e=13===t.tag)&&(e=null===(e=t.memoizedState)||null!==e.dehydrated),e)return t;t=t.return}while(null!==t);return null}function yi(t,e,n,r,a){return 0===(1&t.mode)?(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((e=Ds(-1,1)).tag=2,Os(n,e,1))),n.lanes|=1),t):(t.flags|=65536,t.lanes=a,t)}var vi=w.ReactCurrentOwner,wi=!1;function xi(t,e,n,r){e.child=null===t?Zs(e,null,n,r):Ys(e,t.child,n,r)}function ki(t,e,n,r,a){n=n.render;var s=e.ref;return Is(e,a),r=Io(t,e,n,r,s,a),n=No(),null===t||wi?(as&&n&&ts(e),e.flags|=1,xi(t,e,r,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Si(t,e,n,r,a){if(null===t){var s=n.type;return"function"!==typeof s||Dc(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((t=zc(n.type,null,r,e,e.mode,a)).ref=e.ref,t.return=e,e.child=t):(e.tag=15,e.type=s,Ii(t,e,s,r,a))}if(s=t.child,0===(t.lanes&a)){var o=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(o,r)&&t.ref===e.ref)return Hi(t,e,a)}return e.flags|=1,(t=Oc(s,r)).ref=e.ref,t.return=e,e.child=t}function Ii(t,e,n,r,a){if(null!==t){var s=t.memoizedProps;if(lr(s,r)&&t.ref===e.ref){if(wi=!1,e.pendingProps=r=s,0===(t.lanes&a))return e.lanes=t.lanes,Hi(t,e,a);0!==(131072&t.flags)&&(wi=!0)}}return Ci(t,e,n,r,a)}function Ni(t,e,n){var r=e.pendingProps,a=r.children,s=null!==t?t.memoizedState:null;if("hidden"===r.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ea(Ol,Dl),Dl|=n;else{if(0===(1073741824&n))return t=null!==s?s.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Ea(Ol,Dl),Dl|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Ea(Ol,Dl),Dl|=r}else null!==s?(r=s.baseLanes|n,e.memoizedState=null):r=n,Ea(Ol,Dl),Dl|=r;return xi(t,e,a,n),e.child}function Ei(t,e){var n=e.ref;(null===t&&null!==n||null!==t&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function Ci(t,e,n,r,a){var s=_a(n)?Ra:Ta.current;return s=Fa(e,s),Is(e,a),n=Io(t,e,n,r,s,a),r=No(),null===t||wi?(as&&r&&ts(e),e.flags|=1,xi(t,e,n,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Ti(t,e,n,r,a){if(_a(n)){var s=!0;La(e)}else s=!1;if(Is(e,a),null===e.stateNode)Gi(t,e),js(e,n,r),Hs(e,n,r,a),r=!0;else if(null===t){var o=e.stateNode,i=e.memoizedProps;o.props=i;var l=o.context,c=n.contextType;"object"===typeof c&&null!==c?c=Ns(c):c=Fa(e,c=_a(n)?Ra:Ta.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof o.getSnapshotBeforeUpdate;h||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==r||l!==c)&&Gs(e,o,r,c),Rs=!1;var d=e.memoizedState;o.state=d,Ms(e,r,o,a),l=e.memoizedState,i!==r||d!==l||Aa.current||Rs?("function"===typeof u&&(Ws(e,n,u,r),l=e.memoizedState),(i=Rs||Vs(e,n,i,r,d,l,c))?(h||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(e.flags|=4194308)):("function"===typeof o.componentDidMount&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),o.props=r,o.state=l,o.context=c,r=i):("function"===typeof o.componentDidMount&&(e.flags|=4194308),r=!1)}else{o=e.stateNode,_s(t,e),i=e.memoizedProps,c=e.type===e.elementType?i:ms(e.type,i),o.props=c,h=e.pendingProps,d=o.context,"object"===typeof(l=n.contextType)&&null!==l?l=Ns(l):l=Fa(e,l=_a(n)?Ra:Ta.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==l)&&Gs(e,o,r,l),Rs=!1,d=e.memoizedState,o.state=d,Ms(e,r,o,a);var f=e.memoizedState;i!==h||d!==f||Aa.current||Rs?("function"===typeof p&&(Ws(e,n,p,r),f=e.memoizedState),(c=Rs||Vs(e,n,c,r,d,f,l)||!1)?(u||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(r,f,l),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof o.componentDidUpdate&&(e.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=f),o.props=r,o.state=f,o.context=l,r=c):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),r=!1)}return Ai(t,e,n,r,s,a)}function Ai(t,e,n,r,a,s){Ei(t,e);var o=0!==(128&e.flags);if(!r&&!o)return a&&Ma(e,n,!1),Hi(t,e,s);r=e.stateNode,vi.current=e;var i=o&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==t&&o?(e.child=Ys(e,t.child,null,s),e.child=Ys(e,null,i,s)):xi(t,e,i,s),e.memoizedState=r.state,a&&Ma(e,n,!0),e.child}function Ri(t){var e=t.stateNode;e.pendingContext?Oa(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Oa(0,e.context,!1),ro(t,e.containerInfo)}function Fi(t,e,n,r,a){return ps(),fs(a),e.flags|=256,xi(t,e,n,r),e.child}var _i,Di,Oi,zi,Li={dehydrated:null,treeContext:null,retryLane:0};function Mi(t){return{baseLanes:t,cachePool:null,transitions:null}}function Pi(t,e,n){var r,a=e.pendingProps,o=io.current,i=!1,l=0!==(128&e.flags);if((r=l)||(r=(null===t||null!==t.memoizedState)&&0!==(2&o)),r?(i=!0,e.flags&=-129):null!==t&&null===t.memoizedState||(o|=1),Ea(io,1&o),null===t)return cs(e),null!==(t=e.memoizedState)&&null!==(t=t.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===t.data?e.lanes=8:e.lanes=1073741824,null):(l=a.children,t=a.fallback,i?(a=e.mode,i=e.child,l={mode:"hidden",children:l},0===(1&a)&&null!==i?(i.childLanes=0,i.pendingProps=l):i=Mc(l,a,0,null),t=Lc(t,a,n,null),i.return=e,t.return=e,i.sibling=t,e.child=i,e.child.memoizedState=Mi(n),e.memoizedState=Li,t):Bi(e,l));if(null!==(o=t.memoizedState)&&null!==(r=o.dehydrated))return function(t,e,n,r,a,o,i){if(n)return 256&e.flags?(e.flags&=-257,Wi(t,e,i,r=hi(Error(s(422))))):null!==e.memoizedState?(e.child=t.child,e.flags|=128,null):(o=r.fallback,a=e.mode,r=Mc({mode:"visible",children:r.children},a,0,null),(o=Lc(o,a,i,null)).flags|=2,r.return=e,o.return=e,r.sibling=o,e.child=r,0!==(1&e.mode)&&Ys(e,t.child,null,i),e.child.memoizedState=Mi(i),e.memoizedState=Li,o);if(0===(1&e.mode))return Wi(t,e,i,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,Wi(t,e,i,r=hi(o=Error(s(419)),r,void 0))}if(l=0!==(i&t.childLanes),wi||l){if(null!==(r=Rl)){switch(i&-i){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|i))?0:a)&&a!==o.retryLane&&(o.retryLane=a,As(t,a),rc(r,t,a,-1))}return mc(),Wi(t,e,i,r=hi(Error(s(421))))}return"$?"===a.data?(e.flags|=128,e.child=t.child,e=Tc.bind(null,t),a._reactRetry=e,null):(t=o.treeContext,rs=ca(a.nextSibling),ns=e,as=!0,ss=null,null!==t&&(qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ya=t.id,Za=t.overflow,Ja=e),e=Bi(e,r.children),e.flags|=4096,e)}(t,e,l,a,r,o,n);if(i){i=a.fallback,l=e.mode,r=(o=t.child).sibling;var c={mode:"hidden",children:a.children};return 0===(1&l)&&e.child!==o?((a=e.child).childLanes=0,a.pendingProps=c,e.deletions=null):(a=Oc(o,c)).subtreeFlags=14680064&o.subtreeFlags,null!==r?i=Oc(r,i):(i=Lc(i,l,n,null)).flags|=2,i.return=e,a.return=e,a.sibling=i,e.child=a,a=i,i=e.child,l=null===(l=t.child.memoizedState)?Mi(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},i.memoizedState=l,i.childLanes=t.childLanes&~n,e.memoizedState=Li,a}return t=(i=t.child).sibling,a=Oc(i,{mode:"visible",children:a.children}),0===(1&e.mode)&&(a.lanes=n),a.return=e,a.sibling=null,null!==t&&(null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=a,e.memoizedState=null,a}function Bi(t,e){return(e=Mc({mode:"visible",children:e},t.mode,0,null)).return=t,t.child=e}function Wi(t,e,n,r){return null!==r&&fs(r),Ys(e,t.child,null,n),(t=Bi(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,t}function Ui(t,e,n){t.lanes|=e;var r=t.alternate;null!==r&&(r.lanes|=e),Ss(t.return,e,n)}function Vi(t,e,n,r,a){var s=t.memoizedState;null===s?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function ji(t,e,n){var r=e.pendingProps,a=r.revealOrder,s=r.tail;if(xi(t,e,r.children,n),0!==(2&(r=io.current)))r=1&r|2,e.flags|=128;else{if(null!==t&&0!==(128&t.flags))t:for(t=e.child;null!==t;){if(13===t.tag)null!==t.memoizedState&&Ui(t,n,e);else if(19===t.tag)Ui(t,n,e);else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break t;for(;null===t.sibling;){if(null===t.return||t.return===e)break t;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(Ea(io,r),0===(1&e.mode))e.memoizedState=null;else switch(a){case"forwards":for(n=e.child,a=null;null!==n;)null!==(t=n.alternate)&&null===lo(t)&&(a=n),n=n.sibling;null===(n=a)?(a=e.child,e.child=null):(a=n.sibling,n.sibling=null),Vi(e,!1,a,n,s);break;case"backwards":for(n=null,a=e.child,e.child=null;null!==a;){if(null!==(t=a.alternate)&&null===lo(t)){e.child=a;break}t=a.sibling,a.sibling=n,n=a,a=t}Vi(e,!0,n,null,s);break;case"together":Vi(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function Gi(t,e){0===(1&e.mode)&&null!==t&&(t.alternate=null,e.alternate=null,e.flags|=2)}function Hi(t,e,n){if(null!==t&&(e.dependencies=t.dependencies),Ml|=e.lanes,0===(n&e.childLanes))return null;if(null!==t&&e.child!==t.child)throw Error(s(153));if(null!==e.child){for(n=Oc(t=e.child,t.pendingProps),e.child=n,n.return=e;null!==t.sibling;)t=t.sibling,(n=n.sibling=Oc(t,t.pendingProps)).return=e;n.sibling=null}return e.child}function Ki(t,e){if(!as)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;null!==e;)null!==e.alternate&&(n=e),e=e.sibling;null===n?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?e||null===t.tail?t.tail=null:t.tail.sibling=null:r.sibling=null}}function qi(t){var e=null!==t.alternate&&t.alternate.child===t.child,n=0,r=0;if(e)for(var a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=t,a=a.sibling;else for(a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=t,a=a.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function Xi(t,e,n){var r=e.pendingProps;switch(es(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qi(e),null;case 1:case 17:return _a(e.type)&&Da(),qi(e),null;case 3:return r=e.stateNode,ao(),Na(Aa),Na(Ta),uo(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==t&&null!==t.child||(hs(e)?e.flags|=4:null===t||t.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ss&&(ic(ss),ss=null))),Di(t,e),qi(e),null;case 5:oo(e);var a=no(eo.current);if(n=e.type,null!==t&&null!=e.stateNode)Oi(t,e,n,r,a),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(null===e.stateNode)throw Error(s(166));return qi(e),null}if(t=no($s.current),hs(e)){r=e.stateNode,n=e.type;var o=e.memoizedProps;switch(r[da]=e,r[pa]=o,t=0!==(1&e.mode),n){case"dialog":Br("cancel",r),Br("close",r);break;case"iframe":case"object":case"embed":Br("load",r);break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],r);break;case"source":Br("error",r);break;case"img":case"image":case"link":Br("error",r),Br("load",r);break;case"details":Br("toggle",r);break;case"input":Y(r,o),Br("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},Br("invalid",r);break;case"textarea":at(r,o),Br("invalid",r)}for(var l in yt(n,o),a=null,o)if(o.hasOwnProperty(l)){var c=o[l];"children"===l?"string"===typeof c?r.textContent!==c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",c]):"number"===typeof c&&r.textContent!==""+c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",""+c]):i.hasOwnProperty(l)&&null!=c&&"onScroll"===l&&Br("scroll",r)}switch(n){case"input":K(r),$(r,o,!0);break;case"textarea":K(r),ot(r);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(r.onclick=$r)}r=a,e.updateQueue=r,null!==r&&(e.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===t&&(t=it(n)),"http://www.w3.org/1999/xhtml"===t?"script"===n?((t=l.createElement("div")).innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):"string"===typeof r.is?t=l.createElement(n,{is:r.is}):(t=l.createElement(n),"select"===n&&(l=t,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):t=l.createElementNS(t,n),t[da]=e,t[pa]=r,_i(t,e,!1,!1),e.stateNode=t;t:{switch(l=vt(n,r),n){case"dialog":Br("cancel",t),Br("close",t),a=r;break;case"iframe":case"object":case"embed":Br("load",t),a=r;break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],t);a=r;break;case"source":Br("error",t),a=r;break;case"img":case"image":case"link":Br("error",t),Br("load",t),a=r;break;case"details":Br("toggle",t),a=r;break;case"input":Y(t,r),a=J(t,r),Br("invalid",t);break;case"option":default:a=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},a=M({},r,{value:void 0}),Br("invalid",t);break;case"textarea":at(t,r),a=rt(t,r),Br("invalid",t)}for(o in yt(n,a),c=a)if(c.hasOwnProperty(o)){var u=c[o];"style"===o?mt(t,u):"dangerouslySetInnerHTML"===o?null!=(u=u?u.__html:void 0)&&ht(t,u):"children"===o?"string"===typeof u?("textarea"!==n||""!==u)&&dt(t,u):"number"===typeof u&&dt(t,""+u):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(i.hasOwnProperty(o)?null!=u&&"onScroll"===o&&Br("scroll",t):null!=u&&v(t,o,u,l))}switch(n){case"input":K(t),$(t,r,!1);break;case"textarea":K(t),ot(t);break;case"option":null!=r.value&&t.setAttribute("value",""+G(r.value));break;case"select":t.multiple=!!r.multiple,null!=(o=r.value)?nt(t,!!r.multiple,o,!1):null!=r.defaultValue&&nt(t,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(t.onclick=$r)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break t;case"img":r=!0;break t;default:r=!1}}r&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return qi(e),null;case 6:if(t&&null!=e.stateNode)zi(t,e,t.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(s(166));if(n=no(eo.current),no($s.current),hs(e)){if(r=e.stateNode,n=e.memoizedProps,r[da]=e,(o=r.nodeValue!==n)&&null!==(t=ns))switch(t.tag){case 3:Qr(r.nodeValue,n,0!==(1&t.mode));break;case 5:!0!==t.memoizedProps.suppressHydrationWarning&&Qr(r.nodeValue,n,0!==(1&t.mode))}o&&(e.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[da]=e,e.stateNode=r}return qi(e),null;case 13:if(Na(io),r=e.memoizedState,null===t||null!==t.memoizedState&&null!==t.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&e.mode)&&0===(128&e.flags))ds(),ps(),e.flags|=98560,o=!1;else if(o=hs(e),null!==r&&null!==r.dehydrated){if(null===t){if(!o)throw Error(s(318));if(!(o=null!==(o=e.memoizedState)?o.dehydrated:null))throw Error(s(317));o[da]=e}else ps(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;qi(e),o=!1}else null!==ss&&(ic(ss),ss=null),o=!0;if(!o)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=n,e):((r=null!==r)!==(null!==t&&null!==t.memoizedState)&&r&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===t||0!==(1&io.current)?0===zl&&(zl=3):mc())),null!==e.updateQueue&&(e.flags|=4),qi(e),null);case 4:return ao(),Di(t,e),null===t&&Vr(e.stateNode.containerInfo),qi(e),null;case 10:return ks(e.type._context),qi(e),null;case 19:if(Na(io),null===(o=e.memoizedState))return qi(e),null;if(r=0!==(128&e.flags),null===(l=o.rendering))if(r)Ki(o,!1);else{if(0!==zl||null!==t&&0!==(128&t.flags))for(t=e.child;null!==t;){if(null!==(l=lo(t))){for(e.flags|=128,Ki(o,!1),null!==(r=l.updateQueue)&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;null!==n;)t=r,(o=n).flags&=14680066,null===(l=o.alternate)?(o.childLanes=0,o.lanes=t,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=l.childLanes,o.lanes=l.lanes,o.child=l.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=l.memoizedProps,o.memoizedState=l.memoizedState,o.updateQueue=l.updateQueue,o.type=l.type,t=l.dependencies,o.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Ea(io,1&io.current|2),e.child}t=t.sibling}null!==o.tail&&Zt()>jl&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304)}else{if(!r)if(null!==(t=lo(l))){if(e.flags|=128,r=!0,null!==(n=t.updateQueue)&&(e.updateQueue=n,e.flags|=4),Ki(o,!0),null===o.tail&&"hidden"===o.tailMode&&!l.alternate&&!as)return qi(e),null}else 2*Zt()-o.renderingStartTime>jl&&1073741824!==n&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304);o.isBackwards?(l.sibling=e.child,e.child=l):(null!==(n=o.last)?n.sibling=l:e.child=l,o.last=l)}return null!==o.tail?(e=o.tail,o.rendering=e,o.tail=e.sibling,o.renderingStartTime=Zt(),e.sibling=null,n=io.current,Ea(io,r?1&n|2:1&n),e):(qi(e),null);case 22:case 23:return dc(),r=null!==e.memoizedState,null!==t&&null!==t.memoizedState!==r&&(e.flags|=8192),r&&0!==(1&e.mode)?0!==(1073741824&Dl)&&(qi(e),6&e.subtreeFlags&&(e.flags|=8192)):qi(e),null;case 24:case 25:return null}throw Error(s(156,e.tag))}function Ji(t,e){switch(es(e),e.tag){case 1:return _a(e.type)&&Da(),65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 3:return ao(),Na(Aa),Na(Ta),uo(),0!==(65536&(t=e.flags))&&0===(128&t)?(e.flags=-65537&t|128,e):null;case 5:return oo(e),null;case 13:if(Na(io),null!==(t=e.memoizedState)&&null!==t.dehydrated){if(null===e.alternate)throw Error(s(340));ps()}return 65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 19:return Na(io),null;case 4:return ao(),null;case 10:return ks(e.type._context),null;case 22:case 23:return dc(),null;default:return null}}_i=function(t,e){for(var n=e.child;null!==n;){if(5===n.tag||6===n.tag)t.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Di=function(){},Oi=function(t,e,n,r){var a=t.memoizedProps;if(a!==r){t=e.stateNode,no($s.current);var s,o=null;switch(n){case"input":a=J(t,a),r=J(t,r),o=[];break;case"select":a=M({},a,{value:void 0}),r=M({},r,{value:void 0}),o=[];break;case"textarea":a=rt(t,a),r=rt(t,r),o=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(t.onclick=$r)}for(u in yt(n,r),n=null,a)if(!r.hasOwnProperty(u)&&a.hasOwnProperty(u)&&null!=a[u])if("style"===u){var l=a[u];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in r){var c=r[u];if(l=null!=a?a[u]:void 0,r.hasOwnProperty(u)&&c!==l&&(null!=c||null!=l))if("style"===u)if(l){for(s in l)!l.hasOwnProperty(s)||c&&c.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in c)c.hasOwnProperty(s)&&l[s]!==c[s]&&(n||(n={}),n[s]=c[s])}else n||(o||(o=[]),o.push(u,n)),n=c;else"dangerouslySetInnerHTML"===u?(c=c?c.__html:void 0,l=l?l.__html:void 0,null!=c&&l!==c&&(o=o||[]).push(u,c)):"children"===u?"string"!==typeof c&&"number"!==typeof c||(o=o||[]).push(u,""+c):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=c&&"onScroll"===u&&Br("scroll",t),o||l===c||(o=[])):(o=o||[]).push(u,c))}n&&(o=o||[]).push("style",n);var u=o;(e.updateQueue=u)&&(e.flags|=4)}},zi=function(t,e,n,r){n!==r&&(e.flags|=4)};var Yi=!1,Zi=!1,Qi="function"===typeof WeakSet?WeakSet:Set,$i=null;function tl(t,e){var n=t.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Nc(t,e,r)}else n.current=null}function el(t,e,n){try{n()}catch(r){Nc(t,e,r)}}var nl=!1;function rl(t,e,n){var r=e.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&t)===t){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(e,n,s)}a=a.next}while(a!==r)}}function al(t,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function sl(t){var e=t.ref;if(null!==e){var n=t.stateNode;t.tag,t=n,"function"===typeof e?e(t):e.current=t}}function ol(t){var e=t.alternate;null!==e&&(t.alternate=null,ol(e)),t.child=null,t.deletions=null,t.sibling=null,5===t.tag&&(null!==(e=t.stateNode)&&(delete e[da],delete e[pa],delete e[ga],delete e[ma],delete e[ba])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function il(t){return 5===t.tag||3===t.tag||4===t.tag}function ll(t){t:for(;;){for(;null===t.sibling;){if(null===t.return||il(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue t;if(null===t.child||4===t.tag)continue t;t.child.return=t,t=t.child}if(!(2&t.flags))return t.stateNode}}function cl(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?8===n.nodeType?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(8===n.nodeType?(e=n.parentNode).insertBefore(t,n):(e=n).appendChild(t),null!==(n=n._reactRootContainer)&&void 0!==n||null!==e.onclick||(e.onclick=$r));else if(4!==r&&null!==(t=t.child))for(cl(t,e,n),t=t.sibling;null!==t;)cl(t,e,n),t=t.sibling}function ul(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(4!==r&&null!==(t=t.child))for(ul(t,e,n),t=t.sibling;null!==t;)ul(t,e,n),t=t.sibling}var hl=null,dl=!1;function pl(t,e,n){for(n=n.child;null!==n;)fl(t,e,n),n=n.sibling}function fl(t,e,n){if(se&&"function"===typeof se.onCommitFiberUnmount)try{se.onCommitFiberUnmount(ae,n)}catch(i){}switch(n.tag){case 5:Zi||tl(n,e);case 6:var r=hl,a=dl;hl=null,pl(t,e,n),dl=a,null!==(hl=r)&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?t.parentNode.removeChild(n):t.removeChild(n)):hl.removeChild(n.stateNode));break;case 18:null!==hl&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?la(t.parentNode,n):1===t.nodeType&&la(t,n),Ve(t)):la(hl,n.stateNode));break;case 4:r=hl,a=dl,hl=n.stateNode.containerInfo,dl=!0,pl(t,e,n),hl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Zi&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,o=s.destroy;s=s.tag,void 0!==o&&(0!==(2&s)||0!==(4&s))&&el(n,e,o),a=a.next}while(a!==r)}pl(t,e,n);break;case 1:if(!Zi&&(tl(n,e),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(i){Nc(n,e,i)}pl(t,e,n);break;case 21:pl(t,e,n);break;case 22:1&n.mode?(Zi=(r=Zi)||null!==n.memoizedState,pl(t,e,n),Zi=r):pl(t,e,n);break;default:pl(t,e,n)}}function gl(t){var e=t.updateQueue;if(null!==e){t.updateQueue=null;var n=t.stateNode;null===n&&(n=t.stateNode=new Qi),e.forEach((function(e){var r=Ac.bind(null,t,e);n.has(e)||(n.add(e),e.then(r,r))}))}}function ml(t,e){var n=e.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var o=t,i=e,l=i;t:for(;null!==l;){switch(l.tag){case 5:hl=l.stateNode,dl=!1;break t;case 3:case 4:hl=l.stateNode.containerInfo,dl=!0;break t}l=l.return}if(null===hl)throw Error(s(160));fl(o,i,a),hl=null,dl=!1;var c=a.alternate;null!==c&&(c.return=null),a.return=null}catch(u){Nc(a,e,u)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)bl(e,t),e=e.sibling}function bl(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(ml(e,t),yl(t),4&r){try{rl(3,t,t.return),al(3,t)}catch(m){Nc(t,t.return,m)}try{rl(5,t,t.return)}catch(m){Nc(t,t.return,m)}}break;case 1:ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return);break;case 5:if(ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return),32&t.flags){var a=t.stateNode;try{dt(a,"")}catch(m){Nc(t,t.return,m)}}if(4&r&&null!=(a=t.stateNode)){var o=t.memoizedProps,i=null!==n?n.memoizedProps:o,l=t.type,c=t.updateQueue;if(t.updateQueue=null,null!==c)try{"input"===l&&"radio"===o.type&&null!=o.name&&Z(a,o),vt(l,i);var u=vt(l,o);for(i=0;i<c.length;i+=2){var h=c[i],d=c[i+1];"style"===h?mt(a,d):"dangerouslySetInnerHTML"===h?ht(a,d):"children"===h?dt(a,d):v(a,h,d,u)}switch(l){case"input":Q(a,o);break;case"textarea":st(a,o);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!o.multiple;var f=o.value;null!=f?nt(a,!!o.multiple,f,!1):p!==!!o.multiple&&(null!=o.defaultValue?nt(a,!!o.multiple,o.defaultValue,!0):nt(a,!!o.multiple,o.multiple?[]:"",!1))}a[pa]=o}catch(m){Nc(t,t.return,m)}}break;case 6:if(ml(e,t),yl(t),4&r){if(null===t.stateNode)throw Error(s(162));a=t.stateNode,o=t.memoizedProps;try{a.nodeValue=o}catch(m){Nc(t,t.return,m)}}break;case 3:if(ml(e,t),yl(t),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ve(e.containerInfo)}catch(m){Nc(t,t.return,m)}break;case 4:default:ml(e,t),yl(t);break;case 13:ml(e,t),yl(t),8192&(a=t.child).flags&&(o=null!==a.memoizedState,a.stateNode.isHidden=o,!o||null!==a.alternate&&null!==a.alternate.memoizedState||(Vl=Zt())),4&r&&gl(t);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&t.mode?(Zi=(u=Zi)||h,ml(e,t),Zi=u):ml(e,t),yl(t),8192&r){if(u=null!==t.memoizedState,(t.stateNode.isHidden=u)&&!h&&0!==(1&t.mode))for($i=t,h=t.child;null!==h;){for(d=$i=h;null!==$i;){switch(f=(p=$i).child,p.tag){case 0:case 11:case 14:case 15:rl(4,p,p.return);break;case 1:tl(p,p.return);var g=p.stateNode;if("function"===typeof g.componentWillUnmount){r=p,n=p.return;try{e=r,g.props=e.memoizedProps,g.state=e.memoizedState,g.componentWillUnmount()}catch(m){Nc(r,n,m)}}break;case 5:tl(p,p.return);break;case 22:if(null!==p.memoizedState){kl(d);continue}}null!==f?(f.return=p,$i=f):kl(d)}h=h.sibling}t:for(h=null,d=t;;){if(5===d.tag){if(null===h){h=d;try{a=d.stateNode,u?"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none":(l=d.stateNode,i=void 0!==(c=d.memoizedProps.style)&&null!==c&&c.hasOwnProperty("display")?c.display:null,l.style.display=gt("display",i))}catch(m){Nc(t,t.return,m)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(m){Nc(t,t.return,m)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===t)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===t)break t;for(;null===d.sibling;){if(null===d.return||d.return===t)break t;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:ml(e,t),yl(t),4&r&&gl(t);case 21:}}function yl(t){var e=t.flags;if(2&e){try{t:{for(var n=t.return;null!==n;){if(il(n)){var r=n;break t}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(dt(a,""),r.flags&=-33),ul(t,ll(t),a);break;case 3:case 4:var o=r.stateNode.containerInfo;cl(t,ll(t),o);break;default:throw Error(s(161))}}catch(i){Nc(t,t.return,i)}t.flags&=-3}4096&e&&(t.flags&=-4097)}function vl(t,e,n){$i=t,wl(t,e,n)}function wl(t,e,n){for(var r=0!==(1&t.mode);null!==$i;){var a=$i,s=a.child;if(22===a.tag&&r){var o=null!==a.memoizedState||Yi;if(!o){var i=a.alternate,l=null!==i&&null!==i.memoizedState||Zi;i=Yi;var c=Zi;if(Yi=o,(Zi=l)&&!c)for($i=a;null!==$i;)l=(o=$i).child,22===o.tag&&null!==o.memoizedState?Sl(a):null!==l?(l.return=o,$i=l):Sl(a);for(;null!==s;)$i=s,wl(s,e,n),s=s.sibling;$i=a,Yi=i,Zi=c}xl(t)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,$i=s):xl(t)}}function xl(t){for(;null!==$i;){var e=$i;if(0!==(8772&e.flags)){var n=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Zi||al(5,e);break;case 1:var r=e.stateNode;if(4&e.flags&&!Zi)if(null===n)r.componentDidMount();else{var a=e.elementType===e.type?n.memoizedProps:ms(e.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var o=e.updateQueue;null!==o&&Ps(e,o,r);break;case 3:var i=e.updateQueue;if(null!==i){if(n=null,null!==e.child)switch(e.child.tag){case 5:case 1:n=e.child.stateNode}Ps(e,i,n)}break;case 5:var l=e.stateNode;if(null===n&&4&e.flags){n=l;var c=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var u=e.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Ve(d)}}}break;default:throw Error(s(163))}Zi||512&e.flags&&sl(e)}catch(p){Nc(e,e.return,p)}}if(e===t){$i=null;break}if(null!==(n=e.sibling)){n.return=e.return,$i=n;break}$i=e.return}}function kl(t){for(;null!==$i;){var e=$i;if(e===t){$i=null;break}var n=e.sibling;if(null!==n){n.return=e.return,$i=n;break}$i=e.return}}function Sl(t){for(;null!==$i;){var e=$i;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{al(4,e)}catch(l){Nc(e,n,l)}break;case 1:var r=e.stateNode;if("function"===typeof r.componentDidMount){var a=e.return;try{r.componentDidMount()}catch(l){Nc(e,a,l)}}var s=e.return;try{sl(e)}catch(l){Nc(e,s,l)}break;case 5:var o=e.return;try{sl(e)}catch(l){Nc(e,o,l)}}}catch(l){Nc(e,e.return,l)}if(e===t){$i=null;break}var i=e.sibling;if(null!==i){i.return=e.return,$i=i;break}$i=e.return}}var Il,Nl=Math.ceil,El=w.ReactCurrentDispatcher,Cl=w.ReactCurrentOwner,Tl=w.ReactCurrentBatchConfig,Al=0,Rl=null,Fl=null,_l=0,Dl=0,Ol=Ia(0),zl=0,Ll=null,Ml=0,Pl=0,Bl=0,Wl=null,Ul=null,Vl=0,jl=1/0,Gl=null,Hl=!1,Kl=null,ql=null,Xl=!1,Jl=null,Yl=0,Zl=0,Ql=null,$l=-1,tc=0;function ec(){return 0!==(6&Al)?Zt():-1!==$l?$l:$l=Zt()}function nc(t){return 0===(1&t.mode)?1:0!==(2&Al)&&0!==_l?_l&-_l:null!==gs.transition?(0===tc&&(tc=ge()),tc):0!==(t=ve)?t:t=void 0===(t=window.event)?16:Ye(t.type)}function rc(t,e,n,r){if(50<Zl)throw Zl=0,Ql=null,Error(s(185));be(t,n,r),0!==(2&Al)&&t===Rl||(t===Rl&&(0===(2&Al)&&(Pl|=n),4===zl&&lc(t,_l)),ac(t,r),1===n&&0===Al&&0===(1&e.mode)&&(jl=Zt()+500,Ba&&Va()))}function ac(t,e){var n=t.callbackNode;!function(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,a=t.expirationTimes,s=t.pendingLanes;0<s;){var o=31-oe(s),i=1<<o,l=a[o];-1===l?0!==(i&n)&&0===(i&r)||(a[o]=pe(i,e)):l<=e&&(t.expiredLanes|=i),s&=~i}}(t,e);var r=de(t,t===Rl?_l:0);if(0===r)null!==n&&Xt(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(null!=n&&Xt(n),1===e)0===t.tag?function(t){Ba=!0,Ua(t)}(cc.bind(null,t)):Ua(cc.bind(null,t)),oa((function(){0===(6&Al)&&Va()})),n=null;else{switch(we(r)){case 1:n=$t;break;case 4:n=te;break;case 16:default:n=ee;break;case 536870912:n=re}n=Rc(n,sc.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function sc(t,e){if($l=-1,tc=0,0!==(6&Al))throw Error(s(327));var n=t.callbackNode;if(Sc()&&t.callbackNode!==n)return null;var r=de(t,t===Rl?_l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&t.expiredLanes)||e)e=bc(t,r);else{e=r;var a=Al;Al|=2;var o=gc();for(Rl===t&&_l===e||(Gl=null,jl=Zt()+500,pc(t,e));;)try{vc();break}catch(l){fc(t,l)}xs(),El.current=o,Al=a,null!==Fl?e=0:(Rl=null,_l=0,e=zl)}if(0!==e){if(2===e&&(0!==(a=fe(t))&&(r=a,e=oc(t,a))),1===e)throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;if(6===e)lc(t,r);else{if(a=t.current.alternate,0===(30&r)&&!function(t){for(var e=t;;){if(16384&e.flags){var n=e.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!ir(s(),a))return!1}catch(i){return!1}}}if(n=e.child,16384&e.subtreeFlags&&null!==n)n.return=e,e=n;else{if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(a)&&(2===(e=bc(t,r))&&(0!==(o=fe(t))&&(r=o,e=oc(t,o))),1===e))throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;switch(t.finishedWork=a,t.finishedLanes=r,e){case 0:case 1:throw Error(s(345));case 2:case 5:kc(t,Ul,Gl);break;case 3:if(lc(t,r),(130023424&r)===r&&10<(e=Vl+500-Zt())){if(0!==de(t,0))break;if(((a=t.suspendedLanes)&r)!==r){ec(),t.pingedLanes|=t.suspendedLanes&a;break}t.timeoutHandle=ra(kc.bind(null,t,Ul,Gl),e);break}kc(t,Ul,Gl);break;case 4:if(lc(t,r),(4194240&r)===r)break;for(e=t.eventTimes,a=-1;0<r;){var i=31-oe(r);o=1<<i,(i=e[i])>a&&(a=i),r&=~o}if(r=a,10<(r=(120>(r=Zt()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Nl(r/1960))-r)){t.timeoutHandle=ra(kc.bind(null,t,Ul,Gl),r);break}kc(t,Ul,Gl);break;default:throw Error(s(329))}}}return ac(t,Zt()),t.callbackNode===n?sc.bind(null,t):null}function oc(t,e){var n=Wl;return t.current.memoizedState.isDehydrated&&(pc(t,e).flags|=256),2!==(t=bc(t,e))&&(e=Ul,Ul=n,null!==e&&ic(e)),t}function ic(t){null===Ul?Ul=t:Ul.push.apply(Ul,t)}function lc(t,e){for(e&=~Bl,e&=~Pl,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-oe(e),r=1<<n;t[n]=-1,e&=~r}}function cc(t){if(0!==(6&Al))throw Error(s(327));Sc();var e=de(t,0);if(0===(1&e))return ac(t,Zt()),null;var n=bc(t,e);if(0!==t.tag&&2===n){var r=fe(t);0!==r&&(e=r,n=oc(t,r))}if(1===n)throw n=Ll,pc(t,0),lc(t,e),ac(t,Zt()),n;if(6===n)throw Error(s(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,kc(t,Ul,Gl),ac(t,Zt()),null}function uc(t,e){var n=Al;Al|=1;try{return t(e)}finally{0===(Al=n)&&(jl=Zt()+500,Ba&&Va())}}function hc(t){null!==Jl&&0===Jl.tag&&0===(6&Al)&&Sc();var e=Al;Al|=1;var n=Tl.transition,r=ve;try{if(Tl.transition=null,ve=1,t)return t()}finally{ve=r,Tl.transition=n,0===(6&(Al=e))&&Va()}}function dc(){Dl=Ol.current,Na(Ol)}function pc(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(-1!==n&&(t.timeoutHandle=-1,aa(n)),null!==Fl)for(n=Fl.return;null!==n;){var r=n;switch(es(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:ao(),Na(Aa),Na(Ta),uo();break;case 5:oo(r);break;case 4:ao();break;case 13:case 19:Na(io);break;case 10:ks(r.type._context);break;case 22:case 23:dc()}n=n.return}if(Rl=t,Fl=t=Oc(t.current,null),_l=Dl=e,zl=0,Ll=null,Bl=Pl=Ml=0,Ul=Wl=null,null!==Es){for(e=0;e<Es.length;e++)if(null!==(r=(n=Es[e]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var o=s.next;s.next=a,r.next=o}n.pending=r}Es=null}return t}function fc(t,e){for(;;){var n=Fl;try{if(xs(),ho.current=oi,yo){for(var r=go.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}yo=!1}if(fo=0,bo=mo=go=null,vo=!1,wo=0,Cl.current=null,null===n||null===n.return){zl=1,Ll=e,Fl=null;break}t:{var o=t,i=n.return,l=n,c=e;if(e=_l,l.flags|=32768,null!==c&&"object"===typeof c&&"function"===typeof c.then){var u=c,h=l,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=bi(i);if(null!==f){f.flags&=-257,yi(f,i,l,0,e),1&f.mode&&mi(o,u,e),c=u;var g=(e=f).updateQueue;if(null===g){var m=new Set;m.add(c),e.updateQueue=m}else g.add(c);break t}if(0===(1&e)){mi(o,u,e),mc();break t}c=Error(s(426))}else if(as&&1&l.mode){var b=bi(i);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),yi(b,i,l,0,e),fs(ui(c,l));break t}}o=c=ui(c,l),4!==zl&&(zl=2),null===Wl?Wl=[o]:Wl.push(o),o=i;do{switch(o.tag){case 3:o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,fi(0,c,e));break t;case 1:l=c;var y=o.type,v=o.stateNode;if(0===(128&o.flags)&&("function"===typeof y.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===ql||!ql.has(v)))){o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,gi(o,l,e));break t}}o=o.return}while(null!==o)}xc(n)}catch(w){e=w,Fl===n&&null!==n&&(Fl=n=n.return);continue}break}}function gc(){var t=El.current;return El.current=oi,null===t?oi:t}function mc(){0!==zl&&3!==zl&&2!==zl||(zl=4),null===Rl||0===(268435455&Ml)&&0===(268435455&Pl)||lc(Rl,_l)}function bc(t,e){var n=Al;Al|=2;var r=gc();for(Rl===t&&_l===e||(Gl=null,pc(t,e));;)try{yc();break}catch(a){fc(t,a)}if(xs(),Al=n,El.current=r,null!==Fl)throw Error(s(261));return Rl=null,_l=0,zl}function yc(){for(;null!==Fl;)wc(Fl)}function vc(){for(;null!==Fl&&!Jt();)wc(Fl)}function wc(t){var e=Il(t.alternate,t,Dl);t.memoizedProps=t.pendingProps,null===e?xc(t):Fl=e,Cl.current=null}function xc(t){var e=t;do{var n=e.alternate;if(t=e.return,0===(32768&e.flags)){if(null!==(n=Xi(n,e,Dl)))return void(Fl=n)}else{if(null!==(n=Ji(n,e)))return n.flags&=32767,void(Fl=n);if(null===t)return zl=6,void(Fl=null);t.flags|=32768,t.subtreeFlags=0,t.deletions=null}if(null!==(e=e.sibling))return void(Fl=e);Fl=e=t}while(null!==e);0===zl&&(zl=5)}function kc(t,e,n){var r=ve,a=Tl.transition;try{Tl.transition=null,ve=1,function(t,e,n,r){do{Sc()}while(null!==Jl);if(0!==(6&Al))throw Error(s(327));n=t.finishedWork;var a=t.finishedLanes;if(null===n)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(s(177));t.callbackNode=null,t.callbackPriority=0;var o=n.lanes|n.childLanes;if(function(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var a=31-oe(n),s=1<<a;e[a]=0,r[a]=-1,t[a]=-1,n&=~s}}(t,o),t===Rl&&(Fl=Rl=null,_l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||Xl||(Xl=!0,Rc(ee,(function(){return Sc(),null}))),o=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||o){o=Tl.transition,Tl.transition=null;var i=ve;ve=1;var l=Al;Al|=4,Cl.current=null,function(t,e){if(ta=Ge,pr(t=dr())){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else t:{var r=(n=(n=t.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch(x){n=null;break t}var i=0,l=-1,c=-1,u=0,h=0,d=t,p=null;e:for(;;){for(var f;d!==n||0!==a&&3!==d.nodeType||(l=i+a),d!==o||0!==r&&3!==d.nodeType||(c=i+r),3===d.nodeType&&(i+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===t)break e;if(p===n&&++u===a&&(l=i),p===o&&++h===r&&(c=i),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===c?null:{start:l,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(ea={focusedElem:t,selectionRange:n},Ge=!1,$i=e;null!==$i;)if(t=(e=$i).child,0!==(1028&e.subtreeFlags)&&null!==t)t.return=e,$i=t;else for(;null!==$i;){e=$i;try{var g=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==g){var m=g.memoizedProps,b=g.memoizedState,y=e.stateNode,v=y.getSnapshotBeforeUpdate(e.elementType===e.type?m:ms(e.type,m),b);y.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var w=e.stateNode.containerInfo;1===w.nodeType?w.textContent="":9===w.nodeType&&w.documentElement&&w.removeChild(w.documentElement);break;default:throw Error(s(163))}}catch(x){Nc(e,e.return,x)}if(null!==(t=e.sibling)){t.return=e.return,$i=t;break}$i=e.return}g=nl,nl=!1}(t,n),bl(n,t),fr(ea),Ge=!!ta,ea=ta=null,t.current=n,vl(n,t,a),Yt(),Al=l,ve=i,Tl.transition=o}else t.current=n;if(Xl&&(Xl=!1,Jl=t,Yl=a),o=t.pendingLanes,0===o&&(ql=null),function(t){if(se&&"function"===typeof se.onCommitFiberRoot)try{se.onCommitFiberRoot(ae,t,void 0,128===(128&t.current.flags))}catch(e){}}(n.stateNode),ac(t,Zt()),null!==e)for(r=t.onRecoverableError,n=0;n<e.length;n++)a=e[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(Hl)throw Hl=!1,t=Kl,Kl=null,t;0!==(1&Yl)&&0!==t.tag&&Sc(),o=t.pendingLanes,0!==(1&o)?t===Ql?Zl++:(Zl=0,Ql=t):Zl=0,Va()}(t,e,n,r)}finally{Tl.transition=a,ve=r}return null}function Sc(){if(null!==Jl){var t=we(Yl),e=Tl.transition,n=ve;try{if(Tl.transition=null,ve=16>t?16:t,null===Jl)var r=!1;else{if(t=Jl,Jl=null,Yl=0,0!==(6&Al))throw Error(s(331));var a=Al;for(Al|=4,$i=t.current;null!==$i;){var o=$i,i=o.child;if(0!==(16&$i.flags)){var l=o.deletions;if(null!==l){for(var c=0;c<l.length;c++){var u=l[c];for($i=u;null!==$i;){var h=$i;switch(h.tag){case 0:case 11:case 15:rl(8,h,o)}var d=h.child;if(null!==d)d.return=h,$i=d;else for(;null!==$i;){var p=(h=$i).sibling,f=h.return;if(ol(h),h===u){$i=null;break}if(null!==p){p.return=f,$i=p;break}$i=f}}}var g=o.alternate;if(null!==g){var m=g.child;if(null!==m){g.child=null;do{var b=m.sibling;m.sibling=null,m=b}while(null!==m)}}$i=o}}if(0!==(2064&o.subtreeFlags)&&null!==i)i.return=o,$i=i;else t:for(;null!==$i;){if(0!==(2048&(o=$i).flags))switch(o.tag){case 0:case 11:case 15:rl(9,o,o.return)}var y=o.sibling;if(null!==y){y.return=o.return,$i=y;break t}$i=o.return}}var v=t.current;for($i=v;null!==$i;){var w=(i=$i).child;if(0!==(2064&i.subtreeFlags)&&null!==w)w.return=i,$i=w;else t:for(i=v;null!==$i;){if(0!==(2048&(l=$i).flags))try{switch(l.tag){case 0:case 11:case 15:al(9,l)}}catch(k){Nc(l,l.return,k)}if(l===i){$i=null;break t}var x=l.sibling;if(null!==x){x.return=l.return,$i=x;break t}$i=l.return}}if(Al=a,Va(),se&&"function"===typeof se.onPostCommitFiberRoot)try{se.onPostCommitFiberRoot(ae,t)}catch(k){}r=!0}return r}finally{ve=n,Tl.transition=e}}return!1}function Ic(t,e,n){t=Os(t,e=fi(0,e=ui(n,e),1),1),e=ec(),null!==t&&(be(t,1,e),ac(t,e))}function Nc(t,e,n){if(3===t.tag)Ic(t,t,n);else for(;null!==e;){if(3===e.tag){Ic(e,t,n);break}if(1===e.tag){var r=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===ql||!ql.has(r))){e=Os(e,t=gi(e,t=ui(n,t),1),1),t=ec(),null!==e&&(be(e,1,t),ac(e,t));break}}e=e.return}}function Ec(t,e,n){var r=t.pingCache;null!==r&&r.delete(e),e=ec(),t.pingedLanes|=t.suspendedLanes&n,Rl===t&&(_l&n)===n&&(4===zl||3===zl&&(130023424&_l)===_l&&500>Zt()-Vl?pc(t,0):Bl|=n),ac(t,e)}function Cc(t,e){0===e&&(0===(1&t.mode)?e=1:(e=ue,0===(130023424&(ue<<=1))&&(ue=4194304)));var n=ec();null!==(t=As(t,e))&&(be(t,e,n),ac(t,n))}function Tc(t){var e=t.memoizedState,n=0;null!==e&&(n=e.retryLane),Cc(t,n)}function Ac(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,a=t.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(e),Cc(t,n)}function Rc(t,e){return qt(t,e)}function Fc(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _c(t,e,n,r){return new Fc(t,e,n,r)}function Dc(t){return!(!(t=t.prototype)||!t.isReactComponent)}function Oc(t,e){var n=t.alternate;return null===n?((n=_c(t.tag,e,t.key,t.mode)).elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&t.flags,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function zc(t,e,n,r,a,o){var i=2;if(r=t,"function"===typeof t)Dc(t)&&(i=1);else if("string"===typeof t)i=5;else t:switch(t){case S:return Lc(n.children,a,o,e);case I:i=8,a|=8;break;case N:return(t=_c(12,n,e,2|a)).elementType=N,t.lanes=o,t;case A:return(t=_c(13,n,e,a)).elementType=A,t.lanes=o,t;case R:return(t=_c(19,n,e,a)).elementType=R,t.lanes=o,t;case D:return Mc(n,a,o,e);default:if("object"===typeof t&&null!==t)switch(t.$$typeof){case E:i=10;break t;case C:i=9;break t;case T:i=11;break t;case F:i=14;break t;case _:i=16,r=null;break t}throw Error(s(130,null==t?t:typeof t,""))}return(e=_c(i,n,e,a)).elementType=t,e.type=r,e.lanes=o,e}function Lc(t,e,n,r){return(t=_c(7,t,r,e)).lanes=n,t}function Mc(t,e,n,r){return(t=_c(22,t,r,e)).elementType=D,t.lanes=n,t.stateNode={isHidden:!1},t}function Pc(t,e,n){return(t=_c(6,t,null,e)).lanes=n,t}function Bc(t,e,n){return(e=_c(4,null!==t.children?t.children:[],t.key,e)).lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function Wc(t,e,n,r,a){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=me(0),this.expirationTimes=me(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=me(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Uc(t,e,n,r,a,s,o,i,l){return t=new Wc(t,e,n,i,l),1===e?(e=1,!0===s&&(e|=8)):e=0,s=_c(3,null,null,e),t.current=s,s.stateNode=t,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fs(s),t}function Vc(t){if(!t)return Ca;t:{if(Vt(t=t._reactInternals)!==t||1!==t.tag)throw Error(s(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break t;case 1:if(_a(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break t}}e=e.return}while(null!==e);throw Error(s(171))}if(1===t.tag){var n=t.type;if(_a(n))return za(t,n,e)}return e}function jc(t,e,n,r,a,s,o,i,l){return(t=Uc(n,r,!0,t,0,s,0,i,l)).context=Vc(null),n=t.current,(s=Ds(r=ec(),a=nc(n))).callback=void 0!==e&&null!==e?e:null,Os(n,s,a),t.current.lanes=a,be(t,a,r),ac(t,r),t}function Gc(t,e,n,r){var a=e.current,s=ec(),o=nc(a);return n=Vc(n),null===e.context?e.context=n:e.pendingContext=n,(e=Ds(s,o)).payload={element:t},null!==(r=void 0===r?null:r)&&(e.callback=r),null!==(t=Os(a,e,o))&&(rc(t,a,o,s),zs(t,a,o)),o}function Hc(t){return(t=t.current).child?(t.child.tag,t.child.stateNode):null}function Kc(t,e){if(null!==(t=t.memoizedState)&&null!==t.dehydrated){var n=t.retryLane;t.retryLane=0!==n&&n<e?n:e}}function qc(t,e){Kc(t,e),(t=t.alternate)&&Kc(t,e)}Il=function(t,e,n){if(null!==t)if(t.memoizedProps!==e.pendingProps||Aa.current)wi=!0;else{if(0===(t.lanes&n)&&0===(128&e.flags))return wi=!1,function(t,e,n){switch(e.tag){case 3:Ri(e),ps();break;case 5:so(e);break;case 1:_a(e.type)&&La(e);break;case 4:ro(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,a=e.memoizedProps.value;Ea(bs,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=e.memoizedState))return null!==r.dehydrated?(Ea(io,1&io.current),e.flags|=128,null):0!==(n&e.child.childLanes)?Pi(t,e,n):(Ea(io,1&io.current),null!==(t=Hi(t,e,n))?t.sibling:null);Ea(io,1&io.current);break;case 19:if(r=0!==(n&e.childLanes),0!==(128&t.flags)){if(r)return ji(t,e,n);e.flags|=128}if(null!==(a=e.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ea(io,io.current),r)break;return null;case 22:case 23:return e.lanes=0,Ni(t,e,n)}return Hi(t,e,n)}(t,e,n);wi=0!==(131072&t.flags)}else wi=!1,as&&0!==(1048576&e.flags)&&$a(e,Ka,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;Gi(t,e),t=e.pendingProps;var a=Fa(e,Ta.current);Is(e,n),a=Io(null,e,r,t,a,n);var o=No();return e.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,_a(r)?(o=!0,La(e)):o=!1,e.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Fs(e),a.updater=Us,e.stateNode=a,a._reactInternals=e,Hs(e,r,t,n),e=Ai(null,e,r,!0,o,n)):(e.tag=0,as&&o&&ts(e),xi(null,e,a,n),e=e.child),e;case 16:r=e.elementType;t:{switch(Gi(t,e),t=e.pendingProps,r=(a=r._init)(r._payload),e.type=r,a=e.tag=function(t){if("function"===typeof t)return Dc(t)?1:0;if(void 0!==t&&null!==t){if((t=t.$$typeof)===T)return 11;if(t===F)return 14}return 2}(r),t=ms(r,t),a){case 0:e=Ci(null,e,r,t,n);break t;case 1:e=Ti(null,e,r,t,n);break t;case 11:e=ki(null,e,r,t,n);break t;case 14:e=Si(null,e,r,ms(r.type,t),n);break t}throw Error(s(306,r,""))}return e;case 0:return r=e.type,a=e.pendingProps,Ci(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 1:return r=e.type,a=e.pendingProps,Ti(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 3:t:{if(Ri(e),null===t)throw Error(s(387));r=e.pendingProps,a=(o=e.memoizedState).element,_s(t,e),Ms(e,r,null,n);var i=e.memoizedState;if(r=i.element,o.isDehydrated){if(o={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},e.updateQueue.baseState=o,e.memoizedState=o,256&e.flags){e=Fi(t,e,r,n,a=ui(Error(s(423)),e));break t}if(r!==a){e=Fi(t,e,r,n,a=ui(Error(s(424)),e));break t}for(rs=ca(e.stateNode.containerInfo.firstChild),ns=e,as=!0,ss=null,n=Zs(e,null,r,n),e.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){e=Hi(t,e,n);break t}xi(t,e,r,n)}e=e.child}return e;case 5:return so(e),null===t&&cs(e),r=e.type,a=e.pendingProps,o=null!==t?t.memoizedProps:null,i=a.children,na(r,a)?i=null:null!==o&&na(r,o)&&(e.flags|=32),Ei(t,e),xi(t,e,i,n),e.child;case 6:return null===t&&cs(e),null;case 13:return Pi(t,e,n);case 4:return ro(e,e.stateNode.containerInfo),r=e.pendingProps,null===t?e.child=Ys(e,null,r,n):xi(t,e,r,n),e.child;case 11:return r=e.type,a=e.pendingProps,ki(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 7:return xi(t,e,e.pendingProps,n),e.child;case 8:case 12:return xi(t,e,e.pendingProps.children,n),e.child;case 10:t:{if(r=e.type._context,a=e.pendingProps,o=e.memoizedProps,i=a.value,Ea(bs,r._currentValue),r._currentValue=i,null!==o)if(ir(o.value,i)){if(o.children===a.children&&!Aa.current){e=Hi(t,e,n);break t}}else for(null!==(o=e.child)&&(o.return=e);null!==o;){var l=o.dependencies;if(null!==l){i=o.child;for(var c=l.firstContext;null!==c;){if(c.context===r){if(1===o.tag){(c=Ds(-1,n&-n)).tag=2;var u=o.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?c.next=c:(c.next=h.next,h.next=c),u.pending=c}}o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Ss(o.return,n,e),l.lanes|=n;break}c=c.next}}else if(10===o.tag)i=o.type===e.type?null:o.child;else if(18===o.tag){if(null===(i=o.return))throw Error(s(341));i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Ss(i,n,e),i=o.sibling}else i=o.child;if(null!==i)i.return=o;else for(i=o;null!==i;){if(i===e){i=null;break}if(null!==(o=i.sibling)){o.return=i.return,i=o;break}i=i.return}o=i}xi(t,e,a.children,n),e=e.child}return e;case 9:return a=e.type,r=e.pendingProps.children,Is(e,n),r=r(a=Ns(a)),e.flags|=1,xi(t,e,r,n),e.child;case 14:return a=ms(r=e.type,e.pendingProps),Si(t,e,r,a=ms(r.type,a),n);case 15:return Ii(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,a=e.pendingProps,a=e.elementType===r?a:ms(r,a),Gi(t,e),e.tag=1,_a(r)?(t=!0,La(e)):t=!1,Is(e,n),js(e,r,a),Hs(e,r,a,n),Ai(null,e,r,!0,t,n);case 19:return ji(t,e,n);case 22:return Ni(t,e,n)}throw Error(s(156,e.tag))};var Xc="function"===typeof reportError?reportError:function(t){console.error(t)};function Jc(t){this._internalRoot=t}function Yc(t){this._internalRoot=t}function Zc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)}function Qc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType&&(8!==t.nodeType||" react-mount-point-unstable "!==t.nodeValue))}function $c(){}function tu(t,e,n,r,a){var s=n._reactRootContainer;if(s){var o=s;if("function"===typeof a){var i=a;a=function(){var t=Hc(o);i.call(t)}}Gc(e,o,t,a)}else o=function(t,e,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var t=Hc(o);s.call(t)}}var o=jc(e,r,t,0,null,!1,0,"",$c);return t._reactRootContainer=o,t[fa]=o.current,Vr(8===t.nodeType?t.parentNode:t),hc(),o}for(;a=t.lastChild;)t.removeChild(a);if("function"===typeof r){var i=r;r=function(){var t=Hc(l);i.call(t)}}var l=Uc(t,0,!1,null,0,!1,0,"",$c);return t._reactRootContainer=l,t[fa]=l.current,Vr(8===t.nodeType?t.parentNode:t),hc((function(){Gc(e,l,n,r)})),l}(n,e,t,a,r);return Hc(o)}Yc.prototype.render=Jc.prototype.render=function(t){var e=this._internalRoot;if(null===e)throw Error(s(409));Gc(t,e,null,null)},Yc.prototype.unmount=Jc.prototype.unmount=function(){var t=this._internalRoot;if(null!==t){this._internalRoot=null;var e=t.containerInfo;hc((function(){Gc(null,t,null,null)})),e[fa]=null}},Yc.prototype.unstable_scheduleHydration=function(t){if(t){var e=Ie();t={blockedOn:null,target:t,priority:e};for(var n=0;n<De.length&&0!==e&&e<De[n].priority;n++);De.splice(n,0,t),0===n&&Me(t)}},xe=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=he(e.pendingLanes);0!==n&&(ye(e,1|n),ac(e,Zt()),0===(6&Al)&&(jl=Zt()+500,Va()))}break;case 13:hc((function(){var e=As(t,1);if(null!==e){var n=ec();rc(e,t,1,n)}})),qc(t,1)}},ke=function(t){if(13===t.tag){var e=As(t,134217728);if(null!==e)rc(e,t,134217728,ec());qc(t,134217728)}},Se=function(t){if(13===t.tag){var e=nc(t),n=As(t,e);if(null!==n)rc(n,t,e,ec());qc(t,e)}},Ie=function(){return ve},Ne=function(t,e){var n=ve;try{return ve=t,e()}finally{ve=n}},kt=function(t,e,n){switch(e){case"input":if(Q(t,n),e=n.name,"radio"===n.type&&null!=e){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var a=xa(r);if(!a)throw Error(s(90));q(r),Q(r,a)}}}break;case"textarea":st(t,n);break;case"select":null!=(e=n.value)&&nt(t,!!n.multiple,e,!1)}},Tt=uc,At=hc;var eu={usingClientEntryPoint:!1,Events:[va,wa,xa,Et,Ct,uc]},nu={findFiberByHostInstance:ya,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},ru={bundleType:nu.bundleType,version:nu.version,rendererPackageName:nu.rendererPackageName,rendererConfig:nu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:w.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return null===(t=Ht(t))?null:t.stateNode},findFiberByHostInstance:nu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{ae=au.inject(ru),se=au}catch(ut){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,e.createPortal=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Zc(e))throw Error(s(200));return function(t,e,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:t,containerInfo:e,implementation:n}}(t,e,null,n)},e.createRoot=function(t,e){if(!Zc(t))throw Error(s(299));var n=!1,r="",a=Xc;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(n=!0),void 0!==e.identifierPrefix&&(r=e.identifierPrefix),void 0!==e.onRecoverableError&&(a=e.onRecoverableError)),e=Uc(t,1,!1,null,0,n,0,r,a),t[fa]=e.current,Vr(8===t.nodeType?t.parentNode:t),new Jc(e)},e.findDOMNode=function(t){if(null==t)return null;if(1===t.nodeType)return t;var e=t._reactInternals;if(void 0===e){if("function"===typeof t.render)throw Error(s(188));throw t=Object.keys(t).join(","),Error(s(268,t))}return t=null===(t=Ht(e))?null:t.stateNode},e.flushSync=function(t){return hc(t)},e.hydrate=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!0,n)},e.hydrateRoot=function(t,e,n){if(!Zc(t))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,o="",i=Xc;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(o=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),e=jc(e,null,t,1,null!=n?n:null,a,0,o,i),t[fa]=e.current,Vr(t),r)for(t=0;t<r.length;t++)a=(a=(n=r[t])._getVersion)(n._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[n,a]:e.mutableSourceEagerHydrationData.push(n,a);return new Yc(e)},e.render=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!1,n)},e.unmountComponentAtNode=function(t){if(!Qc(t))throw Error(s(40));return!!t._reactRootContainer&&(hc((function(){tu(null,null,t,!1,(function(){t._reactRootContainer=null,t[fa]=null}))})),!0)},e.unstable_batchedUpdates=uc,e.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!Qc(n))throw Error(s(200));if(null==t||void 0===t._reactInternals)throw Error(s(38));return tu(t,e,n,!1,r)},e.version="18.2.0-next-9e3b772b8-20220608"},4391:(t,e,n)=>{"use strict";var r=n(7950);e.createRoot=r.createRoot,e.hydrateRoot=r.hydrateRoot},7950:(t,e,n)=>{"use strict";!function t(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}(),t.exports=n(2730)},1153:(t,e,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,i=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(t,e,n){var r,s={},c=null,u=null;for(r in void 0!==n&&(c=""+n),void 0!==e.key&&(c=""+e.key),void 0!==e.ref&&(u=e.ref),e)o.call(e,r)&&!l.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps)void 0===s[r]&&(s[r]=e[r]);return{$$typeof:a,type:t,key:c,ref:u,props:s,_owner:i.current}}e.Fragment=s,e.jsx=c,e.jsxs=c},4202:(t,e)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),l=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}function y(){}function v(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(t,e){if("object"!==typeof t&&"function"!==typeof t&&null!=t)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},b.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")},y.prototype=b.prototype;var w=v.prototype=new y;w.constructor=v,g(w,b.prototype),w.isPureReactComponent=!0;var x=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(t,e,r){var a,s={},o=null,i=null;if(null!=e)for(a in void 0!==e.ref&&(i=e.ref),void 0!==e.key&&(o=""+e.key),e)k.call(e,a)&&!I.hasOwnProperty(a)&&(s[a]=e[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var c=Array(l),u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}if(t&&t.defaultProps)for(a in l=t.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:t,key:o,ref:i,props:s,_owner:S.current}}function E(t){return"object"===typeof t&&null!==t&&t.$$typeof===n}var C=/\/+/g;function T(t,e){return"object"===typeof t&&null!==t&&null!=t.key?function(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,(function(t){return e[t]}))}(""+t.key):e.toString(36)}function A(t,e,a,s,o){var i=typeof t;"undefined"!==i&&"boolean"!==i||(t=null);var l=!1;if(null===t)l=!0;else switch(i){case"string":case"number":l=!0;break;case"object":switch(t.$$typeof){case n:case r:l=!0}}if(l)return o=o(l=t),t=""===s?"."+T(l,0):s,x(o)?(a="",null!=t&&(a=t.replace(C,"$&/")+"/"),A(o,e,a,"",(function(t){return t}))):null!=o&&(E(o)&&(o=function(t,e){return{$$typeof:n,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}(o,a+(!o.key||l&&l.key===o.key?"":(""+o.key).replace(C,"$&/")+"/")+t)),e.push(o)),1;if(l=0,s=""===s?".":s+":",x(t))for(var c=0;c<t.length;c++){var u=s+T(i=t[c],c);l+=A(i,e,a,u,o)}else if(u=function(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=p&&t[p]||t["@@iterator"])?t:null}(t),"function"===typeof u)for(t=u.call(t),c=0;!(i=t.next()).done;)l+=A(i=i.value,e,a,u=s+T(i,c++),o);else if("object"===i)throw e=String(t),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return l}function R(t,e,n){if(null==t)return t;var r=[],a=0;return A(t,r,"","",(function(t){return e.call(n,t,a++)})),r}function F(t){if(-1===t._status){var e=t._result;(e=e()).then((function(e){0!==t._status&&-1!==t._status||(t._status=1,t._result=e)}),(function(e){0!==t._status&&-1!==t._status||(t._status=2,t._result=e)})),-1===t._status&&(t._status=0,t._result=e)}if(1===t._status)return t._result.default;throw t._result}var _={current:null},D={transition:null},O={ReactCurrentDispatcher:_,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};e.Children={map:R,forEach:function(t,e,n){R(t,(function(){e.apply(this,arguments)}),n)},count:function(t){var e=0;return R(t,(function(){e++})),e},toArray:function(t){return R(t,(function(t){return t}))||[]},only:function(t){if(!E(t))throw Error("React.Children.only expected to receive a single React element child.");return t}},e.Component=b,e.Fragment=a,e.Profiler=o,e.PureComponent=v,e.StrictMode=s,e.Suspense=u,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,e.cloneElement=function(t,e,r){if(null===t||void 0===t)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var a=g({},t.props),s=t.key,o=t.ref,i=t._owner;if(null!=e){if(void 0!==e.ref&&(o=e.ref,i=S.current),void 0!==e.key&&(s=""+e.key),t.type&&t.type.defaultProps)var l=t.type.defaultProps;for(c in e)k.call(e,c)&&!I.hasOwnProperty(c)&&(a[c]=void 0===e[c]&&void 0!==l?l[c]:e[c])}var c=arguments.length-2;if(1===c)a.children=r;else if(1<c){l=Array(c);for(var u=0;u<c;u++)l[u]=arguments[u+2];a.children=l}return{$$typeof:n,type:t.type,key:s,ref:o,props:a,_owner:i}},e.createContext=function(t){return(t={$$typeof:l,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:t},t.Consumer=t},e.createElement=N,e.createFactory=function(t){var e=N.bind(null,t);return e.type=t,e},e.createRef=function(){return{current:null}},e.forwardRef=function(t){return{$$typeof:c,render:t}},e.isValidElement=E,e.lazy=function(t){return{$$typeof:d,_payload:{_status:-1,_result:t},_init:F}},e.memo=function(t,e){return{$$typeof:h,type:t,compare:void 0===e?null:e}},e.startTransition=function(t){var e=D.transition;D.transition={};try{t()}finally{D.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(t,e){return _.current.useCallback(t,e)},e.useContext=function(t){return _.current.useContext(t)},e.useDebugValue=function(){},e.useDeferredValue=function(t){return _.current.useDeferredValue(t)},e.useEffect=function(t,e){return _.current.useEffect(t,e)},e.useId=function(){return _.current.useId()},e.useImperativeHandle=function(t,e,n){return _.current.useImperativeHandle(t,e,n)},e.useInsertionEffect=function(t,e){return _.current.useInsertionEffect(t,e)},e.useLayoutEffect=function(t,e){return _.current.useLayoutEffect(t,e)},e.useMemo=function(t,e){return _.current.useMemo(t,e)},e.useReducer=function(t,e,n){return _.current.useReducer(t,e,n)},e.useRef=function(t){return _.current.useRef(t)},e.useState=function(t){return _.current.useState(t)},e.useSyncExternalStore=function(t,e,n){return _.current.useSyncExternalStore(t,e,n)},e.useTransition=function(){return _.current.useTransition()},e.version="18.2.0"},5043:(t,e,n)=>{"use strict";t.exports=n(4202)},579:(t,e,n)=>{"use strict";t.exports=n(1153)},7234:(t,e)=>{"use strict";function n(t,e){var n=t.length;t.push(e);t:for(;0<n;){var r=n-1>>>1,a=t[r];if(!(0<s(a,e)))break t;t[r]=e,t[n]=a,n=r}}function r(t){return 0===t.length?null:t[0]}function a(t){if(0===t.length)return null;var e=t[0],n=t.pop();if(n!==e){t[0]=n;t:for(var r=0,a=t.length,o=a>>>1;r<o;){var i=2*(r+1)-1,l=t[i],c=i+1,u=t[c];if(0>s(l,n))c<a&&0>s(u,l)?(t[r]=u,t[c]=n,r=c):(t[r]=l,t[i]=n,r=i);else{if(!(c<a&&0>s(u,n)))break t;t[r]=u,t[c]=n,r=c}}}return e}function s(t,e){var n=t.sortIndex-e.sortIndex;return 0!==n?n:t.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var o=performance;e.unstable_now=function(){return o.now()}}else{var i=Date,l=i.now();e.unstable_now=function(){return i.now()-l}}var c=[],u=[],h=1,d=null,p=3,f=!1,g=!1,m=!1,b="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function w(t){for(var e=r(u);null!==e;){if(null===e.callback)a(u);else{if(!(e.startTime<=t))break;a(u),e.sortIndex=e.expirationTime,n(c,e)}e=r(u)}}function x(t){if(m=!1,w(t),!g)if(null!==r(c))g=!0,D(k);else{var e=r(u);null!==e&&O(x,e.startTime-t)}}function k(t,n){g=!1,m&&(m=!1,y(E),E=-1),f=!0;var s=p;try{for(w(n),d=r(c);null!==d&&(!(d.expirationTime>n)||t&&!A());){var o=d.callback;if("function"===typeof o){d.callback=null,p=d.priorityLevel;var i=o(d.expirationTime<=n);n=e.unstable_now(),"function"===typeof i?d.callback=i:d===r(c)&&a(c),w(n)}else a(c);d=r(c)}if(null!==d)var l=!0;else{var h=r(u);null!==h&&O(x,h.startTime-n),l=!1}return l}finally{d=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,E=-1,C=5,T=-1;function A(){return!(e.unstable_now()-T<C)}function R(){if(null!==N){var t=e.unstable_now();T=t;var n=!0;try{n=N(!0,t)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"===typeof v)S=function(){v(R)};else if("undefined"!==typeof MessageChannel){var F=new MessageChannel,_=F.port2;F.port1.onmessage=R,S=function(){_.postMessage(null)}}else S=function(){b(R,0)};function D(t){N=t,I||(I=!0,S())}function O(t,n){E=b((function(){t(e.unstable_now())}),n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(t){t.callback=null},e.unstable_continueExecution=function(){g||f||(g=!0,D(k))},e.unstable_forceFrameRate=function(t){0>t||125<t?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<t?Math.floor(1e3/t):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(c)},e.unstable_next=function(t){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var n=p;p=e;try{return t()}finally{p=n}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(t,e){switch(t){case 1:case 2:case 3:case 4:case 5:break;default:t=3}var n=p;p=t;try{return e()}finally{p=n}},e.unstable_scheduleCallback=function(t,a,s){var o=e.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?o+s:o:s=o,t){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return t={id:h++,callback:a,priorityLevel:t,startTime:s,expirationTime:i=s+i,sortIndex:-1},s>o?(t.sortIndex=s,n(u,t),null===r(c)&&t===r(u)&&(m?(y(E),E=-1):m=!0,O(x,s-o))):(t.sortIndex=i,n(c,t),g||f||(g=!0,D(k))),t},e.unstable_shouldYield=A,e.unstable_wrapCallback=function(t){var e=p;return function(){var n=p;p=e;try{return t.apply(this,arguments)}finally{p=n}}}},8853:(t,e,n)=>{"use strict";t.exports=n(7234)},4334:(t,e,n)=>{var r=n(7359),a=n(7066),s=n(9016),o=n(9538),i=n(6288),l=n(5262),c=n(2430);c.alea=r,c.xor128=a,c.xorwow=s,c.xorshift7=o,c.xor4096=i,c.tychei=l,t.exports=c},7359:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n=function(){var t=4022871197,e=function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)};return e}();e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=n(" "),e.s1=n(" "),e.s2=n(" "),e.s0-=n(t),e.s0<0&&(e.s0+=1),e.s1-=n(t),e.s1<0&&(e.s1+=1),e.s2-=n(t),e.s2<0&&(e.s2+=1),n=null}function i(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},5262:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,a=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^a,e.a=a-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},7066:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},6288:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.w,a=e.X,s=e.i;return e.w=r=r+1640531527|0,n=a[s+34&127],t=a[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=a[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,a,s,o,i=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),a=0,s=-32;s<l;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(n=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(e&&e.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;t.w=o,t.X=i,t.i=a}(e,t)}function i(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},9538:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.x,a=e.i;return t=r[a],n=(t^=t>>>7)^t<<24,n^=(t=r[a+1&7])^t>>>10,n^=(t=r[a+3&7])^t>>>3,n^=(t=r[a+4&7])^t<<7,t=r[a+7&7],n^=(t^=t<<13)^t<<9,r[a]=n,e.i=a+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function i(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},9016:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},2430:function(t,e,n){var r;!function(a,s,o){var i,l=256,c=o.pow(l,6),u=o.pow(2,52),h=2*u,d=l-1;function p(t,e,n){var r=[],d=b(m((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return i&&(t=i.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),y(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&g(r,p),t.state=function(){return g(p,{})}),n?(o.random=t,e):t})(v,d,"global"in e?e.global:this==o,e.state)}function f(t){var e,n=t.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);a<l;)o[a]=a++;for(a=0;a<l;a++)o[a]=o[s=d&s+t[a%n]+(e=o[a])],o[s]=e;(r.g=function(t){for(var e,n=0,a=r.i,s=r.j,o=r.S;t--;)e=o[a=d&a+1],n=n*l+o[d&(o[a]=o[s=d&s+e])+(o[s]=e)];return r.i=a,r.j=s,n})(l)}function g(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function m(t,e){var n,r=[],a=typeof t;if(e&&"object"==a)for(n in t)try{r.push(m(t[n],e-1))}catch(s){}return r.length?r:"string"==a?t:t+"\0"}function b(t,e){for(var n,r=t+"",a=0;a<r.length;)e[d&a]=d&(n^=19*e[d&a])+r.charCodeAt(a++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(b(o.random(),s),t.exports){t.exports=p;try{i=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}("undefined"!==typeof self?self:this,[],Math)},5438:(t,e,n)=>{"use strict";var r=n(2),a=n(4992),s=n(2101)(),o=n(5558),i=n(4902),l=r("%Math.floor%");t.exports=function(t,e){if("function"!==typeof t)throw new i("`fn` is not a function");if("number"!==typeof e||e<0||e>4294967295||l(e)!==e)throw new i("`length` must be a positive 32-bit integer");var n=arguments.length>2&&!!arguments[2],r=!0,c=!0;if("length"in t&&o){var u=o(t,"length");u&&!u.configurable&&(r=!1),u&&!u.writable&&(c=!1)}return(r||c||!n)&&(s?a(t,"length",e,!0,!0):a(t,"length",e)),t}},5446:t=>{t.exports=function(t){return t&&"object"===typeof t&&"function"===typeof t.copy&&"function"===typeof t.fill&&"function"===typeof t.readUInt8}},9321:(t,e,n)=>{"use strict";var r=n(8317),a=n(1583),s=n(8004),o=n(9849);function i(t){return t.call.bind(t)}var l="undefined"!==typeof BigInt,c="undefined"!==typeof Symbol,u=i(Object.prototype.toString),h=i(Number.prototype.valueOf),d=i(String.prototype.valueOf),p=i(Boolean.prototype.valueOf);if(l)var f=i(BigInt.prototype.valueOf);if(c)var g=i(Symbol.prototype.valueOf);function m(t,e){if("object"!==typeof t)return!1;try{return e(t),!0}catch(n){return!1}}function b(t){return"[object Map]"===u(t)}function y(t){return"[object Set]"===u(t)}function v(t){return"[object WeakMap]"===u(t)}function w(t){return"[object WeakSet]"===u(t)}function x(t){return"[object ArrayBuffer]"===u(t)}function k(t){return"undefined"!==typeof ArrayBuffer&&(x.working?x(t):t instanceof ArrayBuffer)}function S(t){return"[object DataView]"===u(t)}function I(t){return"undefined"!==typeof DataView&&(S.working?S(t):t instanceof DataView)}e.isArgumentsObject=r,e.isGeneratorFunction=a,e.isTypedArray=o,e.isPromise=function(t){return"undefined"!==typeof Promise&&t instanceof Promise||null!==t&&"object"===typeof t&&"function"===typeof t.then&&"function"===typeof t.catch},e.isArrayBufferView=function(t){return"undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):o(t)||I(t)},e.isUint8Array=function(t){return"Uint8Array"===s(t)},e.isUint8ClampedArray=function(t){return"Uint8ClampedArray"===s(t)},e.isUint16Array=function(t){return"Uint16Array"===s(t)},e.isUint32Array=function(t){return"Uint32Array"===s(t)},e.isInt8Array=function(t){return"Int8Array"===s(t)},e.isInt16Array=function(t){return"Int16Array"===s(t)},e.isInt32Array=function(t){return"Int32Array"===s(t)},e.isFloat32Array=function(t){return"Float32Array"===s(t)},e.isFloat64Array=function(t){return"Float64Array"===s(t)},e.isBigInt64Array=function(t){return"BigInt64Array"===s(t)},e.isBigUint64Array=function(t){return"BigUint64Array"===s(t)},b.working="undefined"!==typeof Map&&b(new Map),e.isMap=function(t){return"undefined"!==typeof Map&&(b.working?b(t):t instanceof Map)},y.working="undefined"!==typeof Set&&y(new Set),e.isSet=function(t){return"undefined"!==typeof Set&&(y.working?y(t):t instanceof Set)},v.working="undefined"!==typeof WeakMap&&v(new WeakMap),e.isWeakMap=function(t){return"undefined"!==typeof WeakMap&&(v.working?v(t):t instanceof WeakMap)},w.working="undefined"!==typeof WeakSet&&w(new WeakSet),e.isWeakSet=function(t){return w(t)},x.working="undefined"!==typeof ArrayBuffer&&x(new ArrayBuffer),e.isArrayBuffer=k,S.working="undefined"!==typeof ArrayBuffer&&"undefined"!==typeof DataView&&S(new DataView(new ArrayBuffer(1),0,1)),e.isDataView=I;var N="undefined"!==typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function E(t){return"[object SharedArrayBuffer]"===u(t)}function C(t){return"undefined"!==typeof N&&("undefined"===typeof E.working&&(E.working=E(new N)),E.working?E(t):t instanceof N)}function T(t){return m(t,h)}function A(t){return m(t,d)}function R(t){return m(t,p)}function F(t){return l&&m(t,f)}function _(t){return c&&m(t,g)}e.isSharedArrayBuffer=C,e.isAsyncFunction=function(t){return"[object AsyncFunction]"===u(t)},e.isMapIterator=function(t){return"[object Map Iterator]"===u(t)},e.isSetIterator=function(t){return"[object Set Iterator]"===u(t)},e.isGeneratorObject=function(t){return"[object Generator]"===u(t)},e.isWebAssemblyCompiledModule=function(t){return"[object WebAssembly.Module]"===u(t)},e.isNumberObject=T,e.isStringObject=A,e.isBooleanObject=R,e.isBigIntObject=F,e.isSymbolObject=_,e.isBoxedPrimitive=function(t){return T(t)||A(t)||R(t)||F(t)||_(t)},e.isAnyArrayBuffer=function(t){return"undefined"!==typeof Uint8Array&&(k(t)||C(t))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(t){Object.defineProperty(e,t,{enumerable:!1,value:function(){throw new Error(t+" is not supported in userland")}})}))},6494:(t,e,n)=>{var r=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),n={},r=0;r<e.length;r++)n[e[r]]=Object.getOwnPropertyDescriptor(t,e[r]);return n},a=/%[sdj%]/g;e.format=function(t){if(!y(t)){for(var e=[],n=0;n<arguments.length;n++)e.push(l(arguments[n]));return e.join(" ")}n=1;for(var r=arguments,s=r.length,o=String(t).replace(a,(function(t){if("%%"===t)return"%";if(n>=s)return t;switch(t){case"%s":return String(r[n++]);case"%d":return Number(r[n++]);case"%j":try{return JSON.stringify(r[n++])}catch(e){return"[Circular]"}default:return t}})),i=r[n];n<s;i=r[++n])m(i)||!x(i)?o+=" "+i:o+=" "+l(i);return o},e.deprecate=function(t,n){if("undefined"!==typeof process&&!0===process.noDeprecation)return t;if("undefined"===typeof process)return function(){return e.deprecate(t,n).apply(this,arguments)};var r=!1;return function(){if(!r){if(process.throwDeprecation)throw new Error(n);process.traceDeprecation?console.trace(n):console.error(n),r=!0}return t.apply(this,arguments)}};var s={},o=/^$/;if({NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG){var i={NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG;i=i.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),o=new RegExp("^"+i+"$","i")}function l(t,n){var r={seen:[],stylize:u};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),g(n)?r.showHidden=n:n&&e._extend(r,n),v(r.showHidden)&&(r.showHidden=!1),v(r.depth)&&(r.depth=2),v(r.colors)&&(r.colors=!1),v(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=c),h(r,t,r.depth)}function c(t,e){var n=l.styles[e];return n?"\x1b["+l.colors[n][0]+"m"+t+"\x1b["+l.colors[n][1]+"m":t}function u(t,e){return t}function h(t,n,r){if(t.customInspect&&n&&I(n.inspect)&&n.inspect!==e.inspect&&(!n.constructor||n.constructor.prototype!==n)){var a=n.inspect(r,t);return y(a)||(a=h(t,a,r)),a}var s=function(t,e){if(v(e))return t.stylize("undefined","undefined");if(y(e)){var n="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(n,"string")}if(b(e))return t.stylize(""+e,"number");if(g(e))return t.stylize(""+e,"boolean");if(m(e))return t.stylize("null","null")}(t,n);if(s)return s;var o=Object.keys(n),i=function(t){var e={};return t.forEach((function(t,n){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(n)),S(n)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return d(n);if(0===o.length){if(I(n)){var l=n.name?": "+n.name:"";return t.stylize("[Function"+l+"]","special")}if(w(n))return t.stylize(RegExp.prototype.toString.call(n),"regexp");if(k(n))return t.stylize(Date.prototype.toString.call(n),"date");if(S(n))return d(n)}var c,u="",x=!1,N=["{","}"];(f(n)&&(x=!0,N=["[","]"]),I(n))&&(u=" [Function"+(n.name?": "+n.name:"")+"]");return w(n)&&(u=" "+RegExp.prototype.toString.call(n)),k(n)&&(u=" "+Date.prototype.toUTCString.call(n)),S(n)&&(u=" "+d(n)),0!==o.length||x&&0!=n.length?r<0?w(n)?t.stylize(RegExp.prototype.toString.call(n),"regexp"):t.stylize("[Object]","special"):(t.seen.push(n),c=x?function(t,e,n,r,a){for(var s=[],o=0,i=e.length;o<i;++o)T(e,String(o))?s.push(p(t,e,n,r,String(o),!0)):s.push("");return a.forEach((function(a){a.match(/^\d+$/)||s.push(p(t,e,n,r,a,!0))})),s}(t,n,r,i,o):o.map((function(e){return p(t,n,r,i,e,x)})),t.seen.pop(),function(t,e,n){var r=t.reduce((function(t,e){return e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0);if(r>60)return n[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+n[1];return n[0]+e+" "+t.join(", ")+" "+n[1]}(c,u,N)):N[0]+u+N[1]}function d(t){return"["+Error.prototype.toString.call(t)+"]"}function p(t,e,n,r,a,s){var o,i,l;if((l=Object.getOwnPropertyDescriptor(e,a)||{value:e[a]}).get?i=l.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):l.set&&(i=t.stylize("[Setter]","special")),T(r,a)||(o="["+a+"]"),i||(t.seen.indexOf(l.value)<0?(i=m(n)?h(t,l.value,null):h(t,l.value,n-1)).indexOf("\n")>-1&&(i=s?i.split("\n").map((function(t){return"  "+t})).join("\n").slice(2):"\n"+i.split("\n").map((function(t){return"   "+t})).join("\n")):i=t.stylize("[Circular]","special")),v(o)){if(s&&a.match(/^\d+$/))return i;(o=JSON.stringify(""+a)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.slice(1,-1),o=t.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=t.stylize(o,"string"))}return o+": "+i}function f(t){return Array.isArray(t)}function g(t){return"boolean"===typeof t}function m(t){return null===t}function b(t){return"number"===typeof t}function y(t){return"string"===typeof t}function v(t){return void 0===t}function w(t){return x(t)&&"[object RegExp]"===N(t)}function x(t){return"object"===typeof t&&null!==t}function k(t){return x(t)&&"[object Date]"===N(t)}function S(t){return x(t)&&("[object Error]"===N(t)||t instanceof Error)}function I(t){return"function"===typeof t}function N(t){return Object.prototype.toString.call(t)}function E(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(t){if(t=t.toUpperCase(),!s[t])if(o.test(t)){var n=process.pid;s[t]=function(){var r=e.format.apply(e,arguments);console.error("%s %d: %s",t,n,r)}}else s[t]=function(){};return s[t]},e.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.types=n(9321),e.isArray=f,e.isBoolean=g,e.isNull=m,e.isNullOrUndefined=function(t){return null==t},e.isNumber=b,e.isString=y,e.isSymbol=function(t){return"symbol"===typeof t},e.isUndefined=v,e.isRegExp=w,e.types.isRegExp=w,e.isObject=x,e.isDate=k,e.types.isDate=k,e.isError=S,e.types.isNativeError=S,e.isFunction=I,e.isPrimitive=function(t){return null===t||"boolean"===typeof t||"number"===typeof t||"string"===typeof t||"symbol"===typeof t||"undefined"===typeof t},e.isBuffer=n(5446);var C=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function T(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){console.log("%s - %s",function(){var t=new Date,e=[E(t.getHours()),E(t.getMinutes()),E(t.getSeconds())].join(":");return[t.getDate(),C[t.getMonth()],e].join(" ")}(),e.format.apply(e,arguments))},e.inherits=n(6329),e._extend=function(t,e){if(!e||!x(e))return t;for(var n=Object.keys(e),r=n.length;r--;)t[n[r]]=e[n[r]];return t};var A="undefined"!==typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(t,e){if(!t){var n=new Error("Promise was rejected with a falsy value");n.reason=t,t=n}return e(t)}e.promisify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');if(A&&t[A]){var e;if("function"!==typeof(e=t[A]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,n,r=new Promise((function(t,r){e=t,n=r})),a=[],s=0;s<arguments.length;s++)a.push(arguments[s]);a.push((function(t,r){t?n(t):e(r)}));try{t.apply(this,a)}catch(o){n(o)}return r}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),A&&Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,r(t))},e.promisify.custom=A,e.callbackify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');function e(){for(var e=[],n=0;n<arguments.length;n++)e.push(arguments[n]);var r=e.pop();if("function"!==typeof r)throw new TypeError("The last argument must be of type Function");var a=this,s=function(){return r.apply(a,arguments)};t.apply(this,e).then((function(t){process.nextTick(s.bind(null,null,t))}),(function(t){process.nextTick(R.bind(null,t,s))}))}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),Object.defineProperties(e,r(t)),e}},8004:(t,e,n)=>{"use strict";var r=n(1903),a=n(2936),s=n(1712),o=n(2028),i=n(5558),l=o("Object.prototype.toString"),c=n(4635)(),u="undefined"===typeof globalThis?n.g:globalThis,h=a(),d=o("String.prototype.slice"),p=Object.getPrototypeOf,f=o("Array.prototype.indexOf",!0)||function(t,e){for(var n=0;n<t.length;n+=1)if(t[n]===e)return n;return-1},g={__proto__:null};r(h,c&&i&&p?function(t){var e=new u[t];if(Symbol.toStringTag in e){var n=p(e),r=i(n,Symbol.toStringTag);if(!r){var a=p(n);r=i(a,Symbol.toStringTag)}g["$"+t]=s(r.get)}}:function(t){var e=new u[t],n=e.slice||e.set;n&&(g["$"+t]=s(n))});t.exports=function(t){if(!t||"object"!==typeof t)return!1;if(!c){var e=d(l(t),8,-1);return f(h,e)>-1?e:"Object"===e&&function(t){var e=!1;return r(g,(function(n,r){if(!e)try{n(t),e=d(r,1)}catch(a){}})),e}(t)}return i?function(t){var e=!1;return r(g,(function(n,r){if(!e)try{"$"+n(t)===r&&(e=d(r,1))}catch(a){}})),e}(t):null}},7571:()=>{},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},7078:()=>{},6905:()=>{},4637:()=>{},279:()=>{},4222:()=>{},1234:()=>{},2936:(t,e,n)=>{"use strict";var r=n(7163),a="undefined"===typeof globalThis?n.g:globalThis;t.exports=function(){for(var t=[],e=0;e<r.length;e++)"function"===typeof a[r[e]]&&(t[t.length]=r[e]);return t}}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var s=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},(()=>{var t,e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var o={};t=t||[null,e({}),e([]),e(e)];for(var i=2&a&&r;"object"==typeof i&&!~t.indexOf(i);i=e(i))Object.getOwnPropertyNames(i).forEach((t=>o[t]=()=>r[t]));return o.default=()=>r,n.d(s,o),s}})(),n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"===typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),n.p="/supercircle/",(()=>{"use strict";var t={};n.r(t),n.d(t,{assertParamsValid:()=>tN,computeFlatOffset:()=>pN,computeOutShape:()=>nN,getNormalizedAxes:()=>oN,isSliceContinous:()=>dN,maskToAxes:()=>eN,parseSliceParams:()=>fN,sliceInfo:()=>gN,startForAxis:()=>uN,startIndicesWithElidedDims:()=>iN,stopForAxis:()=>hN,stopIndicesWithElidedDims:()=>lN,stridesForAxis:()=>cN,stridesWithElidedDims:()=>rN});var e={};n.r(e),n.d(e,{collectGatherOpShapeInfo:()=>FA,computeOutShape:()=>RA,segOpComputeOptimalWindowSize:()=>AA});var r={};n.r(r),n.d(r,{ERF_A1:()=>qT,ERF_A2:()=>XT,ERF_A3:()=>JT,ERF_A4:()=>YT,ERF_A5:()=>ZT,ERF_P:()=>KT,PARALLELIZE_THRESHOLD:()=>_T,RowPartitionType:()=>CT,SELU_SCALE:()=>HT,SELU_SCALEALPHA:()=>GT,applyActivation:()=>RC,assertAndGetBroadcastShape:()=>MI,assertAxesAreInnerMostDims:()=>IE,assertParamsConsistent:()=>NT,assignToTypedArray:()=>rA,axesAreInnerMostDims:()=>wE,calculateShapes:()=>jT,checkEinsumDimSizes:()=>dA,checkPadOnDimRoundingMode:()=>ON,combineLocations:()=>xE,combineRaggedTensorToTensorShapes:()=>TT,complexWithEvenIndex:()=>tA,complexWithOddIndex:()=>eA,computeConv2DInfo:()=>SN,computeConv3DInfo:()=>IN,computeDefaultPad:()=>NN,computeDilation2DInfo:()=>wN,computeOptimalWindowSize:()=>DT,computeOutAndReduceShapes:()=>kE,computeOutShape:()=>ET,computePool2DInfo:()=>xN,computePool3DInfo:()=>kN,convertConv2DDataFormat:()=>DN,decodeEinsumEquation:()=>uA,eitherStridesOrDilationsAreOne:()=>FN,expandShapeToKeepDim:()=>SE,exponent:()=>sA,exponents:()=>aA,fromStringArrayToUint8:()=>DA,fromUint8ToStringArray:()=>_A,getAxesPermutation:()=>NE,getBroadcastDims:()=>zI,getComplexWithIndex:()=>nA,getEinsumComputePath:()=>pA,getEinsumPermutation:()=>hA,getFusedBiasGradient:()=>AC,getFusedDyActivation:()=>TC,getImageCenter:()=>OT,getInnerMostAxes:()=>CE,getPermuted:()=>LT,getRaggedRank:()=>RT,getReductionAxes:()=>LI,getReshaped:()=>zT,getReshapedPermuted:()=>MT,getRowPartitionTypesHelper:()=>AT,getSliceBeginCoords:()=>PT,getSliceSize:()=>BT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>bA,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>yA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>vA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>kA,getSparseReshapeInputOutputMismatchErrorMessage:()=>IA,getSparseReshapeInputOutputMultipleErrorMessage:()=>SA,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>wA,getSparseReshapeNegativeOutputDimErrorMessage:()=>xA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>TA,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>NA,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>EA,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>CA,getUndoAxesPermutation:()=>EE,isIdentityPermutation:()=>fA,log:()=>Kx,mergeRealAndImagArrays:()=>QT,prepareAndValidate:()=>WT,prepareSplitSize:()=>mA,segment_util:()=>e,shouldFuse:()=>FC,slice_util:()=>t,splitRealAndImagArrays:()=>$T,stridesOrDilationsArePositive:()=>_N,tupleValuesAreOne:()=>RN,upcastType:()=>Kk,validateDefaultValueShape:()=>FT,validateInput:()=>VT,validateUpdateShape:()=>UT,warn:()=>Hx});var a={};n.r(a),n.d(a,{addImpl:()=>wB,bincountImpl:()=>dW,bincountReduceImpl:()=>pW,bitwiseAndImpl:()=>gW,castImpl:()=>gB,ceilImpl:()=>yW,concatImpl:()=>IW,equalImpl:()=>lU,expImpl:()=>vU,expm1Impl:()=>IU,floorImpl:()=>UU,gatherNdImpl:()=>JU,gatherV2Impl:()=>ZU,greaterEqualImpl:()=>nV,greaterImpl:()=>$U,lessEqualImpl:()=>gV,lessImpl:()=>dV,linSpaceImpl:()=>yV,logImpl:()=>wV,maxImpl:()=>zV,maximumImpl:()=>PV,minimumImpl:()=>XV,multiplyImpl:()=>tU,negImpl:()=>aj,notEqualImpl:()=>dj,prodImpl:()=>Nj,raggedGatherImpl:()=>Rj,raggedRangeImpl:()=>Dj,raggedTensorToTensorImpl:()=>Bj,rangeImpl:()=>Uj,rsqrtImpl:()=>$j,scatterImpl:()=>nG,sigmoidImpl:()=>oB,simpleAbsImpl:()=>AB,sliceImpl:()=>lW,sparseFillEmptyRowsImpl:()=>kG,sparseReshapeImpl:()=>IG,sparseSegmentReductionImpl:()=>EG,sqrtImpl:()=>FG,staticRegexReplaceImpl:()=>PG,stridedSliceImpl:()=>jG,stringNGramsImpl:()=>KG,stringSplitImpl:()=>JG,stringToHashBucketFastImpl:()=>ZG,subImpl:()=>RU,tileImpl:()=>rH,topKImpl:()=>iH,transposeImpl:()=>LB,uniqueImpl:()=>fH});var s,o=n(5043),i=n.t(o,2),l=n(4391),c=n(7950),u=n.t(c,2);function h(){return h=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},h.apply(this,arguments)}!function(t){t.Pop="POP",t.Push="PUSH",t.Replace="REPLACE"}(s||(s={}));const d="popstate";function p(t,e){if(!1===t||null===t||"undefined"===typeof t)throw new Error(e)}function f(t,e){if(!t){"undefined"!==typeof console&&console.warn(e);try{throw new Error(e)}catch(n){}}}function g(t,e){return{usr:t.state,key:t.key,idx:e}}function m(t,e,n,r){return void 0===n&&(n=null),h({pathname:"string"===typeof t?t:t.pathname,search:"",hash:""},"string"===typeof e?y(e):e,{state:n,key:e&&e.key||r||Math.random().toString(36).substr(2,8)})}function b(t){let{pathname:e="/",search:n="",hash:r=""}=t;return n&&"?"!==n&&(e+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(e+="#"===r.charAt(0)?r:"#"+r),e}function y(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let r=t.indexOf("?");r>=0&&(e.search=t.substr(r),t=t.substr(0,r)),t&&(e.pathname=t)}return e}function v(t,e,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:o=!1}=r,i=a.history,l=s.Pop,c=null,u=f();function f(){return(i.state||{idx:null}).idx}function y(){l=s.Pop;let t=f(),e=null==t?null:t-u;u=t,c&&c({action:l,location:w.location,delta:e})}function v(t){let e="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof t?t:b(t);return n=n.replace(/ $/,"%20"),p(e,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,e)}null==u&&(u=0,i.replaceState(h({},i.state,{idx:u}),""));let w={get action(){return l},get location(){return t(a,i)},listen(t){if(c)throw new Error("A history only accepts one active listener");return a.addEventListener(d,y),c=t,()=>{a.removeEventListener(d,y),c=null}},createHref:t=>e(a,t),createURL:v,encodeLocation(t){let e=v(t);return{pathname:e.pathname,search:e.search,hash:e.hash}},push:function(t,e){l=s.Push;let r=m(w.location,t,e);n&&n(r,t),u=f()+1;let h=g(r,u),d=w.createHref(r);try{i.pushState(h,"",d)}catch(p){if(p instanceof DOMException&&"DataCloneError"===p.name)throw p;a.location.assign(d)}o&&c&&c({action:l,location:w.location,delta:1})},replace:function(t,e){l=s.Replace;let r=m(w.location,t,e);n&&n(r,t),u=f();let a=g(r,u),h=w.createHref(r);i.replaceState(a,"",h),o&&c&&c({action:l,location:w.location,delta:0})},go:t=>i.go(t)};return w}var w;!function(t){t.data="data",t.deferred="deferred",t.redirect="redirect",t.error="error"}(w||(w={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function x(t,e,n){void 0===n&&(n="/");let r=z(("string"===typeof e?y(e):e).pathname||"/",n);if(null==r)return null;let a=k(t);!function(t){t.sort(((t,e)=>t.score!==e.score?e.score-t.score:function(t,e){let n=t.length===e.length&&t.slice(0,-1).every(((t,n)=>t===e[n]));return n?t[t.length-1]-e[e.length-1]:0}(t.routesMeta.map((t=>t.childrenIndex)),e.routesMeta.map((t=>t.childrenIndex)))))}(a);let s=null;for(let o=0;null==s&&o<a.length;++o){let t=O(r);s=_(a[o],t)}return s}function k(t,e,n,r){void 0===e&&(e=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(t,a,s)=>{let o={relativePath:void 0===s?t.path||"":s,caseSensitive:!0===t.caseSensitive,childrenIndex:a,route:t};o.relativePath.startsWith("/")&&(p(o.relativePath.startsWith(r),'Absolute route path "'+o.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),o.relativePath=o.relativePath.slice(r.length));let i=W([r,o.relativePath]),l=n.concat(o);t.children&&t.children.length>0&&(p(!0!==t.index,'Index routes must not have child routes. Please remove all child routes from route path "'+i+'".'),k(t.children,e,l,i)),(null!=t.path||t.index)&&e.push({path:i,score:F(i,t.index),routesMeta:l})};return t.forEach(((t,e)=>{var n;if(""!==t.path&&null!=(n=t.path)&&n.includes("?"))for(let r of S(t.path))a(t,e,r);else a(t,e)})),e}function S(t){let e=t.split("/");if(0===e.length)return[];let[n,...r]=e,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let o=S(r.join("/")),i=[];return i.push(...o.map((t=>""===t?s:[s,t].join("/")))),a&&i.push(...o),i.map((e=>t.startsWith("/")&&""===e?"/":e))}const I=/^:[\w-]+$/,N=3,E=2,C=1,T=10,A=-2,R=t=>"*"===t;function F(t,e){let n=t.split("/"),r=n.length;return n.some(R)&&(r+=A),e&&(r+=E),n.filter((t=>!R(t))).reduce(((t,e)=>t+(I.test(e)?N:""===e?C:T)),r)}function _(t,e){let{routesMeta:n}=t,r={},a="/",s=[];for(let o=0;o<n.length;++o){let t=n[o],i=o===n.length-1,l="/"===a?e:e.slice(a.length)||"/",c=D({path:t.relativePath,caseSensitive:t.caseSensitive,end:i},l);if(!c)return null;Object.assign(r,c.params);let u=t.route;s.push({params:r,pathname:W([a,c.pathname]),pathnameBase:U(W([a,c.pathnameBase])),route:u}),"/"!==c.pathnameBase&&(a=W([a,c.pathnameBase]))}return s}function D(t,e){"string"===typeof t&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=function(t,e,n){void 0===e&&(e=!1);void 0===n&&(n=!0);f("*"===t||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were "'+t.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+t.replace(/\*$/,"/*")+'".');let r=[],a="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((t,e,n)=>(r.push({paramName:e,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));t.endsWith("*")?(r.push({paramName:"*"}),a+="*"===t||"/*"===t?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==t&&"/"!==t&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,e?void 0:"i");return[s,r]}(t.path,t.caseSensitive,t.end),a=e.match(n);if(!a)return null;let s=a[0],o=s.replace(/(.)\/+$/,"$1"),i=a.slice(1);return{params:r.reduce(((t,e,n)=>{let{paramName:r,isOptional:a}=e;if("*"===r){let t=i[n]||"";o=s.slice(0,s.length-t.length).replace(/(.)\/+$/,"$1")}const l=i[n];return t[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),t}),{}),pathname:s,pathnameBase:o,pattern:t}}function O(t){try{return t.split("/").map((t=>decodeURIComponent(t).replace(/\//g,"%2F"))).join("/")}catch(e){return f(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+e+")."),t}}function z(t,e){if("/"===e)return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,r=t.charAt(n);return r&&"/"!==r?null:t.slice(n)||"/"}function L(t,e,n,r){return"Cannot include a '"+t+"' character in a manually specified `to."+e+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function M(t){return t.filter(((t,e)=>0===e||t.route.path&&t.route.path.length>0))}function P(t,e){let n=M(t);return e?n.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase)):n.map((t=>t.pathnameBase))}function B(t,e,n,r){let a;void 0===r&&(r=!1),"string"===typeof t?a=y(t):(a=h({},t),p(!a.pathname||!a.pathname.includes("?"),L("?","pathname","search",a)),p(!a.pathname||!a.pathname.includes("#"),L("#","pathname","hash",a)),p(!a.search||!a.search.includes("#"),L("#","search","hash",a)));let s,o=""===t||""===a.pathname,i=o?"/":a.pathname;if(null==i)s=n;else{let t=e.length-1;if(!r&&i.startsWith("..")){let e=i.split("/");for(;".."===e[0];)e.shift(),t-=1;a.pathname=e.join("/")}s=t>=0?e[t]:"/"}let l=function(t,e){void 0===e&&(e="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof t?y(t):t,s=n?n.startsWith("/")?n:function(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach((t=>{".."===t?n.length>1&&n.pop():"."!==t&&n.push(t)})),n.length>1?n.join("/"):"/"}(n,e):e;return{pathname:s,search:V(r),hash:j(a)}}(a,s),c=i&&"/"!==i&&i.endsWith("/"),u=(o||"."===i)&&n.endsWith("/");return l.pathname.endsWith("/")||!c&&!u||(l.pathname+="/"),l}const W=t=>t.join("/").replace(/\/\/+/g,"/"),U=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),V=t=>t&&"?"!==t?t.startsWith("?")?t:"?"+t:"",j=t=>t&&"#"!==t?t.startsWith("#")?t:"#"+t:"";Error;function G(t){return null!=t&&"number"===typeof t.status&&"string"===typeof t.statusText&&"boolean"===typeof t.internal&&"data"in t}const H=["post","put","patch","delete"],K=(new Set(H),["get",...H]);new Set(K),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function q(){return q=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},q.apply(this,arguments)}const X=o.createContext(null);const J=o.createContext(null);const Y=o.createContext(null);const Z=o.createContext(null);const Q=o.createContext({outlet:null,matches:[],isDataRoute:!1});const $=o.createContext(null);function tt(){return null!=o.useContext(Z)}function et(){return tt()||p(!1),o.useContext(Z).location}function nt(t){o.useContext(Y).static||o.useLayoutEffect(t)}function rt(){let{isDataRoute:t}=o.useContext(Q);return t?function(){let{router:t}=pt(ht.UseNavigateStable),e=gt(dt.UseNavigateStable),n=o.useRef(!1);return nt((()=>{n.current=!0})),o.useCallback((function(r,a){void 0===a&&(a={}),n.current&&("number"===typeof r?t.navigate(r):t.navigate(r,q({fromRouteId:e},a)))}),[t,e])}():function(){tt()||p(!1);let t=o.useContext(X),{basename:e,future:n,navigator:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,n.v7_relativeSplatPath)),l=o.useRef(!1);nt((()=>{l.current=!0}));let c=o.useCallback((function(n,a){if(void 0===a&&(a={}),!l.current)return;if("number"===typeof n)return void r.go(n);let o=B(n,JSON.parse(i),s,"path"===a.relative);null==t&&"/"!==e&&(o.pathname="/"===o.pathname?e:W([e,o.pathname])),(a.replace?r.replace:r.push)(o,a.state,a)}),[e,r,i,s,t]);return c}()}function at(t,e){let{relative:n}=void 0===e?{}:e,{future:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,r.v7_relativeSplatPath));return o.useMemo((()=>B(t,JSON.parse(i),s,"path"===n)),[t,i,s,n])}function st(t,e,n,r){tt()||p(!1);let{navigator:a}=o.useContext(Y),{matches:i}=o.useContext(Q),l=i[i.length-1],c=l?l.params:{},u=(l&&l.pathname,l?l.pathnameBase:"/");l&&l.route;let h,d=et();if(e){var f;let t="string"===typeof e?y(e):e;"/"===u||(null==(f=t.pathname)?void 0:f.startsWith(u))||p(!1),h=t}else h=d;let g=h.pathname||"/",m=g;if("/"!==u){let t=u.replace(/^\//,"").split("/");m="/"+g.replace(/^\//,"").split("/").slice(t.length).join("/")}let b=x(t,{pathname:m});let v=ut(b&&b.map((t=>Object.assign({},t,{params:Object.assign({},c,t.params),pathname:W([u,a.encodeLocation?a.encodeLocation(t.pathname).pathname:t.pathname]),pathnameBase:"/"===t.pathnameBase?u:W([u,a.encodeLocation?a.encodeLocation(t.pathnameBase).pathname:t.pathnameBase])}))),i,n,r);return e&&v?o.createElement(Z.Provider,{value:{location:q({pathname:"/",search:"",hash:"",state:null,key:"default"},h),navigationType:s.Pop}},v):v}function ot(){let t=function(){var t;let e=o.useContext($),n=ft(dt.UseRouteError),r=gt(dt.UseRouteError);if(void 0!==e)return e;return null==(t=n.errors)?void 0:t[r]}(),e=G(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return o.createElement(o.Fragment,null,o.createElement("h2",null,"Unexpected Application Error!"),o.createElement("h3",{style:{fontStyle:"italic"}},e),n?o.createElement("pre",{style:a},n):null,null)}const it=o.createElement(ot,null);class lt extends o.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,e){return e.location!==t.location||"idle"!==e.revalidation&&"idle"===t.revalidation?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:void 0!==t.error?t.error:e.error,location:e.location,revalidation:t.revalidation||e.revalidation}}componentDidCatch(t,e){console.error("React Router caught the following error during render",t,e)}render(){return void 0!==this.state.error?o.createElement(Q.Provider,{value:this.props.routeContext},o.createElement($.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function ct(t){let{routeContext:e,match:n,children:r}=t,a=o.useContext(X);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),o.createElement(Q.Provider,{value:e},r)}function ut(t,e,n,r){var a;if(void 0===e&&(e=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==t){var s;if(null==(s=n)||!s.errors)return null;t=n.matches}let i=t,l=null==(a=n)?void 0:a.errors;if(null!=l){let t=i.findIndex((t=>t.route.id&&(null==l?void 0:l[t.route.id])));t>=0||p(!1),i=i.slice(0,Math.min(i.length,t+1))}let c=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let o=0;o<i.length;o++){let t=i[o];if((t.route.HydrateFallback||t.route.hydrateFallbackElement)&&(u=o),t.route.id){let{loaderData:e,errors:r}=n,a=t.route.loader&&void 0===e[t.route.id]&&(!r||void 0===r[t.route.id]);if(t.route.lazy||a){c=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((t,r,a)=>{let s,h=!1,d=null,p=null;var f;n&&(s=l&&r.route.id?l[r.route.id]:void 0,d=r.route.errorElement||it,c&&(u<0&&0===a?(f="route-fallback",!1||mt[f]||(mt[f]=!0),h=!0,p=null):u===a&&(h=!0,p=r.route.hydrateFallbackElement||null)));let g=e.concat(i.slice(0,a+1)),m=()=>{let e;return e=s?d:h?p:r.route.Component?o.createElement(r.route.Component,null):r.route.element?r.route.element:t,o.createElement(ct,{match:r,routeContext:{outlet:t,matches:g,isDataRoute:null!=n},children:e})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?o.createElement(lt,{location:n.location,revalidation:n.revalidation,component:d,error:s,children:m(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):m()}),null)}var ht=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(ht||{}),dt=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(dt||{});function pt(t){let e=o.useContext(X);return e||p(!1),e}function ft(t){let e=o.useContext(J);return e||p(!1),e}function gt(t){let e=function(t){let e=o.useContext(Q);return e||p(!1),e}(),n=e.matches[e.matches.length-1];return n.route.id||p(!1),n.route.id}const mt={};i.startTransition;function bt(t){p(!1)}function yt(t){let{basename:e="/",children:n=null,location:r,navigationType:a=s.Pop,navigator:i,static:l=!1,future:c}=t;tt()&&p(!1);let u=e.replace(/^\/*/,"/"),h=o.useMemo((()=>({basename:u,navigator:i,static:l,future:q({v7_relativeSplatPath:!1},c)})),[u,c,i,l]);"string"===typeof r&&(r=y(r));let{pathname:d="/",search:f="",hash:g="",state:m=null,key:b="default"}=r,v=o.useMemo((()=>{let t=z(d,u);return null==t?null:{location:{pathname:t,search:f,hash:g,state:m,key:b},navigationType:a}}),[u,d,f,g,m,b,a]);return null==v?null:o.createElement(Y.Provider,{value:h},o.createElement(Z.Provider,{children:n,value:v}))}function vt(t){let{children:e,location:n}=t;return st(wt(e),n)}new Promise((()=>{}));o.Component;function wt(t,e){void 0===e&&(e=[]);let n=[];return o.Children.forEach(t,((t,r)=>{if(!o.isValidElement(t))return;let a=[...e,r];if(t.type===o.Fragment)return void n.push.apply(n,wt(t.props.children,a));t.type!==bt&&p(!1),t.props.index&&t.props.children&&p(!1);let s={id:t.props.id||a.join("-"),caseSensitive:t.props.caseSensitive,element:t.props.element,Component:t.props.Component,index:t.props.index,path:t.props.path,loader:t.props.loader,action:t.props.action,errorElement:t.props.errorElement,ErrorBoundary:t.props.ErrorBoundary,hasErrorBoundary:null!=t.props.ErrorBoundary||null!=t.props.errorElement,shouldRevalidate:t.props.shouldRevalidate,handle:t.props.handle,lazy:t.props.lazy};t.props.children&&(s.children=wt(t.props.children,a)),n.push(s)})),n}function xt(){return xt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},xt.apply(this,arguments)}function kt(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const St=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"];try{window.__reactRouterVersion="6"}catch(d1){}new Map;const It=i.startTransition;u.flushSync,i.useId;function Nt(t){let{basename:e,children:n,future:r,window:a}=t,s=o.useRef();var i;null==s.current&&(s.current=(void 0===(i={window:a,v5Compat:!0})&&(i={}),v((function(t,e){let{pathname:n,search:r,hash:a}=t.location;return m("",{pathname:n,search:r,hash:a},e.state&&e.state.usr||null,e.state&&e.state.key||"default")}),(function(t,e){return"string"===typeof e?e:b(e)}),null,i)));let l=s.current,[c,u]=o.useState({action:l.action,location:l.location}),{v7_startTransition:h}=r||{},d=o.useCallback((t=>{h&&It?It((()=>u(t))):u(t)}),[u,h]);return o.useLayoutEffect((()=>l.listen(d)),[l,d]),o.createElement(yt,{basename:e,children:n,location:c.location,navigationType:c.action,navigator:l,future:r})}const Et="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Ct=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Tt=o.forwardRef((function(t,e){let n,{onClick:r,relative:a,reloadDocument:s,replace:i,state:l,target:c,to:u,preventScrollReset:h,unstable_viewTransition:d}=t,f=kt(t,St),{basename:g}=o.useContext(Y),m=!1;if("string"===typeof u&&Ct.test(u)&&(n=u,Et))try{let t=new URL(window.location.href),e=u.startsWith("//")?new URL(t.protocol+u):new URL(u),n=z(e.pathname,g);e.origin===t.origin&&null!=n?u=n+e.search+e.hash:m=!0}catch(d1){}let y=function(t,e){let{relative:n}=void 0===e?{}:e;tt()||p(!1);let{basename:r,navigator:a}=o.useContext(Y),{hash:s,pathname:i,search:l}=at(t,{relative:n}),c=i;return"/"!==r&&(c="/"===i?r:W([r,i])),a.createHref({pathname:c,search:l,hash:s})}(u,{relative:a}),v=function(t,e){let{target:n,replace:r,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l}=void 0===e?{}:e,c=rt(),u=et(),h=at(t,{relative:i});return o.useCallback((e=>{if(function(t,e){return 0===t.button&&(!e||"_self"===e)&&!function(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}(t)}(e,n)){e.preventDefault();let n=void 0!==r?r:b(u)===b(h);c(t,{replace:n,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l})}}),[u,c,h,r,a,n,t,s,i,l])}(u,{replace:i,state:l,target:c,preventScrollReset:h,relative:a,unstable_viewTransition:d});return o.createElement("a",xt({},f,{href:n||y,onClick:m||s?r:function(t){r&&r(t),t.defaultPrevented||v(t)},ref:e,target:c}))}));var At,Rt;(function(t){t.UseScrollRestoration="useScrollRestoration",t.UseSubmit="useSubmit",t.UseSubmitFetcher="useSubmitFetcher",t.UseFetcher="useFetcher",t.useViewTransitionState="useViewTransitionState"})(At||(At={})),function(t){t.UseFetcher="useFetcher",t.UseFetchers="useFetchers",t.UseScrollRestoration="useScrollRestoration"}(Rt||(Rt={}));var Ft={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},_t=o.createContext&&o.createContext(Ft),Dt=["attr","size","title"];function Ot(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}function zt(){return zt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},zt.apply(this,arguments)}function Lt(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function Mt(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?Lt(Object(n),!0).forEach((function(e){Pt(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):Lt(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function Pt(t,e,n){return e=function(t){var e=function(t,e){if("object"!==typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!==typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"===typeof e?e:String(e)}(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Bt(t){return t&&t.map(((t,e)=>o.createElement(t.tag,Mt({key:e},t.attr),Bt(t.child))))}function Wt(t){return e=>o.createElement(Ut,zt({attr:Mt({},t.attr)},e),Bt(t.child))}function Ut(t){var e=e=>{var n,{attr:r,size:a,title:s}=t,i=Ot(t,Dt),l=a||e.size||"1em";return e.className&&(n=e.className),t.className&&(n=(n?n+" ":"")+t.className),o.createElement("svg",zt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},e.attr,r,i,{className:n,style:Mt(Mt({color:t.color||e.color},e.style),t.style),height:l,width:l,xmlns:"http://www.w3.org/2000/svg"}),s&&o.createElement("title",null,s),t.children)};return void 0!==_t?o.createElement(_t.Consumer,null,(t=>e(t))):e(Ft)}function Vt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"21",y1:"10",x2:"3",y2:"10"},child:[]},{tag:"line",attr:{x1:"21",y1:"6",x2:"3",y2:"6"},child:[]},{tag:"line",attr:{x1:"21",y1:"14",x2:"3",y2:"14"},child:[]},{tag:"line",attr:{x1:"21",y1:"18",x2:"3",y2:"18"},child:[]}]})(t)}function jt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"path",attr:{d:"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"},child:[]},{tag:"polyline",attr:{points:"3.27 6.96 12 12.01 20.73 6.96"},child:[]},{tag:"line",attr:{x1:"12",y1:"22.08",x2:"12",y2:"12"},child:[]}]})(t)}function Gt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"18",y1:"6",x2:"6",y2:"18"},child:[]},{tag:"line",attr:{x1:"6",y1:"6",x2:"18",y2:"18"},child:[]}]})(t)}var Ht=n(579);const Kt=function(){const[t,e]=(0,o.useState)(!1),[n,r]=(0,o.useState)(!1),a=()=>e(!1);return window.addEventListener("resize",(()=>{window.innerWidth<=960?r(!1):r(!0)})),(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)("nav",{className:"navbar",children:(0,Ht.jsxs)("div",{className:"navbar-container",children:[(0,Ht.jsxs)(Tt,{to:"/",className:"navbar-logo",onClick:a,children:["CIRCLE ",(0,Ht.jsx)(jt,{className:"name-icon"})]}),(0,Ht.jsx)("div",{className:"menu-icon",onClick:()=>e(!t),children:t?(0,Ht.jsx)(Gt,{className:"close-icon"}):(0,Ht.jsx)(Vt,{className:"open-icon"})}),(0,Ht.jsxs)("ul",{className:t?"nav-menu active":"nav-menu",children:[(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/",className:"nav-links",onClick:a,children:"Home"})}),(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/projects",className:"nav-links",onClick:a,children:"Projects"})})," ",(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/contact",className:"nav-links",onClick:a,children:"Contact Info"})})]})]})})})};function qt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"},child:[]}]})(t)}function Xt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M913.9 552.2L805 181.4v-.1c-7.6-22.9-25.7-36.5-48.3-36.5-23.4 0-42.5 13.5-49.7 35.2l-71.4 213H388.8l-71.4-213c-7.2-21.7-26.3-35.2-49.7-35.2-23.1 0-42.5 14.8-48.4 36.6L110.5 552.2c-4.4 14.7 1.2 31.4 13.5 40.7l368.5 276.4c2.6 3.6 6.2 6.3 10.4 7.8l8.6 6.4 8.5-6.4c4.9-1.7 9-4.7 11.9-8.9l368.4-275.4c12.4-9.2 18-25.9 13.6-40.6zM751.7 193.4c1-1.8 2.9-1.9 3.5-1.9 1.1 0 2.5.3 3.4 3L818 394.3H684.5l67.2-200.9zm-487.4 1c.9-2.6 2.3-2.9 3.4-2.9 2.7 0 2.9.1 3.4 1.7l67.3 201.2H206.5l57.8-200zM158.8 558.7l28.2-97.3 202.4 270.2-230.6-172.9zm73.9-116.4h122.1l90.8 284.3-212.9-284.3zM512.9 776L405.7 442.3H620L512.9 776zm157.9-333.7h119.5L580 723.1l90.8-280.8zm-40.7 293.9l207.3-276.7 29.5 99.2-236.8 177.5z"},child:[]}]})(t)}const Jt=function(){return(0,Ht.jsx)("div",{className:"contact-page",children:(0,Ht.jsx)("a",{href:"https://www.linkedin.com/in/wiramonth/",children:(0,Ht.jsx)(qt,{className:"sns-icon"})})})};const Yt=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Jt,{})})},Zt=n.p+"static/media/video3.438dba662d3f94358903.mp4";const Qt=function(){return(0,Ht.jsx)("div",{className:"hero-container",children:(0,Ht.jsx)("video",{src:Zt,autoPlay:!0,loop:!0,muted:!0})})};const $t=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Qt,{})})};class te{refCount(t){return ee("refCount")}incRef(t){return ee("incRef")}timerAvailable(){return!0}time(t){return ee("time")}read(t){return ee("read")}readSync(t){return ee("readSync")}readToGPU(t,e){return ee("readToGPU")}numDataIds(){return ee("numDataIds")}disposeData(t,e){return ee("disposeData")}write(t,e,n){return ee("write")}move(t,e,n,r,a){return ee("move")}memory(){return ee("memory")}floatPrecision(){return ee("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return ee("dispose")}}function ee(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function ne(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,re(t,e,n)}function re(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function ae(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function se(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";ae(ce(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function oe(t){ae(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function ie(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),Array.isArray(t)||pe(t)&&!n)for(let r=0;r<t.length;++r)ie(t[r],e,n);else e.push(t);return e}function le(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function ce(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ue(t){return t%1===0}function he(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function de(t,e){const n=e.length;return ae((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),ae(t.every((t=>ue(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function pe(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function fe(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function ge(t){return"string"===typeof t||t instanceof String}function me(t){return"number"===typeof t}function be(t){return Array.isArray(t)?be(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":me(t)?"float32":ge(t)?"string":"boolean"===typeof t?"bool":"float32"}function ye(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ve(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function we(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=we(t+e*i,o,n,r)}return a}function xe(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return we(0,t,e,n)}function ke(t,e){const n=Se(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Se(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function Ie(t){t.forEach((e=>{ae(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function Ne(t){return t&&t.then&&"function"===typeof t.then}const Ee="tfjsflags";class Ce{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Te,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ne(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Ee in t){t[Ee].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if("".concat(+e)===e)return+e;throw new Error("Could not parse value flag value ".concat(e," for flag ").concat(t,"."))}(e,n)}))}}}function Te(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Ae(){return Fe}let Re,Fe=null;function _e(){if(null==Re){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Re=t}return Re}function De(t,e){const n=function(){const t=_e();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Oe="Add",ze="ArgMax",Le="AvgPool",Me="AvgPool3D",Pe="BatchMatMul",Be="BatchToSpaceND",We="Cast",Ue="ClipByValue",Ve="ComplexAbs",je="Concat",Ge="Conv2D",He="Conv2DBackpropInput",Ke="Conv3D",qe="Cosh",Xe="Cumsum",Je="DepthwiseConv2dNative",Ye="RealDiv",Ze="ExpandDims",Qe="Fill",$e="Floor",tn="FloorDiv",en="FusedBatchNorm",nn="GatherV2",rn="GreaterEqual",an="Identity",sn="LeakyRelu",on="Log1p",ln="Maximum",cn="MaxPool",un="MaxPool3D",hn="Mean",dn="Minimum",pn="Multiply",fn="OnesLike",gn="OneHot",mn="Pack",bn="PadV2",yn="Prelu",vn="Range",wn="Relu",xn="Reshape",kn="ResizeNearestNeighbor",Sn="ResizeBilinear",In="Relu6",Nn="Reverse",En="Round",Cn="Rsqrt",Tn="Select",An="Selu",Rn="Slice",Fn="Sinh",_n="Sigmoid",Dn="Softplus",On="Sqrt",zn="SpaceToBatchND",Ln="SplitV",Mn="Softmax",Pn="SquaredDifference",Bn="Tanh",Wn="Tile",Un="Transpose",Vn="Unpack",jn="UnsortedSegmentSum",Gn="ZerosLike",Hn="Step",Kn="FromPixels",qn="_FusedMatMul",Xn="FusedConv2D",Jn="FusedDepthwiseConv2D";function Yn(){Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn(...arguments)}const Zn=De("kernelRegistry",(()=>new Map)),Qn=De("gradRegistry",(()=>new Map));function $n(t,e){const n=rr(t,e);return Zn.get(n)}function tr(t){return Qn.get(t)}function er(t){const e=Zn.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function nr(t){const{kernelName:e}=t;Qn.has(e)&&Ae().getBool("DEBUG")&&Yn("Overriding the gradient for '".concat(e,"'")),Qn.set(e,t)}function rr(t,e){return"".concat(e,"_").concat(t)}var ar=n(7353),sr=n.n(ar);const or=sr()||ar;function ir(t){return or.fromString(t,!0,16)}ir("c3a5c85c97cb3127"),ir("b492b66fbe98f273"),ir("9ae16a3b2f90404f");function lr(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=ie(t)),Ae().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function cr(){return Ae().platform.now()}function ur(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ae().platform.encode(t,e)}function hr(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ae().platform.decode(t,e)}class dr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new fr)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=cr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:cr()-o})}if(Ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{pr(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function pr(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class fr{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?he("".concat(r,"ms"),9):r.error,i=he(t,25),l=e.rank,c=e.size,u=he(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const gr=20,mr=3,br=7;function yr(t,e,n,r){const a=ve(e),s=function(t,e,n,r){const a=le(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?kr(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],vr(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=xr(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function vr(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(br))," + ")+"".concat(parseFloat(t[1].toFixed(br)),"j"):ge(t)?"'".concat(t,"'"):"bool"===n?wr(t):parseFloat(t.toFixed(br)).toString(),he(r,e)}function wr(t){return 0===t?"false":"true"}function xr(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[vr(kr(t)[0],0,n)]}return"bool"===n?[wr(t[0])]:[t[0].toString()]}if(1===l){if(i>gr){const e=mr*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-mr)*o,i*o));return"complex64"===n&&(r=kr(r),s=kr(s)),["["+r.map(((t,e)=>vr(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>vr(t,a[i-mr+e],n))).join(", ")+"]"]}return["["+("complex64"===n?kr(t):Array.from(t)).map(((t,e)=>vr(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>gr){for(let e=0;e<mr;e++){const r=e*h,s=r+h;d.push(...xr(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-mr;e<i;e++){const r=e*h,s=r+h;d.push(...xr(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...xr(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function kr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Sr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=le(t),null!=n){const t=n.length;ae(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||function(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}(e,this.size),this.strides=ve(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),ae(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ir().makeTensor(this.values,this.shape,this.dtype)}}let Ir=null,Nr=null,Er=null;class Cr{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=le(t),this.strides=ve(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Nr.buffer(this.shape,this.dtype,t)}bufferSync(){return Nr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return xe(this.shape,t,"complex64"===this.dtype)}arraySync(){return xe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Ir().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>hr(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ir().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ir().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>hr(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ir().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ir().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Nr.print(this,t)}clone(){return this.throwIfDisposed(),Nr.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return yr(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Nr.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Ir().makeVariable(this,t,e,n)}}Object.defineProperty(Cr,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),De("Tensor",(()=>Cr));class Tr extends Cr{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!ce(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Ir().disposeTensor(this),this.dataId=t.dataId,Ir().incRef(this,null)}dispose(){Ir().disposeVariable(this),this.isDisposedInternal=!0}}var Ar,Rr,Fr,_r,Dr;Object.defineProperty(Tr,Symbol.hasInstance,{value:t=>t instanceof Cr&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Ar||(Ar={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Rr||(Rr={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Fr||(Fr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(_r||(_r={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Dr||(Dr={}));const Or={float32:_r,int32:Rr,bool:Fr,complex64:Dr};function zr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return Or[t][e]}function Lr(t,e){if(t.dtype===e.dtype)return[t,e];const n=zr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Mr(t,e){return e.some((e=>e.id===t.id))}function Pr(t){const e=[];return Br(t,e,new Set),e}function Br(t,e,n){if(null==t)return;if(t instanceof Cr)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),Br(t,e,n))}}function Wr(t){return null!=t.kernelName}class Ur{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Vr{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ur}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(Yn("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new dr(this.backendInstance),!0}setupRegisteredKernels(){er(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){er(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof te||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Yn("Initialization of backend ".concat(t," failed")),Yn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return Yn("Initialization of backend ".concat(t," failed")),Yn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return Vr.nextTensorId++}nextVariableId(){return Vr.nextVariableId++}clone(t){const e=Gr.runKernel(an,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Gr.runKernel(We,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=$n(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Wr(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Wr(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=$n(e,this.backendName);ae(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=Wr(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=tr(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(ae(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&ge(t[0])&&(a=t.map((t=>ur(t))));const s=r.write(a,e,n),o=new Cr(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Cr(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Tr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*fe(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Tr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*fe(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=tr(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=Se(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Pr(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(ae(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));ae(a instanceof Cr,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=ke(le(t),"float32");return Gr.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!ce(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),Hr);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return ae(ye(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;ae(r.every((t=>t instanceof Cr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),ae(s.value instanceof Cr,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),ae(ye(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];ae(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),ae(a.every((t=>t instanceof Cr)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=cr(),n=await this.backend.time(t);return n.wallMs=cr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ur;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function jr(){const t=_e();if(null==t._tfengine){const e=new Ce(t);t._tfengine=new Vr(e)}var e;return e=t._tfengine.ENV,Fe=e,Ir=()=>t._tfengine,t._tfengine}Vr.nextTensorId=0,Vr.nextVariableId=0;const Gr=jr();function Hr(t,e){const n={a:t,b:e};return Gr.runKernel(Oe,n)}const Kr=Ae();function qr(t,e){let n=t;if(pe(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||pe(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Xr(t,r,[]),r}function Xr(t,e,n){if(n=n||[],!Array.isArray(t)&&!pe(t))return void ae(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));ae(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),ae(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)Xr(t[a],r,n.concat(a))}function Jr(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function Yr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Cr)return Jr(r,t.dtype,e,n),t;let a=be(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Jr(r,a,e,n),null==t||!pe(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=qr(t,a);pe(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?lr(t,a):ie(t,[],!0);return Gr.makeTensor(o,s,a)}function Zr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>Yr(t,"".concat(e,"[").concat(a,"]"),n,r)))}Kr.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Kr.registerFlag("IS_BROWSER",(()=>"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope)),Kr.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Kr.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Kr.registerFlag("PROD",(()=>!1)),Kr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Kr.getBool("DEBUG"))),Kr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Kr.registerFlag("IS_TEST",(()=>!1)),Kr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Kr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Kr.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),Kr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Kr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Qr(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Gr.startScope(n);try{const t=r(...arguments);return Ne(t)&&console.error("Cannot return a Promise inside of tidy."),Gr.endScope(t),t}catch(t){throw Gr.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const $r=Qr({complex_:function(t,e){const n=Yr(t,"real","complex"),r=Yr(e,"imag","complex");se(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return Gr.runKernel("Complex",a)}});function ta(t,e,n,r){if(null==r&&(r=be(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!pe(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Ie(e);const t=le(e),r=le(n);ae(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==le(e.slice(a));ae(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return pe(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?lr(t,r):ie(t,[],!0),Gr.makeTensor(t,e,r)}function ea(t,e,n){return ta(t,e,qr(t,n),n)}const na={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ra=4;async function aa(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+ra*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=ra,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:oa(await Promise.all(r)),specs:n}}function sa(t,e){const n={};let r,a=0;for(const s of e){const e=s.name,o=s.dtype,i=s.shape,l=le(i);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(s.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(s.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==o)throw new Error("Weight ".concat(s.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(o,"."))}const i=na[n.dtype],u=t.slice(a,a+l*i),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===r&&(r=pa()),c=r(h)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");c=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=Math.round(e*n.scale+n.min)}}a+=l*i}else if("string"===o){const e=le(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(a,a+ra))[0];a+=ra;const n=new Uint8Array(t.slice(a,a+e));c.push(n),a+=e}}else{const r=na[o],s=t.slice(a,a+l*r);if("float32"===o)c=new Float32Array(s);else if("int32"===o)c=new Int32Array(s);else if("bool"===o)c=new Uint8Array(s);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const a=ea(t,i,"float32"),o=ea(r,i,"float32");n[e]=$r(a,o),a.dispose(),o.dispose()}}a+=l*r}"complex64"!==o&&(n[e]=ea(c,i,o))}return n}function oa(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const ia="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function la(t){return ia?Buffer.byteLength(t):new Blob([t]).size}function ca(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function ua(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function ha(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),r}(t,n,r)}function da(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:la(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:la(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function pa(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0===(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const a=r[o],i=t[n[a>>10]+(1023&a)]+e[a>>10];s[o]=i}return new Float32Array(a)}}class fa{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==fa.instance&&(fa.instance=new fa),fa.instance}static registerSaveRouter(t){fa.getInstance().saveRouters.push(t)}static registerLoadRouter(t){fa.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return fa.getHandlers(t,"save")}static getLoadHandlers(t,e){return fa.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?fa.getInstance().loadRouters:fa.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const ga=(t,e)=>fa.getLoadHandlers(t,e),ma="tensorflowjs",ba="models_store",ya="model_info_store";function va(){if(!Ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function wa(t){const e=t.result;e.createObjectStore(ba,{keyPath:"modelPath"}),e.createObjectStore(ya,{keyPath:"modelPath"})}class xa{constructor(t){if(this.indexedDB=va(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(ma,1);r.onupgradeneeded=()=>wa(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(ba,"readonly"),r=e.objectStore(ba).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{const r=da(e),s=a.transaction(ya,"readwrite");let o=s.objectStore(ya);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;i.onsuccess=()=>{l=a.transaction(ba,"readwrite");const i=l.objectStore(ba).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});i.onsuccess=()=>t({modelArtifactsInfo:r}),i.onerror=t=>{o=s.objectStore(ya);const e=o.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(i.error)),e.onerror=t=>(a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}xa.URL_SCHEME="indexeddb://";const ka=t=>{return Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(xa.URL_SCHEME)?(e=t.slice(xa.URL_SCHEME.length),new xa(e)):null;var e};fa.registerSaveRouter(ka),fa.registerLoadRouter(ka);class Sa{constructor(){this.indexedDB=va()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(ma,1);n.onupgradeneeded=()=>wa(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(ya,"readonly"),s=a.objectStore(ya).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(xa.URL_SCHEME)?e.slice(xa.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(ma,1);r.onupgradeneeded=()=>wa(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(ya,"readwrite"),o=s.objectStore(ya),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(ba,"readwrite");const r=l.objectStore(ba).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const Ia="/",Na="tensorflowjs_models",Ea="info",Ca="model_topology",Ta="weight_specs",Aa="weight_data",Ra="model_metadata";function Fa(t){return{info:[Na,t,Ea].join(Ia),topology:[Na,t,Ca].join(Ia),weightSpecs:[Na,t,Ta].join(Ia),weightData:[Na,t,Aa].join(Ia),modelMetadata:[Na,t,Ra].join(Ia)}}function _a(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Da(t){const e=t.split(Ia);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(Ia)}class Oa{constructor(t){if(!Ae().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Fa(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),a=da(t);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(t){if(ia)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData));const e={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(e)),{modelArtifactsInfo:a}}catch(e){throw _a(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(ia){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}Oa.URL_SCHEME="localstorage://";const za=t=>{return Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Oa.URL_SCHEME)?(e=t.slice(Oa.URL_SCHEME.length),new Oa(e)):null;var e};fa.registerSaveRouter(za),fa.registerLoadRouter(za);class La{constructor(){ae(Ae().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),ae("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Na+Ia,n=Ia+Ea;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[Da(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=Fa(t=(e=t).startsWith(Oa.URL_SCHEME)?e.slice(Oa.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return _a(n),r}}const Ma="://";class Pa{constructor(){this.managers={}}static getInstance(){return null==Pa.instance&&(Pa.instance=new Pa),Pa.instance}static registerManager(t,e){ae(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(Ma)&&(t=t.slice(0,t.indexOf(Ma))),ae(t.length>0,(()=>"scheme must not be an empty string."));const n=Pa.getInstance();ae(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=Pa.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(Pa.getInstance().managers)}}class Ba{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){window&&Ae().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}}if(Ae().get("IS_BROWSER")){Ae().setPlatform("browser",new Ba);try{Pa.registerManager(Oa.URL_SCHEME,new La)}catch(p1){}try{Pa.registerManager(xa.URL_SCHEME,new Sa)}catch(p1){}}const Wa=()=>n(5817);let Ua;class Va{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ae().global.fetch?Ae().global.fetch(t,e):(null==Ua&&(Ua=Wa()),Ua(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}function ja(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",Ie(t),new Sr(t,e,n)}Ae().get("IS_NODE")&&!Ae().get("IS_BROWSER")&&Ae().setPlatform("node",new Va);const Ga=Qr({cast_:function(t,e){const n=Yr(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return Gr.runKernel(We,r,a)}});const Ha=Qr({clone_:function(t){const e={x:Yr(t,"x","clone","string_or_numeric")};return Gr.runKernel(an,e)}});jr();Nr={buffer:ja,cast:Ga,clone:Ha,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}};function Ka(t){return new Promise((t=>setTimeout(t))).then(t)}class qa{constructor(t){if(!Ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(qa.URL_SCHEME)&&(t=t.slice(qa.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=ua(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Ka((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Ka((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:da(t)}}}}qa.URL_SCHEME="downloads://";function Xa(t,e,n,r){!function(t){ae(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){ae(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),ae(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),ae(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function Ja(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ae().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await Xa(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await Xa(a,e.onProgress,.5,1)}fa.registerSaveRouter((t=>Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(qa.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new qa(t)}(t.slice(qa.URL_SCHEME.length)):null));class Ya{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(ae("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Ae().platform.fetch,ae(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&ae(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=ua(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:da(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(d1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return ha(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=function(t){const e=[];for(const n of t)e.push(...n.weights);return e}(t),o=[],i=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):o.push(a+t+r);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,ca(await Ja(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Za(t){return null!=t.match(Ya.URL_SCHEME_REGEX)}Ya.URL_SCHEME_REGEX=/^https?:\/\//;const Qa=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Za(t))):Za(t),n)return $a(t,e)}return null};function $a(t,e){return new Ya(t,e)}fa.registerSaveRouter(Qa),fa.registerLoadRouter(Qa);class ts{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class es{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function ns(t,e,n,r){return new es(function(t,e,n,r){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new ts(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ts({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ts({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r})}(...arguments))}function rs(t,e,n){if(oe(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=qr(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ta(t,e,r,n)}let as;function ss(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&t instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(t.constructor.name));i=!0}if(null!=$n(Kn,Gr.backendName)){const n={pixels:t},r={numChannels:e};return Gr.runKernel(Kn,n,r)}const[l,c]=a?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,h;if(o)u=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)u=t.data;else if(s||a||i){if(null==as)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");as=new OffscreenCanvas(1,1).getContext("2d")}else as=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});as.canvas.width=l,as.canvas.height=c,as.drawImage(t,0,0,l,c),u=as.getImageData(0,0,l,c).data}if(4===e)h=new Int32Array(u);else{const t=l*c;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=u[4*n+t]}return rs(h,[c,l,e],"int32")}Qr({fromPixels_:ss});class os{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class is{constructor(){this.classNameMap={}}static getMap(){return null==is.instance&&(is.instance=new is),is.instance}static register(t){is.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ls(t){ae(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),ae("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),ae(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),is.register(t)}function cs(){return Gr.memory()}function us(t,e){return Gr.tidy(t,e)}function hs(t){Pr(t).forEach((t=>t.dispose()))}function ds(t){return Gr.keep(t)}function ps(){return Gr.backend}function fs(t){return Gr.customGrad(t)}function gs(t,e){if((pe(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&pe(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ta(t,[],[],e)}Er=function(t){Ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class ms extends os{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return hs(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){ae(ye(t),(()=>"The f passed in variableGrads(f) must be a function")),ae(null==e||Array.isArray(e)&&e.every((t=>t instanceof Tr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in Gr.registeredVariables)e.push(Gr.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),ae(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=Gr.gradients(t,e,null,!0);ae(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),ae(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&hs(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:gs(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ms,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const bs=Qr({abs_:function(t){const e=Yr(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return Gr.runKernel(Ve,t)}{const t={x:e};return Gr.runKernel("Abs",t)}}});const ys=Qr({add_:function(t,e){let n=Yr(t,"a","add"),r=Yr(e,"b","add");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(Oe,a)}});const vs=Qr({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","all","bool")},a={axis:e,keepDims:n};return Gr.runKernel("All",r,a)}});const ws=Qr({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","any","bool")},a={axis:e,keepDims:n};return Gr.runKernel("Any",r,a)}});const xs=Qr({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Yr(t,"x","argMax")},r={axis:e};return Gr.runKernel(ze,n,r)}});function ks(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=Is(n),[b,y]=Is(r),v=Ns(d,b),w=Ns(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=Ss(t,e,n));const s=t[0],o=t[1],i=Es((s-e+2*r)/n+1,a),l=Es((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=Es((e-s+d+p)/r+1,i),h=Es((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function Ss(t,e,n){const r=Ns(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function Is(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Ns(t,e){return e<=1?t:t+(t-1)*(e-1)}function Es(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function Cs(t){const[e,n,r]=Is(t);return 1===e&&1===n&&1===r}function Ts(t,e){return Cs(t)||Cs(e)}function As(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)ae(ue(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{ae(ue(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const Rs=Qr({reshape_:function(t,e){const n={x:Yr(t,"x","reshape","string_or_numeric")},r={shape:e};return Gr.runKernel(xn,n,r)}});const Fs=Qr({avgPool_:function(t,e,n,r,a){const s=Yr(t,"x","avgPool","float32");ae(Ts(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),As("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=Gr.runKernel(Le,l,c);return u=Ga(u,s.dtype),i?Rs(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const _s=Qr({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Yr(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),ae("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),As("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=Gr.runKernel(Me,c,u);return h=Ga(h,i.dtype),l?Rs(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Ds=Qr({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ae(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ae(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?Rs(t,[1,1,1,t.size]):2===t.rank?Rs(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=Gr.runKernel(en,h,d);return Rs(p,o.shape)}});const Os=Qr({batchNorm2d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),ae(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});const zs=Qr({batchNorm3d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),ae(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});const Ls=Qr({batchNorm4d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),ae(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});function Ms(t,e,n){const r={shape:t,value:e,dtype:n};return Gr.runKernel(Qe,{},r)}const Ps=Qr({clipByValue_:function(t,e,n){const r=Yr(t,"x","clipByValue");if(ae(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return Ms(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return Gr.runKernel(Ue,a,s)}});const Bs=Qr({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;ae(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Zr(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return Ha(n[0]);const r=n,a={axis:e};return Gr.runKernel(je,r,a)}});const Ws=Qr({concat1d_:function(t){return Bs(t,0)}});const Us=Qr({concat2d_:function(t,e){return Bs(t,e)}});const Vs=Qr({concat3d_:function(t,e){return Bs(t,e)}});const js=Qr({concat4d_:function(t,e){return Bs(t,e)}});const Gs=Qr({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","conv2d","float32"),l=Yr(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),ae(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),As("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];ae(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),ae(Ts(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Ge,d,p);return u?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Hs=Qr({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","conv1d"),l=Yr(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1]])),ae(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),ae(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),As("conv1d",r,o),ae(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),ae(Ts(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),ae("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=Rs(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Rs(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Gs(d,h,[1,n],r,"NHWC",[1,s],o);return Rs(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Ks=Qr({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;ae(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),ae(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),ae(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),ae(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];ae(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),ae(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),As("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Gr.runKernel(He,d,p);return c?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const qs=Qr({conv2dTranspose_:function(t,e,n,r,a,s){const o=Yr(t,"x","conv2dTranspose"),i=Yr(e,"filter","conv2dTranspose");return Ks(n,o,i,r,a,"NHWC",s)}});const Xs=Qr({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=Yr(t,"x","conv3d"),i=Yr(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),ae(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),ae(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),ae(Ts(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),ae("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported.")));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=Gr.runKernel(Ke,u,h);return c?Rs(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Js=Qr({conv3DBackpropInput_:function(t,e,n,r,a){ae(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];ae(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),ae(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),ae(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),ae(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),ae(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=Gr.runKernel("Conv3DBackpropInputV2",u,h);return i?Rs(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ys=Qr({conv3dTranspose_:function(t,e,n,r,a){const s=Yr(t,"x","conv3dTranspose"),o=Yr(e,"filter","conv3dTranspose");return Js(n,s,o,r,a)}});const Zs=Qr({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","depthwiseConv2d","float32"),l=Yr(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),ae(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];ae(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),As("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Je,d,p);return u?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Qs=Qr({floorDiv_:function(t,e){let n=Yr(t,"a","floorDiv"),r=Yr(e,"b","floorDiv");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(tn,a)}});const $s=Qr({div_:function(t,e){let n=Yr(t,"a","div"),r=Yr(e,"b","div");if([n,r]=Lr(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Qs(n,r);const a={a:n,b:r};return Gr.runKernel(Ye,a,{})}});const to=Qr({elu_:function(t){const e={x:Yr(t,"x","elu","float32")};return Gr.runKernel("Elu",e)}});function eo(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function no(t,e){const n=[],r=Math.max(t.length,e.length);for(let a=0;a<r;a++){let r=t[t.length-a-1];null==r&&(r=1);let s=e[e.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}n.unshift(r)}}return n}const ro=Qr({equal_:function(t,e){let n=Yr(t,"a","equal","string_or_numeric"),r=Yr(e,"b","equal","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Equal",a)}});const ao=Qr({exp_:function(t){const e={x:Yr(t,"x","exp")};return Gr.runKernel("Exp",e)}});const so=Qr({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Yr(t,"x","expandDims","string_or_numeric");ae(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return Gr.runKernel(Ze,r,a)}});const oo=Qr({tile_:function(t,e){const n=Yr(t,"x","tile","string_or_numeric");ae(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return Gr.runKernel(Wn,r,a)}});const io=Qr({eye_:function(t,e,n){null==e&&(e=t);const r=ja([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=Rs(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return oo(so(s,0),[n[0],1,1]);if(2===n.length)return oo(so(so(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return oo(so(so(so(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const lo=Qr({floor_:function(t){const e={x:Yr(t,"x","floor","float32")};return Gr.runKernel($e,e)}});const co=Qr({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:Yr(t,"x","gather"),indices:Yr(e,"indices","gather","int32")},s={axis:n,batchDims:r};return Gr.runKernel(nn,a,s)}});const uo=Qr({greater_:function(t,e){let n=Yr(t,"a","greater","string_or_numeric"),r=Yr(e,"b","greater","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Greater",a)}});const ho=Qr({greaterEqual_:function(t,e){let n=Yr(t,"a","greaterEqual","string_or_numeric"),r=Yr(e,"b","greaterEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(rn,a)}});const po=Qr({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Yr(t,"x","leakyRelu")},r={alpha:e};return Gr.runKernel(sn,n,r)}});const fo=Qr({log_:function(t){const e={x:Yr(t,"x","log","float32")};return Gr.runKernel("Log",e)}});const go=Qr({log1p_:function(t){const e={x:Yr(t,"x","log1p")};return Gr.runKernel(on,e)}});const mo=Qr({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","max")},a={reductionIndices:e,keepDims:n};return Gr.runKernel("Max",r,a)}});const bo=Qr({mul_:function(t,e){let n=Yr(t,"a","mul"),r=Yr(e,"b","mul");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(pn,a)}});const yo=Qr({sub_:function(t,e){let n=Yr(t,"a","sub"),r=Yr(e,"b","sub");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel("Sub",a)}});const vo=Qr({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Yr(t,"x","sum");"bool"===r.dtype&&(r=Ga(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return Gr.runKernel("Sum",a,s)}});const wo=Qr({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Yr(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=fs(((t,n)=>{const r=mo(t,e,!0),a=yo(t,r),s=yo(Ga(a,"float32"),fo(vo(ao(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=ao(r);return yo(t,bo(vo(t,e,!0),a))}}}));return r(n)}});const xo=Qr({logicalAnd_:function(t,e){const n=Yr(t,"a","logicalAnd","bool"),r=Yr(e,"b","logicalAnd","bool");no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LogicalAnd",a)}});const ko=Qr({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Yr(t,"a","matMul"),s=Yr(e,"b","matMul");[a,s]=Lr(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return Gr.runKernel(Pe,o,i)}});const So=Qr({maxPool_:function(t,e,n,r,a){const s=Yr(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),ae(Ts(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),As("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=Gr.runKernel(cn,l,c);return i?Rs(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Io=Qr({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Yr(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),ae("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),As("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=Gr.runKernel(un,c,u);return l?Rs(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const No=Qr({maximum_:function(t,e){let n=Yr(t,"a","maximum"),r=Yr(e,"b","maximum");[n,r]=Lr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(ln,a)}});const Eo=Qr({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","mean")},a={axis:e,keepDims:n};return Gr.runKernel(hn,r,a)}});const Co=Qr({minimum_:function(t,e){let n=Yr(t,"a","minimum"),r=Yr(e,"b","minimum");[n,r]=Lr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(dn,a)}});function To(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Ao(t,e){return function(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}(t,e.map((t=>1)),e)}function Ro(t,e){if(To(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Fo(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}const _o=Qr({square_:function(t){const e=Yr(t,"x","square");return Gr.runKernel("Square",{x:e},{})}});const Do=Qr({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=de(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=Yr(t,"x","moments")).shape),r=Eo(t,n,e);let a=r.shape;e||(a=Ao(r.shape,n));const s=_o(yo(Ga(t,"float32"),Rs(r,a)));return{mean:r,variance:Eo(s,n,e)}}});const Oo=Qr({neg_:function(t){const e={x:Yr(t,"x","neg")};return Gr.runKernel("Neg",e)}});const zo=Qr({notEqual_:function(t,e){let n=Yr(t,"a","notEqual","string_or_numeric"),r=Yr(e,"b","notEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("NotEqual",a)}});const Lo=Qr({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:Yr(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return Gr.runKernel(gn,s,o)}});function Mo(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Mo(t,"float32"),n=Mo(t,"float32");return $r(e,n)}const n=Se(le(t),e);return Gr.makeTensor(n,t,e)}function Po(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Po(t,"float32"),n=Mo(t,"float32");return $r(e,n)}const n=ke(le(t),e);return Gr.makeTensor(n,t,e)}const Bo=Qr({onesLike_:function(t){const e={x:Yr(t,"x","onesLike")};return Gr.runKernel(fn,e)}});const Wo=Qr({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=Yr(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return Gr.runKernel(bn,s,a)}});const Uo=Qr({prelu_:function(t,e){const n={x:Yr(t,"x","prelu"),alpha:Yr(e,"alpha","prelu")};return Gr.runKernel(yn,n)}});var Vo=n(4334);class jo{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Vo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Go{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Vo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ho=Qr({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new jo(e,n,r,!1,a),o=ja(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const Ko=Qr({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>4?arguments[4]:void 0;const a=ja(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=new Go(e,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}});const qo=Qr({relu_:function(t){const e={x:Yr(t,"x","relu")};return Gr.runKernel(wn,e)}});const Xo=Qr({reverse_:function(t,e){const n={x:Yr(t,"x","reverse")},r={dims:e};return Gr.runKernel(Nn,n,r)}});const Jo=Qr({selu_:function(t){const e={x:Yr(t,"x","selu")};return Gr.runKernel(An,e)}});const Yo=Qr({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Yr(t,"x","separableConv2d"),l=Yr(e,"depthwiseFilter","separableConv2d"),c=Yr(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ae(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),ae(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),ae(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),ae(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),ae(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];ae(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=Zs(u,l,r,a,o,s),g=Gs(f,c,1,"valid",o);return h?Rs(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const Zo=Qr({sigmoid_:function(t){const e={x:Yr(t,"x","sigmoid","float32")};return Gr.runKernel(_n,e)}});const Qo=Qr({slice_:function(t,e,n){const r=Yr(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return Gr.runKernel(Rn,a,s)}});const $o=Qr({slice1d_:function(t,e,n){const r=Yr(t,"x","slice1d");return ae(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,[e],[n])}});const ti=Qr({slice2d_:function(t,e,n){const r=Yr(t,"x","slice2d");return ae(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ei=Qr({slice3d_:function(t,e,n){const r=Yr(t,"x","slice3d");return ae(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ni=Qr({slice4d_:function(t,e,n){const r=Yr(t,"x","slice4d");return ae(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ri=Qr({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Yr(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return Gr.runKernel(Mn,r,a)}});const ai=Qr({softplus_:function(t){const e={x:Yr(t,"x","softplus")};return Gr.runKernel(Dn,e)}});const si=Qr({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:Yr(t,"x","split")},a={numOrSizeSplits:e,axis:n};return Gr.runKernel(Ln,r,a)}});const oi=Qr({sqrt_:function(t){const e={x:Yr(t,"x","sqrt","float32")};return Gr.runKernel(On,e)}});const ii=Qr({squeeze_:function(t,e){const n=Yr(t,"x","squeeze","string_or_numeric");return Rs(n,function(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:de(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}(n.shape,e).newShape)}});const li=Qr({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Zr(t,"tensors","stack","string_or_numeric");ae(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&ae(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return Gr.runKernel(mn,r,a)}});const ci=Qr({tanh_:function(t){const e={x:Yr(t,"x","tanh","float32")};return Gr.runKernel(Bn,e)}});function ui(t,e){oe(t);const n=qr(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ta(t,null,n,e)}function hi(t,e,n){if(oe(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=qr(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ta(t,e,r,n)}const di=Qr({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new jo(e,n,r,!0,a),o=ja(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const pi=Qr({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Yr(t,"x","unstack","string_or_numeric");ae(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return Gr.runKernel(Vn,r,a)}});const fi=Qr({broadcastTo_:function(t,e){let n=Yr(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!==0)))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(e,"]."));if(e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Rs(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Ha(n);const o={x:n},i={reps:s};return Gr.runKernel(Wn,o,i)}});const gi=Qr({where_:function(t,e,n){const r=Yr(e,"a","where"),a=Yr(n,"b","where"),s=Yr(t,"condition","where","bool"),o=no(no(s.shape,r.shape),a.shape),i={condition:fi(s,o),t:fi(r,o),e:fi(a,o)};return Gr.runKernel(Tn,i)}});const mi=Qr({zerosLike_:function(t){const e={x:Yr(t,"x","zerosLike")};return Gr.runKernel(Gn,e)}});const bi=Qr({imag_:function(t){const e={input:Yr(t,"input","imag")};return Gr.runKernel("Imag",e)}});const yi=Qr({real_:function(t){const e={input:Yr(t,"input","real")};return Gr.runKernel("Real",e)}});const vi=Qr({transpose_:function(t,e,n){const r=Yr(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),ae(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{ae(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?us((()=>{let t=yi(r),e=bi(r);return t=Gr.runKernel(Un,{x:t},s),e=Gr.runKernel(Un,{x:e},s),n&&(e=Oo(e)),$r(t,e)})):Gr.runKernel(Un,a,s)}});const wi=Qr({dropout_:function(t,e,n,r){const a=Yr(t,"x","dropout");if(ae("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),ae(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Cr?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if(ce(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=$s(lo(ys(Ko(s,0,1,"float32",r),o)),o);return bo(a,i)}});const xi=Qr({fft_:function(t){ae("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("FFT",e)}});const ki=Qr({rfft_:function(t,e){ae("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=Qo(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=Bs([t,Mo(r)],t.shape.length-1),n=e}else a=t;const s=mi(a),o=Rs($r(a,s),[r,n]),i=xi(o),l=Math.floor(n/2)+1,c=yi(i),u=bi(i),h=si(c,[l,n-l],c.shape.length-1),d=si(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,Rs($r(h[0],d[0]),p)}});const Si=Qr({ifft_:function(t){ae("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("IFFT",e)}});Qr({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=Rs(t,[n,e]);r=Si(a)}else{const a=[n,2*(e-1)],s=Rs(yi(t),[n,e]),o=Rs(bi(t),[n,e]),i=Xo(Qo(s,[0,1],[n,e-2]),1),l=bo(Xo(Qo(o,[0,1],[n,e-2]),1),gs(-1)),c=Bs([s,i],1),u=Bs([o,l],1),h=Rs($r(c,u),[a[0],a[1]]);r=Si(h)}if(r=yi(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=Rs(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const Ii=Qr({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ae(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),ae(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),ae(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];ae(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),ae(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),As("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return Gr.runKernel("Conv2DBackpropFilter",h,d)}});const Ni=Qr({relu6_:function(t){const e={x:Yr(t,"x","relu6")};return Gr.runKernel(In,e)}});const Ei=Qr({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Yr(t,"x","step")},r={alpha:e};return Gr.runKernel(Hn,n,r)}});function Ci(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return bo(t,Ei(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Ti(t,e){let n=e;const r=eo(t.shape,e.shape);return r.length>0&&(n=vo(n,r)),Rs(n,t.shape)}function Ai(t,e,n,r){if("linear"===e)return t;if("relu"===e)return qo(t);if("elu"===e)return to(t);if("relu6"===e)return Ni(t);if("prelu"===e)return Uo(t,n);if("leakyrelu"===e)return po(t,r);if("sigmoid"===e)return Zo(t);throw new Error("Unknown fused activation ".concat(e,"."))}const Ri=(t,e)=>!(t>0)||"linear"===e;const Fi=Qr({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===Ri(Gr.state.gradientDepth,c)){ae("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=Gs(e,n,r,a,s,o,i);return null!=l&&(t=ys(t,l)),Ai(t,c,u,h)}const d=Yr(e,"x","conv2d","float32"),p=Yr(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Rs(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),ae(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),As("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];ae(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),ae(Ts(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=ks(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=Yr(l,"bias","fused conv2d"),[y]=Lr(y,d),"NHWC"===s?no(b.outShape,y.shape):(ae(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),ae(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(ae(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)ae(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{no(t,b.outShape)}catch(d1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=Yr(u,"prelu weights","fused conv2d")}const w=(t,e)=>{ae("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=Ci(t,l,c);ae(Cs(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[Ks(i.shape,h,n,r,a),Ii(i,h,n.shape,r,a)];if(null!=u){const t=Ti(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=fs(((t,e,n)=>{let r=Gr.runKernel(Xn,x,k);return n([e,t,r]),g&&(r=Rs(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=fs(((t,e,n,r)=>{let a=Gr.runKernel(Xn,x,k);return r([e,t,a,n]),g&&(a=Rs(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const _i=Qr({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return Gr.runKernel("DepthwiseConv2dNativeBackpropFilter",c,u)}});const Di=Qr({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=Gr.runKernel("DepthwiseConv2dNativeBackpropInput",c,u);return l?Rs(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Qr({fusedDepthwiseConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(!1===Ri(Gr.state.gradientDepth,c)){let t=Zs(e,n,r,a,s,o,i);return null!=l&&(t=ys(t,l)),Ai(t,c,u,h)}const d=Yr(e,"x","depthwiseConv2d","float32"),p=Yr(n,"filter","depthwiseConv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Rs(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),ae(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),ae(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==o&&(o=[1,1]),ae(Ts(r,o),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(r," and dilations '").concat(o,"'"))),As("fused depthwiseConv2d",a,i);const m=ks(f.shape,p.shape,r,o,a,i,!0);let b,y;null!=l&&(b=Yr(l,"bias","fused conv2d"),[b]=Lr(b,d),no(m.outShape,b.shape)),null!=u&&(y=Yr(u,"prelu weights","fused depthwiseConv2d"));const v=(t,e)=>{ae(Cs(o),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'")));const[n,s,l,u]=e,h=Ci(t,l,c),d=Di(s.shape,h,n,r,a,o,i),p=_i(s,h,n.shape,r,a,o,i);if(null!=u){return[d,p,Ti(b,h)]}return[d,p]},w={x:f,filter:p,bias:b,preluActivationWeights:y},x={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=fs(((t,e,n)=>{let r=Gr.runKernel(Jn,w,x);return n([e,t,r]),g&&(r=Rs(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(f,p)}{const t=fs(((t,e,n,r)=>{let a=Gr.runKernel(Jn,w,x);return r([e,t,a,n]),g&&(a=Rs(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return t(f,p,b)}}});const Oi=Qr({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===Ri(Gr.state.gradientDepth,o)){let t=ko(e,n,r,a);return null!=s&&(t=ys(t,s)),Ai(t,o,i,l)}let c=Yr(e,"a","fused matMul"),u=Yr(n,"b","fused matMul");[c,u]=Lr(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=le(g),y=le(m);ae(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=no(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=Rs(c,r?[b,h,p]:[b,p,h]),x=Rs(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=Yr(s,"bias","fused matMul"),[k]=Lr(k,c),no(v,k.shape)),null!=i&&(S=Yr(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=Ci(Rs(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=ko(u,i,!1,!1),d=ko(u,n,!0,!1)):r&&!a?(h=ko(i,u,!1,!0),d=ko(n,u,!1,!1)):(h=ko(i,u,!0,!0),d=ko(u,n,!0,!0)):(h=ko(u,i,!1,!0),d=ko(n,u,!0,!1)),null!=s){return[h,d,Ti(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},E={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=fs(((t,e,n)=>{const r=Gr.runKernel(qn,N,E);return n([t,e,r]),{value:Rs(r,v),gradFunc:I}}));return t(w,x)}{const t=fs(((t,e,n,r)=>{const a=Gr.runKernel(qn,N,E);return r([t,e,a,n]),{value:Rs(a,v),gradFunc:I}}));return t(w,x,k)}}});function zi(t,e,n){const r=1-t%2,a=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);a[s]=e-n*Math.cos(o)}return ui(a,"float32")}Qr({hammingWindow_:function(t){return zi(t,.54,.46)}});const Li=Qr({hannWindow_:function(t){return zi(t,.5,.5)}});const Mi=Qr({frame_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const o=[];for(;s+e<=t.size;)o.push(Qo(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,i=Bs([Qo(t,s,e-r),Ms([r],a)]);o.push(i),s+=n}return 0===o.length?hi([],[0,e]):Rs(Bs(o),[o.length,e])}});Qr({stft_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Li;var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=Mi(t,e,n),i=bo(o,a(e));return ki(i,r)}});const Pi=Qr({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"image","cropAndResize"),i=Yr(e,"boxes","cropAndResize","float32"),l=Yr(n,"boxInd","cropAndResize","int32"),c=i.shape[0];ae(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),ae(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),ae(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),ae(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),ae(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),ae("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return Gr.runKernel("CropAndResize",u,h)}});const Bi=Qr({flipLeftRight_:function(t){const e=Yr(t,"image","flipLeftRight","float32");ae(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return Gr.runKernel("FlipLeftRight",n,{})}});const Wi=Qr({grayscaleToRGB_:function(t){const e=Yr(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];ae(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),ae(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,oo(e,a)}});const Ui=Qr({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Yr(t,"image","rotateWithOffset","float32");ae(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return Gr.runKernel("RotateWithOffset",s,o)}});function Vi(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),ae(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),ae(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),ae(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),ae(1===e.rank,(()=>"scores must be a 1D tensor")),ae(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),ae(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const ji=Qr({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Yr(t,"boxes","nonMaxSuppression","float32"),o=Yr(e,"scores","nonMaxSuppression","float32"),i=Vi(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Gr.runKernel("NonMaxSuppressionV3",{boxes:s,scores:o},l)}});function Gi(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||Hi)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function Hi(t,e){return t>e?1:t<e?-1:0}function Ki(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(Ji);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=qi(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*Xi(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&Gi(c,e,Ji))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function qi(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function Xi(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Ji(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const Yi=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Yr(t,"boxes","nonMaxSuppressionAsync"),o=Yr(e,"scores","nonMaxSuppressionAsync"),i=Vi(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=function(t,e,n,r,a){return Ki(t,e,n,r,a,0)}(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),ui(h,"int32")};const Zi=Qr({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"boxes","nonMaxSuppression"),i=Yr(e,"scores","nonMaxSuppression"),l=Vi(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=Gr.runKernel("NonMaxSuppressionV5",c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const Qi=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"boxes","nonMaxSuppressionAsync"),i=Yr(e,"scores","nonMaxSuppressionAsync"),l=Vi(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=function(t,e,n,r,a,s){return Ki(t,e,n,r,a,s,!0)}(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ui(d,"int32"),selectedScores:ui(p)}};const $i=Qr({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Yr(t,"boxes","nonMaxSuppression"),i=Yr(e,"scores","nonMaxSuppression"),l=Vi(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=Gr.runKernel("NonMaxSuppressionV4",c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const tl=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Yr(t,"boxes","nonMaxSuppressionAsync"),i=Yr(e,"scores","nonMaxSuppressionAsync"),l=Vi(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=function(t,e,n,r,a,s){return Ki(t,e,n,r,a,0,!1,s,!0)}(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ui(f,"int32"),validOutputs:gs(g,"int32")}};const el=Qr({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Yr(t,"images","resizeBilinear");ae(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),ae(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),ae(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Rs(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(Sn,i,l);return o?Rs(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const nl=Qr({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Yr(t,"images","resizeNearestNeighbor");ae(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),ae(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),ae("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),ae(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Rs(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(kn,i,l);return o?Rs(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const rl=Qr({bincount_:function(t,e,n){const r=Yr(t,"x","bincount"),a=Yr(e,"weights","bincount");ae("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),ae(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),ae(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return Gr.runKernel("Bincount",s,o)}});const al=Qr({lessEqual_:function(t,e){let n=Yr(t,"a","lessEqual","string_or_numeric"),r=Yr(e,"b","lessEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LessEqual",a)}});const sl=Qr({round_:function(t){const e={x:Yr(t,"x","round")};return Gr.runKernel(En,e)}});function ol(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return Gr.runKernel(vn,{},a)}const il=Qr({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Yr(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=bo(ui([r]),255);if(ae(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),ae(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),ae("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),ae("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=si(a,[1,1,1],-1);const t=bo(o,.2989),e=bo(i,.587),n=bo(l,.114);c=ys(ys(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=ui([-1]),c=ui([0]),u=ui([0]);for(let h=0;h<t.size-1;h++){n=Qo(t,0,h+1),r=Qo(t,h+1),o=$s(vo(n),e),i=$s(vo(r),e);const d=vo(bo(n,ol(0,n.size)));a=$s(d,vo(n));const p=Ms(r.shape,n.size),f=ys(ol(0,r.size),p),g=bo(r,f);s=$s(vo(g),vo(r));const m=yo(a,s),b=yo(a,s),y=bo(o,i);u=bo(bo(y,m),b);const v=uo(u,c);c=gi(v,u,c),l=gi(v,ui([h]),l)}return l}(rl(Ga(sl(c),"int32"),ea([]),256),s)}const h=n?al(c,u):uo(c,u);return Ga(bo(h,255),"int32")}});const ll=Qr({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=Yr(t,"image","transform","float32"),i=Yr(e,"transforms","transform","float32");ae(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),ae(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),ae(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Gr.runKernel("Transform",l,c)}});const cl=Qr({bandPart_:function(t,e,n){ae(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),ae(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")));const r=Yr(t,"a","bandPart");ae(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);if(!(e<=s))throw new Error("bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=o))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."));e<0&&(e=s),n<0&&(n=o);const i=Rs(ol(0,s,1,"int32"),[-1,1]),l=ol(0,o,1,"int32"),c=yo(i,l),u=xo(al(c,gs(+e,"int32")),ho(c,gs(-n,"int32"))),h=Mo([s,o],r.dtype);return Rs(li(pi(Rs(r,[-1,s,o])).map((t=>gi(u,t,h)))),a)}});const ul=Qr({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","min")},a={axis:e,keepDims:n};return Gr.runKernel("Min",r,a)}});const hl=Qr({pow_:function(t,e){let n=Yr(t,"base","pow"),r=Yr(e,"exp","pow");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel("Pow",a)}});function dl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return bs(t);if(1!==t.rank&&null===n)return dl(Rs(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return vo(bs(t),n);if(e===1/0)return mo(bs(t),n);if(e===-1/0)return ul(bs(t),n);if("euclidean"===e||2===e)return oi(vo(hl(bs(t),gs(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return mo(vo(bs(t),n[0]),n[1]-1);if(e===1/0)return mo(vo(bs(t),n[1]),n[0]);if(e===-1/0)return ul(vo(bs(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return oi(vo(_o(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const pl=Qr({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dl(t=Yr(t,"x","norm"),e,n);let s=a.shape;if(r){const e=de(n,t.shape);s=Ao(a.shape,e)}return Rs(a,s)}});const fl=Qr({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,ae(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)ae(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=si(t,t.shape[0],0).map((t=>ii(t,[0])));ae(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(Gr.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=bo(vo(bo(n[e],t)),n[e]);t=yo(t,r)}return $s(t,pl(t,"euclidean"))})));return e?li(n,0):n}});function gl(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Gr.tidy((()=>{ae(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=io(n),s=Ha(t);const o=hi([[1]],[1,1]);let i=Ha(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=Gr.tidy((()=>{const e=Qo(s,[t,t],[n-t,1]),l=pl(e),c=Qo(s,[t,t],[1,1]),u=gi(uo(c,0),hi([[-1]]),hi([[1]])),h=yo(c,bo(u,l)),d=$s(e,h);i=1===d.shape[0]?Ha(o):Bs([o,Qo(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Oo($s(ko(u,h),l)),f=Qo(s,[t,0],[n-t,r]),g=bo(p,i),m=vi(i);if(0===t)s=yo(f,ko(g,ko(m,f)));else{const e=yo(f,ko(g,ko(m,f)));s=Bs([Qo(s,[0,0],[t,r]),e],0)}const b=vi(g),y=Qo(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=yo(y,ko(ko(y,i),b));else{const e=yo(y,ko(ko(y,i),b));a=Bs([Qo(a,[0,0],[n,t]),e],1)}return[i,s,a]})),hs([e,l,c])}return!e&&n>r&&(a=Qo(a,[0,0],[n,r]),s=Qo(s,[0,0],[r,r])),[a,s]}))}const ml=Qr({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(ae(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return gl(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=pi(Rs(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=gl(t,e);a.push(n),s.push(r)}));return[Rs(li(a,0),t.shape),Rs(li(s,0),t.shape)]}}});var bl;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(bl||(bl={}));const yl=Qr({computeWeightedLoss_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bl.SUM_BY_NONZERO_WEIGHTS;const r=Yr(t,"losses","computeWeightedLoss");let a=null;null!=e&&(a=Yr(e,"weights","computeWeightedLoss"));const s=null==a?r:bo(r,a);if(n===bl.NONE)return s;if(n===bl.SUM)return vo(s);if(n===bl.MEAN){if(null==a)return Eo(s);{const t=r.size/a.size,e=$s(vo(s),vo(a));return t>1?$s(e,gs(t)):e}}if(n===bl.SUM_BY_NONZERO_WEIGHTS){if(null==a)return $s(vo(s),gs(r.size));{const t=bo(a,Po(r.shape)),e=Ga(vo(zo(t,gs(0))),"float32");return $s(vo(s),e)}}throw Error("Unknown reduction: ".concat(n))}});Qr({absoluteDifference_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS;const a=Yr(t,"labels","absoluteDifference"),s=Yr(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=Yr(n,"weights","absoluteDifference")),se(a.shape,s.shape,"Error in absoluteDifference: ");const i=bs(yo(a,s));return yl(i,o,r)}});Qr({cosineDistance_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","cosineDistance"),o=Yr(e,"predictions","cosineDistance");let i=null;null!=r&&(i=Yr(r,"weights","cosineDistance")),se(s.shape,o.shape,"Error in cosineDistance: ");const l=gs(1),c=yo(l,vo(bo(s,o),n,!0));return yl(c,i,a)}});Qr({hingeLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS,a=Yr(t,"labels","hingeLoss");const s=Yr(e,"predictions","hingeLoss");let o=null;null!=n&&(o=Yr(n,"weights","hingeLoss")),se(a.shape,s.shape,"Error in hingeLoss: ");const i=gs(1);a=yo(bo(gs(2),a),i);const l=qo(yo(i,bo(a,s)));return yl(l,o,r)}});Qr({huberLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","huberLoss"),o=Yr(e,"predictions","huberLoss");let i=null;null!=n&&(i=Yr(n,"weights","huberLoss")),se(s.shape,o.shape,"Error in huberLoss: ");const l=gs(r),c=bs(yo(o,s)),u=Co(c,l),h=yo(c,u),d=ys(bo(gs(.5),_o(u)),bo(l,h));return yl(d,i,a)}});Qr({logLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","logLoss"),o=Yr(e,"predictions","logLoss");let i=null;null!=n&&(i=Yr(n,"weights","logLoss")),se(s.shape,o.shape,"Error in logLoss: ");const l=gs(1),c=gs(r),u=Oo(bo(s,fo(ys(o,c)))),h=bo(yo(l,s),fo(ys(yo(l,o),c))),d=yo(u,h);return yl(d,i,a)}});const vl=Qr({squaredDifference_:function(t,e){let n=Yr(t,"a","squaredDifference"),r=Yr(e,"b","squaredDifference");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(Pn,a,{})}});Qr({meanSquaredError_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS;const a=Yr(t,"labels","meanSquaredError"),s=Yr(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=Yr(n,"weights","meanSquaredError")),se(a.shape,s.shape,"Error in meanSquaredError: ");const i=vl(a,s);return yl(i,o,r)}});Qr({sigmoidCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS,s=Yr(t,"multiClassLabels","sigmoidCrossEntropy");const o=Yr(e,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Yr(n,"weights","sigmoidCrossEntropy")),se(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=gs(r),e=gs(1),n=gs(.5);s=ys(bo(s,yo(e,t)),bo(n,t))}const l=function(t,e){const n=Yr(t,"labels","sigmoidCrossEntropyWithLogits"),r=Yr(e,"logits","sigmoidCrossEntropyWithLogits");se(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=qo(r),s=bo(r,n),o=go(ao(Oo(bs(r))));return ys(yo(a,s),o)}(s,o);return yl(l,i,a)}});const wl=Qr({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=Yr(t,"x","logSumExp"),a=de(e,r.shape),s=mo(r,a,!0),o=yo(r,s),i=ao(o),l=vo(i,a),c=fo(l),u=ys(Rs(s,c.shape),c);if(n){const t=Ao(u.shape,a);return Rs(u,t)}return u}});Qr({softmaxCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS,s=Yr(t,"onehotLabels","softmaxCrossEntropy");const o=Yr(e,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Yr(n,"weights","softmaxCrossEntropy")),se(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=gs(r),e=gs(1),n=gs(s.shape[1]);s=ys(bo(s,yo(e,t)),$s(t,n))}const l=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(e.rank," ")+"and dim was ".concat(n));const r=fs(((t,e,r)=>{const a=wl(e,[n],!0),s=yo(Ga(e,"float32"),a);r([t,s]);const o=Oo(bo(s,t));return{value:vo(o,[n]),gradFunc:(t,e)=>{const[r,a]=e,s=Ao(t.shape,[n]);return[bo(Rs(t,s),yo(Ga(r,"float32"),ao(a))),bo(Rs(t,s),yo(ao(a),Ga(r,"float32")))]}}}));return r(t,e)}(s,o);return yl(l,i,a)}});Qr({sparseFillEmptyRows_:function(t,e,n,r){const a=Yr(t,"indices","sparseFillEmptyRows","int32"),s=Yr(e,"values","sparseFillEmptyRows"),o=Yr(n,"denseShape","sparseFillEmptyRows","int32"),i=Yr(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const l={indices:a,values:s,denseShape:o,defaultValue:i},c=Gr.runKernel("SparseFillEmptyRows",l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}});Qr({sparseReshape_:function(t,e,n){const r=Yr(t,"inputIndices","sparseReshape","int32"),a=Yr(e,"inputShape","sparseReshape","int32"),s=Yr(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==a.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(a.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const o={inputIndices:r,inputShape:a,newShape:s},i=Gr.runKernel("SparseReshape",o);return{outputIndices:i[0],outputShape:i[1]}}});Qr({sparseSegmentMean_:function(t,e,n){const r=Yr(t,"data","sparseSegmentMean"),a=Yr(e,"indices","sparseSegmentMean","int32"),s=Yr(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentMean",o)}});Qr({sparseSegmentSum_:function(t,e,n){const r=Yr(t,"data","sparseSegmentSum"),a=Yr(e,"indices","sparseSegmentSum","int32"),s=Yr(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentSum",o)}});Qr({stringNGrams_:function(t,e,n,r,a,s,o,i){const l=Yr(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error("Data must be a vector, saw: ".concat(l.shape));const c=Yr(e,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},h={data:l,dataSplits:c},d=Gr.runKernel("StringNGrams",h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});Qr({stringSplit_:function(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Yr(t,"input","stringSplit","string"),a=Yr(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error("Input should be Tensor1D but received shape ".concat(r.shape));if(0!==a.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(a.shape));const s={skipEmpty:n},o={input:r,delimiter:a},i=Gr.runKernel("StringSplit",o,s);return{indices:i[0],values:i[1],shape:i[2]}}});Qr({stringToHashBucketFast_:function(t,e){const n=Yr(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return Gr.runKernel("StringToHashBucketFast",a,r)}});const xl={flipLeftRight:Bi,grayscaleToRGB:Wi,resizeNearestNeighbor:nl,resizeBilinear:el,rotateWithOffset:Ui,cropAndResize:Pi,nonMaxSuppression:ji,nonMaxSuppressionAsync:Yi,nonMaxSuppressionWithScore:Zi,nonMaxSuppressionWithScoreAsync:Qi,nonMaxSuppressionPadded:$i,nonMaxSuppressionPaddedAsync:tl,threshold:il,transform:ll},kl={bandPart:cl,gramSchmidt:fl,qr:ml};class Sl extends ms{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:us((()=>mi(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:us((()=>mi(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;us((()=>{const t=ys(bo(s,this.rho),bo(_o(a),1-this.rho)),e=bo($s(oi(ys(o,this.epsilon)),oi(ys(s,this.epsilon))),a),n=ys(bo(o,this.rho),bo(_o(e),1-this.rho));s.assign(t),o.assign(n);const i=ys(bo(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(hs(this.accumulatedGrads.map((t=>t.variable))),hs(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}Sl.className="Adadelta",ls(Sl);class Il extends ms{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:us((()=>Ms(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;us((()=>{const t=ys(s,_o(a));s.assign(t);const e=ys(bo($s(a,oi(ys(t,Gr.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&hs(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}Il.className="Adagrad",ls(Il);class Nl extends ms{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],us((()=>{this.accBeta1=gs(e).variable(),this.accBeta2=gs(n).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);us((()=>{const n=yo(1,this.accBeta1),r=yo(1,this.accBeta2);e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:us((()=>mi(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:us((()=>mi(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=ys(bo(i,this.beta1),bo(o,1-this.beta1)),u=ys(bo(l,this.beta2),bo(_o(o),1-this.beta2)),h=$s(c,n),d=$s(u,r);i.assign(c),l.assign(u);const p=ys(bo($s(h,ys(oi(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(bo(this.accBeta1,this.beta1)),this.accBeta2.assign(bo(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&hs(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&hs(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),us((()=>{this.accBeta1.assign(hl(this.beta1,this.iterations_+1)),this.accBeta2.assign(hl(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Nl.className="Adam",ls(Nl);class El extends ms{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],us((()=>{this.iteration=gs(0).variable(),this.accBeta1=gs(e).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);us((()=>{const n=yo(1,this.accBeta1),r=$s(-this.learningRate,ys(bo(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:mi(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:mi(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=ys(bo(i,this.beta1),bo(o,1-this.beta1)),u=bo(l,this.beta2),h=bs(o),d=No(u,h);i.assign(c),l.assign(d);const p=ys(bo($s(r,n),$s(c,ys(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(ys(this.iteration,1)),this.accBeta1.assign(bo(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&hs(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&hs(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}El.className="Adamax",ls(El);class Cl extends ms{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=Gr.registeredVariables[e];us((()=>{const t=ys(bo(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=ds(gs(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Cl.className="SGD",ls(Cl);class Tl extends Cl{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=gs(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:us((()=>mi(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&us((()=>{let t;const e=ys(bo(this.m,a),s);t=this.useNesterov?ys(bo(this.c,ys(s,bo(e,this.m))),r):ys(bo(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&hs(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Tl.className="Momentum",ls(Tl);class Al extends ms{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Gr.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:us((()=>mi(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:us((()=>mi(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:us((()=>mi(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;us((()=>{const t=ys(bo(o,this.decay),bo(_o(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=ys(bo(e,this.decay),bo(s,1-this.decay)),l=$s(bo(s,this.learningRate),oi(yo(t,ys(_o(a),this.epsilon)))),c=ys(bo(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=yo(r,c);r.assign(u)}else{const t=ys(bo(o,this.decay),bo(_o(s),1-this.decay)),e=ys(bo(i,this.momentum),$s(bo(s,this.learningRate),oi(ys(t,this.epsilon))));o.assign(t),i.assign(e);const n=yo(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&hs(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&hs(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&hs(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Al.className="RMSProp",ls(Al);class Rl{static sgd(t){return new Cl(t)}static momentum(t,e){return new Tl(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new Al(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Nl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Sl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new El(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new Il(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Fl={sgd:Rl.sgd,momentum:Rl.momentum,adadelta:Rl.adadelta,adagrad:Rl.adagrad,rmsprop:Rl.rmsprop,adamax:Rl.adamax,adam:Rl.adam},_l="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function Dl(){return new Promise((t=>_l((()=>t()))))}var Ol,zl=n(6494);function Ll(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(Ul(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=Ll(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function Ml(t){return Pl(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:Bl)}function Pl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(Ul(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=Pl(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function Bl(t){return null===t?null:Ul(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function Wl(t,e){const n=new Map;Ll(t,e,n);for(const r of Array.from(n.keys())){const t=n.get(r);if(Ne(t)){const e=await t;n.set(r,e)}}return Ll(t,e,n)}function Ul(t){let e=!1;if(Ae().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(551);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Cr)&&!(t instanceof Promise)&&!e)}function Vl(t){return function(t,e){return Ll(t,e)}(t,jl)}function jl(t){return t instanceof Cr?{value:t.clone(),recurse:!1}:Ul(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class Gl{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class Hl extends Gl{constructor(){super(Hl.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function Kl(t){return new Yl(t)}function ql(t){return new Zl(t)}function Xl(t,e){return new lc(t,e)}Hl.INITIAL_CAPACITY=32;class Jl{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new ac(this,t)}filter(t){return new nc(this,t)}map(t){return new rc(this,t)}mapAsync(t){return new sc(this,t)}serialMapAsync(t){return new sc(this,t).serial()}flatmap(t){return new ic(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new ec(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bl;return this.rowMajorBatch(t,e).map((t=>Ml(t,n)))}concatenate(t,e){return new lc(Kl([this,t]),e)}take(t){return t<0||null==t?this:new tc(this,t)}skip(t){return t<0||null==t?this:new $l(this,t)}prefetch(t){return new uc(this,t)}shuffle(t,e){return new hc(this,t,e)}serial(){return new Ql(this)}}class Yl extends Jl{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:Vl(t),done:!1}}}class Zl extends Jl{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(d1){throw d1.message="Error thrown while iterating through a dataset: ".concat(d1.message),d1}}}class Ql extends Jl{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class $l extends Jl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;hs(t.value)}return this.upstream.next()}}class tc extends Jl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class ec extends Jl{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class nc extends Jl{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;hs(t.value)}}}class rc extends Jl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Pr(t.value),n=this.transform(t.value),r=Pr(n);for(const a of e)Mr(a,r)||a.dispose();return{value:n,done:!1}}}class ac extends Jl{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(d1){if(!this.handler(d1))return{value:null,done:!0}}}}class sc extends Jl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Pr(t.value),n=await this.transform(t.value),r=Pr(n);for(const a of e)Mr(a,r)||a.dispose();return{value:n,done:!1}}}class oc extends Jl{constructor(){super(),this.outputQueue=new Hl,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ic extends oc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Pr(t.value),n=this.transform(t.value),r=Pr(n);this.outputQueue.pushAll(n);for(const a of e)Mr(a,r)||a.dispose();return!0}}class lc extends Jl{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(Ol||(Ol={}));class cc extends Jl{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ol.FAIL;super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{".concat("TODO: fill in upstream of zip summaries","} -> Zip")}async nextState(t){await t;let e=0,n=0;const r=await Wl(this.iterators,(function(t){if(t instanceof Jl){return{value:t.next().then((t=>(e++,t.done&&n++,t.value))),recurse:!1}}return{value:null,recurse:!0}}));if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Ol.FAIL:throw new Error("Zipped streams should have the same length. "+"Mismatched at element ".concat(this.count,"."));case Ol.SHORTEST:return{value:null,done:!0};case Ol.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class uc extends Jl{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new Gl(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class hc extends uc{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Vo.alea(n||cr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class dc{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return ae(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),pc((async()=>(await n.iterator()).columnMajorBatch(t,e,mc)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,pc((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,pc((async()=>(await e.iterator()).filter((e=>us((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return pc((async()=>(await e.iterator()).map((e=>us((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return pc((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return pc((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,pc((async()=>Xl(ql((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,pc((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Vo.alea(e||cr().toString());return pc((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,pc((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function pc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends dc{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function fc(t){return pc((async()=>Kl(t)),t.length)}function gc(t){if(!Ul(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=null==e?t[n].size:Math.min(e,t[n].size);return pc((async()=>function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ol.FAIL;return new cc(t,e)}(await Wl(t,(t=>{if(t instanceof dc)return{value:t.iterator(),recurse:!1};if(Ul(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),Ol.SHORTEST)),e)}function mc(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Cr||pe(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Cr?li(t):ea(t)}(t),recurse:!1}}return{value:null,recurse:!0}}dc.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");class bc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bc.prototype)}}class yc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,yc.prototype)}}class vc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vc.prototype)}}class wc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,wc.prototype)}}class xc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xc.prototype)}}Error;class kc{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function Sc(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function Ic(t,e){if(!t)throw new xc(e)}function Nc(t,e){let n=0;for(const r of t)r===e&&n++;return n}function Ec(t){return 1===t.length?t[0]:t}function Cc(t){return Array.isArray(t)?t:[t]}function Tc(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Ac(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let Rc={};function Fc(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function _c(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>_c(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?_c(e):t[n]=e.value)}}}function Dc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in Rc)s=Rc[a];else if(s=e[a],null==s)throw new vc("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new vc("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in Rc?[i,l]=Rc.className:o in e&&([i,l]=e[o]),null==i)throw new vc("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(Rc))t[n]=Rc[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},Rc);for(const a of Object.keys(n))Rc[a]=n[a];_c(s.config);const r=l(i,s.config,n,a);return Rc=Object.assign({},e),r}{const t=Object.assign({},Rc);for(const r of Object.keys(n))Rc[r]=n[r];const e=new i(s.config);return Rc=Object.assign({},t),e}}}function Oc(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function zc(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function Lc(t){if(null==t)throw new vc("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Mc(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new vc("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function Pc(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Ic(n>=0),Ic(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function Bc(t,e){Array.isArray(t)?(ae(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>Bc(t,"element ".concat(n+1," of ").concat(e))))):ae(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(Wc(t),".")))}function Wc(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>Wc(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function Uc(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let Vc=0;function jc(){return Vc++}const Gc={};function Hc(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in Gc||(Gc[t]=0),Gc[t]+=1,t+Gc[t].toString()}const Kc=["channelsFirst","channelsLast"],qc=["nearest","bilinear"],Xc=["valid","same","causal"],Jc=["max","avg"],Yc=["sum","mul","concat","ave"],Zc=new Map;function Qc(t){Mc(Kc,"DataFormat",t)}function $c(t){Mc(Xc,"PaddingMode",t)}function tu(t){Mc(Jc,"PoolMode",t)}const eu=[],nu="/";function ru(t,e){eu.push(t);try{const t=e();return eu.pop(),t}catch(d1){throw eu.pop(),d1}}function au(t){if(!iu(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===eu.length?"":eu.join(nu)+nu)+t}function su(t){if(!iu(t))throw new Error("Not a valid tensor name: '"+t+"'");Zc.has(t)||Zc.set(t,0);const e=Zc.get(t);if(Zc.set(t,Zc.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return Zc.set(n,1),n}return t}const ou=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function iu(t){return!!t.match(ou)}function lu(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function cu(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function uu(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function hu(t,e){if(e<t)throw new vc("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let du;function pu(){return null==du&&(du=ps().epsilon()),du}function fu(t,e){return Ga(t,e)}function gu(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),Rs(t,n)}function mu(t,e,n){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:return ti(t,[e,0],[n,t.shape[1]]);case 3:return ei(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return ni(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Qo(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Qo(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new vc("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function bu(t,e,n){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:return ti(t,[0,e],[t.shape[0],n]);case 3:return ei(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return ni(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new vc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function yu(t,e,n,r){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:switch(r){case 1:return mu(t,e,n);case 2:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return mu(t,e,n);case 2:return ei(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return mu(t,e,n);case 2:return ni(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return ni(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new vc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function vu(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Bs(t,n)}function wu(t,e){switch(t.rank){case 1:return Ws([t,e]);case 2:return Us([t,e],0);case 3:return Vs([t,e],0);case 4:return js([t,e],0);default:throw new vc("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function xu(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new vc("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return oo(t,e)}function ku(t){return Ho(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Su(t,e,n,r){if(t.rank<2||e.rank<2)throw new wc("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new wc("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return Oi({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Eu(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=Rs(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=Rs(vi(e,u),[l,-1]);const h=[...a,...c];return Rs(Oi({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Eu(t.rank,r,"channelsLast"):null,activation:n}),h)}}function Iu(t,e,n){return us((()=>(e=Array.isArray(e)?ui(e,"int32"):Ga(e,"int32"),co(t,e,n))))}function Nu(t){return bo(t,t)}function Eu(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new vc("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1,1,1]):Rs(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,1,1,r[0]]):Rs(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1,1]):Rs(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,1,r[0]]):Rs(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1]):Rs(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,r[0]]):Rs(e,[1].concat(r))}else if(t<3)return e;throw new vc("Unsupported input rank by biasAdd: ".concat(e.rank))}function Cu(t,e,n){return us((()=>(null==n&&(n="channelsLast"),Qc(n),ys(t,Eu(t.rank,e,n)))))}function Tu(t,e,n,r){return us((()=>wi(t,e,n,r)))}function Au(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const Ru=["fanIn","fanOut","fanAvg"],Fu=["normal","uniform","truncatedNormal"];class _u extends os{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Du extends _u{apply(t,e){return Mo(t,e)}}Du.className="Zeros",ls(Du);class Ou extends _u{apply(t,e){return Po(t,e)}}Ou.className="Ones",ls(Ou);class zu extends _u{constructor(t){if(super(),"object"!==typeof t)throw new vc("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new vc("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return us((()=>bo(gs(this.value),Po(t,e))))}getConfig(){return{value:this.value}}}zu.className="Constant",ls(zu);class Lu extends _u{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Ko(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Lu.className="RandomUniform",ls(Lu);class Mu extends _u{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("randomNormal does not support dType ".concat(e,"."));return ku(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Mu.className="RandomNormal",ls(Mu);class Pu extends _u{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("truncatedNormal does not support dType ".concat(e,"."));return di(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Pu.className="TruncatedNormal",ls(Pu);class Bu extends _u{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return us((()=>{if(2!==t.length||t[0]!==t[1])throw new vc("Identity matrix initializer can only be used for 2D square matrices.");return bo(this.gain,io(t[0]))}))}getConfig(){return{gain:this.gain}}}Bu.className="Identity",ls(Bu);class Wu extends _u{constructor(t){if(super(),t.scale<0)throw new vc("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,Mc(Ru,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){Mc(Fu,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Qc(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=lu(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=lu(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=lu(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("".concat(this.getClassName()," does not support dType ").concat(e,"."));return di(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return Ko(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Wu.className="VarianceScaling",ls(Wu);class Uu extends Wu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Uu.className="GlorotUniform",ls(Uu);class Vu extends Wu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Vu.className="GlorotNormal",ls(Vu);class ju extends Wu{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}ju.className="HeNormal",ls(ju);class Gu extends Wu{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Gu.className="HeUniform",ls(Gu);class Hu extends Wu{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Hu.className="LeCunNormal",ls(Hu);class Ku extends Wu{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Ku.className="LeCunNormal",ls(Ku);class qu extends _u{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new wc("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return us((()=>{if(t.length<2)throw new wc("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than 2000 (".concat(t[0]*t[1],") elements: ")+"Slowness may result.");const e=ku(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=kl.gramSchmidt(e);return t[0]>t[1]&&(n=vi(n)),bo(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}qu.className="Orthogonal",ls(qu);const Xu={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ju(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"initializer")}function Yu(t){return Fc(t)}function Zu(t){if("string"===typeof t){const e=t in Xu?Xu[t]:t;if("GlorotNormal"===e)return new Vu;if("GlorotUniform"===e)return new Uu;if("HeNormal"===e)return new ju;if("HeUniform"===e)return new Gu;if("LeCunNormal"===e)return new Hu;if("LeCunUniform"===e)return new Ku;{const t={};return t.className=e,t.config={},Ju(t)}}return t instanceof _u?t:Ju(t)}function Qu(t){return Array.isArray(t)&&Array.isArray(t[0])}function $u(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function th(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new vc("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function eh(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new vc("Expected exactly 1 Shape; got ".concat(t.length))}return t}function nh(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const rh="Variable";class ah{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rh,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=jc(),n=null==n?rh:n,this.originalName=au(n),this.name=su(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Gr.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function sh(t){return t.map((t=>t.read()))}function oh(t){t.forEach((t=>{t[0].write(t[1])}))}class ih{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class lh{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=jc(),null!=s&&(this.originalName=au(s),this.name=su(this.originalName)),this.rank=e.length}}let ch=0;class uh{constructor(t,e){this.callArgs=e,this.id=ch++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hh=0;class dh extends os{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hh++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=Tc(t)+"_"+Hc(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new yc("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new vc("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return Ec(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ec(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new bc("Layer ".concat(this.name)+" is not connected, no input to return.");return Ec(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bc("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new bc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Ec(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Cc(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=Cc(this.inputSpec);if(t.length!==e.length)throw new vc("Layer ".concat(this.name," expects ").concat(e.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(t));for(let n=0;n<t.length;n++){const r=t[n],a=e[n];if(null==a)continue;const s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&r.dtype!==a.dtype)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(r.dtype,"."));if(a.axes){const t=r.shape;for(const e in a.axes){const r=Number(e),s=a.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(o))throw new vc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(r," of input shape to ")+"have value ".concat(s," but got shape ").concat(t,"."))}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const e=a.shape[t],s=r.shape[t];if(null!=e&&null!=s&&e!==s)throw new vc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(r.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=Cc(t);let r=!0;for(const s of n)if(!(s instanceof lh)){r=!1;break}let a=!0;for(const s of n)if(s instanceof lh){a=!1;break}if(r===a)throw new vc("Arguments to apply() must be all SymbolicTensors or all Tensors");return ru(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of Cc(t))e.push(n.shape);this.build(Ec(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);const a=Cc(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=Ec(s),null!=this.activityRegularizer)throw new wc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=Cc(t);const e=[];for(const n of t)e.push(n.shape);return Ec(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new lh(s,n,this,Cc(t),e,this.name,r))):new lh(s,r,this,Cc(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new wc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bc("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new bc("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new yc("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return nh(this.weights)}build(t){this.built=!0}getWeights(){return sh(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){us((()=>{const e=this.weights;if(e.length!==t.length)throw new vc('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=sh(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!ce(s.shape,i.shape))throw new vc("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}oh(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new vc("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():Zu("zeros"));const l=r.apply(e,n),c=new ah(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Cc(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=Cc(t);e=Cc(e),n=Cc(n),r=Cc(r),a=$u(a),s=$u(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new uh({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function ph(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=ph(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class fh extends dh{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:Hc("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new vc("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new vc("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new vc("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new lh(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new vc("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function gh(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new vc("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;null==n&&(n="float32");return new fh({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}fh.className="InputLayer",ls(fh);class mh{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof mh)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new vc("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Ga(e,t.dtype)}catch(p1){throw new vc("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof lh){if(null==this.id2Value[t.id])throw new vc("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new vc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof lh){if(null==this.id2Value[t.id])throw new vc("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new vc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&hs(this.id2Mask)}}const bh=new kc,yh=new kc;function vh(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=bh.get(u);if(null==d){const t=function(t,e){ae(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=xh(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=xh(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:wh(r)}}(o,e);d=t.sorted,h=t.recipientCounts,bh.put(u,d),yh.put(u,h)}h={},a||Object.assign(h,yh.get(u));const p=new mh(e);for(let f=0;f<d.length;++f){if(null!=r){const t=cs().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof fh)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=Cc(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=kh(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||hs(u)}return p.disposeMasks(),s?l:l[0]}function wh(t){const e={};for(const n in t)e[n]=t[n].size;return e}function xh(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function kh(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}Ae().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=bh&&bh.setMaxEntries(t),null!=yh&&yh.setMaxEntries(t)}));const Sh={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Ei(Ga(n,"float32"),-1))}}},Ih={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=_o(Ga(n,"float32")),r=oi(yo(gs(1),e));return Oo($s(t,r))}}}},Nh={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oi(yo(_o(Ga(n,"float32")),1));return $s(t,e)}}}},Eh={kernelName:Oe,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{let e=t;const r=eo(n.shape,a);return r.length>0&&(e=vo(e,r)),Rs(e,n.shape)},b:()=>{let e=t;const n=eo(r.shape,a);return n.length>0&&(e=vo(e,n)),Rs(e,r.shape)}}}},Ch={kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},Th={kernelName:ze,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mi(n)}}},Ah={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mi(n)}}},Rh={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,oi(yo(gs(1),_o(Ga(n,"float32")))))}}},Fh={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oi(ys(gs(1),_o(Ga(n,"float32"))));return $s(t,e)}}}},_h={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=ys(_o(n),_o(r));let s=bo(t,$s(r,e));const o=eo(n.shape,a);return o.length>0&&(s=vo(s,o)),Rs(s,n.shape)},b:()=>{const e=ys(_o(n),_o(r));let s=Oo(bo(t,$s(n,e)));const o=eo(r.shape,a);return o.length>0&&(s=vo(s,o)),Rs(s,r.shape)}}}},Dh={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,ys(_o(Ga(n,"float32")),1))}}},Oh={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,yo(gs(1),_o(Ga(n,"float32"))))}}};const zh=Qr({avgPool3dGrad_:function(t,e,n,r,a,s){const o=Yr(t,"dy","avgPool3dGrad"),i=Yr(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),ae(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),As("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Gr.runKernel("AvgPool3DGrad",h,d);return u?Rs(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Lh={kernelName:Me,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>zh(t,r,a,s,o,i)}}};const Mh=Qr({avgPoolGrad_:function(t,e,n,r,a){const s=Yr(t,"dy","avgPoolGrad"),o=Yr(e,"input","avgPoolGrad");ae(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),ae(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=Gr.runKernel("AvgPoolGrad",u,h);return c?Rs(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ph={kernelName:Le,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Mh(t,r,a,s,o)}}},Bh={kernelName:Pe,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>ko(t,a,!1,!1),b:()=>ko(t,r,!0,!1)}:s&&!o?{a:()=>ko(a,t,!1,!0),b:()=>ko(r,t,!1,!1)}:{a:()=>ko(a,t,!0,!0),b:()=>ko(t,r,!0,!0)}:{a:()=>ko(t,a,!1,!0),b:()=>ko(r,t,!0,!1)}}};const Wh=Qr({spaceToBatchND_:function(t,e,n){const r=Yr(t,"x","spaceToBatchND");ae(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),ae(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),ae(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return Gr.runKernel(zn,a,s)}}),Uh={kernelName:Be,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Wh(t,r,a)}}},Vh={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>vo(t,i,!0)}}},jh={kernelName:We,gradFunc:t=>({x:()=>t.clone()})},Gh={kernelName:"Ceil",gradFunc:t=>({x:()=>mi(t)})},Hh={kernelName:Ue,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>gi(xo(ho(r,a),al(r,s)),t,mi(t))}}},Kh={kernelName:Ve,inputsToSave:["x"],gradFunc:Sh.gradFunc},qh={kernelName:je,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=de(a,e[0].shape)[0],o=r.map((t=>t[s]));return si(t,o,s).map((t=>()=>t))}},Xh={kernelName:Ge,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return ae(Cs(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>Ks(r.shape,t,a,o,i,l),filter:()=>Ii(r,t,a.shape,o,i,l)}}},Jh={kernelName:He,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Gs(t,a,s,o,i,1,l),filter:()=>Ii(t,r,a.shape,s,o,i,l)}}};const Yh=Qr({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ae(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),ae(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),ae(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),ae(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),ae(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return Gr.runKernel("Conv3DBackpropFilterV2",i,l)}}),Zh={kernelName:Ke,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;ae(Cs(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>Js(o.shape,t,i,a,s),filter:()=>Yh(o,t,i.shape,a,s)}}};const Qh=Qr({sin_:function(t){const e={x:Yr(t,"x","sin","float32")};return Gr.runKernel("Sin",e)}}),$h={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(Oo(Qh(Ga(n,"float32"))),t)}}};const td=Qr({sinh_:function(t){const e={x:Yr(t,"x","sinh")};return Gr.runKernel(Fn,e)}}),ed={kernelName:qe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(td(Ga(n,"float32")),t)}}};const nd=Qr({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Yr(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel(Xe,a,s)}}),rd={kernelName:Xe,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=Ro([a],r.rank);let n=nd(t,a,s,!o);return null!=e&&(n=vi(n,e)),n}}}},ad={kernelName:Je,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;ae(Cs(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return ae(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),ae(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),ae(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),ae(Ts(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),As("depthwiseConv2d",s,o),{x:()=>Di(l.shape,t,c,a,s,i,o),filter:()=>_i(l,t,c.shape,a,s,i,o)}}},sd={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>Gr.runKernel("Dilation2DBackpropInput",s,n),filter:()=>Gr.runKernel("Dilation2DBackpropFilter",o,n)}}},od={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Gr.runKernel("EluGrad",r)}}},id={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bo(ao(Oo(_o(n))),2/Math.sqrt(Math.PI));return{x:()=>bo(t,r)}}},ld={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,n)}}},cd={kernelName:Ze,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>Rs(t,n.shape)}}},ud={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,ao(n))}}},hd={kernelName:$e,gradFunc:t=>({x:()=>mi(t)})},dd={kernelName:tn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=$s(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{let e=bo(t,Ga(n,"float32"));const s=eo(r.shape,a);s.length>0&&(e=Rs(vo(e,s),r.shape));const o=_o(r);return Oo($s(e,Ga(o,"float32")))}}}};const pd=Qr({rsqrt_:function(t){const e={x:Yr(t,"x","rsqrt","float32")};return Gr.runKernel(Cn,e)}}),fd={kernelName:en,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?gs(1):i,c=eo(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=yo(a,s),d=bo(t,l),p=pd(ys(o,gs(r))),f=bo(bo(bo(p,p),p),gs(-.5));return{x:()=>1===s.rank?Rs(bo(bo(t,oo(Rs(p,[1,1,1,s.shape[0]]),u)),l),a.shape):Rs(bo(bo(t,p),l),a.shape),mean:()=>{let t=bo(bo(p,gs(-1)),d);return 1===s.rank&&(t=vo(t,c)),Rs(t,s.shape)},variance:()=>{let t=bo(bo(f,h),d);return 1===s.rank&&(t=vo(t,c)),Rs(t,s.shape)},scale:()=>{const e=bo(h,p);let n=bo(t,e);return 1===s.rank&&(n=vo(n,c)),Rs(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=vo(e,c)),Rs(e,s.shape)}}}};const gd=Qr({unsortedSegmentSum_:function(t,e,n){const r=Yr(t,"x","unsortedSegmentSum"),a=Yr(e,"segmentIds","unsortedSegmentSum","int32");ae(ue(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return Gr.runKernel(jn,s,o)}}),md={kernelName:nn,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s}=n,o=de(s,r.shape)[0];return{x:()=>{const e=r.shape,n=a.size,i=e.slice(0,o),l=i.length,c=e.slice(s,e.length).slice(1),u=c.length,h=bd(0,l),d=bd(l+1,l+1+u),p=yd([i,[n],c]),f=Rs(t,p),g=Rs(a,[n]),m=yd([[l],h,d]),b=vi(f,m);let y=gd(b,g,r.shape[o]);const v=Fo(m);return y=vi(y,v),y},indices:()=>a}}};function bd(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function yd(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const vd={kernelName:rn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mi(n),b:()=>mi(r)}}},wd={kernelName:an,gradFunc:t=>({x:()=>Ga(t,"float32")})},xd={kernelName:"IsFinite",gradFunc:t=>({x:()=>mi(t)})},kd={kernelName:"IsInf",gradFunc:t=>({x:()=>mi(t)})},Sd={kernelName:"IsNan",gradFunc:t=>({x:()=>mi(t)})},Id={kernelName:sn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=uo(r,0);return{x:()=>gi(s,t,bo(t,a))}}},Nd={kernelName:on,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,ys(n,1))}}},Ed={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,Ga(n,"float32"))}}},Cd={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=ao(r);return yo(t,bo(vo(t,a,!0),e))}}}};const Td=Qr({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Gr.runKernel("LRNGrad",r,a)}}),Ad={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>Td(r,a,t,s,o,i,l)}}};function Rd(t,e,n,r){return e.rank<n.rank&&(e=Rs(e,Ao(e.shape,r))),t.rank<n.rank&&(t=Rs(t,Ao(t.shape,r))),{x:()=>bo(t,Ga(ro(n,e),t.dtype))}}const Fd={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=Rd(t,e[1],s,de(a,s.shape));return{x:()=>o.x()}}};const _d=Qr({less_:function(t,e){let n=Yr(t,"a","less","string_or_numeric"),r=Yr(e,"b","less","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Less",a)}}),Dd={kernelName:ln,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bo(t,Ga(ho(n,r),"float32")),b:()=>bo(t,Ga(_d(n,r),"float32"))}}};const Od=Qr({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=Yr(t,"dy","maxPool3dGrad"),l=Yr(e,"input","maxPool3dGrad"),c=Yr(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=Rs(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Rs(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ae(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),ae(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),ae(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),As("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=Gr.runKernel("MaxPool3DGrad",f,g);return p?Rs(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),zd={kernelName:un,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>Od(t,r,a,s,o,i,l)}}};const Ld=Qr({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=Yr(t,"dy","maxPoolGrad"),l=Yr(e,"input","maxPoolGrad"),c=Yr(n,"output","maxPoolGrad");ae(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),ae(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),ae(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),As("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return Gr.runKernel("MaxPoolGrad",u,h)}}),Md={kernelName:cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>Ld(t,r,a,s,o,i)}}},Pd={kernelName:hn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=de(a,r.shape),o=function(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}(r.shape,s),i=le(o[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=Rs(t,e);return $s(bo(n,Po(r.shape,"float32")),i)}}}},Bd={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=Rd(t,o,s,de(a,s.shape));return{x:()=>i.x()}}},Wd={kernelName:dn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bo(t,Ga(al(n,r),"float32")),b:()=>bo(t,Ga(uo(n,r),"float32"))}}},Ud={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Qo(t,s,r.shape)}}},Vd={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=eo(n.shape,a);return e.length>0?Rs(vo(t,e),n.shape):t},b:()=>{const e=bo(t,Oo(lo($s(n,r)))),s=eo(r.shape,a);return s.length>0?Rs(vo(e,s),r.shape):e}}}},jd={kernelName:pn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=bo(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{const e=bo(t,Ga(n,"float32")),s=eo(r.shape,a);return s.length>0?Rs(vo(e,s),r.shape):e}}}},Gd={kernelName:"Neg",gradFunc:t=>({x:()=>Oo(t)})},Hd={kernelName:gn,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Mo(n.shape,"float32")}}},Kd={kernelName:fn,gradFunc:t=>({x:()=>mi(t)})},qd={kernelName:mn,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return pi(t,r).map((t=>()=>t))}},Xd={kernelName:bn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Qo(t,s,r.shape)}}},Jd={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=no(s.shape,o.shape);return{a:()=>{const e=Ga(o,"float32");let n=bo(t,bo(e,hl(s,yo(e,gs(1)))));const r=eo(s.shape,i);return r.length>0&&(n=vo(n,r)),Rs(n,s.shape)},b:()=>{const e=uo(s,0),n=gi(e,fo(s),mi(s));let r=bo(t,bo(a,n));const l=eo(o.shape,i);return l.length>0&&(r=vo(r,l)),Rs(r,o.shape)}}}},Yd={kernelName:yn,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=uo(n,0);return{x:()=>gi(a,t,bo(t,r)),alpha:()=>{let e=gi(a,mi(t),bo(t,n));const s=eo(r.shape,t.shape);return s.length>0&&(e=vo(e,s)),Rs(e,r.shape)}}}};const Zd=Qr({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Yr(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel("Cumprod",a,s)}});function Qd(t,e,n){const r=t.shape.length,a=r-n.length,s=Ro(n,r);let o=t;null!=s&&(o=vi(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=Rs(e,r),s=Zd(t,n,!0,!1),o=Zd(t,n,!0,!0),i=bo(s,o);return bo(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=Fo(s);c=vi(c,t)}return c}const $d={kernelName:"Prod",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>Qd(r,t,s)}}},tp={kernelName:Ye,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=$s(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{let e=bo(t,Ga(n,"float32"));const s=eo(r.shape,a);s.length>0&&(e=Rs(vo(e,s),r.shape));const o=_o(r);return Oo($s(e,Ga(o,"float32")))}}}},ep={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,Oo(_o(n)))}}},np={kernelName:In,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bo(al(n,6),Ei(n));return{x:()=>bo(t,Ga(r,"float32"))}}},rp={kernelName:wn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Ga(Ei(n),"float32"))}}},ap={kernelName:xn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Rs(t,n.shape)}}},sp={kernelName:Sn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeBilinearGrad",a,n)}}},op={kernelName:kn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeNearestNeighborGrad",a,n)}}},ip={kernelName:Nn,gradFunc:(t,e,n)=>{const{dims:r}=n,a=de(r,t.shape);return{x:()=>Xo(t,a)}}},lp={kernelName:En,gradFunc:t=>({x:()=>mi(t)})},cp={kernelName:Cn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Oo($s(t,bo(hl(n,1.5),2)))}}};const up=Qr({logicalNot_:function(t){const e={x:Yr(t,"x","logicalNot","bool")};return Gr.runKernel("LogicalNot",e)}}),hp={kernelName:Tn,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Ga(mi(n),"float32"),t:()=>bo(t,Ga(n,t.dtype)),e:()=>bo(t,Ga(up(n),t.dtype))}}},dp={kernelName:An,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=uo(n,gs(0)),r=gs(1.7580993408473768),a=gs(1.0507009873554805),s=bo(t,a),o=bo(bo(t,r),ao(Ga(n,"float32")));return gi(e,s,o)}}}},pp={kernelName:_n,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,bo(n,yo(gs(1),n)))}}},fp={kernelName:"Sign",gradFunc:t=>({x:()=>mi(t)})};const gp=Qr({cos_:function(t){const e={x:Yr(t,"x","cos","float32")};return Gr.runKernel("Cos",e)}}),mp={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(gp(Ga(n,"float32")),t)}}};const bp=Qr({cosh_:function(t){const e={x:Yr(t,"x","cosh","float32")};return Gr.runKernel(qe,e)}}),yp={kernelName:Fn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(bp(Ga(n,"float32")),t)}}};const vp={kernelName:Rn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=function(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{ae(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(ae(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>Wo(t,c)}}},wp={kernelName:Mn,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=bo(t,r);return{logits:()=>yo(s,bo(vo(s,[a],true),r))}}},xp={kernelName:Dn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Zo(n))}}};const kp=Qr({batchToSpaceND_:function(t,e,n){const r=Yr(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));ae(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),ae(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),ae(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return Gr.runKernel(Be,s,o)}}),Sp={kernelName:zn,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>kp(t,r,a)}}},Ip={kernelName:Ln,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Bs(t,r)}}};const Np=[Sh,Ih,Nh,Eh,Ch,Th,Ah,Rh,Fh,_h,Dh,Oh,Lh,Ph,Bh,Uh,Vh,jh,Gh,Hh,Kh,qh,Jh,Xh,Zh,$h,ed,rd,ad,sd,tp,od,id,ld,cd,ud,dd,hd,fd,md,vd,wd,xd,kd,Sd,Id,Nd,Ed,Cd,Ad,Fd,Fd,Dd,zd,Md,Pd,Bd,Wd,Ud,Vd,jd,Gd,Hd,Kd,qd,Xd,Xd,Jd,Yd,$d,ep,np,rp,ap,sp,op,ip,lp,cp,hp,dp,pp,fp,mp,yp,vp,wp,xp,Sp,Sp,Ip,Ip,{kernelName:On,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,bo(oi(Ga(n,"float32")),2))}}},{kernelName:Pn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=gs(2);return{a:()=>bo(t,bo(a,yo(n,r))),b:()=>bo(t,bo(a,yo(r,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,bo(Ga(n,"float32"),2))}}},{kernelName:Hn,gradFunc:t=>({x:()=>mi(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{let e=t;const r=eo(n.shape,a);return r.length>0&&(e=vo(e,r)),Rs(e,n.shape)},b:()=>{let e=t;const n=eo(r.shape,a);return n.length>0&&(e=vo(e,n)),Rs(Oo(e),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;de(s,r.shape).forEach((t=>{a[t]=1}));const o=Rs(t,a),i=bo(o,Po(r.shape,"float32"));return{x:()=>i}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,_o(gp(n)))}}},{kernelName:Bn,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(yo(gs(1),_o(n)),t)}}},{kernelName:Wn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=mi(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=ys(e,Qo(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Un,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=Fo(a);return{x:()=>vi(t,s)}}},{kernelName:Vn,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>li(t,a)}}},{kernelName:jn,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=No(e,mi(e)),r=co(t,n);let a=ho(e,gs(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=so(a,i+1);a=xo(a,Po(r.shape,"bool"));const o=mi(r);return gi(a,r,o)}(t,n)}}},{kernelName:Gn,gradFunc:t=>({x:()=>mi(t)})}];for(const n of Np)nr(n);function Ep(t,e){return us((()=>oi(vo(bo(t,t),e,!0))))}class Cp extends os{getConfig(){return{}}}class Tp extends Cp{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>{const e=Ep(t,this.axis),n=Ps(e,0,this.maxValue);return bo(t,$s(n,ys(pu(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Tp.className="MaxNorm",ls(Tp);class Ap extends Cp{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>$s(t,ys(pu(),Ep(t,this.axis)))))}getConfig(){return{axis:this.axis}}}Ap.className="UnitNorm",ls(Ap);class Rp extends Cp{apply(t){return qo(t)}}Rp.className="NonNeg",ls(Rp);class Fp extends Cp{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>{const e=Ep(t,this.axis),n=ys(bo(this.rate,Ps(e,this.minValue,this.maxValue)),bo(1-this.rate,e));return bo(t,$s(n,ys(pu(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Fp.className="MinMaxNorm",ls(Fp);const _p={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Dp(t){return Fc(t)}function Op(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"constraint")}function zp(t){if(null==t)return null;if("string"===typeof t){return Op({className:t in _p?_p[t]:t,config:{}})}return t instanceof Cp?t:Op(t)}async function Lp(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];hs(r)}}function Mp(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var Pp;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(Pp||(Pp={}));class Bp{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Wp{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class Up extends Bp{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=us((()=>ys(this.totals[r],bo(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:us((()=>{const t=bo($s(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),ds(e[n])})))}}class Vp extends Bp{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class jp extends Bp{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Dl,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");me(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():cr();return function(){const s=null!=n?n():cr();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await Lp(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await Lp(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await Lp(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await Lp(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await Lp(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):me(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await Lp(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await Lp(t),await this.trainEnd(t))}}function Gp(t,e){if(null==t&&(t={}),t instanceof Bp)return[t];if(Array.isArray(t)&&t[0]instanceof Bp)return t;return Cc(t).map((t=>new jp(t,e)))}class Hp{constructor(){}static registerCallbackConstructor(t,e){ae(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),Hp.checkForDuplicate(e),null==Hp.constructors[t]&&(Hp.constructors[t]=[]),Hp.constructors[t].push(e)}static checkForDuplicate(t){for(const e in Hp.constructors){Hp.constructors[+e].forEach((e=>{if(e===t)throw new vc("Duplicate callback constructor.")}))}}static clear(){Hp.constructors={}}static createCallbacks(t){const e=[];for(const n in Hp.constructors){const r=+n;t>=r&&e.push(...Hp.constructors[r])}return e.map((t=>new t))}}function Kp(t,e,n,r,a,s,o,i,l){const c=new Vp,u=[new Up,...Hp.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new Wp(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function qp(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Dc(t,is.getMap().classNameMap,e,"layer",n)}function Xp(t,e){return us((()=>{"float32"!==t.dtype&&(t=Ga(t,"float32"));const n=vo(Nu(t),e,!0),r=Ms(n.shape,pu()),a=oi(No(n,r));return $s(t,a)}))}function Jp(t,e){return us((()=>Eo(Nu(yo(e,t)),-1)))}function Yp(t,e){return us((()=>Eo(bs(yo(e,t)),-1)))}function Zp(t,e){return us((()=>{const n=yo(t,e),r=Ps(bs(t),pu(),Number.MAX_VALUE),a=bs($s(n,r));return bo(100,Eo(a,-1))}))}function Qp(t,e){return us((()=>{const n=Ps(e,pu(),Number.MAX_VALUE),r=fo(ys(1,n)),a=Ps(t,pu(),Number.MAX_VALUE),s=fo(ys(1,a));return Eo(Nu(yo(r,s)),-1)}))}function $p(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{if(n)e=ri(e);else{const t=vo(e,e.shape.length-1,!0);e=$s(e,t)}return e=Ps(e,pu(),1-pu()),Oo(vo(bo(Ga(t,"float32"),fo(e)),e.shape.length-1))}))}function tf(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{const r=Ga(lo(function(t){const e=[lu(t.shape)];return Rs(t,e)}(t)),"int32"),a=(e=Ps(e,pu(),1-pu())).shape;return $p(Rs(Lo(r,a[a.length-1]),a),e,n)}))}function ef(t,e){return us((()=>{let n;return n=Ps(e,pu(),1-pu()),n=fo($s(n,yo(1,n))),Eo(function(t,e){if(!ce(t.shape,e.shape))throw new vc("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return us((()=>{const n=qo(e),r=Oo(bs(e));return ys(yo(n,bo(e,t)),go(ao(r)))}))}(t,n),-1)}))}function nf(t,e){return us((()=>{const n=Ps(t,pu(),1),r=Ps(e,pu(),1);return vo(bo(t,fo($s(n,r))),-1)}))}function rf(t,e){return us((()=>{const n=Xp(t,-1),r=Xp(e,-1),a=bo(n,r);return Oo(vo(a,-1))}))}Hp.constructors={};const af={meanSquaredError:Jp,meanAbsoluteError:Yp,meanAbsolutePercentageError:Zp,meanSquaredLogarithmicError:Qp,squaredHinge:function(t,e){return us((()=>{const n=No(0,yo(1,bo(t,e)));return Eo(Nu(n),-1)}))},hinge:function(t,e){return us((()=>{const n=No(0,yo(1,bo(t,e)));return Eo(n,-1)}))},categoricalHinge:function(t,e){return us((()=>{const n=vo(bo(t,e),-1),r=mo(bo(yo(1,t),e),-1);return No(0,ys(1,yo(r,n)))}))},logcosh:function(t,e){return us((()=>{const n=Math.log(2),r=yo(e,t),a=yo(ys(r,ai(bo(-2,r))),n);return Eo(a,-1)}))},categoricalCrossentropy:$p,sparseCategoricalCrossentropy:tf,binaryCrossentropy:ef,kullbackLeiblerDivergence:nf,poisson:function(t,e){return us((()=>{const n=fo(ys(pu(),e));return Eo(yo(e,bo(t,n)),-1)}))},cosineProximity:rf};function sf(t){if("string"===typeof t){if(t in af)return af[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new vc(e)}return t}function of(t,e){return us((()=>{const n=bo(.5,Bo(e)),r=fu(uo(e,n),t.dtype);return Eo(ro(t,r),-1)}))}function lf(t,e){return us((()=>fu(ro(xs(t,-1),xs(e,-1)),"float32")))}function cf(t,e){return us((()=>Ga(vo(xo(ro(t,1),ro(e,1))),"float32")))}function uf(t,e){return ef(t,e)}function hf(t,e){return t.rank===e.rank&&(t=ii(t,[t.rank-1])),(e=xs(e,-1)).dtype!==t.dtype&&(e=Ga(e,t.dtype)),Ga(ro(t,e),"float32")}const df=$p,pf=tf,ff={binaryAccuracy:of,categoricalAccuracy:lf,precision:function(t,e){return us((()=>{const n=cf(t,e),r=function(t,e){return us((()=>Ga(vo(xo(ro(t,0),ro(e,1))),"float32")))}(t,e),a=ys(n,r);return Ga(gi(uo(a,0),$s(n,a),0),"float32")}))},categoricalCrossentropy:df,sparseCategoricalCrossentropy:pf,mse:Jp,MSE:Jp,mae:Yp,MAE:Yp,mape:Zp,MAPE:Zp,cosine:rf};function gf(t){if("string"===typeof t&&t in ff)return ff[t];if("string"!==typeof t&&null!=t)return t;throw new vc("Unknown metric ".concat(t))}function mf(t){if(Ic(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys(af))if(af[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(ff))if(ff[n]===t){e=n;break}return void 0!==e?e:t.name}}const bf=1048576;function yf(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!vf(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>bf&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(bf,"."))}}function vf(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!vf(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!vf(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function wf(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),xf(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?kf(i[u],n,r):Sf(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?nh(t.collectedTrainableWeights):nh(t.trainableWeights);return e}(t),c=nh(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function xf(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function kf(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(p1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(p1){r="multiple"}const s=t.name,o=t.getClassName();xf(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function Sf(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(p1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(p1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];xf(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)xf(["","","","",o[u]],e,r)}function If(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function Nf(t,e){if(null===t)return null;if("string"===typeof t)return Ac(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];If(e,a,r)?n.push(r):n.push(Nf(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=Ac(n);e[t]=Nf(r,t)}}return e}}function Ef(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return Tc(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];If(e,a,r)?n.push(r):n.push(Ef(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=Tc(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?Ef(r,n):r}return e}}const Cf="3.21.0";class Tf extends dh{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=Hc(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],zc(this.inputs).length!==this.inputs.length)throw new vc("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));zc(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;Ic(0===e,"input layer has >1 nodes"),Ic(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof fh))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new yc("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(Tf.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(Oc);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Tf&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(Oc);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new yc("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new yc('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new vc("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;for(const s of this.layers)for(const t of s.weights){if(null!=n[t.originalName])throw new vc("Duplicate weight name: ".concat(t.originalName));n[t.originalName]=t,r++}const a=[];for(const s in t){let r=s;if(null==n[s]){const t=s.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])a.push([n[r],t[s]]);else if(e)throw new vc("Provided weight data has no target variable: ".concat(s));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new vc("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}oh(a)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(Cf),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Ef(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return us((()=>{t=Cc(t);const n=new mh;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return vh(this.outputs,n,e)}))}computeMask(t,e){return us((()=>{let n;return t=Cc(t),n=null==e?Sc(null,t.length):Cc(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=$u(t);if(e.length!==this.inputLayers.length)throw new vc("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Oc);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=$u(t.computeOutputShape(Ec(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];Ic(t in n),a.push(n[t])}return Ec(a)}runInternalGraph(t,e){null==e&&(e=Sc(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Oc);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=Cc(t.call(e,c)),l=Cc(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=Cc(t.call(r,c)),l=Cc(t.computeMask(r,o));if(t.activityRegularizer)throw new wc("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){Ic(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof Tf?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=Tf.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new vc("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}if(null==t)throw new vc("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new vc("No such layer: ".concat(t))}calculateLosses(){return us((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=Tf.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=Tf.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(p1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[Tf.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=Tf.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=Tf.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(Ec(n),a)}function i(t){const a=t.name,o=qp(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new vc("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!Lc(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];Ic(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];Ic(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new vc("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){us((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function Af(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Rf(t,e){return Af(t,e,"classWeight")}async function Ff(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=us((()=>{if(1===t.shape.length)return Ha(t);if(2===t.shape.length){if(t.shape[1]>1){return xs(t,1)}if(1===t.shape[1])return Rs(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());hs(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),ui(a,"float32")}return null}function _f(t,e){return bo(t,e)}function Df(t,e){let n,r;const a=e;n=a.xs,r=a.ys,ae(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=Of("input",t.inputNames,n),o=Of("output",t.outputNames,r),i=s[0].shape[0];ae(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),ae(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)ae(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)ae(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function Of(t,e,n){if(n instanceof Cr)return[n];if(Array.isArray(n))return ae(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new vc("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function zf(t,e,n){const r=null!=n.batchesPerEpoch;if(ae(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),ae(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),ae(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),ae(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),ae(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(Lf(n.validationData))ae(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new wc("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=Gp(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Kp(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=Df(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Rf(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Ff(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);hs(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,ds(n)}await d.onBatchEnd(h,s),Mp(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=Lf(n.validationData)?Cc(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):Cc(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Lf(t){return"function"===typeof t.iterator}function Mf(t){ae(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function Pf(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>mu(t,e,n-e))):mu(t,e,n-e)}function Bf(t,e){return us((()=>null==t?null:Array.isArray(t)?t.map((t=>Bf(t,e))):Iu(t,"int32"===e.dtype?e:Ga(e,"int32"))))}function Wf(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}async function Uf(t,e,n){let r,a,s,o,i,l,c,u,h,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const p=null==d.batchSize?32:d.batchSize;Mf(p);const f=!1,g=await t.standardizeUserData(e,n,d.sampleWeight,d.classWeight,f,p);r=g[0],a=g[1],h=g[2];let m,b=!1;if(null!=d.validationData&&d.validationData.length>0){if(b=!0,2!==d.validationData.length)throw 3===d.validationData.length?new wc("validationData including sample weights is not supported yet."):new vc("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));i=d.validationData[0],l=d.validationData[1];const e=!0,n=await t.standardizeUserData(i,l,null,null,e,p);c=n[0],u=n[1],m=c.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){b=!0;const t=Math.floor(r[0].shape[0]*(1-d.validationSplit)),e=r[0].shape[0];c=Pf(r,t,e),s=r,r=Pf(r,0,t),u=Pf(a,t,e),o=a,a=Pf(a,0,t),m=c.concat(u)}else null!=d.validationSteps&&(b=!0);const y=r.concat(a).concat(h);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),w=t.getDedupedMetricsNames();let x,k;b?(t.makeTestFunction(),x=t.testFunction,k=w.slice().concat(w.map((t=>"val_"+t)))):(x=null,m=[],k=w.slice());const S=Gp(d.callbacks,d.yieldEvery),I=await async function(t,e,n,r,a,s,o,i,l,c,u,h,d,p,f){null==a&&(a=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let g=!1;if(null!=l&&null!=c&&(g=!0),null!=f&&(g=!0,null==p))throw new vc("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=t.checkNumSamples(n,a,p,"steps_per_epoch");let b;null!=m&&(b=hu(0,m)),null==o&&(o=1);const{callbackList:y,history:v}=Kp(i,o,s,d,m,p,a,g,h);y.setModel(t),t.history=v,await y.onTrainBegin(),t.stopTraining_=!1;for(let w=d;w<s;++w){await y.onEpochBegin(w);const s={};if(null!=p)throw new wc("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new wc("batch shuffling is not implemneted yet");u&&ne(b);const o=ui(b),i=Wf(m,a);for(let u=0;u<i.length;++u){const h={};if(await y.onBatchBegin(u,h),us((()=>{const d=i[u][0],p=i[u][1],f=mu(o,d,p-d);h.batch=u,h.size=p-d;const m=Bf(n,f),b=e(m);for(let t=0;t<r.length;++t){const e=r[t],n=b[t];h[e]=n,ds(n)}if(u===i.length-1&&g){const e=t.testLoop(l,c,a);for(let t=0;t<r.length;++t){const n=r[t],a=e[t];ds(a),s["val_"+n]=a}}})),await y.onBatchEnd(u,h),Mp(h),t.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(w,s),t.stopTraining_)break}return await y.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,w,p,d.epochs,d.verbose,S,x,m,d.shuffle,k,d.initialEpoch,null,null);return I}finally{t.isTraining=!1,jf(r,e),jf(a,n),jf(s,e),jf(o,n),jf(c,i),jf(u,l),null!=h&&hs(h)}}function Vf(t){const e=[];t instanceof Cr&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(gu(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function jf(t,e){if(null==t)return;const n=[];if(e instanceof Cr)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Cr)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Gf(t){return Array.isArray(t)}function Hf(t){return!function(t){return t instanceof Cr}(t)&&!Gf(t)}function Kf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Gf(t)&&t.length>0)e=!0;else if(Hf(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new vc("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(Hf(t)){r=[];for(const n of e){if(null==t[n])throw new vc('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Gf(t)){if(t.length!==e.length)throw new vc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new vc("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=Vf(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new vc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new vc("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function qf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new vc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new vc("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new vc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new vc("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class Xf extends Tf{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new vc("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");wf(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>Fl.adagrad(.01),Adadelta:()=>Fl.adadelta(1,.95,pu()),Adam:()=>Fl.adam(.001,.9,.999,pu()),Adamax:()=>Fl.adamax(.002,.9,.999,pu(),0),RMSProp:()=>Fl.rmsprop(.001,.9,0,pu()),SGD:()=>Fl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new vc("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ms))throw new vc("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new vc("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>sf(t)))}else{const n=sf(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new vc('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push(sf(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ru("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};ru("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===ef?-1!==["accuracy","acc"].indexOf(o)?r=of:-1!==["crossentropy","ce"].indexOf(o)&&(r=uf):this.lossFunctions[t]===tf?-1!==["accuracy","acc"].indexOf(o)?r=hf:-1!==["crossentropy","ce"].indexOf(o)&&(r=pf):-1!==["accuracy","acc"].indexOf(o)?r=lf:-1!==["crossentropy","ce"].indexOf(o)&&(r=df),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=gf(o);s=t,n=""+mf(o)}let e;ru(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Mf(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return Ec(this.testLoop(e,t,r,n.verbose,n.steps))}finally{jf(a[0],t),jf(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new wc("Verbose mode is not implemented yet.");ae(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=us((()=>{if(e.value){const{xs:n,ys:r}=Df(t,e.value),o=n.concat(r),c=us((()=>a(o)));if(hs(o),0===l)for(let t=0;t<c.length;++t)s.push(gs(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=us((()=>ys(s[t],bo(u,e)))),l>0&&hs(n)}hs(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=$s(s[c],i),hs(t)}return Ec(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new vc("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new vc("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new vc("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new mh;if(t instanceof Cr&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new vc("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new vc("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=vh(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=Sc(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new vc("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{const r=this.checkNumSamples(t);if(n)throw new wc("Verbose predictLoop() is not implemented yet.");const a=Wf(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){us((()=>{const n=a[e][0],r=a[e][1],s=Pf(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new mh(o);return vh(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return Ec(s.map((t=>Bs(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Vf(t);qf(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return Mf(t),this.predictLoop(n,t)}finally{jf(n,t)}}predictOnBatch(t){qf(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new yc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===tf?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=zc(t.map((t=>t.shape[0])));r.sort();const a=zc(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new vc("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new vc("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!ce(r,a))throw new vc("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=Kf(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Kf(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[Jp,ef,$p];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===$p&&1===s.shape[s.shape.length-1])throw new vc("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new vc("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new vc("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Rf(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Ff(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return us((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new wc("Verbose mode is not implemented yet.");if(null!=a)throw new wc("steps mode in testLoop() is not implemented yet");{const r=Wf(s,n),a=ui(hu(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=mu(a,s,i-s),c=Bf(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(gs(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=ys(o[t],bo(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=$s(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(Nc(t,r)>1){const e=Nc(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new mh(t),i=vh(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=_f(t,a[n]));const s=Eo(t);e.push(s),l=0===n?t:ys(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=Eo(e(r[a],i[a]))}ds(t),s.push(t)}return l=Eo(l),this.calculateLosses().forEach((t=>{l=ys(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>us((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new mh(s),i=vh(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=Eo(r(a[t],i[t]));n=0===t?s:ys(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=Eo(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){return Uf(this,t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}async fitDataset(t,e){return zf(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return hs(s),jf(n[0],t),jf(n[1],e),Ec(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=cs().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-cs().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=Tc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>Tc(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=Tc(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Tc(mf(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>Tc(mf(t))));{const t={};for(const e in this.metrics)t[e]=Tc(mf(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=qp(Nf(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=Ac(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>Ac(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=Ac(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>Ac(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=Ac(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,fa.getSaveHandlers(n));if(0===e.length)throw new vc("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new vc("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new vc("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await aa(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Cf),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await aa(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=ca([r.data,e])}if(null!=this.userDefinedMetadata){const t=!0;yf(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){yf(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Xf.className="Model",ls(Xf);class Jf extends Xf{}async function Yf(t,e){if(null==e&&(e={}),"string"===typeof t){const n=ga(t,e);if(0===n.length)n.push($a(t,e));else if(n.length>1)throw new vc("Found more than one (".concat(n.length,") load handlers for ")+"URL '".concat(t,"'"));t=n[0]}return async function(t,e,n){null==n&&(n={});if(null==t.load)throw new vc("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let a=r.modelTopology;null!=a.model_config&&(a=a.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,i=qp(Nf(a),e,o),l=r.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=r.userDefinedMetadata&&i.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new vc("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=sa(t,e),r={},a=[];return e.forEach((t=>{"optimizer"===t.group?a.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);i.loadWeights(t,s),null!=i.optimizer&&e.length>0&&await i.optimizer.setWeights(e),hs(t),hs(e.map((t=>t.tensor)))}return i}(t,void 0,e)}Jf.className="Functional",ls(Jf);class Zf extends Xf{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:Hc("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new vc("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof Zf||t instanceof Xf;let n;if(e){if(n=t,1!==n.outputs.length)throw new vc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new vc("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new vc("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=gh({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new vc("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new vc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=ph(this.outputs[0])}this.inboundNodes=[],new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Sc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(eh(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Xf({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new vc("Legacy serialization format not supported yet.");n=e}else ae(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof Zf))throw new wc("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=qp(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new vc("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new vc("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}function Qf(t){return new Xf(t)}function $f(t,e){return null==e&&(e={}),Yf(t,e)}Zf.className="Sequential",ls(Zf);class tg extends os{getConfig(){return{}}}class eg extends tg{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new wc("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return to(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}eg.className="elu",ls(eg);class ng extends tg{apply(t){return Jo(t)}}ng.className="selu",ls(ng);class rg extends tg{apply(t){return qo(t)}}rg.className="relu",ls(rg);class ag extends tg{apply(t){return us((()=>Co(6,qo(t))))}}ag.className="relu6",ls(ag);class sg extends tg{apply(t){return t}}sg.className="linear",ls(sg);class og extends tg{apply(t){return Zo(t)}}og.className="sigmoid",ls(og);class ig extends tg{apply(t){return function(t){return us((()=>{const e=ys(.5,bo(.2,t));return Ps(e,0,1)}))}(t)}}ig.className="hardSigmoid",ls(ig);class lg extends tg{apply(t){return ai(t)}}lg.className="softplus",ls(lg);class cg extends tg{apply(t){return function(t){return us((()=>$s(t,ys(bs(t),1))))}(t)}}cg.className="softsign",ls(cg);class ug extends tg{apply(t){return ci(t)}}ug.className="tanh",ls(ug);class hg extends tg{apply(t){return ri(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}hg.className="softmax",ls(hg);class dg extends tg{apply(t){return wo(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}dg.className="logSoftmax",ls(dg);class pg extends tg{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return us((()=>bo(Zo(bo(t,e)),t)))}}pg.className="swish",ls(pg);class fg extends tg{apply(t){return us((()=>bo(t,ci(ai(t)))))}}function gg(t){return t.getClassName()}function mg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"activation")}function bg(t){if(null==t){const t={className:"linear",config:{}};return mg(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},mg(e)}return t instanceof tg?t:mg(t)}function yg(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}fg.className="mish",ls(fg);class vg extends os{}class wg extends vg{constructor(t){super(),yg(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return us((()=>{let e=Mo([1]);return this.hasL1&&(e=ys(e,vo(bo(this.l1,bs(t))))),this.hasL2&&(e=ys(e,vo(bo(this.l2,Nu(t))))),Rs(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}wg.className="L1L2",ls(wg);const xg={l1l2:"L1L2"};function kg(t){return Fc(t)}function Sg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"regularizer")}function Ig(t){if(null==t)return null;if("string"===typeof t){return Sg({className:t in xg?xg[t]:t,config:{}})}return t instanceof vg?t:Sg(t)}class Ng extends dh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=th(t);let n=qo(t);return null!=this.maxValue&&(n=Ps(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}Ng.className="ReLU",ls(Ng);class Eg extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=th(t);return po(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Eg.className="LeakyReLU",ls(Eg);class Cg extends dh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Zu(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ig(t.alphaRegularizer),this.alphaConstraint=zp(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new vc("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=eh(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new ih({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=th(t),Uo(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Yu(this.alphaInitializer),alphaRegularizer:kg(this.alphaRegularizer),alphaConstraint:Dp(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}Cg.className="PReLU",ls(Cg);class Tg extends dh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new wc("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=th(t);return to(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Tg.className="ELU",ls(Tg);class Ag extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=th(t);return bo(n,Ga(uo(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}Ag.className="ThresholdedReLU",ls(Ag);class Rg extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new hg).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=th(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Fg(t,e,n){if("number"===typeof t)return Sc(t,e);if(t.length!==e)throw new vc("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new vc("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function _g(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function Dg(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+uu([n-e,0]);else{if("same"!==r)throw new vc("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function Og(t,e){return us((()=>(Qc(e),"channelsFirst"===e?vi(t,[0,2,3,1]):t)))}function zg(t,e){return us((()=>(Qc(e),"channelsFirst"===e?vi(t,[0,2,3,4,1]):t)))}function Lg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),3!==t.shape.length)throw new vc("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new vc("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new vc("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=vi(t,[0,2,1])),"causal"===a)throw new wc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Hs(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=Cu(i,n)),i}))}function Mg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),3!==t.rank&&4!==t.rank)throw new vc("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new vc("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=Og(t,s);if("causal"===a)throw new wc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Fi({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=vi(l,[0,3,1,2])),l}))}function Pg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),4!==t.rank&&5!==t.rank)throw new vc("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new vc("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=zg(t,s);if("causal"===a)throw new wc("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=Xs(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=Cu(i,n)),"channelsFirst"===s&&(i=vi(i,[0,4,1,2,3])),i}))}Rg.className="Softmax",ls(Rg);class Bg extends dh{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Bg.verifyArgs(e),this.rank=t,Bc(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new wc("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=Fg(e.kernelSize,t,"kernelSize"),this.strides=Fg(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,$c(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Qc(this.dataFormat),this.activation=bg(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Zu(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=zp(e.biasConstraint),this.biasRegularizer=Ig(e.biasRegularizer),this.activityRegularizer=Ig(e.activityRegularizer),this.dilationRate=Fg(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new vc("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new vc("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new vc("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(Ic("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,3))throw new vc("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:gg(this.activation),useBias:this.useBias,biasInitializer:Yu(this.biasInitializer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),biasConstraint:Dp(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Wg extends Bg{constructor(t,e){super(t,e),this.kernel=null,Wg.verifyArgs(e),this.filters=e.filters,Bc(this.filters,"filters"),this.kernelInitializer=Zu(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=zp(e.kernelConstraint),this.kernelRegularizer=Ig(e.kernelRegularizer)}build(t){t=eh(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return us((()=>{let e;t=th(t);const n=null==this.bias?null:this.bias.read(),r=Uc(this.activation.getClassName());if(null!=r&&2===this.rank)e=Mg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=Lg(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=Mg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new wc("convolutions greater than 3D are not implemented yet.");e=Pg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=eh(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=_g(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Yu(this.kernelInitializer),kernelRegularizer:kg(this.kernelRegularizer),kernelConstraint:Dp(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new vc("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class Ug extends Wg{constructor(t){super(2,t),Ug.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,2))throw new vc("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}Ug.className="Conv2D",ls(Ug);class Vg extends Wg{constructor(t){super(3,t),Vg.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new vc("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}Vg.className="Conv3D",ls(Vg);class jg extends Ug{constructor(t){if(super(t),this.inputSpec=[new ih({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new vc("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=eh(t)).length)throw new vc("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ih({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e=th(t);if(4!==e.shape.length)throw new vc("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,Dg(o,u,l,this.padding),Dg(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vi(e,[0,2,3,1]));let p=qs(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=vi(p,[0,3,1,2])),null!=this.bias&&(p=Cu(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=eh(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=Dg(e[r],i,s,this.padding),e[a]=Dg(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}jg.className="Conv2DTranspose",ls(jg);class Gg extends Vg{constructor(t){if(super(t),this.inputSpec=[new ih({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new vc("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=eh(t)).length)throw new vc("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ih({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e=th(t);if(5!==e.shape.length)throw new vc("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,Dg(i,p,u,this.padding),Dg(l,f,h,this.padding),Dg(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vi(e,[0,2,3,4,1]));let b=Ys(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=vi(b,[0,4,1,2,3])),null!==this.bias&&(b=Cu(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=eh(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=Dg(e[r],c,o,this.padding),e[a]=Dg(e[a],u,i,this.padding),e[s]=Dg(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Gg.className="Conv3DTranspose",ls(Gg);class Hg extends Wg{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new vc("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new vc("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new vc("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Zu(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ig(e.depthwiseRegularizer),this.depthwiseConstraint=zp(e.depthwiseConstraint),this.pointwiseInitializer=Zu(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ig(e.pointwiseRegularizer),this.pointwiseConstraint=zp(e.pointwiseConstraint)}build(t){if((t=eh(t)).length<this.rank+2)throw new vc("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new vc("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new ih({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e;if(t=th(t),1===this.rank)throw new wc("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=vi(t,[0,2,3,1])),e=Yo(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=Cu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=vi(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Yu(this.depthwiseInitializer),t.pointwiseInitializer=Yu(this.pointwiseInitializer),t.depthwiseRegularizer=kg(this.depthwiseRegularizer),t.pointwiseRegularizer=kg(this.pointwiseRegularizer),t.depthwiseConstraint=Dp(this.depthwiseConstraint),t.pointwiseConstraint=Dp(this.pointwiseConstraint),t}}Hg.className="SeparableConv";class Kg extends Hg{constructor(t){super(2,t)}}Kg.className="SeparableConv2D",ls(Kg);class qg extends Wg{constructor(t){super(1,t),qg.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,1))throw new vc("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}qg.className="Conv1D",ls(qg);class Xg extends dh{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return us((()=>{if(t=th(t),"channelsLast"===this.dataFormat){const e=yu(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yu(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=yu(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yu(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Xg.className="Cropping2D",ls(Xg);class Jg extends dh{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,Mc(qc,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return us((()=>{let e=th(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=vi(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?xl.resizeNearestNeighbor(e,[t,r]):xl.resizeBilinear(e,[t,r]);return vi(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?xl.resizeNearestNeighbor(e,[t,r]):xl.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}Jg.className="UpSampling2D",ls(Jg);class Yg extends Bg{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Zu(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=zp(t.depthwiseConstraint),this.depthwiseRegularizer=Ig(t.depthwiseRegularizer)}build(t){if((t=eh(t)).length<4)throw new vc("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new vc("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return us((()=>{null==a&&(a="channelsLast"),Qc(a);let o=Og(t,a);if(4!==t.rank)throw new vc("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new vc("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=Zs(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=vi(o,[0,3,1,2])),o}))}(t=th(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=Cu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=eh(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=_g(e,this.kernelSize[0],this.padding,this.strides[0]),s=_g(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Yu(this.depthwiseInitializer),t.depthwiseRegularizer=kg(this.depthwiseRegularizer),t.depthwiseConstraint=Dp(this.depthwiseRegularizer),t}}function Zg(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new vc("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function Qg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return us((()=>{const l=e.shape.length;if(l<3)throw new vc("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(hu(2,l));if(e=vi(e,c),null!=s)throw new wc("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=Ga(Ga(a,"bool"),"float32"),a.rank===l-1&&(a=so(a,-1)),a=vi(a,c)),r&&(e=Xo(e,0),null!=a&&(a=Xo(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=pi(e);let g,m;null!=a&&(g=pi(a));for(let e=0;e<p;++e){const n=f[e],r=us((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=us((()=>{const t=g[e],n=yo(Bo(t),t);return{output:ys(bo(r[0],t),bo(d[0],n)),newStates:d.map(((e,a)=>ys(bo(r[1][a],t),bo(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=li(u,1)}return[h,m,d]}))}Yg.className="DepthwiseConv2D",ls(Yg);class $g extends dh{constructor(t){let e;if(super(t),null==t.cell)throw new vc("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new im({cells:t.cell}):t.cell,null==e.stateSize)throw new vc("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new ih({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return hu(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Qu(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return us((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new wc("Constants support is not implemented in RNN yet.");Qu(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new ih({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ce(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new vc("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new ih({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];us((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new vc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Mo([n,t]))):this.states_=[Mo([n,this.cell.stateSize])];else if(null==t)hs(this.states_),null!=this.keptStates&&(hs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Mo([n,t]))):this.states_[0]=Mo([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new vc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):hs(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!ce(r.shape,s))throw new vc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>ds(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Zg(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new ih({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof lh){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return us((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=th(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new vc("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=Qg(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return us((()=>{let e=Mo(t.shape);return e=vo(e,[1,2]),e=gu(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?xu(e,[1,t]):e)):this.cell.stateSize>1?[xu(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===$g.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=qp(e.cell,n);return new t(Object.assign(e,{cell:r}))}}$g.className="RNN",ls($g);class tm extends dh{}class em extends tm{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Bc(this.units,"units"),this.activation=bg(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=eh(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{if(2!==t.length)throw new vc("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=Su(null!=s?bo(t,s):t,this.kernel.read()),null!=this.bias&&(a=Cu(a,this.bias.read())),null!=o&&(n=bo(n,o));let i=ys(a,Su(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}em.className="SimpleRNNCell",ls(em);class nm extends $g{constructor(t){t.cell=new em(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}nm.className="SimpleRNN",ls(nm);class rm extends tm{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new vc("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Bc(this.units,"units"),this.activation=bg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=bg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=eh(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{if(2!==t.length)throw new vc("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=bo(t,a[0]));let c=Su(t,this.kernel.read());this.useBias&&(c=Cu(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bo(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=si(u,[2*this.units,this.units],u.rank-1),p=Su(r,h),[f,g,m]=si(c,3,c.rank-1),[b,y]=si(p,2,p.rank-1);o=this.recurrentActivation.apply(ys(f,b)),i=this.recurrentActivation.apply(ys(g,y));const v=Su(bo(i,r),d);l=this.activation.apply(ys(m,v));const w=ys(bo(o,r),bo(ys(1,Oo(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),recurrentActivation:gg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}rm.className="GRUCell",ls(rm);class am extends $g{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new rm(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}am.className="GRU",ls(am);class sm extends tm{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Bc(this.units,"units"),this.activation=bg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=bg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=eh(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends _u{apply(e,r){const a=t.apply([n]),s=(new Ou).apply([n]),o=t.apply([2*n]);return wu(wu(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return us((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new vc("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=bo(t,s[0]));let h=Su(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bo(r,o[0])),h=ys(h,Su(r,this.recurrentKernel.read())),this.useBias&&(h=Cu(h,this.bias.read()));const[d,p,f,g]=si(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=ys(bo(l,a),bo(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=bo(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),recurrentActivation:gg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}sm.className="LSTMCell",ls(sm);class om extends $g{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new sm(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}om.className="LSTM",ls(om);class im extends tm{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return us((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;Qu(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{ru("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign({},t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(qp(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return sh(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}oh(e)}}function lm(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):Tu(e(),n),i=()=>Au(o,e,r);if(!a||a<=1)return ds(i().clone());return Array(a).fill(void 0).map(i).map((t=>ds(t.clone())))}im.className="StackedRNNCells",ls(im);var cm=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class um extends $g{constructor(t){if(t.unroll)throw new wc("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new wc("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ih({ndim:5})]}call(t,e){return us((()=>{if(null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new vc("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return us((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=Mo([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];us((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new vc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mo(a))):this.states_=[Mo(a)];else if(null==t)hs(this.states_),null!=this.keptStates&&(hs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mo(a))):this.states_[0]=Mo(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new vc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):hs(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!ce(n.shape,r))throw new vc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>ds(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=_g(l,r[0],a,s[0],o[0]),h=_g(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}um.className="ConvRNN2D";class hm extends sm{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign({},t,{units:e})),this.filters=e,Bc(this.filters,"filters"),this.kernelSize=Fg(n,2,"kernelSize"),this.kernelSize.forEach((t=>Bc(t,"kernelSize"))),this.strides=Fg(r||1,2,"strides"),this.strides.forEach((t=>Bc(t,"strides"))),this.padding=a||"valid",$c(this.padding),this.dataFormat=s||"channelsLast",Qc(this.dataFormat),this.dilationRate=Fg(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>Bc(t,"dilationRate")))}build(t){var e;t=eh(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new vc("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends _u{apply(t,e){return vu([n.apply([r]),Po([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return us((()=>{if(3!==t.length)throw new vc("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?bo(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=si(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?si(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,E,C,T]=si(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,E),g=this.recurrentConv(g,C),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(ys(l,p)),R=this.recurrentActivation.apply(ys(c,f)),F=ys(bo(R,s),bo(A,this.activation.apply(ys(u,g)))),_=bo(this.recurrentActivation.apply(ys(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=cm(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(t,e,n,r){const a=Gs(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Cu(a,n,this.dataFormat):a}recurrentConv(t,e){return Gs(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}hm.className="ConvLSTM2DCell",ls(hm);class dm extends um{constructor(t){const e=new hm(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}dm.className="ConvLSTM2D",ls(dm);class pm extends dh{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return Au((()=>Tu(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}pm.className="Dropout",ls(pm);class fm extends pm{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}fm.className="SpatialDropout1D",ls(fm);class gm extends dh{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Bc(this.units,"units"),this.activation=bg(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=zp(t.kernelConstraint),this.biasConstraint=zp(t.biasConstraint),this.kernelRegularizer=Ig(t.kernelRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.activityRegularizer=Ig(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=eh(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=eh(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=Uc(this.activation.getClassName());let a;return null!=r?a=Su(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Su(n,this.kernel.read()),null!=this.bias&&(a=Cu(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:gg(this.activation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),biasConstraint:Dp(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}gm.className="Dense",ls(gm);class mm extends dh{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=eh(t);for(const e of t.slice(1))if(null==e)throw new vc('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],lu(t,1)]}call(t,e){return us((()=>{this.invokeCallHook(t,e);let n=th(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=vi(n,t)}return function(t){if(t.rank<=1)throw new vc("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],lu(t.shape,1)];return Rs(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}mm.className="Flatten",ls(mm);class bm extends dh{constructor(t){super(t),this.supportsMasking=!0,this.activation=bg(t.activation)}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);return this.activation.apply(n)}))}getConfig(){const t={activation:gg(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}bm.className="Activation",ls(bm);class ym extends dh{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return us((()=>{return t=th(t),e=t,n=this.n,us((()=>{if(2!==e.shape.length)throw new vc("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return xu(gu(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}ym.className="RepeatVector",ls(ym);class vm extends dh{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new vc("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=lu(t);if(null!==s){if(0===a||o%a!==0)throw new vc(n);r[s]=o/a}else if(o!==a)throw new vc(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Rs(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}vm.className="Reshape",ls(vm);class wm extends dh{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=hu(1,t.dims.length+1);if(!ce(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ih({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=eh(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return vi(th(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}wm.className="Permute",ls(wm);class xm extends dh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=th(t);return ws(zo(n,this.maskValue),-1)}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=ws(zo(n,this.maskValue),-1,!0);return bo(n,Ga(r,n.dtype))}))}}xm.className="Masking",ls(xm);class km extends dh{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Cc(t.inputLength))}this.inputDim=t.inputDim,Bc(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Bc(this.outputDim,"outputDim"),this.embeddingsInitializer=Zu(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ig(t.embeddingsRegularizer),this.activityRegularizer=Ig(t.activityRegularizer),this.embeddingsConstraint=zp(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return us((()=>this.maskZero?(t=th(t),zo(t,mi(t))):null))}computeOutputShape(t){if(t=eh(t),null==this.inputLength)return[...t,this.outputDim];const e=Cc(this.inputLength);if(e.length!==t.length-1)throw new vc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new vc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return us((()=>{this.invokeCallHook(t,e);let n=th(t);"int32"!==n.dtype&&(n=fu(n,"int32"));const r=Iu(this.embeddings.read(),Rs(n,[n.size]));return Rs(r,eh(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yu(this.embeddingsInitializer),embeddingsRegularizer:kg(this.embeddingsRegularizer),activityRegularizer:kg(this.activityRegularizer),embeddingsConstraint:Dp(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}km.className="Embedding",ls(km);class Sm extends dh{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new wc}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new vc("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[eh(t)]),t.length<2)throw new vc("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=zc(e),e.length>1)throw new vc("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===zc(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return us((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=uu(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=gu(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=Rs(s,[r].concat(lu(t.slice(1))));o=vi(o,[1,0]),o=Rs(o,a),e.push(o),n=!0}else if(t>1){const r=hu(1,t).concat([0]);e.push(vi(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=Rs(vi(Rs(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(hu(0,a-1));r=vi(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=zc(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return us((()=>{if(null==e)return null;if(!Array.isArray(e))throw new vc("`mask` should be an Array");if(!Array.isArray(t))throw new vc("`inputs` should be an Array");if(e.length!==t.length)throw new vc("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:so(t,0))))[0];for(let t=1;t<e.length-1;++t)n=xo(n,e[t]);return n}))}}class Im extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ys(e,t[n]);return e}))}}Im.className="Add",ls(Im);class Nm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bo(e,t[n]);return e}))}}Nm.className="Multiply",ls(Nm);class Em extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ys(e,t[n]);return bo(1/t.length,e)}))}}Em.className="Average",ls(Em);class Cm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=No(e,t[n]);return e}))}}Cm.className="Maximum",ls(Cm);class Tm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Co(e,t[n]);return e}))}}Tm.className="Minimum",ls(Tm);class Am extends Sm{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new vc("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if(ce(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new vc("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return us((()=>vu(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new vc("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new vc("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new vc("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new vc("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return us((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(Ga(Bo(t[s]),"bool")):e[s].rank<t[s].rank?r.push(so(e[s],-1)):r.push(e[s]);const a=Bs(r,this.axis);return vs(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Rm(t,e){for(;t<0;)t+=e;return t}Am.className="Concatenate",ls(Am);class Fm extends Sm{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){ae(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new wc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new vc("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new vc("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>Rm(e,t[n].shape.length))):[Rm(this.axes,n.shape.length),Rm(this.axes,r.shape.length)],this.normalize&&(n=Xp(n,e[0]),r=Xp(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new wc("batchDot is not implemented for tensors of 4D or higher rank yet");if(ae(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),ae(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new wc("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return us((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Rs(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Rs(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?vo(bo(t,e),s[0]):vo(bo(vi(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=ko(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=ii(o,e)}return 1===o.shape.length&&(o=so(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[Rm(this.axes,t.length),Rm(this.axes,e.length)],n}computeOutputShape(t){ae(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new wc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Fm.className="Dot",ls(Fm);class _m extends dh{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);return Au((()=>ys(ku(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}_m.className="GaussianNoise",ls(_m);class Dm extends dh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);if(this.rate>0&&this.rate<1){return Au((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return bo(n,ku(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}Dm.className="GaussianDropout",ls(Dm);class Om extends dh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||th(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return us((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=th(t),r=-1.7580993408473766;let a=ho(Ko(n),this.rate);a=fu(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=ys(bo(e,a),bo(ys(a,-1),r));return ys(bo(i,s),o)};return Au(r,(()=>th(t)),e.training||!1)}return t}))}}function zm(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=Os(t,e,n,r,a,o);else if(3===t.rank)s=zs(t,e,n,r,a,o);else{if(4!==t.rank)throw new wc("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=Ls(t,e,n,r,a,o)}return s}function Lm(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ce(r.slice().sort(),hu(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return us((()=>{const s=Do(t,r),o=s.mean,i=s.variance;return[zm(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return us((()=>{const s=Do(t,r),o=s.mean,i=s.variance,l=[];for(const e of hu(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=Rs(o,l),u=Rs(i,l),h=null==e?null:Rs(e,l),d=null==n?null:Rs(n,l);return[zm(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}Om.className="AlphaDropout",ls(Om);class Mm extends dh{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Zu(t.betaInitializer||"zeros"),this.gammaInitializer=Zu(t.gammaInitializer||"ones"),this.movingMeanInitializer=Zu(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Zu(t.movingVarianceInitializer||"ones"),this.betaConstraint=zp(t.betaConstraint),this.gammaConstraint=zp(t.gammaConstraint),this.betaRegularizer=Ig(t.betaRegularizer),this.gammaRegularizer=Ig(t.gammaRegularizer)}build(t){t=eh(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new vc("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new ih({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return us((()=>{const n=null!=e.training&&e.training,r=th(t),a=r.shape,s=a.length,o=hu(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=Sc(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!ce(c,hu(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=Rs(this.movingMean.read(),l),e=Rs(this.movingVariance.read(),l),n=this.center?Rs(this.beta.read(),l):null,a=this.scale?Rs(this.gamma.read(),l):null;return zm(r,t,e,n,a,this.epsilon)}return zm(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=Lm(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{us((()=>{const r=1-n,a=t.read(),s=bo(yo(a,e),r);t.write(yo(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yu(this.betaInitializer),gammaInitializer:Yu(this.gammaInitializer),movingMeanInitializer:Yu(this.movingMeanInitializer),movingVarianceInitializer:Yu(this.movingVarianceInitializer),betaRegularizer:kg(this.betaRegularizer),gammaRegularizer:kg(this.gammaRegularizer),betaConstraint:Dp(this.betaConstraint),gammaConstraint:Dp(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Mm.className="BatchNormalization",ls(Mm);class Pm extends dh{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Zu(t.betaInitializer||"zeros"),this.gammaInitializer=Zu(t.gammaInitializer||"ones"),this.betaRegularizer=Ig(t.betaRegularizer),this.gammaRegularizer=Ig(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=eh(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==zc(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=th(t),r=n.shape,a=r.length;return us((()=>{let{mean:t,variance:e}=Do(n,this.axis,!0);const s=Sc(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?Rs(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=oo(t,c),e=oo(e,c),null!=i&&(i=oo(i,u)),null!=l&&(l=oo(l,u)),zm(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yu(this.betaInitializer),gammaInitializer:Yu(this.gammaInitializer),betaRegularizer:kg(this.betaRegularizer),gammaRegularizer:kg(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Pm.className="LayerNormalization",ls(Pm);class Bm extends dh{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new vc("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new vc("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new vc("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){let e,n;return t=eh(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return us((()=>{return e=th(t),n=this.padding,r=this.dataFormat,us((()=>{if(4!==e.rank)throw new vc("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new vc("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new vc("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Wo(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function Wm(t,e,n,r,a,s){return us((()=>{let o;Qc(a),tu(s),$c(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Og(t,a);const i="same"===r?"same":"valid";return o="max"===s?So(t,e,n,i):Fs(t,e,n,i),"channelsFirst"===a&&(o=vi(o,[0,3,1,2])),o}))}function Um(t,e,n,r,a,s){return us((()=>{let o;Qc(a),tu(s),$c(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=zg(t,a);const i="same"===r?"same":"valid";return o="max"===s?Io(t,e,n,i):_s(t,e,n,i),"channelsFirst"===a&&(o=vi(o,[0,4,1,2,3])),o}))}Bm.className="ZeroPadding2D",ls(Bm);class Vm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new vc("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(Bc(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new vc("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,$c(this.padding),this.inputSpec=[new ih({ndim:3})]}computeOutputShape(t){const e=_g((t=eh(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return us((()=>{this.invokeCallHook(t,e),t=gu(th(t),2);const n=this.poolingFunction(th(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ii(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class jm extends Vm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"max")}}jm.className="MaxPooling1D",ls(jm);class Gm extends Vm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"avg")}}Gm.className="AveragePooling1D",ls(Gm);class Hm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new vc("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];Bc(this.poolSize,"poolSize"),Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),$c(this.padding),this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){t=eh(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=_g(e,this.poolSize[0],this.padding,this.strides[0]),n=_g(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return us((()=>(this.invokeCallHook(t,e),this.poolingFunction(th(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Km extends Hm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"max")}}Km.className="MaxPooling2D",ls(Km);class qm extends Hm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"avg")}}qm.className="AveragePooling2D",ls(qm);class Xm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new vc("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Bc(this.poolSize,"poolSize"),Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),$c(this.padding),this.inputSpec=[new ih({ndim:5})]}computeOutputShape(t){t=eh(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=_g(e,this.poolSize[0],this.padding,this.strides[0]),n=_g(n,this.poolSize[1],this.padding,this.strides[1]),r=_g(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return us((()=>(this.invokeCallHook(t,e),this.poolingFunction(th(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Jm extends Xm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Um(t,e,n,r,a,"max")}}Jm.className="MaxPooling3D",ls(Jm);class Ym extends Xm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Um(t,e,n,r,a,"avg")}}Ym.className="AveragePooling3D",ls(Ym);class Zm extends dh{constructor(t){super(t),this.inputSpec=[new ih({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new wc}}class Qm extends Zm{constructor(t){super(t||{})}call(t,e){return us((()=>{const e=th(t);return Eo(e,1)}))}}Qm.className="GlobalAveragePooling1D",ls(Qm);class $m extends Zm{constructor(t){super(t||{})}call(t,e){return us((()=>{const e=th(t);return mo(e,1)}))}}$m.className="GlobalMaxPooling1D",ls($m);class tb extends dh{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new wc}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class eb extends tb{call(t,e){return us((()=>{const e=th(t);return"channelsLast"===this.dataFormat?Eo(e,[1,2]):Eo(e,[2,3])}))}}eb.className="GlobalAveragePooling2D",ls(eb);class nb extends tb{call(t,e){return us((()=>{const e=th(t);return"channelsLast"===this.dataFormat?mo(e,[1,2]):mo(e,[2,3])}))}}nb.className="GlobalMaxPooling2D",ls(nb);class rb extends dh{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=qp(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class ab extends rb{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=eh(t)).length<3)throw new vc("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=eh(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return us((()=>Qg(((t,n)=>[th(this.layer.call(t,e)),[]]),t=th(t),[],!1,null,null,!1,!0)[1]))}}ab.className="TimeDistributed",ls(ab);class sb extends rb{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=qp(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=qp(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,Mc(Yc,"BidirectionalMergeMode",a),t.weights)throw new wc("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Ec(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Zg(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new vc("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new ih({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new wc("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof lh;for(const l of s)if(l instanceof lh!==i)throw new vc("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return us((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Xo(a,1)),"concat"===this.mergeMode?o=vu([r,a]):"sum"===this.mergeMode?o=ys(r,a):"ave"===this.mergeMode?o=bo(.5,ys(r,a)):"mul"===this.mergeMode?o=bo(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){ru(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),ru(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=qp(e.layer);if(delete e.layer,null!=e.numConstants)throw new wc("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}sb.className="Bidirectional",ls(sb);class ob extends dh{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return us((()=>("float32"!==(t=th(t)).dtype&&(t=fu(t,"float32")),ys(bo(t,this.scale),this.offset))))}}ob.className="Rescaling",ls(ob);var ib=function(t,e){return(ib=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};var lb=function(){return(lb=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var a in e=arguments[n])Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t}).apply(this,arguments)};function cb(t,e,n,r){return new(n||(n=Promise))((function(a,s){function o(t){try{l(r.next(t))}catch(t){s(t)}}function i(t){try{l(r.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?a(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,i)}l((r=r.apply(t,e||[])).next())}))}function ub(t,e){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}function hb(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],r=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function db(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var r,a,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(r=s.next()).done;)o.push(r.value)}catch(t){a={error:t}}finally{try{r&&!r.done&&(n=s.return)&&n.call(s)}finally{if(a)throw a.error}}return o}function pb(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(db(arguments[e]));return t}function fb(t){return cb(this,void 0,void 0,(function(){var e,r,a,s,o;return ub(this,(function(i){switch(i.label){case 0:return"http://","https://",e="file://",0!==t.indexOf("http://")&&0!==t.indexOf("https://")?[3,3]:[4,fetch(t)];case 1:return[4,i.sent().json()];case 2:return[2,i.sent()];case 3:return 0!==t.indexOf(e)?[3,5]:(r=n(7571),a=(0,zl.promisify)(r.readFile),o=(s=JSON).parse,[4,a(t.slice(e.length),{encoding:"utf-8"})]);case 4:return[2,o.apply(s,[i.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+t+". Supported schemes are: http://, https://, and (node.js-only) file://")}}))}))}var gb=null;function mb(t){return null==gb&&(gb=ps().epsilon()),us((function(){var e=Do(t),n=e.mean,r=e.variance;return $s(yo(t,n),ys(oi(r),gb))}))}function bb(t){if(t.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return null==gb&&(gb=ps().epsilon()),us((function(){var e=Do(ui(t)),n=e.mean,r=e.variance,a=n.arraySync(),s=Math.sqrt(r.arraySync()),o=Array.from(t).map((function(t){return(t-a)/(s+gb)}));return new Float32Array(o)}))}function yb(t){return cb(this,void 0,void 0,(function(){return ub(this,(function(e){return[2,navigator.mediaDevices.getUserMedia({audio:null==t||t,video:!1})]}))}))}var vb=function(){function t(t){var e=this;if(null==t)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(null==t.spectrogramCallback)throw new Error("spectrogramCallback cannot be null or undefined");if(!(t.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+t.numFramesPerSpectrogram);if(t.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+t.suppressionTimeMillis);if(this.suppressionTimeMillis=t.suppressionTimeMillis,this.spectrogramCallback=t.spectrogramCallback,this.numFrames=t.numFramesPerSpectrogram,this.sampleRateHz=t.sampleRateHz||44100,this.fftSize=t.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.overlapFactor=t.overlapFactor,this.includeRawAudio=t.includeRawAudio,ae(this.overlapFactor>=0&&this.overlapFactor<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+e.overlapFactor})),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=window.AudioContext||window.webkitAudioContext}return t.prototype.start=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){switch(a.label){case 0:if(null!=this.frameIntervalTask)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return e=this,[4,yb(t)];case 1:return e.stream=a.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),n=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,n.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),r=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new kb(r,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}}))}))},t.prototype.onAudioFrame=function(){return cb(this,void 0,void 0,(function(){var t,e,n,r;return ub(this,(function(a){switch(a.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(t=wb(this.freqDataQueue),e=xb(t,[1,this.numFrames,this.columnTruncateLength,1]),n=void 0,this.includeRawAudio&&(r=wb(this.timeDataQueue),n=xb(r,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(e,n)]):[3,2]);case 1:a.sent()&&this.tracker.suppress(),hs([e,n]),a.label=2;case 2:return[2]}}))}))},t.prototype.stop=function(){return cb(this,void 0,void 0,(function(){return ub(this,(function(t){if(null==this.frameIntervalTask)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]}))}))},t.prototype.setConfig=function(t){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},t.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},t}();function wb(t){var e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((function(t,r){return n.set(t,r*e)})),n}function xb(t,e){var n=new Float32Array(le(e));return n.set(t,n.length-t.length),ea(n,e)}var kb=function(){function t(t,e){var n=this;this.period=t,this.suppressionTime=null==e?0:e,this.counter=0,ae(this.period>0,(function(){return"Expected period to be positive, but got "+n.period}))}return t.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(null==this.suppressionOnset||this.counter-this.suppressionOnset>this.suppressionTime)},t.prototype.suppress=function(){this.suppressionOnset=this.counter},t}();function Sb(t){var e=0;t.forEach((function(t){e+=t.byteLength}));var n=new Uint8Array(e),r=0;return t.forEach((function(t){n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Ib(t){var e=0;t.forEach((function(t){return e+=t.length}));var n=new Float32Array(e),r=0;return t.forEach((function(t){n.set(t,r),r+=t.length})),n}function Nb(t){if(null==t)throw new Error("Received null or undefind string");for(var e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n.buffer}function Eb(t){if(null==t)throw new Error("Received null or undefind buffer");var e=new Uint8Array(t);return decodeURIComponent(escape(String.fromCharCode.apply(String,pb(e))))}var Cb="TFJSSCDS",Tb="_background_noise_",Ab=function(){function t(t){if(this.examples={},this.label2Ids={},null!=t)for(var e=function(t){ae(null!=t,(function(){return"Received null or undefined buffer"}));var e=0,n=Eb(t.slice(e,8));ae(n===Cb,(function(){return"Deserialization error: Invalid descriptor"})),e+=8,e+=4;var r=new Uint32Array(t,e,1),a=e+=4;e=a+r[0];var s=Eb(t.slice(a,e));return{manifest:JSON.parse(s),data:t.slice(e)}}(t),n=0,r=0;r<e.manifest.length;++r){var a=e.manifest[r],s=a.spectrogramNumFrames*a.spectrogramFrameSize;null!=a.rawAudioNumSamples&&(s+=a.rawAudioNumSamples),s*=4,this.addExample(Fb({spec:a,data:e.data.slice(n,n+s)})),n+=s}}return t.prototype.addExample=function(t){ae(null!=t,(function(){return"Got null or undefined example"})),ae(null!=t.label&&t.label.length>0,(function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(t.label)}));var e=function(){function t(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return t()+t()+"-"+t()+"-"+t()+"-"+t()+"-"+t()+t()+t()}();return this.examples[e]=t,t.label in this.label2Ids||(this.label2Ids[t.label]=[]),this.label2Ids[t.label].push(e),e},t.prototype.merge=function(t){var e,n,r,a;ae(t!==this,(function(){return"Cannot merge a dataset into itself"}));var s=t.getVocabulary();try{for(var o=hb(s),i=o.next();!i.done;i=o.next()){var l=i.value,c=t.getExamples(l);try{for(var u=(r=void 0,hb(c)),h=u.next();!h.done;h=u.next()){var d=h.value;this.addExample(d.example)}}catch(t){r={error:t}}finally{try{h&&!h.done&&(a=u.return)&&a.call(u)}finally{if(r)throw r.error}}}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}},t.prototype.getExampleCounts=function(){var t={};for(var e in this.examples){var n=this.examples[e];n.label in t||(t[n.label]=0),t[n.label]++}return t},t.prototype.getExamples=function(t){var e=this;ae(null!=t,(function(){return"Expected label to be a string, but got "+JSON.stringify(t)})),ae(t in this.label2Ids,(function(){return'No example of label "'+t+'" exists in dataset'}));var n=[];return this.label2Ids[t].forEach((function(t){n.push({uid:t,example:e.examples[t]})})),n},t.prototype.getData=function(t,e){var n=this;ae(this.size()>0,(function(){return"Cannot get spectrograms as tensors because the dataset is empty"}));var r=this.getVocabulary();null!=t?ae(-1!==r.indexOf(t),(function(){return"Label "+t+" is not in the vocabulary ("+JSON.stringify(r)+")"})):ae(r.length>1,(function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+r.length+" word."})),null==e&&(e={});var a,s,o=this.getSortedUniqueNumFrames();1===o.length?(a=null==e.numFrames?o[0]:e.numFrames,s=null==e.hopFrames?1:e.hopFrames):(ae(null!=(a=e.numFrames)&&Number.isInteger(a)&&a>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."})),ae(a<=o[0],(function(){return"numFrames ("+a+") exceeds the minimum numFrames ("+o[0]+") among the examples of the Dataset."})),ae(null!=(s=e.hopFrames)&&Number.isInteger(s)&&s>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."})));var i=null==e.normalize||e.normalize;return us((function(){for(var o,l,c,u=[],h=[],d=[],p=0;p<r.length;++p){var f=r[p];if(null==t||f===t){var g=n.label2Ids[f],m=function(r){var o,l,g=n.examples[r].spectrogram,m=g.frameSize;null==c?c=m:ae(m===c,(function(){return"Mismatch in frameSize  ("+m+" vs "+c+")"}));var b=g.data.length/m,y=null;f!==Tb&&(y=null==g.keyFrameIndex?Db(g).dataSync()[0]:g.keyFrameIndex);var v=rs(g.data,[b,m,1]),w=_b(b,y,a,s),x=function(n){var r=us((function(){var t=Qo(v,[n[0],0,0],[n[1]-n[0],-1,-1]);return i?mb(t):t}));e.getDataset?h.push(r.dataSync()):u.push(r),null==t&&d.push(p)};try{for(var k=(o=void 0,hb(w)),S=k.next();!S.done;S=k.next())x(S.value)}catch(t){o={error:t}}finally{try{S&&!S.done&&(l=k.return)&&l.call(k)}finally{if(o)throw o.error}}hs(v)};try{for(var b=(o=void 0,hb(g)),y=b.next();!y.done;y=b.next())m(y.value)}catch(t){o={error:t}}finally{try{y&&!y.done&&(l=b.return)&&l.call(b)}finally{if(o)throw o.error}}}}null!=e.augmentByMixingNoiseRatio&&n.augmentByMixingNoise(e.getDataset?h:u,d,e.augmentByMixingNoiseRatio);var v=null==e.shuffle||e.shuffle;if(e.getDataset){var w=null==e.datasetBatchSize?32:e.datasetBatchSize,x=null==e.datasetValidationSplit?.15:e.datasetValidationSplit;ae(x>0&&x<1,(function(){return"Invalid dataset validation split: "+x}));var k=h.map((function(t,e){return[t,d[e]]}));ne(k),h=k.map((function(t){return t[0]}));var S=k.map((function(t){return t[1]})),I=function(t,e,n){var r,a,s,o,i,l,c,u;ae(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n}));for(var h=!Array.isArray(t[0]),d=e,p=[],f=0;f<d.length;++f){var g=d[f];null==p[g]&&(p[g]=[]),p[g].push(f)}var m=p.length,b=[],y=[];for(p.map((function(t){return ne(t)})),f=0;f<m;++f)for(var v=p[f],w=Math.round(v.length*(1-n)),x=0;x<v.length;++x)x<w?b.push(v[x]):y.push(v[x]);if(h){var k=[],S=[],I=[],N=[];try{for(var E=hb(b),C=E.next();!C.done;C=E.next()){var T=C.value;k.push(t[T]),S.push(e[T])}}catch(t){r={error:t}}finally{try{C&&!C.done&&(a=E.return)&&a.call(E)}finally{if(r)throw r.error}}try{for(var A=hb(y),R=A.next();!R.done;R=A.next())T=R.value,I.push(t[T]),N.push(e[T])}catch(t){s={error:t}}finally{try{R&&!R.done&&(o=A.return)&&o.call(A)}finally{if(s)throw s.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}k=[],S=[],I=[],N=[];try{for(var F=hb(b),_=F.next();!_.done;_=F.next())T=_.value,k.push(t[T]),S.push(e[T])}catch(t){i={error:t}}finally{try{_&&!_.done&&(l=F.return)&&l.call(F)}finally{if(i)throw i.error}}try{for(var D=hb(y),O=D.next();!O.done;O=D.next())T=O.value,I.push(t[T]),N.push(e[T])}catch(t){c={error:t}}finally{try{O&&!O.done&&(u=D.return)&&u.call(D)}finally{if(c)throw c.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}(h,S,x),N=I.trainXs,E=I.trainYs,C=I.valXs,T=I.valYs,A=fc(N).map((function(t){return rs(t,[a,c,1])})),R=fc(E).map((function(t){return ii(Lo([t],r.length),[0])})),F=gc({xs:A,ys:R});v&&(F=F.shuffle(h.length)),F=F.batch(w).prefetch(4);var _=fc(C).map((function(t){return rs(t,[a,c,1])})),D=fc(T).map((function(t){return ii(Lo([t],r.length),[0])})),O=gc({xs:_,ys:D});return[F,O=O.batch(w).prefetch(4)]}if(v){var z=[];u.forEach((function(t,e){z.push({x:t,y:d[e]})})),ne(z),u=z.map((function(t){return t.x})),d=z.map((function(t){return t.y}))}var L=null==t?Ga(Lo(ui(d,"int32"),r.length),"float32"):void 0;return{xs:li(u),ys:L}}))},t.prototype.augmentByMixingNoise=function(t,e,n){var r,a;if(null==t||0===t.length)throw new Error("Cannot perform augmentation because data is null or empty");for(var s=t[0]instanceof Float32Array,o=this.getVocabulary(),i=[],l=[],c=0;c<e.length;++c)o[e[c]]===Tb?i.push(c):l.push(c);if(0===i.length)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+Tb);var u=[],h=[],d=function(r){var a=i[function(t,e){return Math.floor((e-t)*Math.random())+t}(0,i.length)],o=s?ui(t[r]):t[r],l=s?ui(t[a]):t[a],c=us((function(){return mb(ys(o,bo(l,n)))}));s?u.push(c.dataSync()):u.push(c),h.push(e[r])};try{for(var p=hb(l),f=p.next();!f.done;f=p.next())d(f.value)}catch(t){r={error:t}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(r)throw r.error}}console.log("Data augmentation: mixing noise: added "+u.length+" examples"),u.forEach((function(e){return t.push(e)})),e.push.apply(e,pb(h))},t.prototype.getSortedUniqueNumFrames=function(){for(var t,e,n=new Set,r=this.getVocabulary(),a=0;a<r.length;++a){var s=r[a],o=this.label2Ids[s];try{for(var i=(t=void 0,hb(o)),l=i.next();!l.done;l=i.next()){var c=l.value,u=this.examples[c].spectrogram,h=u.data.length/u.frameSize;n.add(h)}}catch(e){t={error:e}}finally{try{l&&!l.done&&(e=i.return)&&e.call(i)}finally{if(t)throw t.error}}}var d=pb(n);return d.sort(),d},t.prototype.removeExample=function(t){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var e=this.examples[t].label;delete this.examples[t];var n=this.label2Ids[e].indexOf(t);this.label2Ids[e].splice(n,1),0===this.label2Ids[e].length&&delete this.label2Ids[e]},t.prototype.setExampleKeyFrameIndex=function(t,e){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var n=this.examples[t].spectrogram,r=n.data.length/n.frameSize;ae(e>=0&&e<r&&Number.isInteger(e),(function(){return"Invalid keyFrameIndex: "+e+". Must be >= 0, < "+r+", and an integer."})),n.keyFrameIndex=e},t.prototype.size=function(){return Object.keys(this.examples).length},t.prototype.durationMillis=function(){var t=0;for(var e in this.examples){var n=this.examples[e].spectrogram,r=23.22|n.frameDurationMillis;t+=n.data.length/n.frameSize*r}return t},t.prototype.empty=function(){return 0===this.size()},t.prototype.clear=function(){this.examples={}},t.prototype.getVocabulary=function(){var t=new Set;for(var e in this.examples){var n=this.examples[e];t.add(n.label)}var r=pb(t);return r.sort(),r},t.prototype.serialize=function(t){var e,n,r,a,s=this.getVocabulary();ae(!this.empty(),(function(){return"Cannot serialize empty Dataset"})),null!=t&&(Array.isArray(t)||(t=[t]),t.forEach((function(t){if(-1===s.indexOf(t))throw new Error('Word label "'+t+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(s)+".")})));var o=[],i=[];try{for(var l=hb(s),c=l.next();!c.done;c=l.next()){var u=c.value;if(null==t||-1!==t.indexOf(u)){var h=this.label2Ids[u];try{for(var d=(r=void 0,hb(h)),p=d.next();!p.done;p=d.next()){var f=p.value,g=Rb(this.examples[f]);o.push(g.spec),i.push(g.data)}}catch(t){r={error:t}}finally{try{p&&!p.done&&(a=d.return)&&a.call(d)}finally{if(r)throw r.error}}}}}catch(t){e={error:t}}finally{try{c&&!c.done&&(n=l.return)&&n.call(l)}finally{if(e)throw e.error}}return function(t){var e=Nb(JSON.stringify(t.manifest)),n=Nb(Cb),r=new Uint32Array([1]),a=new Uint32Array([e.byteLength]);return Sb([Sb([n,r.buffer,a.buffer]),e,t.data])}({manifest:o,data:Sb(i)})},t}();function Rb(t){var e=null!=t.rawAudio,n={label:t.label,spectrogramNumFrames:t.spectrogram.data.length/t.spectrogram.frameSize,spectrogramFrameSize:t.spectrogram.frameSize};null!=t.spectrogram.keyFrameIndex&&(n.spectrogramKeyFrameIndex=t.spectrogram.keyFrameIndex);var r=t.spectrogram.data.buffer.slice(0);return e&&(n.rawAudioNumSamples=t.rawAudio.data.length,n.rawAudioSampleRateHz=t.rawAudio.sampleRateHz,r=Sb([r,t.rawAudio.data.buffer])),{spec:n,data:r}}function Fb(t){var e={frameSize:t.spec.spectrogramFrameSize,data:new Float32Array(t.data.slice(0,4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))};null!=t.spec.spectrogramKeyFrameIndex&&(e.keyFrameIndex=t.spec.spectrogramKeyFrameIndex);var n={label:t.spec.label,spectrogram:e};return null!=t.spec.rawAudioNumSamples&&(n.rawAudio={sampleRateHz:t.spec.rawAudioSampleRateHz,data:new Float32Array(t.data.slice(4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))}),n}function _b(t,e,n,r){if(ae(Number.isInteger(t)&&t>0,(function(){return"snippetLength must be a positive integer, but got "+t})),null!=e&&ae(Number.isInteger(e)&&e>=0,(function(){return"focusIndex must be a non-negative integer, but got "+e})),ae(Number.isInteger(n)&&n>0,(function(){return"windowLength must be a positive integer, but got "+n})),ae(Number.isInteger(r)&&r>0,(function(){return"windowHop must be a positive integer, but got "+r})),ae(n<=t,(function(){return"windowLength ("+n+") exceeds snippetLength ("+t+")"})),ae(e<t,(function(){return"focusIndex ("+e+") equals or exceeds snippetLength ("+t+")"})),n===t)return[[0,t]];var a=[];if(null==e){for(var s=0;s+n<=t;)a.push([s,s+n]),s+=r;return a}var o=Math.floor(n/2),i=e-o;for(i<0?i=0:i+n>t&&(i=t-n);!(i-r<0||e>=i-r+n);)i-=r;for(;i+n<=t&&!(e<i);)a.push([i,i+n]),i+=r;return a}function Db(t){return us((function(){return xs(function(t){return us((function(){var e=t.data.length/t.frameSize,n=hi(t.data,[e,t.frameSize]);return Eo(n,-1)}))}(t))}))}var Ob="0.5.4",zb="tfjs-speech-commands-saved-model-metadata",Lb="indexeddb://tfjs-speech-commands-model/",Mb={localStorage:"undefined"==typeof window?null:window.localStorage};var Pb=.25,Bb=function(){function t(e,n,r){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+function(t){return t.split(".").slice(0,2).join(".")}(Ob)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},ae(null==n&&null==r||null!=n&&null!=r,(function(){return"modelURL and metadataURL must be both provided or both not provided."})),null==n?(null==e?e=t.DEFAULT_VOCABULARY_NAME:ae(-1!==t.VALID_VOCABULARY_NAMES.indexOf(e),(function(){return"Invalid vocabulary name: '"+e+"'"})),this.vocabulary=e,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(ae(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided"})),this.modelArtifactsOrURL=n,this.metadataOrURL=r),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return t.prototype.listen=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o,i=this;return ub(this,(function(l){switch(l.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(l.sent(),null==e&&(e={}),n=null==e.probabilityThreshold?0:e.probabilityThreshold,e.includeEmbedding&&(n=0),ae(n>=0&&n<=1,(function(){return"Invalid probabilityThreshold value: "+n})),r=null!=e.invokeCallbackOnNoiseAndUnknown&&e.invokeCallbackOnNoiseAndUnknown,e.includeEmbedding&&(r=!0),e.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+e.suppressionTimeMillis);return ae((a=null==e.overlapFactor?.5:e.overlapFactor)>=0&&a<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+a})),s=function(a,s){return cb(i,void 0,void 0,(function(){var s,o,i,l,c,u,h,d,p,f,g;return ub(this,(function(m){switch(m.label){case 0:return s=mb(a),e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return m.sent(),g=db(this.modelWithEmbeddingOutput.predict(s),2),o=g[0],i=g[1],[3,3];case 2:o=this.model.predict(s),m.label=3;case 3:return[4,o.data()];case 4:return l=m.sent(),[4,(c=o.argMax(-1)).data()];case 5:return u=m.sent()[0],h=Math.max.apply(Math,pb(l)),hs([o,c,s]),h<n?[2,!1]:[3,6];case 6:return d=void 0,e.includeSpectrogram?(p={},[4,a.data()]):[3,8];case 7:p.data=m.sent(),p.frameSize=this.nonBatchInputShape[1],d=p,m.label=8;case 8:return f=!0,r||this.words[u]!==Tb&&"_unknown_"!==this.words[u]||(f=!1),f&&t({scores:l,spectrogram:d,embedding:i}),[2,f]}}))}))},o=null==e.suppressionTimeMillis?this.DEFAULT_SUPPRESSION_TIME_MILLIS:e.suppressionTimeMillis,this.audioDataExtractor=new vb({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:o,spectrogramCallback:s,overlapFactor:a}),[4,this.audioDataExtractor.start(e.audioTrackConstraints)];case 2:return l.sent(),this.streaming=!0,[2]}}))}))},t.prototype.ensureModelLoaded=function(){return cb(this,void 0,void 0,(function(){var t,e,n,r,a=this;return ub(this,(function(s){switch(s.label){case 0:return null!=this.model?[2]:[4,this.ensureMetadataLoaded()];case 1:return s.sent(),"string"!=typeof this.modelArtifactsOrURL?[3,3]:[4,$f(this.modelArtifactsOrURL)];case 2:return t=s.sent(),[3,5];case 3:return[4,$f(ns(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:t=s.sent(),s.label=5;case 5:if(1!==t.inputs.length)throw new Error("Expected model to have 1 input, but got a model with "+t.inputs.length+" inputs");if(4!==t.inputs[0].shape.length)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+t.inputs[0].shape.length);if(1!==t.inputs[0].shape[3])throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(t.inputs[0].shape[3])+"}");if(2!==(e=t.outputShape).length)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(e));if(e[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+e[1]+") and number of words ("+this.words.length+").");return this.model=t,this.freezeModel(),this.nonBatchInputShape=t.inputs[0].shape.slice(1),this.elementsPerExample=1,t.inputs[0].shape.slice(1).forEach((function(t){return a.elementsPerExample*=t})),this.warmUpModel(),n=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,r=t.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=r*n,[2]}}))}))},t.prototype.ensureModelWithEmbeddingOutputCreated=function(){return cb(this,void 0,void 0,(function(){var t,e;return ub(this,(function(n){switch(n.label){case 0:return null!=this.modelWithEmbeddingOutput?[2]:[4,this.ensureModelLoaded()];case 1:for(n.sent(),e=this.model.layers.length-2;e>=0;--e)if("Dense"===this.model.layers[e].getClassName()){t=this.model.layers[e];break}if(null==t)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=Qf({inputs:this.model.inputs,outputs:[this.model.outputs[0],t.output]}),[2]}}))}))},t.prototype.warmUpModel=function(){var t=this;us((function(){for(var e=Mo([1].concat(t.nonBatchInputShape)),n=0;n<3;++n)t.model.predict(e)}))},t.prototype.ensureMetadataLoaded=function(){return cb(this,void 0,void 0,(function(){var t,e,n;return ub(this,(function(r){switch(r.label){case 0:return null!=this.words?[2]:"string"!=typeof this.metadataOrURL?[3,2]:[4,fb(this.metadataOrURL)];case 1:return e=r.sent(),[3,3];case 2:e=this.metadataOrURL,r.label=3;case 3:if(null==(t=e).wordLabels){if(null==(n=t.words))throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=n}else this.words=t.wordLabels;return[2]}}))}))},t.prototype.stopListening=function(){return cb(this,void 0,void 0,(function(){return ub(this,(function(t){switch(t.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return t.sent(),this.streaming=!1,[2]}}))}))},t.prototype.isListening=function(){return this.streaming},t.prototype.wordLabels=function(){return this.words},t.prototype.params=function(){return this.parameters},t.prototype.modelInputShape=function(){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},t.prototype.recognize=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o,i,l,c,u,h,d,p,f;return ub(this,(function(g){switch(g.label){case 0:return null==e&&(e={}),[4,this.ensureModelLoaded()];case 1:return g.sent(),null!=t?[3,3]:[4,this.recognizeOnline()];case 2:n=g.sent(),t=n.data,g.label=3;case 3:if(t instanceof Cr)this.checkInputTensorShape(t),a=t,r=t.shape[0];else{if(t.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+t.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");r=t.length/this.elementsPerExample,a=function(t,e,n){if(oe(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=qr(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ta(t,e,r,n)}(t,[r].concat(this.nonBatchInputShape))}return o={scores:null},e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return g.sent(),i=this.modelWithEmbeddingOutput.predict(a),s=i[0],o.embedding=i[1],[3,6];case 5:s=this.model.predict(a),g.label=6;case 6:return 1!==r?[3,8]:(l=o,[4,s.data()]);case 7:return l.scores=g.sent(),[3,10];case 8:return c=pi(s),u=c.map((function(t){return t.data()})),h=o,[4,Promise.all(u)];case 9:h.scores=g.sent(),hs(c),g.label=10;case 10:return e.includeSpectrogram?(d=o,p={},t instanceof Cr?[4,t.data()]:[3,12]):[3,14];case 11:return f=g.sent(),[3,13];case 12:f=t,g.label=13;case 13:d.spectrogram=(p.data=f,p.frameSize=this.nonBatchInputShape[1],p),g.label=14;case 14:return hs(s),[2,o]}}))}))},t.prototype.recognizeOnline=function(){return cb(this,void 0,void 0,(function(){var t=this;return ub(this,(function(e){return[2,new Promise((function(e,n){t.audioDataExtractor=new vb({sampleRateHz:t.parameters.sampleRateHz,numFramesPerSpectrogram:t.nonBatchInputShape[0],columnTruncateLength:t.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n){return cb(t,void 0,void 0,(function(){var t,r,a;return ub(this,(function(s){switch(s.label){case 0:return t=mb(n),[4,this.audioDataExtractor.stop()];case 1:return s.sent(),r=e,a={},[4,t.data()];case 2:return r.apply(void 0,[(a.data=s.sent(),a.frameSize=this.nonBatchInputShape[1],a)]),t.dispose(),[2,!1]}}))}))},overlapFactor:0}),t.audioDataExtractor.start()}))]}))}))},t.prototype.createTransfer=function(t){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");ae(null!=t&&"string"==typeof t&&t.length>1,(function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(t)})),ae(null==this.transferRecognizers[t],(function(){return"There is already a transfer-learning model named '"+t+"'"}));var e=new Wb(t,this.parameters,this.model);return this.transferRecognizers[t]=e,e},t.prototype.freezeModel=function(){var t,e;try{for(var n=hb(this.model.layers),r=n.next();!r.done;r=n.next())r.value.trainable=!1}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}},t.prototype.checkInputTensorShape=function(t){var e=this.model.inputs[0].shape.length;if(t.shape.length!==e)throw new Error("Expected input Tensor to have rank "+e+", but got rank "+t.shape.length+" that differs ");var n=t.shape.slice(1),r=this.model.inputs[0].shape.slice(1);if(!ce(n,r))throw new Error("Expected input to have shape [null,"+r+"], but got shape [null,"+n+"]")},t.VALID_VOCABULARY_NAMES=["18w","directional4w"],t.DEFAULT_VOCABULARY_NAME="18w",t}(),Wb=function(t){function e(e,n,r){var a=t.call(this)||this;return a.name=e,a.parameters=n,a.baseModel=r,ae(null!=e&&"string"==typeof e&&e.length>0,(function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(e)})),a.nonBatchInputShape=a.baseModel.inputs[0].shape.slice(1),a.words=null,a.dataset=new Ab,a}return function(t,e){function n(){this.constructor=t}ib(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}(e,t),e.prototype.collectExample=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o=this;return ub(this,(function(i){if(ae(!this.streaming,(function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"})),ae(null!=t&&"string"==typeof t&&t.length>0,(function(){return"Must provide a non-empty string when collecting transfer-learning example"})),null==e&&(e={}),null!=e.durationMultiplier&&null!=e.durationSec)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return null!=e.durationSec?(ae(e.durationSec>0,(function(){return"Expected durationSec to be > 0, but got "+e.durationSec})),r=this.parameters.fftSize/this.parameters.sampleRateHz,n=Math.ceil(e.durationSec/r)):null!=e.durationMultiplier?(ae(e.durationMultiplier>=1,(function(){return"Expected duration multiplier to be >= 1, but got "+e.durationMultiplier})),n=Math.round(this.nonBatchInputShape[0]*e.durationMultiplier)):n=this.nonBatchInputShape[0],null!=e.snippetDurationSec&&(ae(e.snippetDurationSec>0,(function(){return"snippetDurationSec is expected to be > 0, but got "+e.snippetDurationSec})),ae(null!=e.onSnippet,(function(){return"onSnippet must be provided if snippetDurationSec is provided."}))),null!=e.onSnippet&&ae(null!=e.snippetDurationSec,(function(){return"snippetDurationSec must be provided if onSnippet is provided."})),a=this.parameters.fftSize/this.parameters.sampleRateHz,s=a*n,this.streaming=!0,[2,new Promise((function(r){var a=null==e.snippetDurationSec?1:e.snippetDurationSec/s,i=1-a,l=Math.round(1/a),c=0,u=-1,h=[];o.audioDataExtractor=new vb({sampleRateHz:o.parameters.sampleRateHz,numFramesPerSpectrogram:n,columnTruncateLength:o.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n,a){return cb(o,void 0,void 0,(function(){var s,o,i,d,p,f,g,m,b,y,v,w,x,k,S,I,N,E,C,T;return ub(this,(function(A){switch(A.label){case 0:return null!=e.onSnippet?[3,7]:(s=mb(n),i=(o=this.dataset).addExample,d={label:t},p={},[4,s.data()]);case 1:return d.spectrogram=(p.data=A.sent(),p.frameSize=this.nonBatchInputShape[1],p),e.includeRawAudio?(g={},[4,a.data()]):[3,3];case 2:return g.data=A.sent(),g.sampleRateHz=this.audioDataExtractor.sampleRateHz,f=g,[3,4];case 3:f=void 0,A.label=4;case 4:return i.apply(o,[(d.rawAudio=f,d)]),s.dispose(),[4,this.audioDataExtractor.stop()];case 5:return A.sent(),this.streaming=!1,this.collateTransferWords(),m=r,b={},[4,n.data()];case 6:return m.apply(void 0,[(b.data=A.sent(),b.frameSize=this.nonBatchInputShape[1],b)]),[3,13];case 7:return[4,n.data()];case 8:for(y=A.sent(),-1===u&&(u=y.length),v=u-1;0!==y[v]&&v>=0;)v--;return w=u-v-1,u=v+1,x=y.slice(y.length-w,y.length),h.push(x),null!=e.onSnippet&&e.onSnippet({data:x,frameSize:this.nonBatchInputShape[1]}),c++!==l?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return A.sent(),this.streaming=!1,this.collateTransferWords(),k=bb(Ib(h)),S={data:k,frameSize:this.nonBatchInputShape[1]},N=(I=this.dataset).addExample,E={label:t,spectrogram:S},e.includeRawAudio?(T={},[4,a.data()]):[3,11];case 10:return T.data=A.sent(),T.sampleRateHz=this.audioDataExtractor.sampleRateHz,C=T,[3,12];case 11:C=void 0,A.label=12;case 12:N.apply(I,[(E.rawAudio=C,E)]),r(S),A.label=13;case 13:return[2,!1]}}))}))},overlapFactor:i,includeRawAudio:e.includeRawAudio}),o.audioDataExtractor.start(e.audioTrackConstraints)}))]}))}))},e.prototype.clearExamples=function(){var t=this;ae(null!=this.words&&this.words.length>0&&!this.dataset.empty(),(function(){return"No transfer learning examples exist for model name "+t.name})),this.dataset.clear(),this.words=null},e.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},e.prototype.getExamples=function(t){return this.dataset.getExamples(t)},e.prototype.setExampleKeyFrameIndex=function(t,e){this.dataset.setExampleKeyFrameIndex(t,e)},e.prototype.removeExample=function(t){this.dataset.removeExample(t),this.collateTransferWords()},e.prototype.isDatasetEmpty=function(){return this.dataset.empty()},e.prototype.loadExamples=function(t,e){var n,r,a,s;void 0===e&&(e=!1);var o=new Ab(t);e&&this.clearExamples();var i=o.getVocabulary();try{for(var l=hb(i),c=l.next();!c.done;c=l.next()){var u=c.value,h=o.getExamples(u);try{for(var d=(a=void 0,hb(h)),p=d.next();!p.done;p=d.next()){var f=p.value;this.dataset.addExample(f.example)}}catch(t){a={error:t}}finally{try{p&&!p.done&&(s=d.return)&&s.call(d)}finally{if(a)throw a.error}}}}catch(t){n={error:t}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}this.collateTransferWords()},e.prototype.serializeExamples=function(t){return this.dataset.serialize(t)},e.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},e.prototype.collectTransferDataAsTensors=function(t,e){var n=this.nonBatchInputShape[0];t=t||Pb;var r=Math.round(t*n),a=this.dataset.getData(null,lb({numFrames:n,hopFrames:r},e));return{xs:a.xs,ys:a.ys}},e.prototype.collectTransferDataAsTfDataset=function(t,e,n,r){void 0===e&&(e=.15),void 0===n&&(n=32);var a=this.nonBatchInputShape[0];t=t||Pb;var s=Math.round(t*a);return this.dataset.getData(null,lb({numFrames:a,hopFrames:s,getDataset:!0,datasetBatchSize:n,datasetValidationSplit:e},r))},e.prototype.train=function(t){return cb(this,void 0,void 0,(function(){var e,n=this;return ub(this,(function(r){return ae(null!=this.words&&this.words.length>0,(function(){return"Cannot train transfer-learning model '"+n.name+"' because no transfer learning example has been collected."})),ae(this.words.length>1,(function(){return"Cannot train transfer-learning model '"+n.name+"' because only 1 word label ('"+JSON.stringify(n.words)+"') has been collected for transfer learning. Requires at least 2."})),null!=t.fineTuningEpochs&&ae(t.fineTuningEpochs>=0&&Number.isInteger(t.fineTuningEpochs),(function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+t.fineTuningEpochs})),null==t&&(t={}),null==this.model&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:t.optimizer||"sgd",metrics:["acc"]}),e=null==t.fitDatasetDurationMillisThreshold?6e4:t.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>e?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+e+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(t)]):[2,this.trainOnTensors(t)]}))}))},e.prototype.trainOnDataset=function(t){return cb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c;return ub(this,(function(u){switch(u.label){case 0:return ae(t.epochs>0,(function(){return"Invalid config.epochs"})),e=null==t.batchSize?32:t.batchSize,n=t.windowHopRatio||Pb,r=db(this.collectTransferDataAsTfDataset(n,t.validationSplit,e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),2),a=r[0],s=r[1],o=cr(),[4,this.model.fitDataset(a,{epochs:t.epochs,validationData:t.validationSplit>0?s:null,callbacks:null==t.callback?null:[t.callback]})];case 1:return i=u.sent(),console.log("fitDataset() took "+(cr()-o).toFixed(2)+" ms"),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?(l=cr(),[4,this.fineTuningUsingTfDatasets(t,a,s)]):[3,3];case 2:return c=u.sent(),console.log("fitDataset() (fine-tuning) took "+(cr()-l).toFixed(2)+" ms"),[2,[i,c]];case 3:return[2,i]}}))}))},e.prototype.trainOnTensors=function(t){return cb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c,u;return ub(this,(function(h){switch(h.label){case 0:e=t.windowHopRatio||Pb,n=this.collectTransferDataAsTensors(e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),r=n.xs,a=n.ys,console.log("Training data: xs.shape = "+r.shape+", ys.shape = "+a.shape),h.label=1;case 1:return h.trys.push([1,,6,7]),null!=t.validationSplit?(l=function(t,e,n){return ae(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n})),us((function(){for(var r=xs(e,-1).dataSync(),a=[],s=0;s<r.length;++s){var o=r[s];null==a[o]&&(a[o]=[]),a[o].push(s)}var i=a.length,l=[],c=[];for(a.map((function(t){return ne(t)})),s=0;s<i;++s)for(var u=a[s],h=Math.round(u.length*(1-n)),d=0;d<u.length;++d)d<h?l.push(u[d]):c.push(u[d]);return{trainXs:co(t,l),trainYs:co(e,l),valXs:co(t,c),valYs:co(e,c)}}))}(r,a,t.validationSplit),s=l.trainXs,o=l.trainYs,i=[l.valXs,l.valYs]):(s=r,o=a),[4,this.model.fit(s,o,{epochs:null==t.epochs?20:t.epochs,validationData:i,batchSize:t.batchSize,callbacks:null==t.callback?null:[t.callback]})];case 2:return c=h.sent(),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(t,s,o,i)]:[3,4];case 3:return u=h.sent(),[2,[c,u]];case 4:return[2,c];case 5:return[3,7];case 6:return hs([r,a,s,o,i]),[7];case 7:return[2]}}))}))},e.prototype.fineTuningUsingTfDatasets=function(t,e,n){return cb(this,void 0,void 0,(function(){var r,a,s;return ub(this,(function(o){switch(o.label){case 0:return r=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,a=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:a,metrics:["acc"]}),[4,this.model.fitDataset(e,{epochs:t.fineTuningEpochs,validationData:n,callbacks:null==t.callback?null:[t.callback]})];case 1:return s=o.sent(),this.secondLastBaseDenseLayer.trainable=r,[2,s]}}))}))},e.prototype.fineTuningUsingTensors=function(t,e,n,r){return cb(this,void 0,void 0,(function(){var a,s,o;return ub(this,(function(i){switch(i.label){case 0:return a=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,s=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:s,metrics:["acc"]}),[4,this.model.fit(e,n,{epochs:t.fineTuningEpochs,validationData:r,batchSize:t.batchSize,callbacks:null==t.fineTuningCallback?null:[t.fineTuningCallback]})];case 1:return o=i.sent(),this.secondLastBaseDenseLayer.trainable=a,[2,o]}}))}))},e.prototype.evaluate=function(t){return cb(this,void 0,void 0,(function(){var e=this;return ub(this,(function(n){return ae(null!=t.wordProbThresholds&&t.wordProbThresholds.length>0,(function(){return"Received null or empty wordProbThresholds"})),0,ae(this.words[0]===Tb,(function(){return"Cannot perform evaluation when the first tag is not "+Tb})),[2,us((function(){for(var n=[],r=0,a=e.collectTransferDataAsTensors(t.windowHopRatio),s=a.xs,o=a.ys.argMax(-1).dataSync(),i=e.model.predict(s),l=mo(Qo(i,[0,1],[i.shape[0],i.shape[1]-1]),-1),c=i.shape[0],u=0;u<t.wordProbThresholds.length;++u){for(var h=t.wordProbThresholds[u],d=l.greater(gs(h)).dataSync(),p=0,f=0,g=0,m=0,b=0;b<c;++b)0===o[b]?(p++,d[b]&&g++):(f++,d[b]&&m++);var y=g/p,v=m/f;n.push({probThreshold:h,fpr:y,tpr:v}),console.log("ROC thresh="+h+": fpr="+y.toFixed(4)+", tpr="+v.toFixed(4)),u>0&&(r+=Math.abs(n[u-1].fpr-n[u].fpr)*(n[u-1].tpr+n[u].tpr)/2)}return{rocCurve:n,auc:r}}))]}))}))},e.prototype.createTransferModelFromBaseModel=function(){var t=this;ae(null!=this.words,(function(){return"No word example is available for tranfer-learning model of name "+t.name}));for(var e=this.baseModel.layers,n=e.length-2;n>=0&&"dense"!==e[n].getClassName().toLowerCase();)n--;if(n<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=e[n];var r,a,s=this.secondLastBaseDenseLayer.output;this.transferHead=new Zf(a),this.transferHead.add((r={units:this.words.length,activation:"softmax",inputShape:s.shape.slice(1),name:"NewHeadDense"},new gm(r)));var o=this.transferHead.apply(s);this.model=Qf({inputs:this.baseModel.inputs,outputs:o})},e.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},e.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:Ob,modelName:this.name,timeStamp:(new Date).toISOString(),wordLabels:this.wordLabels()}},e.prototype.save=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){return e=null!=t,t=t||Ub(this.name),e||(n=Mb.localStorage.getItem(zb),(r=null==n?{}:JSON.parse(n))[this.name]=this.getMetadata(),Mb.localStorage.setItem(zb,JSON.stringify(r))),console.log("Saving model to "+t),[2,this.model.save(t)]}))}))},e.prototype.load=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){switch(a.label){case 0:if(e=null!=t,t=t||Ub(this.name),!e){if(null==(n=JSON.parse(Mb.localStorage.getItem(zb)))||null==n[this.name])throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=n[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return r=this,[4,$f(t)];case 1:return r.model=a.sent(),console.log("Loaded model from "+t+":"),this.model.summary(),[2]}}))}))},e.prototype.createTransfer=function(t){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},e}(Bb);function Ub(t){return""+Lb+t}class Vb{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class jb{refCount(t){return Gb("refCount")}incRef(t){return Gb("incRef")}timerAvailable(){return!0}time(t){return Gb("time")}read(t){return Gb("read")}readSync(t){return Gb("readSync")}readToGPU(t,e){return Gb("readToGPU")}numDataIds(){return Gb("numDataIds")}disposeData(t,e){return Gb("disposeData")}write(t,e,n){return Gb("write")}move(t,e,n,r,a){return Gb("move")}createTensorFromGPUData(t,e,n){return Gb("createTensorFromGPUData")}memory(){return Gb("memory")}floatPrecision(){return Gb("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Gb("dispose")}}function Gb(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function Hb(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Xb(t,e,n)}function Kb(t,e,n){return Math.max(t,Math.min(e,n))}function qb(t){return t%2===0?t:t+1}function Xb(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Jb(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function Yb(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Jb($b(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function Zb(t){Jb(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function Qb(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function $b(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ty(t){return t%1===0}function ey(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function ny(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function ry(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let o=0;const i=()=>{if(t())return void a();o++;const l=e(o);null!=n&&o>=n?s():null!=r?r(i,l):setTimeout(i,l)};i()}))}function ay(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(-1===t[s]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(r," and dim ").concat(s));r=s}else if(t[s]<0)throw Error("Shapes can not be < 0. Found ".concat(t[s]," at dim ").concat(s));if(-1===r){if(e>0&&e!==n)throw Error("Size(".concat(e,") must match the product of shape ").concat(t));return t}if(0===n)throw Error("Cannot infer the missing size in [".concat(t,"] when ")+"there are 0 elements");if(e%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(e," / ").concat(n));const a=t.slice();return a[r]=e/n,a}function sy(t,e){const n=e.length;return Jb((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),Jb(t.every((t=>ty(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function oy(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:sy(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function iy(t,e){return ly(t,e)}function ly(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}function cy(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function uy(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function hy(t){return"string"===typeof t||t instanceof String}function dy(t){return"number"===typeof t}function py(t){return Array.isArray(t)?py(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":dy(t)?"float32":hy(t)?"string":"boolean"===typeof t?"bool":"float32"}function fy(t){return!!(t&&t.constructor&&t.call&&t.apply)}function gy(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function my(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function by(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=by(t+e*i,o,n,r)}return a}function yy(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return by(0,t,e,n)}function vy(t,e){const n=wy(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function wy(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function xy(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return yy(t,new Float32Array(n));if("int32"===e)return yy(t,new Int32Array(n));if("bool"===e)return yy(t,new Uint8Array(n));throw new Error("Unknown data type ".concat(e))}function ky(t){t.forEach((e=>{Jb(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function Sy(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let a=0;a<t.length-1;++a)r+=n[a]*t[a];return r}function Iy(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(t/n[a]),t-=r[a]*n[a];return r[r.length-1]=t,r}function Ny(t){return t&&t.then&&"function"===typeof t.then}const Ey="tfjsflags";class Cy{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ty,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ny(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Ey in t){t[Ey].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){const n=e.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:e}(0,n)}))}}}function Ty(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Ay(){return Fy}let Ry,Fy=null;function _y(){if(null==Ry){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Ry=t}return Ry}function Dy(t,e){const n=function(){const t=_y();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Oy="Abs",zy="Acos",Ly="Acosh",My="Add",Py="AddN",By="All",Wy="Any",Uy="ArgMax",Vy="ArgMin",jy="Asin",Gy="Asinh",Hy="Atan",Ky="Atanh",qy="Atan2",Xy="AvgPool",Jy="AvgPoolGrad",Yy="AvgPool3D",Zy="AvgPool3DGrad",Qy="BatchMatMul",$y="BatchToSpaceND",tv="Bincount",ev="BitwiseAnd",nv="BroadcastArgs",rv="Cast",av="Ceil",sv="ClipByValue",ov="Complex",iv="ComplexAbs",lv="Concat",cv="Conv2D",uv="Conv2DBackpropFilter",hv="Conv2DBackpropInput",dv="Conv3D",pv="Conv3DBackpropFilterV2",fv="Conv3DBackpropInputV2",gv="Cos",mv="Cosh",bv="Cumprod",yv="Cumsum",vv="CropAndResize",wv="DenseBincount",xv="DepthToSpace",kv="DepthwiseConv2dNative",Sv="DepthwiseConv2dNativeBackpropFilter",Iv="DepthwiseConv2dNativeBackpropInput",Nv="Diag",Ev="Dilation2D",Cv="Dilation2DBackpropInput",Tv="Dilation2DBackpropFilter",Av="Draw",Rv="RealDiv",Fv="Einsum",_v="Elu",Dv="EluGrad",Ov="Erf",zv="Equal",Lv="Exp",Mv="ExpandDims",Pv="Expm1",Bv="FFT",Wv="Fill",Uv="FlipLeftRight",Vv="Floor",jv="FloorDiv",Gv="FusedBatchNorm",Hv="GatherV2",Kv="GatherNd",qv="Greater",Xv="GreaterEqual",Jv="Identity",Yv="IFFT",Zv="Imag",Qv="IsFinite",$v="IsInf",tw="IsNan",ew="LeakyRelu",nw="Less",rw="LessEqual",aw="LinSpace",sw="Log",ow="Log1p",iw="LogicalAnd",lw="LogicalNot",cw="LogicalOr",uw="LRN",hw="LRNGrad",dw="Max",pw="Maximum",fw="MaxPool",gw="MaxPoolGrad",mw="MaxPool3D",bw="MaxPool3DGrad",yw="MaxPoolWithArgmax",vw="Mean",ww="Min",xw="Minimum",kw="MirrorPad",Sw="Mod",Iw="Multinomial",Nw="Multiply",Ew="Neg",Cw="NotEqual",Tw="NonMaxSuppressionV3",Aw="NonMaxSuppressionV4",Rw="NonMaxSuppressionV5",Fw="OnesLike",_w="OneHot",Dw="Pack",Ow="PadV2",zw="Pow",Lw="Prelu",Mw="Prod",Pw="RaggedGather",Bw="RaggedRange",Ww="RaggedTensorToTensor",Uw="Range",Vw="Real",jw="Reciprocal",Gw="Relu",Hw="Reshape",Kw="ResizeNearestNeighbor",qw="ResizeNearestNeighborGrad",Xw="ResizeBilinear",Jw="ResizeBilinearGrad",Yw="Relu6",Zw="Reverse",Qw="Round",$w="Rsqrt",tx="ScatterNd",ex="TensorScatterUpdate",nx="SearchSorted",rx="Select",ax="Selu",sx="Slice",ox="Sin",ix="Sinh",lx="Sign",cx="Sigmoid",ux="Softplus",hx="Sqrt",dx="Sum",px="SpaceToBatchND",fx="SplitV",gx="Softmax",mx="SparseFillEmptyRows",bx="SparseReshape",yx="SparseSegmentMean",vx="SparseSegmentSum",wx="SparseToDense",xx="SquaredDifference",kx="Square",Sx="StaticRegexReplace",Ix="StridedSlice",Nx="StringNGrams",Ex="StringSplit",Cx="StringToHashBucketFast",Tx="Sub",Ax="Tan",Rx="Tanh",Fx="Tile",_x="TopK",Dx="Transform",Ox="Transpose",zx="Unique",Lx="Unpack",Mx="UnsortedSegmentSum",Px="ZerosLike",Bx="Step",Wx="FromPixels",Ux="RotateWithOffset",Vx="_FusedMatMul",jx="FusedConv2D",Gx="FusedDepthwiseConv2D";function Hx(){Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn(...arguments)}function Kx(){Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.log(...arguments)}const qx=Dy("kernelRegistry",(()=>new Map)),Xx=Dy("gradRegistry",(()=>new Map));function Jx(t,e){const n=tk(t,e);return qx.get(n)}function Yx(t){return Xx.get(t)}function Zx(t){const e=qx.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function Qx(t){const{kernelName:e,backendName:n}=t,r=tk(e,n);qx.has(r)&&Hx("The kernel '".concat(e,"' for backend ")+"'".concat(n,"' is already registered")),qx.set(r,t)}function $x(t){const{kernelName:e}=t;Xx.has(e)&&Ay().getBool("DEBUG")&&Hx("Overriding the gradient for '".concat(e,"'")),Xx.set(e,t)}function tk(t,e){return"".concat(e,"_").concat(t)}function ek(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}const nk=sr()||ar;function rk(t){return nk.fromString(t,!0,16)}const ak=rk("c3a5c85c97cb3127"),sk=rk("b492b66fbe98f273"),ok=rk("9ae16a3b2f90404f");function ik(t){return t.xor(t.shru(47))}function lk(t,e,n){const r=t.slice(e,e+n);return nk.fromBytes(Array.from(r),!0,!0)}function ck(t,e){return lk(t,e,8)}function uk(t,e){return lk(t,e,4)}function hk(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function dk(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rk("9ddfea08eb382d69"),r=t.xor(e).mul(n);r=r.xor(r.shru(47));let a=e.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function pk(t,e,n,r){return function(t,e,n,r,a,s){a=a.add(t),s=hk(s.add(a).add(r),21);const o=a;return a=(a=a.add(e)).add(n),s=s.add(hk(a,44)),[a.add(r),s.add(o)]}(ck(t,e),ck(t,e+8),ck(t,e+16),ck(t,e+24),n,r)}function fk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=nk.fromNumber(81,!0);if(e<=32)return e<=16?function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;if(e>=8){const n=ok.add(2*e),r=ck(t,0).add(ok),a=ck(t,e-8);return dk(hk(a,37).mul(n).add(r),hk(r,25).add(a).mul(n),n)}if(e>=4){const n=ok.add(2*e);return dk(uk(t,0).shl(3).add(e),uk(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return ik(ok.mul(n).xor(ak.mul(r))).mul(ok)}return ok}(t,e):function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=ok.add(2*e),r=ck(t,0).mul(sk),a=ck(t,8),s=ck(t,e-8).mul(n),o=ck(t,e-16).mul(ok);return dk(hk(r.add(a),43).add(hk(s,30)).add(o),r.add(hk(a.add(ok),18)).add(s),n)}(t,e);if(e<=64)return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=ok.add(2*e),r=ck(t,0).mul(ok),a=ck(t,8),s=ck(t,e-8).mul(n),o=ck(t,e-16).mul(ok),i=hk(r.add(a),43).add(hk(s,30)).add(o),l=dk(i,r.add(hk(a.add(ok),18)).add(s),n),c=ck(t,16).mul(n),u=ck(t,24),h=i.add(ck(t,e-32)).mul(n),d=l.add(ck(t,e-24)).mul(n);return dk(hk(c.add(u),43).add(hk(h,30)).add(d),c.add(hk(u.add(r),18)).add(h),n)}(t,e);let r=n,a=n.mul(sk).add(113),s=ik(a.mul(ok).add(113)).mul(ok),o=[nk.UZERO,nk.UZERO],i=[nk.UZERO,nk.UZERO];r=r.mul(ok).add(ck(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{r=hk(r.add(a).add(o[0]).add(ck(t,l+8)),37).mul(sk),a=hk(a.add(o[1]).add(ck(t,l+48)),42).mul(sk),r=r.xor(i[1]),a=a.add(o[0]).add(ck(t,l+40)),s=hk(s.add(i[0]),33).mul(sk),o=pk(t,l,o[1].mul(sk),r.add(i[0])),i=pk(t,l+32,s.add(i[1]),a.add(ck(t,l+16))),[s,r]=[r,s],l+=64}while(l!==c);const h=sk.add(s.and(255).shl(1));return l=u,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=hk(r.add(a).add(o[0]).add(ck(t,l+8)),37).mul(h),a=hk(a.add(o[1]).add(ck(t,l+48)),42).mul(h),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(ck(t,l+40))),s=hk(s.add(i[0]),33).mul(h),o=pk(t,l,o[1].mul(h),r.add(i[0])),i=pk(t,l+32,s.add(i[1]),a.add(ck(t,l+16))),[s,r]=[r,s],dk(dk(o[0],i[0],h).add(ik(a).mul(ak)).add(s),dk(o[1],i[1],h).add(r),h)}function gk(t,e){return"string"===e?yk(t):mk([t],e)}function mk(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=xk(t)),Ay().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function bk(){return Ay().platform.now()}function yk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ay().platform.encode(t,e)}function vk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ay().platform.decode(t,e)}function wk(t){return null!=Ay().platform.isTypedArray?Ay().platform.isTypedArray(t):ek(t)}function xk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),"boolean"===typeof t||"number"===typeof t||"string"===typeof t||Ny(t)||null==t||wk(t)&&n)e.push(t);else if(Array.isArray(t)||wk(t))for(let r=0;r<t.length;++r)xk(t[r],e,n);else{let r=-1;for(const e of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(e)&&(r=Math.max(r,Number(e)));for(let a=0;a<=r;a++)xk(t[a],e,n)}return e}class kk{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Ik)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=bk();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:bk()-o})}if(Ay().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{Sk(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function Sk(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class Ik{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?ny("".concat(r,"ms"),9):r.error,i=ny(t,25),l=e.rank,c=e.size,u=ny(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Nk=20,Ek=3,Ck=7;function Tk(t,e,n,r){const a=my(e),s=function(t,e,n,r){const a=Qb(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?_k(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Ak(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=Fk(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function Ak(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(Ck))," + ")+"".concat(parseFloat(t[1].toFixed(Ck)),"j"):hy(t)?"'".concat(t,"'"):"bool"===n?Rk(t):parseFloat(t.toFixed(Ck)).toString(),ny(r,e)}function Rk(t){return 0===t?"false":"true"}function Fk(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[Ak(_k(t)[0],0,n)]}return"bool"===n?[Rk(t[0])]:[t[0].toString()]}if(1===l){if(i>Nk){const e=Ek*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-Ek)*o,i*o));return"complex64"===n&&(r=_k(r),s=_k(s)),["["+r.map(((t,e)=>Ak(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>Ak(t,a[i-Ek+e],n))).join(", ")+"]"]}return["["+("complex64"===n?_k(t):Array.from(t)).map(((t,e)=>Ak(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>Nk){for(let e=0;e<Ek;e++){const r=e*h,s=r+h;d.push(...Fk(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-Ek;e<i;e++){const r=e*h,s=r+h;d.push(...Fk(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...Fk(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+(i>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function _k(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Dk{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Qb(t),null!=n){const t=n.length;Jb(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ly(e,this.size),this.strides=my(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Jb(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ok().makeTensor(this.values,this.shape,this.dtype)}}let Ok=null,zk=null,Lk=null;class Mk{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Qb(t),this.strides=my(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return zk.buffer(this.shape,this.dtype,t)}bufferSync(){return zk.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return yy(this.shape,t,"complex64"===this.dtype)}arraySync(){return yy(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Ok().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>vk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ok().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ok().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>vk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ok().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ok().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return zk.print(this,t)}clone(){return this.throwIfDisposed(),zk.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Tk(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),zk.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Ok().makeVariable(this,t,e,n)}}function Pk(){return Dy("Tensor",(()=>Mk))}Object.defineProperty(Mk,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Pk();class Bk extends Mk{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!$b(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Ok().disposeTensor(this),this.dataId=t.dataId,Ok().incRef(this,null)}dispose(){Ok().disposeVariable(this),this.isDisposedInternal=!0}}var Wk,Uk,Vk,jk,Gk;Object.defineProperty(Bk,Symbol.hasInstance,{value:t=>t instanceof Mk&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Wk||(Wk={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Uk||(Uk={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Vk||(Vk={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(jk||(jk={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Gk||(Gk={}));const Hk={float32:jk,int32:Uk,bool:Vk,complex64:Gk};function Kk(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return Hk[t][e]}function qk(t){return Kk(t,"int32")}function Xk(t){return null!=t&&"object"===typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function Jk(t){return"undefined"!==typeof GPUBuffer&&null!=t&&"object"===typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function Yk(t,e){if(t.dtype===e.dtype)return[t,e];const n=Kk(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Zk(t,e){return e.some((e=>e.id===t.id))}function Qk(t){const e=[];return $k(t,e,new Set),e}function $k(t,e,n){if(null==t)return;if(t instanceof Mk)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),$k(t,e,n))}}function tS(t){return null!=t.kernelName}class eS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class nS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new eS}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(Hx("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new kk(this.backendInstance),!0}setupRegisteredKernels(){Zx(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Zx(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof jb||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Hx("Initialization of backend ".concat(t," failed")),Hx(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(p1){return Hx("Initialization of backend ".concat(t," failed")),Hx(p1.stack||p1.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return nS.nextTensorId++}nextVariableId(){return nS.nextVariableId++}clone(t){const e=aS.runKernel(Jv,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return aS.runKernel(rv,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=Jx(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=tS(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(tS(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=Jx(e,this.backendName);Jb(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=tS(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=Yx(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Jb(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&hy(t[0])&&(a=t.map((t=>yk(t))));const s=r.write(a,e,n),o=new Mk(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Mk(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Bk(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*uy(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Bk||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*uy(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=Yx(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=wy(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Qk(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Jb(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));Jb(a instanceof Mk,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=vy(Qb(t),"float32");return aS.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!$b(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),sS);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return Jb(fy(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Jb(r.every((t=>t instanceof Mk)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),Jb(s.value instanceof Mk,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Jb(fy(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];Jb(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Jb(a.every((t=>t instanceof Mk)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=bk(),n=await this.backend.time(t);return n.wallMs=bk()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new eS;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function rS(){const t=_y();if(null==t._tfengine){const e=new Cy(t);t._tfengine=new nS(e)}var e;return e=t._tfengine.ENV,Fy=e,function(t){Ok=t}((()=>t._tfengine)),t._tfengine}nS.nextTensorId=0,nS.nextVariableId=0;const aS=rS();function sS(t,e){const n={a:t,b:e};return aS.runKernel(My,n)}let oS;function iS(t){if(void 0!==oS)return oS;if(t||"undefined"!==typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!==typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function lS(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const cS=Ay();function uS(t,e){let n=t;if(wk(t))return"string"===e?[]:[t.length];if(Xk(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if(Jk(t))return[t.buffer.size/(null==e?4:uy(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||wk(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Ay().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hS(t,r,[]),r}function hS(t,e,n){if(n=n||[],!Array.isArray(t)&&!wk(t))return void Jb(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));Jb(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),Jb(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)hS(t[a],r,n.concat(a))}function dS(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function pS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Pk())return dS(r,t.dtype,e,n),t;let a=py(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),dS(r,a,e,n),null==t||!wk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=uS(t,a);wk(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?mk(t,a):xk(t,[],!0);return aS.makeTensor(o,s,a)}function fS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>pS(t,"".concat(e,"[").concat(a,"]"),n,r)))}cS.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),cS.registerFlag("IS_BROWSER",(()=>lS())),cS.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),cS.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),cS.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),cS.registerFlag("PROD",(()=>!1)),cS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>cS.getBool("DEBUG"))),cS.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),cS.registerFlag("IS_TEST",(()=>!1)),cS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>cS.getBool("DEBUG"))),cS.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),cS.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),cS.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function gS(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){aS.startScope(n);try{const t=r(...arguments);return Ny(t)&&console.error("Cannot return a Promise inside of tidy."),aS.endScope(t),t}catch(t){throw aS.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const mS=gS({complex_:function(t,e){const n=pS(t,"real","complex"),r=pS(e,"imag","complex");Yb(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return aS.runKernel(ov,a)}});function bS(t,e,n,r){if(null==r)r=py(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Jk(t)||Xk(t)){if("float32"!==r&&"int32"!==r)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(r,"."));return aS.backend.createTensorFromGPUData(t,e||n,r)}if(!wk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){ky(e);const t=Qb(e),r=Qb(n);Jb(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==Qb(e.slice(a));Jb(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return wk(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?mk(t,r):xk(t,[],!0),aS.makeTensor(t,e,r)}function yS(t,e,n){return bS(t,e,uS(t,n),n)}class vS{static join(t){return new vS(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t)return;if(t instanceof Array||(t=[t]),0===(t=t.map((t=>wk(t)?t.buffer:t))).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=e+r.byteLength;this.shards.push({buffer:r,start:e,end:a}),e=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(-1===n)throw new Error("Could not find start shard for byte ".concat(t));const r=new ArrayBuffer(e-t),a=new Uint8Array(r);let s=0;for(let o=n;o<this.shards.length;o++){const n=this.shards[o],r=t+s-n.start,i=s,l=Math.min(e,n.end)-n.start,c=new Uint8Array(n.buffer,r,l-r);if(a.set(c,i),s+=c.length,e<n.end)break}return r}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(t,e){let n=0,r=t.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=e(t[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,e);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function wS(){return aS}function xS(){return aS.memory()}function kS(t,e){return aS.tidy(t,e)}function SS(t){Qk(t).forEach((t=>t.dispose()))}function IS(t){return aS.keep(t)}function NS(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return aS.registerBackend(t,e,n)}function ES(){return aS.backend}!function(t){Lk=t}((function(t){Ay().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const CS=4;async function TS(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+CS*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=CS,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:AS(await Promise.all(r)),specs:n}}function AS(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const RS="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function FS(t){return RS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function _S(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(n.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function DS(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}(t,n,r)}function OS(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:FS(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:FS(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:new vS(t.weightData).byteLength}}function zS(t){const e=[];for(const n of t)e.push(...n.weights);return e}class LS{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==LS.instance&&(LS.instance=new LS),LS.instance}static registerSaveRouter(t){LS.getInstance().saveRouters.push(t)}static registerLoadRouter(t){LS.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return LS.getHandlers(t,"save")}static getLoadHandlers(t,e){return LS.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?LS.getInstance().loadRouters:LS.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const MS="tensorflowjs",PS="models_store",BS="model_info_store";function WS(){if(!Ay().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function US(t){const e=t.result;e.createObjectStore(PS,{keyPath:"modelPath"}),e.createObjectStore(BS,{keyPath:"modelPath"})}class VS{constructor(t){if(this.indexedDB=WS(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(MS,1);r.onupgradeneeded=()=>US(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(PS,"readonly"),r=e.objectStore(PS).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{e.weightData=vS.join(e.weightData);const r=OS(e),o=a.transaction(BS,"readwrite");let i,l,c=o.objectStore(BS);try{i=c.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}i.onsuccess=()=>{l=a.transaction(PS,"readwrite");const i=l.objectStore(PS);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r})}catch(s){return n(s)}u.onsuccess=()=>t({modelArtifactsInfo:r}),u.onerror=t=>{c=o.objectStore(BS);const e=c.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(u.error)),e.onerror=t=>(a.close(),n(u.error))}},i.onerror=t=>(a.close(),n(i.error)),o.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}VS.URL_SCHEME="indexeddb://";const jS=t=>{return Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(VS.URL_SCHEME)?(e=t.slice(VS.URL_SCHEME.length),new VS(e)):null;var e};LS.registerSaveRouter(jS),LS.registerLoadRouter(jS);class GS{constructor(){this.indexedDB=WS()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(MS,1);n.onupgradeneeded=()=>US(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(BS,"readonly"),s=a.objectStore(BS).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(VS.URL_SCHEME)?e.slice(VS.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(MS,1);r.onupgradeneeded=()=>US(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(BS,"readwrite"),o=s.objectStore(BS),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(PS,"readwrite");const r=l.objectStore(PS).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const HS="/",KS="tensorflowjs_models",qS="info",XS="model_topology",JS="weight_specs",YS="weight_data",ZS="model_metadata";function QS(t){return{info:[KS,t,qS].join(HS),topology:[KS,t,XS].join(HS),weightSpecs:[KS,t,JS].join(HS),weightData:[KS,t,YS].join(HS),modelMetadata:[KS,t,ZS].join(HS)}}function $S(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function tI(t){const e=t.split(HS);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(HS)}class eI{constructor(t){if(!Ay().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=QS(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=OS(t),a=vS.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(RS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(a));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(p1){throw $S(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(RS){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}eI.URL_SCHEME="localstorage://";const nI=t=>{return Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(eI.URL_SCHEME)?(e=t.slice(eI.URL_SCHEME.length),new eI(e)):null;var e};LS.registerSaveRouter(nI),LS.registerLoadRouter(nI);class rI{constructor(){Jb(Ay().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Jb("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=KS+HS,n=HS+qS;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[tI(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=QS(t=(e=t).startsWith(eI.URL_SCHEME)?e.slice(eI.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return $S(n),r}}const aI="://";class sI{constructor(){this.managers={}}static getInstance(){return null==sI.instance&&(sI.instance=new sI),sI.instance}static registerManager(t,e){Jb(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(aI)&&(t=t.slice(0,t.indexOf(aI))),Jb(t.length>0,(()=>"scheme must not be an empty string."));const n=sI.getInstance();Jb(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=sI.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(sI.getInstance().managers)}}class oI{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!==typeof window&&Ay().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return ek(t)}}if(Ay().get("IS_BROWSER")){Ay().setPlatform("browser",new oI);try{sI.registerManager(eI.URL_SCHEME,new rI)}catch(p1){}try{sI.registerManager(VS.URL_SCHEME,new GS)}catch(p1){}}const iI=()=>n(7078);let lI;class cI{constructor(){this.util=n(6905),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ay().global.fetch?Ay().global.fetch(t,e):(null==lI&&(lI=iI()),lI(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}function uI(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",ky(t),new Dk(t,e,n)}Ay().get("IS_NODE")&&!Ay().get("IS_BROWSER")&&Ay().setPlatform("node",new cI);const hI=gS({cast_:function(t,e){const n=pS(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return aS.runKernel(rv,r,a)}});const dI=gS({clone_:function(t){const e={x:pS(t,"x","clone","string_or_numeric")};return aS.runKernel(Jv,e)}});rS();!function(t){zk=t}({buffer:uI,cast:hI,clone:dI,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}});const pI=gS({add_:function(t,e){let n=pS(t,"a","add"),r=pS(e,"b","add");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(My,a)}});const fI=gS({floorDiv_:function(t,e){let n=pS(t,"a","floorDiv"),r=pS(e,"b","floorDiv");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(jv,a)}});const gI=gS({div_:function(t,e){let n=pS(t,"a","div"),r=pS(e,"b","div");if([n,r]=Yk(n,r),"int32"===n.dtype&&"int32"===r.dtype)return fI(n,r);const a={a:n,b:r};return aS.runKernel(Rv,a,{})}});const mI=gS({mul_:function(t,e){let n=pS(t,"a","mul"),r=pS(e,"b","mul");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Nw,a)}});const bI=gS({sqrt_:function(t){const e={x:pS(t,"x","sqrt","float32")};return aS.runKernel(hx,e)}});const yI=gS({square_:function(t){const e=pS(t,"x","square");return aS.runKernel("Square",{x:e},{})}});const vI=gS({zerosLike_:function(t){const e={x:pS(t,"x","zerosLike")};return aS.runKernel(Px,e)}});function wI(t){return aS.customGrad(t)}function xI(t,e){if((wk(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&wk(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bS(t,[],[],e)}const kI=new Map,SI=new Map;class II{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class NI{constructor(){this.classNameMap={}}static getMap(){return null==NI.instance&&(NI.instance=new NI),NI.instance}static register(t){NI.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function EI(t,e,n){Jb(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),Jb("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),Jb(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof e&&(e="Custom"),"undefined"===typeof n&&(n=t.className);const r=e+">"+n;return NI.register(t),kI.set(r,t),SI.set(t,r),t}class CI extends II{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return SS(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){Jb(fy(t),(()=>"The f passed in variableGrads(f) must be a function")),Jb(null==e||Array.isArray(e)&&e.every((t=>t instanceof Bk)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in aS.registeredVariables)e.push(aS.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),Jb(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=aS.gradients(t,e,null,!0);Jb(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Jb(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&SS(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:xI(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(CI,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class TI extends CI{static get className(){return"Adadelta"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:kS((()=>vI(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:kS((()=>vI(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;kS((()=>{const t=pI(mI(s,this.rho),mI(yI(a),1-this.rho)),e=mI(gI(bI(pI(o,this.epsilon)),bI(pI(s,this.epsilon))),a),n=pI(mI(o,this.rho),mI(yI(e),1-this.rho));s.assign(t),o.assign(n);const i=pI(mI(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(SS(this.accumulatedGrads.map((t=>t.variable))),SS(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function AI(t,e,n){ky(t);const r={shape:t,value:e,dtype:n=n||py(e)};return aS.runKernel(Wv,{},r)}class RI extends CI{static get className(){return"Adagrad"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:kS((()=>AI(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;kS((()=>{const t=pI(s,yI(a));s.assign(t);const e=pI(mI(gI(a,bI(pI(t,aS.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&SS(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const FI=gS({pow_:function(t,e){let n=pS(t,"base","pow"),r=pS(e,"exp","pow");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(zw,a)}});const _I=gS({sub_:function(t,e){let n=pS(t,"a","sub"),r=pS(e,"b","sub");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Tx,a)}});class DI extends CI{static get className(){return"Adam"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],kS((()=>{this.accBeta1=xI(e).variable(),this.accBeta2=xI(n).variable()})),null==r&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);kS((()=>{const n=_I(1,this.accBeta1),r=_I(1,this.accBeta2);e.forEach(((e,a)=>{const s=aS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:kS((()=>vI(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:kS((()=>vI(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=pI(mI(i,this.beta1),mI(o,1-this.beta1)),u=pI(mI(l,this.beta2),mI(yI(o),1-this.beta2)),h=gI(c,n),d=gI(u,r);i.assign(c),l.assign(u);const p=pI(mI(gI(h,pI(bI(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(mI(this.accBeta1,this.beta1)),this.accBeta2.assign(mI(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&SS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&SS(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),kS((()=>{this.accBeta1.assign(FI(this.beta1,this.iterations_+1)),this.accBeta2.assign(FI(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const OI=gS({abs_:function(t){const e=pS(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return aS.runKernel(iv,t)}{const t={x:e};return aS.runKernel(Oy,t)}}});function zI(t,e){const n=t.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=t[s]||1;(e[e.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function LI(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function MI(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let a=0;a<n;a++){let s=t[t.length-a-1];null==s&&(s=1);let o=e[e.length-a-1];if(null==o&&(o=1),1===s)r[n-a-1]=o;else if(1===o)r[n-a-1]=s;else{if(s!==o){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}r[n-a-1]=s}}return r}const PI=gS({maximum_:function(t,e){let n=pS(t,"a","maximum"),r=pS(e,"b","maximum");[n,r]=Yk(n,r),"bool"===n.dtype&&(n=hI(n,"int32"),r=hI(r,"int32")),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(pw,a)}});class BI extends CI{static get className(){return"Adamax"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],kS((()=>{this.iteration=xI(0).variable(),this.accBeta1=xI(e).variable()})),null==r&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);kS((()=>{const n=_I(1,this.accBeta1),r=gI(-this.learningRate,pI(mI(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=aS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:vI(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:vI(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=pI(mI(i,this.beta1),mI(o,1-this.beta1)),u=mI(l,this.beta2),h=OI(o),d=PI(u,h);i.assign(c),l.assign(d);const p=pI(mI(gI(r,n),gI(c,pI(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(pI(this.iteration,1)),this.accBeta1.assign(mI(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&SS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&SS(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class WI extends CI{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=aS.registeredVariables[e];kS((()=>{const t=pI(mI(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=IS(xI(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class UI extends WI{static get className(){return"Momentum"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=xI(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:kS((()=>vI(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&kS((()=>{let t;const e=pI(mI(this.m,a),s);t=this.useNesterov?pI(mI(this.c,pI(s,mI(e,this.m))),r):pI(mI(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&SS(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class VI extends CI{static get className(){return"RMSProp"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=aS.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:kS((()=>vI(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:kS((()=>vI(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:kS((()=>vI(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;kS((()=>{const t=pI(mI(o,this.decay),mI(yI(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=pI(mI(e,this.decay),mI(s,1-this.decay)),l=gI(mI(s,this.learningRate),bI(_I(t,pI(yI(a),this.epsilon)))),c=pI(mI(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=_I(r,c);r.assign(u)}else{const t=pI(mI(o,this.decay),mI(yI(s),1-this.decay)),e=pI(mI(i,this.momentum),gI(mI(s,this.learningRate),bI(pI(t,this.epsilon))));o.assign(t),i.assign(e);const n=_I(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&SS(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&SS(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&SS(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const jI=[TI,RI,DI,BI,UI,VI,WI];function GI(t){return new Promise((t=>setTimeout(t))).then(t)}class HI{constructor(t){if(!Ay().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(HI.URL_SCHEME)&&(t=t.slice(HI.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=vS.join(t.weightData),n=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const e=_S(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(e)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await GI((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=n,await GI((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:OS(t)}}}}HI.URL_SCHEME="downloads://";function KI(t,e,n,r){!function(t){Jb(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Jb(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),Jb(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),Jb(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function qI(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ay().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await KI(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await KI(a,e.onProgress,.5,1)}LS.registerSaveRouter((t=>Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(HI.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new HI(t)}(t.slice(HI.URL_SCHEME.length)):null));class XI{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Jb("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Ay().platform.fetch,Jb(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&Jb(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=_S(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);if(e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData){const n=vS.join(t.weightData);e.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:OS(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(d1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return DS(await this.loadModelJSON(),(t=>this.loadWeights(t)))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),n=zS(t.weightsManifest);return Object.assign(Object.assign({},t),{weightSpecs:n,getWeightStream:()=>function(t,e){var n;const r=null==e.fetchFunc?Ay().platform.fetch:e.fetchFunc;let a,s=0;return null===(n=e.onProgress)||void 0===n||n.call(e,0),new ReadableStream({pull:async n=>{for(var o;s<t.length;){if(!a){const n=(await r(t[s],e.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:i,value:l}=await a.read();if(!i)return void n.enqueue(l);s++,a=void 0,null===(o=e.onProgress)||void 0===o||o.call(e,s/t.length)}n.close()}})}(e,this.loadOptions)})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=[],o=[];for(const i of t)for(const t of i.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):s.push(a+t+r);return this.weightUrlConverter&&s.push(...await Promise.all(o)),s}async loadWeights(t){const e=await this.getWeightUrls(t);return[zS(t),await qI(e,this.loadOptions)]}}function JI(t){return null!=t.match(XI.URL_SCHEME_REGEX)}XI.URL_SCHEME_REGEX=/^https?:\/\//;const YI=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>JI(t))):JI(t),n)return ZI(t,e)}return null};function ZI(t,e){return new XI(t,e)}LS.registerSaveRouter(YI),LS.registerLoadRouter(YI);const QI=-2,$I=-1;function tN(t,e,n){const r=t.shape.length;Jb(r===e.length,(()=>"Error in slice".concat(r,"D: Length of begin ").concat(e," must ")+"match the rank of the array (".concat(r,")."))),Jb(r===n.length,(()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,").")));for(let a=0;a<r;++a)Jb(e[a]+n[a]<=t.shape[a],(()=>"Error in slice".concat(r,"D: begin[").concat(a,"] + size[").concat(a,"] ")+"(".concat(e[a]+n[a],") would overflow input.shape[").concat(a,"] (").concat(t.shape[a],")")))}function eN(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function nN(t,e,n){const r=[];for(let a=0;a<t.length;a++)r[a]=Math.ceil((e[a]-t[a])/n[a]);return r}function rN(t,e,n,r){const a=[...t];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[e]=1:(a.splice(e,0,1),a.pop());return a}function aN(t,e,n){return n<=t?n:n-(e-1)}function sN(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function oN(t,e,n,r,a,s,o,i,l){const c=t.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;u=iN(o,l,c,r,t),h=lN(i,l,c,a,t),d=rN(s,l,c,t)}else for(let p=0;p<c;p++)u[p]=uN(o,r,s,t,p,l),h[p]=hN(i,a,s,t,p,l),d[p]=cN(s,p,l);return{begin:u,end:h,strides:d}}function iN(t,e,n,r,a){const s=[...a],o=sN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const a=aN(e,n,i);let o=r[a];t&1<<a&&(o=0),s[i]=o}return s}function lN(t,e,n,r,a){const s=[...a],o=sN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const a=aN(e,n,i);let o=r[a];t&1<<a&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const t=a[i];s[i]<0&&(s[i]+=t),s[i]=Kb(0,s[i],a[i])}return s}function cN(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function uN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=Kb(0,o,l-1),o}function hN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=i>0?Kb(0,o,l):Kb(-1,o,l-1),o}function dN(t,e,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(e[a]>0||n[a]!==t[a])return!1;return!0}function pN(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function fN(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{Jb(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(Jb(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}function gN(t,e,n,r,a,s,o,i,l){let c;if(null==r?(c=new Array(e.length),c.fill(1)):c=r,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let y=0;y<h.dims;y++)u&&0!==(1<<y&i)&&h.numAddAxisAfterEllipsis++,1<<y&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const a=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<a;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(QI),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(e.dims," dims, ").concat(e.begin.length,"."));null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push($I),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let y=0;y<t.length;++y){if(0===d.strides[y])throw Error("strides[".concat(y,"] must be non-zero"));const e=!!(d.shrinkAxisMask&1<<y),n=t[y];if(-1===n){m.push(e?1:-1);continue}const r=[d.beginMask&1<<y,d.endMask&1<<y],a=[d.strides[y]>0?0:-1,d.strides[y]>0?n:n-1];if(e&&d.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[y];const s=!!(d.beginMask&1<<y&&d.endMask&1<<y);if(d.beginValid&&d.endValid){if(e){const t=d.begin[y]<0?n+d.begin[y]:d.begin[y];if(d.begin[y]=t,d.end[y]=d.begin[y]+1,t<0||t>=n)throw Error("slice index ".concat(d.begin[y]," of dimension ").concat(y," out of bounds."))}else d.begin[y]=mN(d.begin[y],0,d.strides[y],n,r,a),d.end[y]=mN(d.end[y],1,d.strides[y],n,r,a);const t=1===d.strides[y]&&0===d.begin[y]&&d.end[y]===n;p=p&&t,f=f&&(0===y&&1===d.strides[y]||t)}else p=p&&1===d.strides[y]&&s,f=f&&(0===y&&1===d.strides[y]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[y]-d.begin[y],i=!0):e?(o=1,i=!0):s&&n>=0&&(o=d.strides[y]<0?-n:n,i=!0),i){let t;t=0===o||o<0!==d.strides[y]<0?0:Math.trunc(o/d.strides[y])+(o%d.strides[y]!==0?1:0),m.push(t)}else m.push(-1)}for(let y=0;y<d.finalShapeGatherIndices.length;++y){const t=d.finalShapeGatherIndices[y];t>=0?b.push(m[t]):t===QI&&b.push(1)}return{finalShapeSparse:b.filter(((t,e)=>d.finalShapeGatherIndices[e]!==QI)),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function mN(t,e,n,r,a,s){if(a[e])return n>0?s[e]:s[e+1&1];{const e=t<0?r+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}const bN=gS({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","all","bool")},a={axis:e,keepDims:n};return aS.runKernel(By,r,a)}});const yN=gS({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","any","bool")},a={axis:e,keepDims:n};return aS.runKernel(Wy,r,a)}});const vN=gS({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","argMax")},r={axis:e};return aS.runKernel(Uy,n,r)}});function wN(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return SN(t,[...e,t[3]],n,s,r,null,null,DN(a))}function xN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,l]=EN(e);let c;if("channelsLast"===o)c=[i,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));c=[i,l,t[1],t[1]]}return SN(t,c,n,r,a,s,!1,o)}function kN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,l,c]=CN(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,l,c,t[1],t[1]]}return IN(t,u,n,r,a,!1,h,s)}function SN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=EN(n),[b,y]=EN(r),v=TN(d,b),w=TN(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=NN(t,e,n));const s=t[0],o=t[1],i=AN((s-e+2*r)/n+1,a),l=AN((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=AN((e-s+d+p)/r+1,i),h=AN((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function IN(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[l,d,c,u,h]=t}const[p,f,g,,m]=e,[b,y,v]=CN(n),[w,x,k]=CN(r),S=TN(p,w),I=TN(f,x),N=TN(g,k),{padInfo:E,outDepth:C,outHeight:T,outWidth:A}=function(t,e,n,r,a,s,o,i,l,c,u){let h,d,p,f;"valid"===t&&(t=0);if("number"===typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const g=function(t,e,n,r,a,s){null==a&&(a=NN(t,e[0],r[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)t[i]+2*a>=e[i]&&(o[i]=AN((t[i]-e[i]+2*a)/r[i]+1,s));return o}([e,n,r,1],[i,l,c],1,[a,s,o],t,u);d=g[0],p=g[1],f=g[2]}else{if("same"!==t)throw Error("Unknown padding parameter: ".concat(t));{d=Math.ceil(e/a),p=Math.ceil(n/s),f=Math.ceil(r/o);const t=(d-1)*a+i-e,u=(p-1)*s+l-n,g=(f-1)*o+c-r,m=Math.floor(t/2),b=t-m,y=Math.floor(u/2),v=u-y,w=Math.floor(g/2);h={top:y,bottom:v,left:w,right:g-w,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(a,c,u,h,b,y,v,S,I,N,i),R=s?m*d:m;let F;return"channelsFirst"===o?F=[l,R,C,T,A]:"channelsLast"===o&&(F=[l,C,T,A,R]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:C,outHeight:T,outWidth:A,outChannels:R,padInfo:E,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:x,dilationWidth:k,inShape:t,outShape:F,filterShape:e}}function NN(t,e,n){const r=TN(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function EN(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function CN(t){return"number"===typeof t?[t,t,t]:t}function TN(t,e){return e<=1?t:t+(t-1)*(e-1)}function AN(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function RN(t){const[e,n,r]=EN(t);return 1===e&&1===n&&1===r}function FN(t,e){return RN(t)||RN(e)}function _N(t){return EN(t).every((t=>t>0))}function DN(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(t))}function ON(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)Jb(ty(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{Jb(ty(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const zN=gS({reshape_:function(t,e){const n={x:pS(t,"x","reshape","string_or_numeric")},r={shape:e};return aS.runKernel(Hw,n,r)}});const LN=gS({avgPool_:function(t,e,n,r,a){const s=pS(t,"x","avgPool","float32");Jb(FN(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=zN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),ON("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=aS.runKernel(Xy,l,c);return u=hI(u,s.dtype),i?zN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const MN=gS({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=pS(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=zN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Jb("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Jb("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),ON("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=aS.runKernel(Yy,c,u);return h=hI(h,i.dtype),l?zN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const PN=gS({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?zN(t,[1,1,1,t.size]):2===t.rank?zN(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?zN(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=aS.runKernel(Gv,h,d);return zN(p,o.shape)}});const BN=gS({batchNorm2d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),Jb(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),PN(o,i,l,u,c,s)}});const WN=gS({batchNorm3d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),Jb(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),PN(o,i,l,u,c,s)}});const UN=gS({batchNorm4d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),Jb(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),PN(o,i,l,u,c,s)}});const VN=gS({broadcastTo_:function(t,e){let n=pS(t,"broadcastTo","x");const r=n.shape;if(ky(e),e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=zN(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return dI(n);const o={x:n},i={reps:s};return aS.runKernel(Fx,o,i)}});const jN=gS({clipByValue_:function(t,e,n){const r=pS(t,"x","clipByValue");if(Jb(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return AI(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return aS.runKernel(sv,a,s)}});const GN=gS({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Jb(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=fS(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return dI(n[0]);const r=n,a={axis:e};return aS.runKernel(lv,r,a)}});const HN=gS({concat1d_:function(t){return GN(t,0)}});const KN=gS({concat2d_:function(t,e){return GN(t,e)}});const qN=gS({concat3d_:function(t,e){return GN(t,e)}});const XN=gS({concat4d_:function(t,e){return GN(t,e)}});const JN=gS({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","conv2d","float32"),l=pS(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=zN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),Jb(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),ON("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];Jb(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),Jb(FN(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Jb(_N(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Jb(_N(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=aS.runKernel(cv,d,p);return u?zN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const YN=gS({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","conv1d"),l=pS(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=zN(i,[1,i.shape[0],i.shape[1]])),Jb(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),Jb(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),ON("conv1d",r,o),Jb(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),Jb(FN(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),Jb(_N(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Jb(_N(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Jb("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=zN(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=zN(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=JN(d,h,[1,n],r,"NHWC",[1,s],o);return zN(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const ZN=gS({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;Jb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=zN(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),Jb(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Jb(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),Jb(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];Jb(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Jb(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),ON("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=aS.runKernel(hv,d,p);return c?zN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const QN=gS({conv2dTranspose_:function(t,e,n,r,a,s){const o=pS(t,"x","conv2dTranspose"),i=pS(e,"filter","conv2dTranspose");return ZN(n,o,i,r,a,"NHWC",s)}});const $N=gS({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=pS(t,"x","conv3d"),i=pS(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=zN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),Jb(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Jb(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Jb(FN(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Jb("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported."))),Jb(_N(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Jb(_N(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=aS.runKernel(dv,u,h);return c?zN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const tE=gS({conv3DBackpropInput_:function(t,e,n,r,a){Jb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=zN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];Jb(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),Jb(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),Jb(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Jb(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Jb(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=aS.runKernel(fv,u,h);return i?zN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const eE=gS({conv3dTranspose_:function(t,e,n,r,a){const s=pS(t,"x","conv3dTranspose"),o=pS(e,"filter","conv3dTranspose");return tE(n,s,o,r,a)}});const nE=gS({denseBincount_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"x","denseBincount"),s=pS(e,"weights","denseBincount");Jb("int32"===a.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Jb(a.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(a.rank,"."))),Jb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Jb(s.size===a.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(a.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:a,weights:s},i={size:n,binaryOutput:r};return aS.runKernel(wv,o,i)}});const rE=gS({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","depthwiseConv2d","float32"),l=pS(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=zN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),Jb(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];Jb(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),ON("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=aS.runKernel(kv,d,p);return u?zN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const aE=gS({elu_:function(t){const e={x:pS(t,"x","elu","float32")};return aS.runKernel(_v,e)}});const sE=gS({equal_:function(t,e){let n=pS(t,"a","equal","string_or_numeric"),r=pS(e,"b","equal","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(zv,a)}});const oE=gS({exp_:function(t){const e={x:pS(t,"x","exp")};return aS.runKernel(Lv,e)}});const iE=gS({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","expandDims","string_or_numeric");Jb(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return aS.runKernel(Mv,r,a)}});const lE=gS({tile_:function(t,e){const n=pS(t,"x","tile","string_or_numeric");Jb(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return aS.runKernel(Fx,r,a)}});const cE=gS({eye_:function(t,e,n){null==e&&(e=t);const r=uI([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=zN(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return lE(iE(s,0),[n[0],1,1]);if(2===n.length)return lE(iE(iE(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return lE(iE(iE(iE(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const uE=gS({floor_:function(t){const e={x:pS(t,"x","floor","float32")};return aS.runKernel(Vv,e)}});const hE=gS({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:pS(t,"x","gather"),indices:pS(e,"indices","gather","int32")},s={axis:n,batchDims:r};return aS.runKernel(Hv,a,s)}});const dE=gS({greater_:function(t,e){let n=pS(t,"a","greater","string_or_numeric"),r=pS(e,"b","greater","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(qv,a)}});const pE=gS({greaterEqual_:function(t,e){let n=pS(t,"a","greaterEqual","string_or_numeric"),r=pS(e,"b","greaterEqual","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(Xv,a)}});const fE=gS({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:pS(t,"x","leakyRelu")},r={alpha:e};return aS.runKernel(ew,n,r)}});const gE=gS({log_:function(t){const e={x:pS(t,"x","log","float32")};return aS.runKernel(sw,e)}});const mE=gS({log1p_:function(t){const e={x:pS(t,"x","log1p")};return aS.runKernel(ow,e)}});const bE=gS({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","max")},a={reductionIndices:e,keepDims:n};return aS.runKernel(dw,r,a)}});const yE=gS({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=pS(t,"x","sum");"bool"===r.dtype&&(r=hI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return aS.runKernel(dx,a,s)}});const vE=gS({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=pS(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=wI(((t,n)=>{const r=bE(t,e,!0),a=_I(t,r),s=_I(hI(a,"float32"),gE(yE(oE(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=oE(r);return _I(t,mI(yE(t,e,!0),a))}}}));return r(n)}});function wE(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function xE(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}function kE(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}function SE(t,e){return xE(t,e.map((t=>1)),e)}function IE(t,e,n){Jb(wE(e,n),(()=>"".concat(t," supports only inner-most axes for now. ")+"Got axes ".concat(e," and rank-").concat(n," input.")))}function NE(t,e){if(wE(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function EE(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function CE(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const TE=gS({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=pS(t,"x","logSumExp"),a=sy(e,r.shape),s=bE(r,a,!0),o=_I(r,s),i=oE(o),l=yE(i,a),c=gE(l),u=pI(zN(s,c.shape),c);if(n){const t=SE(u.shape,a);return zN(u,t)}return u}});const AE=gS({logicalAnd_:function(t,e){const n=pS(t,"a","logicalAnd","bool"),r=pS(e,"b","logicalAnd","bool");MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(iw,a)}});const RE=gS({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=pS(t,"a","matMul"),s=pS(e,"b","matMul");[a,s]=Yk(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return aS.runKernel(Qy,o,i)}});const FE=gS({maxPool_:function(t,e,n,r,a){const s=pS(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=zN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),Jb(FN(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),ON("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=aS.runKernel(fw,l,c);return i?zN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const _E=gS({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=pS(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=zN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Jb("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),ON("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=aS.runKernel(mw,c,u);return l?zN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const DE=gS({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","mean")},a={axis:e,keepDims:n};return aS.runKernel(vw,r,a)}});const OE=gS({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","min")},a={axis:e,keepDims:n};return aS.runKernel(ww,r,a)}});const zE=gS({minimum_:function(t,e){let n=pS(t,"a","minimum"),r=pS(e,"b","minimum");[n,r]=Yk(n,r),"bool"===n.dtype&&(n=hI(n,"int32"),r=hI(r,"int32")),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(xw,a)}});const LE=gS({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=sy(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=pS(t,"x","moments")).shape),r=DE(t,n,e);let a=r.shape;e||(a=SE(r.shape,n));const s=yI(_I(hI(t,"float32"),zN(r,a)));return{mean:r,variance:DE(s,n,e)}}});const ME=gS({neg_:function(t){const e={x:pS(t,"x","neg")};return aS.runKernel(Ew,e)}});const PE=gS({notEqual_:function(t,e){let n=pS(t,"a","notEqual","string_or_numeric"),r=pS(e,"b","notEqual","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(Cw,a)}});const BE=gS({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:pS(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return aS.runKernel(_w,s,o)}});function WE(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(ky(t),"complex64"===e){const e=WE(t,"float32"),n=WE(t,"float32");return mS(e,n)}const n=wy(Qb(t),e);return aS.makeTensor(n,t,e)}function UE(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(ky(t),"complex64"===e){const e=UE(t,"float32"),n=WE(t,"float32");return mS(e,n)}const n=vy(Qb(t),e);return aS.makeTensor(n,t,e)}const VE=gS({onesLike_:function(t){const e={x:pS(t,"x","onesLike")};return aS.runKernel(Fw,e)}});const jE=gS({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=pS(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return aS.runKernel(Ow,s,a)}});const GE=gS({prelu_:function(t,e){const n={x:pS(t,"x","prelu"),alpha:pS(e,"alpha","prelu")};return aS.runKernel(Lw,n)}});class HE{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Vo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class KE{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Vo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const qE=gS({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(ky(t),null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new HE(e,n,r,!1,a),o=uI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const XE=gS({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;ky(t);const s=uI(t,r),o=new KE(e,n,null,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});function JE(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return aS.runKernel(Uw,{},a)}const YE=gS({relu_:function(t){const e={x:pS(t,"x","relu")};return aS.runKernel(Gw,e)}});const ZE=gS({reverse_:function(t,e){const n={x:pS(t,"x","reverse")},r={dims:e};return aS.runKernel(Zw,n,r)}});const QE=gS({selu_:function(t){const e={x:pS(t,"x","selu")};return aS.runKernel(ax,e)}});const $E=gS({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=pS(t,"x","separableConv2d"),l=pS(e,"depthwiseFilter","separableConv2d"),c=pS(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=zN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Jb(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Jb(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Jb(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Jb(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),Jb(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];Jb(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=rE(u,l,r,a,o,s),g=JN(f,c,1,"valid",o);return h?zN(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const tC=gS({sigmoid_:function(t){const e={x:pS(t,"x","sigmoid","float32")};return aS.runKernel(cx,e)}});const eC=gS({slice_:function(t,e,n){const r=pS(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return aS.runKernel(sx,a,s)}});const nC=gS({slice1d_:function(t,e,n){const r=pS(t,"x","slice1d");return Jb(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),eC(r,[e],[n])}});const rC=gS({slice2d_:function(t,e,n){const r=pS(t,"x","slice2d");return Jb(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),eC(r,e,n)}});const aC=gS({slice3d_:function(t,e,n){const r=pS(t,"x","slice3d");return Jb(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),eC(r,e,n)}});const sC=gS({slice4d_:function(t,e,n){const r=pS(t,"x","slice4d");return Jb(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),eC(r,e,n)}});const oC=gS({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=pS(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return aS.runKernel(gx,r,a)}});const iC=gS({softplus_:function(t){const e={x:pS(t,"x","softplus")};return aS.runKernel(ux,e)}});const lC=gS({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:pS(t,"x","split")},a={numOrSizeSplits:e,axis:n};return aS.runKernel(fx,r,a)}});const cC=gS({squeeze_:function(t,e){const n=pS(t,"x","squeeze","string_or_numeric");return zN(n,oy(n.shape,e).newShape)}});const uC=gS({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=fS(t,"tensors","stack","string_or_numeric");Jb(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Jb(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return aS.runKernel(Dw,r,a)}});const hC=gS({tanh_:function(t){const e={x:pS(t,"x","tanh","float32")};return aS.runKernel(Rx,e)}});function dC(t,e){Zb(t);const n=uS(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bS(t,null,n,e)}function pC(t,e,n){if(Zb(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=uS(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bS(t,e,r,n)}const fC=gS({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(ky(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new HE(e,n,r,!0,a),o=uI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const gC=gS({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","unstack","string_or_numeric");Jb(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return aS.runKernel(Lx,r,a)}});const mC=gS({where_:function(t,e,n){const r=pS(e,"a","where"),a=pS(n,"b","where"),s=pS(t,"condition","where","bool"),o=MI(MI(s.shape,r.shape),a.shape),i={condition:VN(s,o),t:VN(r,o),e:VN(a,o)};return aS.runKernel(rx,i)}});const bC=gS({imag_:function(t){const e={input:pS(t,"input","imag")};return aS.runKernel(Zv,e)}});const yC=gS({real_:function(t){const e={input:pS(t,"input","real")};return aS.runKernel(Vw,e)}});const vC=gS({transpose_:function(t,e,n){const r=pS(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),Jb(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{Jb(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?kS((()=>{let t=yC(r),e=bC(r);return t=aS.runKernel(Ox,{x:t},s),e=aS.runKernel(Ox,{x:e},s),n&&(e=ME(e)),mS(t,e)})):aS.runKernel(Ox,a,s)}});const wC=gS({dropout_:function(t,e,n,r){const a=pS(t,"x","dropout");if(Jb("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),Jb(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Mk?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if($b(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=gI(uE(pI(XE(s,0,1,"float32",r),o)),o);return mI(a,i)}});const xC=gS({fft_:function(t){Jb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return aS.runKernel(Bv,e)}});const kC=gS({rfft_:function(t,e){Jb("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=eC(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=GN([t,WE(r)],t.shape.length-1),n=e}else a=t;const s=vI(a),o=zN(mS(a,s),[r,n]),i=xC(o),l=Math.floor(n/2)+1,c=yC(i),u=bC(i),h=lC(c,[l,n-l],c.shape.length-1),d=lC(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,zN(mS(h[0],d[0]),p)}});const SC=gS({ifft_:function(t){Jb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return aS.runKernel(Yv,e)}});const IC=gS({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=zN(t,[n,e]);r=SC(a)}else{const a=[n,2*(e-1)],s=zN(yC(t),[n,e]),o=zN(bC(t),[n,e]),i=ZE(eC(s,[0,1],[n,e-2]),1),l=mI(ZE(eC(o,[0,1],[n,e-2]),1),xI(-1)),c=GN([s,i],1),u=GN([o,l],1),h=zN(mS(c,u),[a[0],a[1]]);r=SC(h)}if(r=yC(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=zN(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const NC=gS({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=zN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=zN(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Jb(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Jb(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),Jb(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];Jb(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),Jb(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),ON("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return aS.runKernel(uv,h,d)}});const EC=gS({relu6_:function(t){const e={x:pS(t,"x","relu6")};return aS.runKernel(Yw,e)}});const CC=gS({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","step")},r={alpha:e};return aS.runKernel(Bx,n,r)}});function TC(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return mI(t,CC(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function AC(t,e){let n=e;const r=LI(t.shape,e.shape);return r.length>0&&(n=yE(n,r)),zN(n,t.shape)}function RC(t,e,n,r){if("linear"===e)return t;if("relu"===e)return YE(t);if("elu"===e)return aE(t);if("relu6"===e)return EC(t);if("prelu"===e)return GE(t,n);if("leakyrelu"===e)return fE(t,r);if("sigmoid"===e)return tC(t);throw new Error("Unknown fused activation ".concat(e,"."))}const FC=(t,e)=>!(t>0)||"linear"===e;const _C=gS({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===FC(aS.state.gradientDepth,c)){Jb("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=JN(e,n,r,a,s,o,i);return null!=l&&(t=pI(t,l)),RC(t,c,u,h)}const d=pS(e,"x","conv2d","float32"),p=pS(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=zN(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Jb(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Jb(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),ON("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];Jb(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Jb(FN(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=SN(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=pS(l,"bias","fused conv2d"),[y]=Yk(y,d),"NHWC"===s?MI(b.outShape,y.shape):(Jb(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),Jb(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(Jb(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)Jb(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{MI(t,b.outShape)}catch(d1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=pS(u,"prelu weights","fused conv2d")}const w=(t,e)=>{Jb("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=TC(t,l,c);Jb(RN(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[ZN(i.shape,h,n,r,a),NC(i,h,n.shape,r,a)];if(null!=u){const t=AC(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=wI(((t,e,n)=>{let r=aS.runKernel(jx,x,k);return n([e,t,r]),g&&(r=zN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=wI(((t,e,n,r)=>{let a=aS.runKernel(jx,x,k);return r([e,t,a,n]),g&&(a=zN(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const DC=gS({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=zN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=zN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return aS.runKernel(Sv,c,u)}});const OC=gS({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=zN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=aS.runKernel(Iv,c,u);return l?zN(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const zC=gS({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===FC(aS.state.gradientDepth,o)){let t=RE(e,n,r,a);return null!=s&&(t=pI(t,s)),RC(t,o,i,l)}let c=pS(e,"a","fused matMul"),u=pS(n,"b","fused matMul");[c,u]=Yk(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=Qb(g),y=Qb(m);Jb(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=MI(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=zN(c,r?[b,h,p]:[b,p,h]),x=zN(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=pS(s,"bias","fused matMul"),[k]=Yk(k,c),MI(v,k.shape)),null!=i&&(S=pS(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=TC(zN(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=RE(u,i,!1,!1),d=RE(u,n,!0,!1)):r&&!a?(h=RE(i,u,!1,!0),d=RE(n,u,!1,!1)):(h=RE(i,u,!0,!0),d=RE(u,n,!0,!0)):(h=RE(u,i,!1,!0),d=RE(n,u,!0,!1)),null!=s){return[h,d,AC(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},E={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=wI(((t,e,n)=>{const r=aS.runKernel(Vx,N,E);return n([t,e,r]),{value:zN(r,v),gradFunc:I}}));return t(w,x)}{const t=wI(((t,e,n,r)=>{const a=aS.runKernel(Vx,N,E);return r([t,e,a,n]),{value:zN(a,v),gradFunc:I}}));return t(w,x,k)}}});const LC=gS({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"image","cropAndResize"),i=pS(e,"boxes","cropAndResize","float32"),l=pS(n,"boxInd","cropAndResize","int32"),c=i.shape[0];Jb(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Jb(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),Jb(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),Jb(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),Jb(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),Jb("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return aS.runKernel(vv,u,h)}});const MC=gS({flipLeftRight_:function(t){const e=pS(t,"image","flipLeftRight","float32");Jb(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return aS.runKernel(Uv,n,{})}});const PC=gS({grayscaleToRGB_:function(t){const e=pS(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];Jb(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Jb(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,lE(e,a)}});const BC=gS({einsum_:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const a=n.map(((t,e)=>pS(t,"tensors".concat(e),"einsum"))),s={equation:t};return aS.runKernel(Fv,a,s)}});const WC=gS({rgbToGrayscale_:function(t){const e=pS(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];Jb(e.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Jb(3===r,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(r,".")));const a=e.dtype,s=hI(e,"float32"),o=dC([.2989,.587,.114]);let i;switch(e.rank){case 2:i=BC("ij,j->i",s,o);break;case 3:i=BC("ijk,k->ij",s,o);break;case 4:i=BC("ijkl,l->ijk",s,o);break;case 5:i=BC("ijklm,m->ijkl",s,o);break;case 6:i=BC("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return i=iE(i,-1),hI(i,a)}});const UC=gS({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=pS(t,"image","rotateWithOffset","float32");Jb(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return aS.runKernel(Ux,s,o)}});function VC(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),Jb(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),Jb(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),Jb(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),Jb(1===e.rank,(()=>"scores must be a 1D tensor")),Jb(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),Jb(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const jC=gS({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=pS(t,"boxes","nonMaxSuppression","float32"),o=pS(e,"scores","nonMaxSuppression","float32"),i=VC(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return aS.runKernel(Tw,{boxes:s,scores:o},l)}});function GC(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||HC)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function HC(t,e){return t>e?1:t<e?-1:0}function KC(t,e,n,r,a){return JC(t,e,n,r,a,0)}function qC(t,e,n,r,a,s){return JC(t,e,n,r,a,0,!1,s,!0)}function XC(t,e,n,r,a,s){return JC(t,e,n,r,a,s,!0)}function JC(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(QC);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=YC(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*ZC(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&GC(c,e,QC))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function YC(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function ZC(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function QC(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const $C=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=pS(t,"boxes","nonMaxSuppressionAsync"),o=pS(e,"scores","nonMaxSuppressionAsync"),i=VC(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=KC(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),dC(h,"int32")};const tT=gS({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"boxes","nonMaxSuppression"),i=pS(e,"scores","nonMaxSuppression"),l=VC(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=aS.runKernel(Rw,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const eT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"boxes","nonMaxSuppressionAsync"),i=pS(e,"scores","nonMaxSuppressionAsync"),l=VC(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=XC(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:dC(d,"int32"),selectedScores:dC(p)}};const nT=gS({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=pS(t,"boxes","nonMaxSuppression"),i=pS(e,"scores","nonMaxSuppression"),l=VC(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=aS.runKernel(Aw,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const rT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=pS(t,"boxes","nonMaxSuppressionAsync"),i=pS(e,"scores","nonMaxSuppressionAsync"),l=VC(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=qC(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:dC(f,"int32"),validOutputs:xI(g,"int32")}};const aT=gS({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"images","resizeBilinear");Jb(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Jb(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),Jb(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=zN(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=aS.runKernel(Xw,i,l);return o?zN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const sT=gS({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"images","resizeNearestNeighbor");Jb(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Jb(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),Jb("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Jb(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=zN(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=aS.runKernel(Kw,i,l);return o?zN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const oT=gS({bincount_:function(t,e,n){const r=pS(t,"x","bincount"),a=pS(e,"weights","bincount");Jb("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Jb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Jb(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return aS.runKernel(tv,s,o)}});const iT=gS({lessEqual_:function(t,e){let n=pS(t,"a","lessEqual","string_or_numeric"),r=pS(e,"b","lessEqual","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(rw,a)}});const lT=gS({round_:function(t){const e={x:pS(t,"x","round")};return aS.runKernel(Qw,e)}});const cT=gS({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=pS(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=mI(dC([r]),255);if(Jb(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),Jb(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),Jb("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),Jb("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=lC(a,[1,1,1],-1);const t=mI(o,.2989),e=mI(i,.587),n=mI(l,.114);c=pI(pI(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=dC([-1]),c=dC([0]),u=dC([0]);for(let h=0;h<t.size-1;h++){n=eC(t,0,h+1),r=eC(t,h+1),o=gI(yE(n),e),i=gI(yE(r),e);const d=yE(mI(n,JE(0,n.size)));a=gI(d,yE(n));const p=AI(r.shape,n.size),f=pI(JE(0,r.size),p),g=mI(r,f);s=gI(yE(g),yE(r));const m=_I(a,s),b=_I(a,s),y=mI(o,i);u=mI(mI(y,m),b);const v=dE(u,c);c=mC(v,u,c),l=mC(v,dC([h]),l)}return l}(oT(hI(lT(c),"int32"),yS([]),256),s)}const h=n?iT(c,u):dE(c,u);return hI(mI(h,255),"int32")}});const uT=gS({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=pS(t,"image","transform","float32"),i=pS(e,"transforms","transform","float32");Jb(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Jb(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Jb(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return aS.runKernel(Dx,l,c)}});const hT=gS({less_:function(t,e){let n=pS(t,"a","less","string_or_numeric"),r=pS(e,"b","less","string_or_numeric");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(nw,a)}});const dT=gS({bandPart_:function(t,e,n){const r=pS(t,"a","bandPart");Jb(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);let i,l;"number"===typeof e?(Jb(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),Jb(e<=s,(()=>"bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."))),i=pS(e<0?s:e,"numLower","bandPart")):(Jb("int32"===e.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=mC(hT(e,0),s,zE(e,s))),"number"===typeof n?(Jb(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Jb(n<=o,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."))),l=pS(n<0?o:n,"numUpper","bandPart")):(Jb("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=mC(hT(n,0),o,zE(n,o)));const c=zN(JE(0,s,1,"int32"),[-1,1]),u=JE(0,o,1,"int32"),h=_I(c,u),d=AE(iT(h,i),pE(h,ME(l))),p=WE([s,o],r.dtype);return zN(uC(gC(zN(r,[-1,s,o])).map((t=>mC(d,t,p)))),a)}});function pT(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return OI(t);if(1!==t.rank&&null===n)return pT(zN(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return yE(OI(t),n);if(e===1/0)return bE(OI(t),n);if(e===-1/0)return OE(OI(t),n);if("euclidean"===e||2===e)return bI(yE(FI(OI(t),xI(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return bE(yE(OI(t),n[0]),n[1]-1);if(e===1/0)return bE(yE(OI(t),n[1]),n[0]);if(e===-1/0)return OE(yE(OI(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return bI(yE(yI(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const fT=gS({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pT(t=pS(t,"x","norm"),e,n);let s=a.shape;if(r){const e=sy(n,t.shape);s=SE(a.shape,e)}return zN(a,s)}});const gT=gS({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Jb(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Jb(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=lC(t,t.shape[0],0).map((t=>cC(t,[0])));Jb(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(aS.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=mI(yE(mI(n[e],t)),n[e]);t=_I(t,r)}return gI(t,fT(t,"euclidean"))})));return e?uC(n,0):n}});function mT(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return aS.tidy((()=>{Jb(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=cE(n),s=dI(t);const o=pC([[1]],[1,1]);let i=dI(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=aS.tidy((()=>{const e=eC(s,[t,t],[n-t,1]),l=fT(e),c=eC(s,[t,t],[1,1]),u=mC(dE(c,0),pC([[-1]]),pC([[1]])),h=_I(c,mI(u,l)),d=gI(e,h);i=1===d.shape[0]?dI(o):GN([o,eC(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=ME(gI(RE(u,h),l)),f=eC(s,[t,0],[n-t,r]),g=mI(p,i),m=vC(i);if(0===t)s=_I(f,RE(g,RE(m,f)));else{const e=_I(f,RE(g,RE(m,f)));s=GN([eC(s,[0,0],[t,r]),e],0)}const b=vC(g),y=eC(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=_I(y,RE(RE(y,i),b));else{const e=_I(y,RE(RE(y,i),b));a=GN([eC(a,[0,0],[n,t]),e],1)}return[i,s,a]})),SS([e,l,c])}return!e&&n>r&&(a=eC(a,[0,0],[n,r]),s=eC(s,[0,0],[r,r])),[a,s]}))}const bT=gS({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Jb(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return mT(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=gC(zN(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=mT(t,e);a.push(n),s.push(r)}));return[zN(uC(a,0),t.shape),zN(uC(s,0),t.shape)]}}});var yT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(yT||(yT={}));const vT=gS({squaredDifference_:function(t,e){let n=pS(t,"a","squaredDifference"),r=pS(e,"b","squaredDifference");[n,r]=Yk(n,r),MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(xx,a,{})}});const wT={flipLeftRight:MC,grayscaleToRGB:PC,resizeNearestNeighbor:sT,resizeBilinear:aT,rgbToGrayscale:WC,rotateWithOffset:UC,cropAndResize:LC,nonMaxSuppression:jC,nonMaxSuppressionAsync:$C,nonMaxSuppressionWithScore:tT,nonMaxSuppressionWithScoreAsync:eT,nonMaxSuppressionPadded:nT,nonMaxSuppressionPaddedAsync:rT,threshold:cT,transform:uT},xT={bandPart:dT,gramSchmidt:gT,qr:bT};const kT=class{static sgd(t){return new WI(t)}static momentum(t,e){return new UI(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new VI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new DI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new TI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new BI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new RI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},ST="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function IT(){return new Promise((t=>ST((()=>t()))))}function NT(t,e){const n=t[0].length;t.forEach(((t,e)=>{Jb(t.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(e,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Jb(e>=0&&e<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const r=t[0];t.forEach(((t,a)=>{for(let s=0;s<n;s++)Jb(s===e||t[s]===r[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(a,"] (").concat(t,") ")+"does not match the shape of the rest (".concat(r,") ")+"along the non-concatenated axis ".concat(a,".")))}))}function ET(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var CT;function TT(t,e,n){let r=new Array;if(null==n&&null==e)return r;if(null==e)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(null==n)return r;if(t+n.length!==r.length)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.rank = ").concat(t+n.length,", but shape.rank = ").concat(r.length));for(let a=1;a<n.length;++a){const s=n[a],o=r[r.length-n.length+a],i=r[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.shape[").concat(a+t,"] = ").concat(s," but shape[").concat(a+t,"] = ").concat(i))}else r[o]=s}return r}function AT(t){const e={FIRST_DIM_SIZE:CT.FIRST_DIM_SIZE,VALUE_ROWIDS:CT.VALUE_ROWIDS,ROW_LENGTHS:CT.ROW_LENGTHS,ROW_SPLITS:CT.ROW_SPLITS,ROW_LIMITS:CT.ROW_LIMITS,ROW_STARTS:CT.ROW_STARTS},n=[];for(const r of t){if(!(r in e))break;n.push(e[r])}return n}function RT(t){return 0===t.length?0:t[0]===CT.FIRST_DIM_SIZE?t.length-1:t.length}function FT(t,e){if(null==t||null==e)return;const n=t.length,r=e.length;if(n>=r)throw new Error("defaultValue.shape=".concat(t," and ragged tensor flatValues.shape=").concat(e,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(r,")"));for(let a=0;a<Math.min(n,r-1);++a){const n=t[a],r=e[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error("defaultValue.shape=".concat(t,", and ragged tensor input flatValues.shape=").concat(e," are incompatible: defaultValue.shape[").concat(a-t.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(a-t.length,"] = ").concat(r))}}!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(CT||(CT={}));const _T=30;function DT(t){return t<=_T?t:gy(t,Math.floor(Math.sqrt(t)))}function OT(t,e,n){return[n*("number"===typeof t?t:t[0]),e*("number"===typeof t?t:t[1])]}function zT(t,e,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let a=0;a<n;++a)r=r.concat([t[a+1]/e[a],e[a]]);r=r.concat(t.slice(n+1))}return r}function LT(t,e){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(e);for(let r=e+1;r<t;++r)r<=2*e?(n.push(r),n.push(r-(e+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<t;++n)n>=2*e+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function MT(t,e,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(t[0]/n):a.push(t[0]*n);for(let s=1;s<t.length;++s)s<=e.length?r?a.push(e[s-1]*t[s]):a.push(t[s]/e[s-1]):a.push(t[s]);return a}function PT(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function BT(t,e,n){const r=t.slice(0,1);for(let a=0;a<n;++a)r.push(t[a+1]-e[a][0]-e[a][1]);return r}function WT(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(r,"."));if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(e.shape[r-1]," vs. ").concat(n));if(0===Qb(t.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(t.shape,"."));const a=e.shape,s=a[a.length-1];let o=1;for(let h=0;h<a.length-1;++h)o*=a[h];const i=t.shape,l=a.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=i[h],l.push(i[h]);const u=[...my(t.shape).map((t=>t/c)),1].slice(0,s);return[l,o,c,u]}function UT(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,a=e.rank>1?e.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(e.shape,", shape: ").concat(t)+", sliceDim: ".concat(r,", and batchDim: ").concat(a,".");if(n.rank<a)throw new Error(s+" update.rank < ".concat(a,". "));if(t.length<r+(n.rank-a))throw new Error(s+" Output shape length < ".concat(r+(n.rank-a)));if(n.rank!==a+t.length-r)throw new Error(s+" update.rank != ".concat(a+t.length-r));for(let o=0;o<a;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(e.shape[o],")."));for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==t[o+r])throw new Error(s+" updates.shape[".concat(o+a,"] (").concat(n.shape[o+a],") != shape[").concat(o+a,"] (").concat(t[o+a],")"))}function VT(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(e.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: ".concat(e.shape));if(0===t.size)throw new Error("Updates specified for empty output. updates shape: ".concat(t.shape))}UT(n,e,t)}function jT(t,e,n){const r=e.shape.length,a=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let l=a;l<s;++l)o*=n[l];const i=a<1?1:a;return{sliceRank:a,numUpdates:Qb(e.shape)/i,sliceSize:o,strides:[...my(n.slice(0,a)),1],outputSize:Qb(n)}}const GT=1.7580993408473768,HT=1.0507009873554805,KT=.3275911,qT=.254829592,XT=-.284496736,JT=1.421413741,YT=-1.453152027,ZT=1.061405429;function QT(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(t.length,", imag: ").concat(e.length,"."));const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function $T(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function tA(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=0;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function eA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=2;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function nA(t,e){return{real:t[2*e],imag:t[2*e+1]}}function rA(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function aA(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let a=0;a<Math.ceil(t/2);a++){const s=(e?2:-2)*Math.PI*(a/t);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function sA(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const oA="->",iA=/->/g,lA=",",cA="...";function uA(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(iA,"").length)/oA.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(oA,'").'));const[r,a]=t.split(oA);Jb(-1===r.indexOf(cA),(()=>'The ellipsis notation ("'.concat(cA,'") is not supported yet.')));const s=r.split(lA),o=s.length;if(e!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(e));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<a.length;++h){const t=a[h];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error("Output subscripts contain the label ".concat(t," ")+"not present in the input subscripts.");-1===i.indexOf(t)&&i.push(t)}for(let h=0;h<r.length;++h){const t=r[h];-1===i.indexOf(t)&&t!==lA&&i.push(t)}const l=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");l[h]=[];for(let t=0;t<s[h].length;++t)l[h].push(i.indexOf(s[h][t]))}const c=i.length,u=[];for(let h=a.length;h<c;++h)u.push(h);return{allDims:i,summedDims:u,idDims:l}}function hA(t,e){let n=new Array(t);n.fill(-1);for(let a=0;a<e.length;++a)n[e[a]]=a;const r=[];for(let a=0;a<t;++a)-1===n[a]&&r.push(a);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function dA(t,e,n){const r=new Array(t);for(let a=0;a<n.length;++a){const t=n[a].shape;for(let n=0;n<e[a].length;++n)void 0===r[e[a][n]]?r[e[a][n]]=t[n]:Jb(r[e[a][n]]===t[n],(()=>"Expected dimension ".concat(r[e[a][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(t),", ")+"but got dimension ".concat(t[n])))}}function pA(t,e){const n=t,r=[];let a=0;0===t.length&&n.push(-1),a=t.length+1;for(let o=0;o<a;++o)r.push([]);const s=[];for(let o=0;o<n.length;++o){const t=gA(e,n[o]);for(const e of t)-1===s.indexOf(e)&&(r[o].push(e),s.push(e))}return{path:n,steps:r}}function fA(t){return t.every(((t,e)=>t===e))}function gA(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function mA(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof e)Jb(t.shape[n]%e===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{const a=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Jb(a<=1,(()=>"There should be only one negative value in split array."));const s=e.indexOf(-1);if(-1!==s){const r=e.reduce(((t,e)=>e>0?t+e:t));e[s]=t.shape[n]-r}Jb(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function bA(t){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(t)}function yA(t,e){return"indices(".concat(t,", 0) is invalid: ").concat(e," < 0")}function vA(t,e,n){return"indices(".concat(t,", 0) is invalid: ").concat(e," >= ").concat(n)}function wA(t,e){return"only one output dimension may be -1, not both ".concat(t," and ").concat(e)}function xA(t,e){return"size ".concat(t," must be non-negative, not ").concat(e)}function kA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function SA(t,e){const n=Qb(t),r=Qb(e);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(r,". inputShape=").concat(t," outputShape= ").concat(e)}function IA(t,e){const n=Qb(t),r=Qb(e);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(r,". inputShape=").concat(t," outputShape=").concat(e)}function NA(){return"segment ids must be >= 0"}function EA(){return"segment ids are not increasing"}function CA(t,e){return"Segment id ".concat(t," out of range [0, ").concat(e,"), possibly because segmentIds input is not sorted.")}function TA(t,e,n){return"Bad: indices[".concat(t,"] == ").concat(e," out of range [0, ").concat(n,")")}function AA(t,e){let n,r=!1;for(t<=_T?(n=t,r=!0):n=gy(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=gy(t,n+1);return n}function RA(t,e,n){const r=[],a=t.length;for(let s=0;s<a;s++)s!==e?r.push(t[s]):r.push(n);return r}function FA(t,e,n,r){const a=e.shape.length,s=t.shape.length;if(0!==r&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-".concat(a,", ").concat(a,"], but got ").concat(r));if(r<0&&(r+=a),r>s)throw new Error("batchDims (".concat(r,") must be less than rank(x) (\n    ").concat(s,")."));if(n<r)throw new Error("batchDims (".concat(r,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(t.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(e.shape[h],"."));const o=t.shape[n],i=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),c*=t.shape[h];for(let h=r;h<a;h++)i.push(e.shape[h]);for(let h=n+1;h<s;h++)i.push(t.shape[h]),u*=t.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:i}}function _A(t){try{return t.map((t=>vk(t)))}catch(p1){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(p1))}}function DA(t){return t.map((t=>yk(t)))}function OA(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const r=uI(t,"int32"),a=uI([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const e=r.indexToLoc(n[s]),o=s*t.length;a.values.set(e,o)}return a.toTensor()}!function(){for(const t of jI)EI(t)}();const zA={kernelName:Oy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,CC(hI(n,"float32"),-1))}}},LA={kernelName:zy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=yI(hI(n,"float32")),r=bI(_I(xI(1),e));return ME(gI(t,r))}}}},MA={kernelName:Ly,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=bI(_I(yI(hI(n,"float32")),1));return gI(t,e)}}}},PA={kernelName:My,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{let e=t;const r=LI(n.shape,a);return r.length>0&&(e=yE(e,r)),zN(e,n.shape)},b:()=>{let e=t;const n=LI(r.shape,a);return n.length>0&&(e=yE(e,n)),zN(e,r.shape)}}}},BA={kernelName:Py,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},WA={kernelName:Uy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(n)}}},UA={kernelName:Vy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(n)}}},VA={kernelName:jy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,bI(_I(xI(1),yI(hI(n,"float32")))))}}},jA={kernelName:Gy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=bI(pI(xI(1),yI(hI(n,"float32"))));return gI(t,e)}}}},GA={kernelName:qy,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{const e=pI(yI(n),yI(r));let s=mI(t,gI(r,e));const o=LI(n.shape,a);return o.length>0&&(s=yE(s,o)),zN(s,n.shape)},b:()=>{const e=pI(yI(n),yI(r));let s=ME(mI(t,gI(n,e)));const o=LI(r.shape,a);return o.length>0&&(s=yE(s,o)),zN(s,r.shape)}}}},HA={kernelName:Hy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,pI(yI(hI(n,"float32")),1))}}},KA={kernelName:Ky,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,_I(xI(1),yI(hI(n,"float32"))))}}};const qA=gS({avgPool3dGrad_:function(t,e,n,r,a,s){const o=pS(t,"dy","avgPool3dGrad"),i=pS(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=zN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=zN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Jb(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),Jb(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),ON("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=aS.runKernel(Zy,h,d);return u?zN(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),XA={kernelName:Yy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>qA(t,r,a,s,o,i)}}};const JA=gS({avgPoolGrad_:function(t,e,n,r,a){const s=pS(t,"dy","avgPoolGrad"),o=pS(e,"input","avgPoolGrad");Jb(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=zN(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=zN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),Jb(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=aS.runKernel(Jy,u,h);return c?zN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),YA={kernelName:Xy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>JA(t,r,a,s,o)}}},ZA={kernelName:Qy,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>RE(t,a,!1,!1),b:()=>RE(t,r,!0,!1)}:s&&!o?{a:()=>RE(a,t,!1,!0),b:()=>RE(r,t,!1,!1)}:{a:()=>RE(a,t,!0,!0),b:()=>RE(t,r,!0,!0)}:{a:()=>RE(t,a,!1,!0),b:()=>RE(r,t,!0,!1)}}};const QA=gS({spaceToBatchND_:function(t,e,n){const r=pS(t,"x","spaceToBatchND");Jb(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),Jb(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),Jb(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return aS.runKernel(px,a,s)}}),$A={kernelName:$y,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>QA(t,r,a)}}},tR={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>yE(t,i,!0)}}},eR={kernelName:rv,gradFunc:t=>({x:()=>t.clone()})},nR={kernelName:av,gradFunc:t=>({x:()=>vI(t)})},rR={kernelName:sv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>mC(AE(pE(r,a),iT(r,s)),t,vI(t))}}},aR={kernelName:iv,inputsToSave:["x"],gradFunc:zA.gradFunc},sR={kernelName:lv,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=sy(a,e[0].shape)[0],o=r.map((t=>t[s]));return lC(t,o,s).map((t=>()=>t))}},oR={kernelName:cv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return Jb(RN(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>ZN(r.shape,t,a,o,i,l),filter:()=>NC(r,t,a.shape,o,i,l)}}},iR={kernelName:hv,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>JN(t,a,s,o,i,1,l),filter:()=>NC(t,r,a.shape,s,o,i,l)}}};const lR=gS({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=zN(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=zN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),Jb(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),Jb(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),Jb(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Jb(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Jb(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return aS.runKernel(pv,i,l)}}),cR={kernelName:dv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;Jb(RN(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>tE(o.shape,t,i,a,s),filter:()=>lR(o,t,i.shape,a,s)}}};const uR=gS({sin_:function(t){const e={x:pS(t,"x","sin","float32")};return aS.runKernel(ox,e)}}),hR={kernelName:gv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(ME(uR(hI(n,"float32"))),t)}}};const dR=gS({sinh_:function(t){const e={x:pS(t,"x","sinh")};return aS.runKernel(ix,e)}}),pR={kernelName:mv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(dR(hI(n,"float32")),t)}}};const fR=gS({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:pS(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return aS.runKernel(yv,a,s)}}),gR={kernelName:yv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=NE([a],r.rank);let n=fR(t,a,s,!o);return null!=e&&(n=vC(n,e)),n}}}},mR={kernelName:kv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;Jb(RN(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return Jb(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),Jb(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),Jb(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),Jb(FN(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),ON("depthwiseConv2d",s,o),{x:()=>OC(l.shape,t,c,a,s,i,o),filter:()=>DC(l,t,c.shape,a,s,i,o)}}},bR={kernelName:Ev,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>aS.runKernel(Cv,s,n),filter:()=>aS.runKernel(Tv,o,n)}}},yR={kernelName:_v,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>aS.runKernel(Dv,r)}}},vR={kernelName:Ov,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=mI(oE(ME(yI(n))),2/Math.sqrt(Math.PI));return{x:()=>mI(t,r)}}},wR={kernelName:Lv,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,n)}}},xR={kernelName:Mv,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>zN(t,n.shape)}}},kR={kernelName:Pv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,oE(n))}}},SR={kernelName:Vv,gradFunc:t=>({x:()=>vI(t)})},IR={kernelName:jv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{const e=gI(t,hI(r,"float32")),s=LI(n.shape,a);return s.length>0?zN(yE(e,s),n.shape):e},b:()=>{let e=mI(t,hI(n,"float32"));const s=LI(r.shape,a);s.length>0&&(e=zN(yE(e,s),r.shape));const o=yI(r);return ME(gI(e,hI(o,"float32")))}}}};const NR=gS({rsqrt_:function(t){const e={x:pS(t,"x","rsqrt","float32")};return aS.runKernel($w,e)}}),ER={kernelName:Gv,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?xI(1):i,c=LI(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=_I(a,s),d=mI(t,l),p=NR(pI(o,xI(r))),f=mI(mI(mI(p,p),p),xI(-.5));return{x:()=>1===s.rank?zN(mI(mI(t,lE(zN(p,[1,1,1,s.shape[0]]),u)),l),a.shape):zN(mI(mI(t,p),l),a.shape),mean:()=>{let t=mI(mI(p,xI(-1)),d);return 1===s.rank&&(t=yE(t,c)),zN(t,s.shape)},variance:()=>{let t=mI(mI(f,h),d);return 1===s.rank&&(t=yE(t,c)),zN(t,s.shape)},scale:()=>{const e=mI(h,p);let n=mI(t,e);return 1===s.rank&&(n=yE(n,c)),zN(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=yE(e,c)),zN(e,s.shape)}}}};const CR=gS({unsortedSegmentSum_:function(t,e,n){const r=pS(t,"x","unsortedSegmentSum"),a=pS(e,"segmentIds","unsortedSegmentSum","int32");Jb(ty(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return aS.runKernel(Mx,s,o)}}),TR={kernelName:Hv,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s,batchDims:o}=n,i=sy(s,r.shape)[0],l=(t,e,n)=>()=>{const r=t.shape,a=e.size,o=r.slice(0,i),l=o.length,c=r.slice(s,r.length).slice(1),u=c.length,h=AR(0,l),d=AR(l+1,l+1+u),p=RR([o,[a],c]),f=zN(n,p),g=zN(e,[a]),m=RR([[l],h,d]),b=vC(f,m);let y=CR(b,g,t.shape[i]);const v=EE(m);return y=vC(y,v),y};if(1===o){const e=r.shape[0],n=r.split(e,0);return{x:()=>{const e=uC(n.map(((e,n)=>l(e,a.slice(n,1),t.slice(n,1))())));return e.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,t),indices:()=>a}}};function AR(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function RR(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const FR={kernelName:Xv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>vI(n),b:()=>vI(r)}}},_R={kernelName:Jv,gradFunc:t=>({x:()=>hI(t,"float32")})},DR={kernelName:Qv,gradFunc:t=>({x:()=>vI(t)})},OR={kernelName:$v,gradFunc:t=>({x:()=>vI(t)})},zR={kernelName:tw,gradFunc:t=>({x:()=>vI(t)})},LR={kernelName:ew,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=dE(r,0);return{x:()=>mC(s,t,mI(t,a))}}},MR={kernelName:ow,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,pI(n,1))}}},PR={kernelName:sw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,hI(n,"float32"))}}},BR={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=oE(r);return _I(t,mI(yE(t,a,!0),e))}}}};const WR=gS({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return aS.runKernel(hw,r,a)}}),UR={kernelName:uw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>WR(r,a,t,s,o,i,l)}}};function VR(t,e,n,r){return e.rank<n.rank&&(e=zN(e,SE(e.shape,r))),t.rank<n.rank&&(t=zN(t,SE(t.shape,r))),{x:()=>mI(t,hI(sE(n,e),t.dtype))}}const jR={kernelName:dw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=VR(t,e[1],s,sy(a,s.shape));return{x:()=>o.x()}}},GR={kernelName:pw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mI(t,hI(pE(n,r),"float32")),b:()=>mI(t,hI(hT(n,r),"float32"))}}};const HR=gS({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=pS(t,"dy","maxPool3dGrad"),l=pS(e,"input","maxPool3dGrad"),c=pS(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=zN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=zN(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=zN(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Jb(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Jb(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Jb(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),ON("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=aS.runKernel(bw,f,g);return p?zN(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),KR={kernelName:mw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>HR(t,r,a,s,o,i,l)}}};const qR=gS({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=pS(t,"dy","maxPoolGrad"),l=pS(e,"input","maxPoolGrad"),c=pS(n,"output","maxPoolGrad");Jb(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),Jb(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),Jb(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),ON("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return aS.runKernel(gw,u,h)}}),XR={kernelName:fw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>qR(t,r,a,s,o,i)}}},JR={kernelName:vw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=sy(a,r.shape),o=Qb(kE(r.shape,s)[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=zN(t,e);return gI(mI(n,UE(r.shape,"float32")),o)}}}},YR={kernelName:ww,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=VR(t,o,s,sy(a,s.shape));return{x:()=>i.x()}}},ZR={kernelName:xw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mI(t,hI(iT(n,r),"float32")),b:()=>mI(t,hI(dE(n,r),"float32"))}}},QR={kernelName:kw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>eC(t,s,r.shape)}}},$R={kernelName:Sw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{const e=LI(n.shape,a);return e.length>0?zN(yE(t,e),n.shape):t},b:()=>{const e=mI(t,ME(uE(gI(n,r)))),s=LI(r.shape,a);return s.length>0?zN(yE(e,s),r.shape):e}}}},tF={kernelName:Nw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{const e=mI(t,hI(r,"float32")),s=LI(n.shape,a);return s.length>0?zN(yE(e,s),n.shape):e},b:()=>{const e=mI(t,hI(n,"float32")),s=LI(r.shape,a);return s.length>0?zN(yE(e,s),r.shape):e}}}},eF={kernelName:Ew,gradFunc:t=>({x:()=>ME(t)})},nF={kernelName:_w,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>WE(n.shape,"float32")}}},rF={kernelName:Fw,gradFunc:t=>({x:()=>vI(t)})},aF={kernelName:Dw,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return gC(t,r).map((t=>()=>t))}},sF={kernelName:Ow,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>eC(t,s,r.shape)}}},oF={kernelName:zw,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=MI(s.shape,o.shape);return{a:()=>{const e=hI(o,"float32");let n=mI(t,mI(e,FI(s,_I(e,xI(1)))));const r=LI(s.shape,i);return r.length>0&&(n=yE(n,r)),zN(n,s.shape)},b:()=>{const e=dE(s,0),n=mC(e,gE(s),vI(s));let r=mI(t,mI(a,n));const l=LI(o.shape,i);return l.length>0&&(r=yE(r,l)),zN(r,o.shape)}}}},iF={kernelName:Lw,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=dE(n,0);return{x:()=>mC(a,t,mI(t,r)),alpha:()=>{let e=mC(a,vI(t),mI(t,n));const s=LI(r.shape,t.shape);return s.length>0&&(e=yE(e,s)),zN(e,r.shape)}}}};const lF=gS({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:pS(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return aS.runKernel(bv,a,s)}});function cF(t,e,n){const r=t.shape.length,a=r-n.length,s=NE(n,r);let o=t;null!=s&&(o=vC(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=zN(e,r),s=lF(t,n,!0,!1),o=lF(t,n,!0,!0),i=mI(s,o);return mI(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=EE(s);c=vC(c,t)}return c}const uF={kernelName:Mw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>cF(r,t,s)}}},hF={kernelName:Rv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{const e=gI(t,hI(r,"float32")),s=LI(n.shape,a);return s.length>0?zN(yE(e,s),n.shape):e},b:()=>{let e=mI(t,hI(n,"float32"));const s=LI(r.shape,a);s.length>0&&(e=zN(yE(e,s),r.shape));const o=yI(r);return ME(gI(e,hI(o,"float32")))}}}},dF={kernelName:jw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,ME(yI(n)))}}},pF={kernelName:Yw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=mI(iT(n,6),CC(n));return{x:()=>mI(t,hI(r,"float32"))}}},fF={kernelName:Gw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,hI(CC(n),"float32"))}}},gF={kernelName:Hw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zN(t,n.shape)}}},mF={kernelName:Xw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>aS.runKernel(Jw,a,n)}}},bF={kernelName:Kw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>aS.runKernel(qw,a,n)}}},yF={kernelName:Zw,gradFunc:(t,e,n)=>{const{dims:r}=n,a=sy(r,t.shape);return{x:()=>ZE(t,a)}}},vF={kernelName:Qw,gradFunc:t=>({x:()=>vI(t)})},wF={kernelName:$w,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ME(gI(t,mI(FI(n,1.5),2)))}}};const xF=gS({logicalNot_:function(t){const e={x:pS(t,"x","logicalNot","bool")};return aS.runKernel(lw,e)}}),kF={kernelName:rx,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>hI(vI(n),"float32"),t:()=>mI(t,hI(n,t.dtype)),e:()=>mI(t,hI(xF(n),t.dtype))}}},SF={kernelName:ax,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=dE(n,xI(0)),r=xI(GT),a=xI(HT),s=mI(t,a),o=mI(mI(t,r),oE(hI(n,"float32")));return mC(e,s,o)}}}},IF={kernelName:cx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,mI(n,_I(xI(1),n)))}}},NF={kernelName:lx,gradFunc:t=>({x:()=>vI(t)})};const EF=gS({cos_:function(t){const e={x:pS(t,"x","cos","float32")};return aS.runKernel(gv,e)}}),CF={kernelName:ox,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(EF(hI(n,"float32")),t)}}};const TF=gS({cosh_:function(t){const e={x:pS(t,"x","cosh","float32")};return aS.runKernel(mv,e)}}),AF={kernelName:ix,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(TF(hI(n,"float32")),t)}}},RF={kernelName:sx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=fN(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>jE(t,c)}}},FF={kernelName:gx,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=mI(t,r);return{logits:()=>_I(s,mI(yE(s,[a],true),r))}}},_F={kernelName:ux,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,tC(n))}}};const DF=gS({batchToSpaceND_:function(t,e,n){const r=pS(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));Jb(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),Jb(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),Jb(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return aS.runKernel($y,s,o)}}),OF={kernelName:px,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>DF(t,r,a)}}},zF={kernelName:fx,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>GN(t,r)}}};const LF=[zA,LA,MA,PA,BA,WA,UA,VA,jA,GA,HA,KA,XA,YA,ZA,$A,tR,eR,nR,rR,aR,sR,iR,oR,cR,hR,pR,gR,mR,bR,hF,yR,vR,wR,xR,kR,IR,SR,ER,TR,FR,_R,DR,OR,zR,LR,MR,PR,BR,UR,jR,jR,GR,KR,XR,JR,YR,ZR,QR,$R,tF,eF,nF,rF,aF,sF,sF,oF,iF,uF,dF,pF,fF,gF,mF,bF,yF,vF,wF,kF,SF,IF,NF,CF,AF,RF,FF,_F,OF,OF,zF,zF,{kernelName:hx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,mI(bI(hI(n,"float32")),2))}}},{kernelName:xx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=xI(2);return{a:()=>mI(t,mI(a,_I(n,r))),b:()=>mI(t,mI(a,_I(r,n)))}}},{kernelName:kx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(t,mI(hI(n,"float32"),2))}}},{kernelName:Bx,gradFunc:t=>({x:()=>vI(t)})},{kernelName:Tx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=MI(n.shape,r.shape);return{a:()=>{let e=t;const r=LI(n.shape,a);return r.length>0&&(e=yE(e,r)),zN(e,n.shape)},b:()=>{let e=t;const n=LI(r.shape,a);return n.length>0&&(e=yE(e,n)),zN(ME(e),r.shape)}}}},{kernelName:dx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;sy(s,r.shape).forEach((t=>{a[t]=1}));const o=zN(t,a),i=mI(o,UE(r.shape,"float32"));return{x:()=>i}}},{kernelName:Ax,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>gI(t,yI(EF(n)))}}},{kernelName:Rx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mI(_I(xI(1),yI(n)),t)}}},{kernelName:Fx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=vI(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=pI(e,eC(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=pI(e,eC(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=pI(e,eC(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=pI(e,eC(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Ox,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=EE(a);return{x:()=>vC(t,s)}}},{kernelName:Lx,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>uC(t,a)}}},{kernelName:Mx,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=PI(e,vI(e)),r=hE(t,n);let a=pE(e,xI(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=iE(a,i+1);a=AE(a,UE(r.shape,"bool"));const o=vI(r);return mC(a,r,o)}(t,n)}}},{kernelName:Px,gradFunc:t=>({x:()=>vI(t)})}];for(const n of LF)$x(n);Pk().prototype.abs=function(){return this.throwIfDisposed(),OI(this)};const MF=gS({acos_:function(t){const e={x:pS(t,"x","acos")};return aS.runKernel(zy,e)}});Pk().prototype.acos=function(){return this.throwIfDisposed(),MF(this)};const PF=gS({acosh_:function(t){const e={x:pS(t,"x","acosh")};return aS.runKernel(Ly,e)}});Pk().prototype.acosh=function(){return this.throwIfDisposed(),PF(this)},Pk().prototype.add=function(t){return this.throwIfDisposed(),pI(this,t)},Pk().prototype.all=function(t,e){return this.throwIfDisposed(),bN(this,t,e)},Pk().prototype.any=function(t,e){return this.throwIfDisposed(),yN(this,t,e)},Pk().prototype.argMax=function(t){return this.throwIfDisposed(),vN(this,t)};const BF=gS({argMin_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","argMin")},r={axis:e};return aS.runKernel(Vy,n,r)}});Pk().prototype.argMin=function(t){return this.throwIfDisposed(),BF(this,t)},Pk().prototype.asScalar=function(){return this.throwIfDisposed(),Jb(1===this.size,(()=>"The array must have only 1 element.")),zN(this,[])},Pk().prototype.asType=function(t){return this.throwIfDisposed(),hI(this,t)},Pk().prototype.as1D=function(){return this.throwIfDisposed(),zN(this,[this.size])},Pk().prototype.as2D=function(t,e){return this.throwIfDisposed(),zN(this,[t,e])},Pk().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),zN(this,[t,e,n])},Pk().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),zN(this,[t,e,n,r])},Pk().prototype.as5D=function(t,e,n,r,a){return this.throwIfDisposed(),zN(this,[t,e,n,r,a])};const WF=gS({asin_:function(t){const e={x:pS(t,"x","asin")};return aS.runKernel(jy,e)}});Pk().prototype.asin=function(){return this.throwIfDisposed(),WF(this)};const UF=gS({asinh_:function(t){const e={x:pS(t,"x","asinh")};return aS.runKernel(Gy,e)}});Pk().prototype.asinh=function(){return this.throwIfDisposed(),UF(this)};const VF=gS({atan_:function(t){const e={x:pS(t,"x","atan")};return aS.runKernel(Hy,e)}});Pk().prototype.atan=function(){return this.throwIfDisposed(),VF(this)};const jF=gS({atan2_:function(t,e){let n=pS(t,"a","atan2"),r=pS(e,"b","atan2");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(qy,a)}});Pk().prototype.atan2=function(t){return this.throwIfDisposed(),jF(this,t)};const GF=gS({atanh_:function(t){const e={x:pS(t,"x","atanh")};return aS.runKernel(Ky,e)}});Pk().prototype.atanh=function(){return this.throwIfDisposed(),GF(this)},Pk().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),LN(this,t,e,n,r)},Pk().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),DF(this,t,e)},Pk().prototype.batchNorm=function(t,e,n,r,a){return this.throwIfDisposed(),PN(this,t,e,n,r,a)},Pk().prototype.broadcastTo=function(t){return this.throwIfDisposed(),VN(this,t)},Pk().prototype.cast=function(t){return this.throwIfDisposed(),hI(this,t)};const HF=gS({ceil_:function(t){const e={x:pS(t,"x","ceil","float32")};return aS.runKernel(av,e)}});Pk().prototype.ceil=function(){return this.throwIfDisposed(),HF(this)},Pk().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),jN(this,t,e)},Pk().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Mk&&(t=[t]),GN([this,...t],e)},Pk().prototype.conv1d=function(t,e,n,r,a,s){return this.throwIfDisposed(),YN(this,t,e,n,r,a,s)},Pk().prototype.conv2dTranspose=function(t,e,n,r,a){return this.throwIfDisposed(),QN(this,t,e,n,r,a)},Pk().prototype.conv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),JN(this,t,e,n,r,a,s)},Pk().prototype.cos=function(){return this.throwIfDisposed(),EF(this)},Pk().prototype.cosh=function(){return this.throwIfDisposed(),TF(this)},Pk().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),lF(this,t,e,n)},Pk().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),fR(this,t,e,n)};const KF=gS({depthToSpace_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=pS(t,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];Jb(e>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(e))),Jb(a*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(a," and ").concat(e,"  for depthToSpace with input shape\n    ").concat(r.shape))),Jb(s*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(e," for depthToSpace with input shape\n        ").concat(r.shape))),Jb(o%(e*e)===0,(()=>"Dimension size must be evenly divisible by ".concat(e*e," but is ").concat(o," for depthToSpace with input shape ").concat(r.shape)));const i={x:r},l={blockSize:e,dataFormat:n};return aS.runKernel(xv,i,l)}});Pk().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),KF(this,t,e)},Pk().prototype.depthwiseConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),rE(this,t,e,n,r,a,s)};const qF=gS({dilation2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=pS(t,"x","dilation2d"),i=pS(e,"filter","dilation2d");Jb(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),Jb(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Jb("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let l=o,c=!1;3===o.rank&&(l=zN(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),Jb(l.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(l.shape[3]," vs ").concat(i.shape[2])));const u={x:l,filter:i},h={strides:n,pad:r,dilations:a},d=aS.runKernel(Ev,u,h);return c?zN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});Pk().prototype.dilation2d=function(t,e,n,r,a){return this.throwIfDisposed(),qF(this,t,e,n,r,a)};const XF=gS({divNoNan_:function(t,e){let n=pS(t,"a","div"),r=pS(e,"b","div");[n,r]=Yk(n,r);const a=gI(n,r),s=vI(a),o=sE(r,s);return mC(o,s,a)}});Pk().prototype.divNoNan=function(t){return this.throwIfDisposed(),XF(this,t)},Pk().prototype.div=function(t){return this.throwIfDisposed(),gI(this,t)};const JF=gS({dot_:function(t,e){const n=pS(t,"t1","dot"),r=pS(e,"t2","dot");Jb((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(r.rank,".")));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Jb(a===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(a," and ").concat(s,"."))),1===n.rank&&1===r.rank){const t=zN(n,[1,-1]),e=zN(r,[-1,1]),a=RE(t,e);return zN(a,[])}if(1===n.rank&&2===r.rank){const t=zN(n,[1,-1]),e=zN(r,[r.shape[0],r.shape[1]]),a=RE(t,e);return zN(a,[a.size])}if(2===n.rank&&1===r.rank){const t=zN(r,[-1,1]),e=RE(n,t);return zN(e,[e.size])}{const t=zN(r,[r.shape[0],r.shape[1]]);return RE(n,t)}}});Pk().prototype.dot=function(t){return this.throwIfDisposed(),JF(this,t)},Pk().prototype.elu=function(){return this.throwIfDisposed(),aE(this)},Pk().prototype.equal=function(t){return this.throwIfDisposed(),sE(this,t)};const YF=gS({erf_:function(t){let e=pS(t,"x","erf");Jb("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=hI(e,"float32"));const n={x:e};return aS.runKernel(Ov,n)}});Pk().prototype.erf=function(){return this.throwIfDisposed(),YF(this)};const ZF=gS({euclideanNorm_:function(t){return fT(t,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Pk().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),ZF(this,t,e)},Pk().prototype.exp=function(){return this.throwIfDisposed(),oE(this)},Pk().prototype.expandDims=function(t){return this.throwIfDisposed(),iE(this,t)};const QF=gS({expm1_:function(t){const e={x:pS(t,"x","expm1")};return aS.runKernel(Pv,e)}});Pk().prototype.expm1=function(){return this.throwIfDisposed(),QF(this)},Pk().prototype.fft=function(){return this.throwIfDisposed(),xC(this)},Pk().prototype.flatten=function(){return this.throwIfDisposed(),zN(this,[this.size])},Pk().prototype.floor=function(){return this.throwIfDisposed(),uE(this)},Pk().prototype.floorDiv=function(t){return this.throwIfDisposed(),fI(this,t)},Pk().prototype.gather=function(t,e,n){return this.throwIfDisposed(),hE(this,t,e,n)},Pk().prototype.greaterEqual=function(t){return this.throwIfDisposed(),pE(this,t)},Pk().prototype.greater=function(t){return this.throwIfDisposed(),dE(this,t)},Pk().prototype.ifft=function(){return this.throwIfDisposed(),SC(this)},Pk().prototype.irfft=function(){return this.throwIfDisposed(),IC(this)};const $F=gS({isFinite_:function(t){const e={x:pS(t,"x","isFinite")};return aS.runKernel(Qv,e)}});Pk().prototype.isFinite=function(){return this.throwIfDisposed(),$F(this)};const t_=gS({isInf_:function(t){const e={x:pS(t,"x","isInf")};return aS.runKernel($v,e)}});Pk().prototype.isInf=function(){return this.throwIfDisposed(),t_(this)};const e_=gS({isNaN_:function(t){const e={x:pS(t,"x","isNaN")};return aS.runKernel(tw,e)}});Pk().prototype.isNaN=function(){return this.throwIfDisposed(),e_(this)},Pk().prototype.leakyRelu=function(t){return this.throwIfDisposed(),fE(this,t)},Pk().prototype.lessEqual=function(t){return this.throwIfDisposed(),iT(this,t)},Pk().prototype.less=function(t){return this.throwIfDisposed(),hT(this,t)};const n_=gS({localResponseNormalization_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=pS(t,"x","localResponseNormalization");Jb(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),Jb(ty(e),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(e,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=zN(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:n,alpha:r,beta:a},u=aS.runKernel(uw,l,c);return i?zN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Pk().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),n_(this,t,e,n,r)};const r_=gS({logSigmoid_:function(t){const e=pS(t,"x","logSigmoid");return wI((t=>({value:ME(iC(ME(t))),gradFunc:e=>mI(e,tC(ME(t)))})))(e)}});Pk().prototype.logSigmoid=function(){return this.throwIfDisposed(),r_(this)},Pk().prototype.logSoftmax=function(t){return this.throwIfDisposed(),vE(this,t)},Pk().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),TE(this,t,e)},Pk().prototype.log=function(){return this.throwIfDisposed(),gE(this)},Pk().prototype.log1p=function(){return this.throwIfDisposed(),mE(this)},Pk().prototype.logicalAnd=function(t){return this.throwIfDisposed(),AE(this,t)},Pk().prototype.logicalNot=function(){return this.throwIfDisposed(),xF(this)};const a_=gS({logicalOr_:function(t,e){const n=pS(t,"a","logicalOr","bool"),r=pS(e,"b","logicalOr","bool");MI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(cw,a)}});Pk().prototype.logicalOr=function(t){return this.throwIfDisposed(),a_(this,t)};const s_=gS({logicalXor_:function(t,e){const n=pS(t,"a","logicalXor","bool"),r=pS(e,"b","logicalXor","bool");return MI(n.shape,r.shape),AE(a_(t,e),xF(AE(t,e)))}});Pk().prototype.logicalXor=function(t){return this.throwIfDisposed(),s_(this,t)},Pk().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),RE(this,t,e,n)},Pk().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),FE(this,t,e,n,r)},Pk().prototype.max=function(t,e){return this.throwIfDisposed(),bE(this,t,e)},Pk().prototype.maximum=function(t){return this.throwIfDisposed(),PI(this,t)},Pk().prototype.mean=function(t,e){return this.throwIfDisposed(),DE(this,t,e)},Pk().prototype.min=function(t,e){return this.throwIfDisposed(),OE(this,t,e)},Pk().prototype.minimum=function(t){return this.throwIfDisposed(),zE(this,t)};const o_=gS({mirrorPad_:function(t,e,n){Jb("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const r=pS(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Jb(e.length===r.rank,(()=>"Padding doesn't match input. Must be ".concat(r.rank,". ")+"Got ".concat(e.length,".")));const a="reflect"===n?1:0;for(let i=0;i<r.rank;i++)Jb(2===e[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Jb(e[i][0]>=0&&e[i][0]<=r.shape[i]-a&&e[i][1]>=0&&e[i][1]<=r.shape[i]-a,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(r.shape[i]-a," or less than 0 for input of ")+"shape ".concat(r.shape)));const s={paddings:e,mode:n},o={x:r};return aS.runKernel(kw,o,s)}});Pk().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),o_(this,t,e)};const i_=gS({mod_:function(t,e){let n=pS(t,"a","mod"),r=pS(e,"b","mod");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Sw,a)}});Pk().prototype.mod=function(t){return this.throwIfDisposed(),i_(this,t)},Pk().prototype.mul=function(t){return this.throwIfDisposed(),mI(this,t)},Pk().prototype.neg=function(){return this.throwIfDisposed(),ME(this)},Pk().prototype.norm=function(t,e,n){return this.throwIfDisposed(),fT(this,t,e,n)},Pk().prototype.notEqual=function(t){return this.throwIfDisposed(),PE(this,t)},Pk().prototype.oneHot=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),BE(this,t,e,n)},Pk().prototype.onesLike=function(){return this.throwIfDisposed(),VE(this)},Pk().prototype.pad=function(t,e){return this.throwIfDisposed(),jE(this,t,e)};const l_=gS({pool_:function(t,e,n,r,a,s,o){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=pS(t,"x","maxPool");let l=i,c=!1;3===i.rank&&(c=!0,l=zN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(FN(s,a),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(a,"'")));const u=xN(l.shape,e,s,a,r),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))),r=n.map((t=>t-1)),a=r.map((t=>Math.floor(t/2))),s=r.map(((t,e)=>t-a[e]));return r.map(((t,e)=>[a[e],s[e]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(t,e,n){const r=n.map((t=>t[0])),a=n.map((t=>t[1])),s=t.concat(r,a),o=e.map(((t,e)=>(t-s[e]%t)%t)),i=a.map(((t,e)=>t+o[e])),l=e.map(((t,e)=>[r[e],i[e]])),c=e.map(((t,e)=>[0,o[e]]));return[l,c]}([u.inHeight,u.inWidth],h,d),m=p?r:"valid",b=p?l:QA(l,h,f),y=("avg"===n?()=>LN(b,e,s,m,o):()=>FE(b,e,s,m,o))(),v=p?y:DF(y,h,g);return c?zN(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Pk().prototype.pool=function(t,e,n,r,a,s){return this.throwIfDisposed(),l_(this,t,e,n,r,a,s)},Pk().prototype.pow=function(t){return this.throwIfDisposed(),FI(this,t)},Pk().prototype.prelu=function(t){return this.throwIfDisposed(),GE(this,t)};const c_=gS({prod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=pS(t,"x","prod");"bool"===r.dtype&&(r=hI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return aS.runKernel(Mw,a,s)}});Pk().prototype.prod=function(t,e){return this.throwIfDisposed(),c_(this,t,e)};const u_=gS({reciprocal_:function(t){const e={x:pS(t,"x","reciprocal")};return aS.runKernel(jw,e)}});Pk().prototype.reciprocal=function(){return this.throwIfDisposed(),u_(this)},Pk().prototype.relu=function(){return this.throwIfDisposed(),YE(this)},Pk().prototype.relu6=function(){return this.throwIfDisposed(),EC(this)},Pk().prototype.reshapeAs=function(t){return this.throwIfDisposed(),zN(this,t.shape)},Pk().prototype.reshape=function(t){return this.throwIfDisposed(),zN(this,t)},Pk().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),aT(this,t,e,n)},Pk().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),sT(this,t,e,n)},Pk().prototype.reverse=function(t){return this.throwIfDisposed(),ZE(this,t)},Pk().prototype.rfft=function(){return this.throwIfDisposed(),kC(this)},Pk().prototype.round=function(){return this.throwIfDisposed(),lT(this)},Pk().prototype.rsqrt=function(){return this.throwIfDisposed(),NR(this)},Pk().prototype.selu=function(){return this.throwIfDisposed(),QE(this)},Pk().prototype.separableConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),$E(this,t,e,n,r,a,s)},Pk().prototype.sigmoid=function(){return this.throwIfDisposed(),tC(this)};const h_=gS({sign_:function(t){const e={x:pS(t,"x","sign")};return aS.runKernel(lx,e)}});Pk().prototype.sign=function(){return this.throwIfDisposed(),h_(this)},Pk().prototype.sin=function(){return this.throwIfDisposed(),uR(this)},Pk().prototype.sinh=function(){return this.throwIfDisposed(),dR(this)},Pk().prototype.slice=function(t,e){return this.throwIfDisposed(),eC(this,t,e)},Pk().prototype.softmax=function(t){return this.throwIfDisposed(),oC(this,t)},Pk().prototype.softplus=function(){return this.throwIfDisposed(),iC(this)},Pk().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),QA(this,t,e)},Pk().prototype.split=function(t,e){return this.throwIfDisposed(),lC(this,t,e)},Pk().prototype.sqrt=function(){return this.throwIfDisposed(),bI(this)},Pk().prototype.square=function(){return this.throwIfDisposed(),yI(this)},Pk().prototype.squaredDifference=function(t){return this.throwIfDisposed(),vT(this,t)},Pk().prototype.squeeze=function(t){return this.throwIfDisposed(),cC(this,t)},Pk().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Mk?[this,t]:[this,...t];return uC(n,e)},Pk().prototype.step=function(t){return this.throwIfDisposed(),CC(this,t)};const d_=gS({stridedSlice_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const c={x:pS(t,"x","stridedSlice","string_or_numeric")},u={begin:e,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};return aS.runKernel(Ix,c,u)}});Pk().prototype.stridedSlice=function(t,e,n,r,a,s,o,i){return this.throwIfDisposed(),d_(this,t,e,n,r,a,s,o,i)},Pk().prototype.sub=function(t){return this.throwIfDisposed(),_I(this,t)},Pk().prototype.sum=function(t,e){return this.throwIfDisposed(),yE(this,t,e)};const p_=gS({tan_:function(t){const e={x:pS(t,"x","tan","float32")};return aS.runKernel(Ax,e)}});Pk().prototype.tan=function(){return this.throwIfDisposed(),p_(this)},Pk().prototype.tanh=function(){return this.throwIfDisposed(),hC(this)},Pk().prototype.tile=function(t){return this.throwIfDisposed(),lE(this,t)},Pk().prototype.toBool=function(){return this.throwIfDisposed(),hI(this,"bool")},Pk().prototype.toFloat=function(){return this.throwIfDisposed(),hI(this,"float32")},Pk().prototype.toInt=function(){return this.throwIfDisposed(),hI(this,"int32")};const f_=gS({topk_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=pS(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(e<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(e));if(e>a)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a,") ")+"but got ".concat(e));const s={x:r},o={k:e,sorted:n},[i,l]=aS.runKernel(_x,s,o);return{values:i,indices:l}}});Pk().prototype.topk=function(t,e){return this.throwIfDisposed(),f_(this,t,e)},Pk().prototype.transpose=function(t){return this.throwIfDisposed(),vC(this,t)};const g_=gS({unique_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","unique","string_or_numeric");Jb(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:e},[s,o]=aS.runKernel(zx,r,a);return{values:s,indices:o}}});Pk().prototype.unique=function(t){return this.throwIfDisposed(),g_(this,t)},Pk().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),CR(this,t,e)},Pk().prototype.unstack=function(t){return this.throwIfDisposed(),gC(this,t)},Pk().prototype.where=function(t,e){return this.throwIfDisposed(),mC(t,this,e)},Pk().prototype.zerosLike=function(){return this.throwIfDisposed(),vI(this)};class m_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,m_.prototype)}}class b_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,b_.prototype)}}class y_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,y_.prototype)}}class v_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,v_.prototype)}}class w_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,w_.prototype)}}Error;class x_{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function k_(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function S_(t,e){if(!t)throw new w_(e)}function I_(t,e){let n=0;for(const r of t)r===e&&n++;return n}function N_(t){return 1===t.length?t[0]:t}function E_(t){return Array.isArray(t)?t:[t]}function C_(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function T_(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let A_={};function R_(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function F_(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>F_(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?F_(e):t[n]=e.value)}}}function __(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in A_)s=A_[a];else if(s=e[a],null==s)throw new y_("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new y_("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in A_?[i,l]=A_.className:o in e&&([i,l]=e[o]),null==i)throw new y_("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(A_))t[n]=A_[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},A_);for(const a of Object.keys(n))A_[a]=n[a];F_(s.config);const r=l(i,s.config,n,a);return A_=Object.assign({},e),r}{const t=Object.assign({},A_);for(const r of Object.keys(n))A_[r]=n[r];const e=new i(s.config);return A_=Object.assign({},t),e}}}function D_(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function O_(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function z_(t){if(null==t)throw new y_("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function L_(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new y_("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function M_(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return S_(n>=0),S_(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function P_(t,e){Array.isArray(t)?(Jb(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>P_(t,"element ".concat(n+1," of ").concat(e))))):Jb(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(B_(t),".")))}function B_(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>B_(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function W_(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let U_=0;function V_(){return U_++}const j_={};function G_(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in j_||(j_[t]=0),j_[t]+=1,t+j_[t].toString()}const H_=["channelsFirst","channelsLast"],K_=["nearest","bilinear"],q_=["valid","same","causal"],X_=["max","avg"],J_=["sum","mul","concat","ave"],Y_=new Map;function Z_(t){L_(H_,"DataFormat",t)}function Q_(t){L_(q_,"PaddingMode",t)}function $_(t){L_(X_,"PoolMode",t)}const tD=[],eD="/";function nD(t,e){tD.push(t);try{const t=e();return tD.pop(),t}catch(d1){throw tD.pop(),d1}}function rD(t){if(!oD(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===tD.length?"":tD.join(eD)+eD)+t}function aD(t){if(!oD(t))throw new Error("Not a valid tensor name: '"+t+"'");Y_.has(t)||Y_.set(t,0);const e=Y_.get(t);if(Y_.set(t,Y_.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return Y_.set(n,1),n}return t}const sD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function oD(t){return!!t.match(sD)}function iD(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function lD(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function cD(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function uD(t,e){if(e<t)throw new y_("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let hD;function dD(){return null==hD&&(hD=ES().epsilon()),hD}function pD(t,e){return hI(t,e)}function fD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),zN(t,n)}function gD(t,e,n){return kS((()=>{switch(t.rank){case 1:return nC(t,e,n);case 2:return rC(t,[e,0],[n,t.shape[1]]);case 3:return aC(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return sC(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return eC(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return eC(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new y_("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function mD(t,e,n){return kS((()=>{switch(t.rank){case 1:return nC(t,e,n);case 2:return rC(t,[0,e],[t.shape[0],n]);case 3:return aC(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return sC(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new y_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function bD(t,e,n,r){return kS((()=>{switch(t.rank){case 1:return nC(t,e,n);case 2:switch(r){case 1:return gD(t,e,n);case 2:return mD(t,e,n);default:throw new y_("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return gD(t,e,n);case 2:return aC(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return mD(t,e,n);default:throw new y_("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return gD(t,e,n);case 2:return sC(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return sC(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return mD(t,e,n);default:throw new y_("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new y_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function yD(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),GN(t,n)}function vD(t,e){switch(t.rank){case 1:return HN([t,e]);case 2:return KN([t,e],0);case 3:return qN([t,e],0);case 4:return XN([t,e],0);default:throw new y_("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function wD(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new y_("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return lE(t,e)}function xD(t){return qE(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function kD(t,e,n,r){if(t.rank<2||e.rank<2)throw new v_("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new v_("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return zC({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?ND(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=zN(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=zN(vC(e,u),[l,-1]);const h=[...a,...c];return zN(zC({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?ND(t.rank,r,"channelsLast"):null,activation:n}),h)}}function SD(t,e,n){return kS((()=>(e=Array.isArray(e)?dC(e,"int32"):hI(e,"int32"),hE(t,e,n))))}function ID(t){return mI(t,t)}function ND(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new y_("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?zN(e,[1,r[0],1,1,1]):zN(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?zN(e,[1,1,1,1,r[0]]):zN(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?zN(e,[1,r[0],1,1]):zN(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?zN(e,[1,1,1,r[0]]):zN(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?zN(e,[1,r[0],1]):zN(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?zN(e,[1,1,r[0]]):zN(e,[1].concat(r))}else if(t<3)return e;throw new y_("Unsupported input rank by biasAdd: ".concat(e.rank))}function ED(t,e,n){return kS((()=>(null==n&&(n="channelsLast"),Z_(n),pI(t,ND(t.rank,e,n)))))}function CD(t,e,n,r){return kS((()=>wC(t,e,n,r)))}function TD(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const AD=["fanIn","fanOut","fanAvg"],RD=["normal","uniform","truncatedNormal"];class FD extends II{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _D extends FD{apply(t,e){return WE(t,e)}}_D.className="Zeros",EI(_D);class DD extends FD{apply(t,e){return UE(t,e)}}DD.className="Ones",EI(DD);class OD extends FD{constructor(t){if(super(),"object"!==typeof t)throw new y_("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new y_("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return kS((()=>mI(xI(this.value),UE(t,e))))}getConfig(){return{value:this.value}}}OD.className="Constant",EI(OD);class zD extends FD{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return XE(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}zD.className="RandomUniform",EI(zD);class LD extends FD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new v_("randomNormal does not support dType ".concat(e,"."));return xD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LD.className="RandomNormal",EI(LD);class MD extends FD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new v_("truncatedNormal does not support dType ".concat(e,"."));return fC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}MD.className="TruncatedNormal",EI(MD);class PD extends FD{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return kS((()=>{if(2!==t.length||t[0]!==t[1])throw new y_("Identity matrix initializer can only be used for 2D square matrices.");return mI(this.gain,cE(t[0]))}))}getConfig(){return{gain:this.gain}}}PD.className="Identity",EI(PD);class BD extends FD{constructor(t){if(super(),t.scale<0)throw new y_("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,L_(AD,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){L_(RD,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Z_(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=iD(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=iD(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=iD(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new v_("".concat(this.getClassName()," does not support dType ").concat(e,"."));return fC(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return XE(t,-n,n,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}BD.className="VarianceScaling",EI(BD);class WD extends BD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return BD.className}}WD.className="GlorotUniform",EI(WD);class UD extends BD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return BD.className}}UD.className="GlorotNormal",EI(UD);class VD extends BD{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return BD.className}}VD.className="HeNormal",EI(VD);class jD extends BD{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return BD.className}}jD.className="HeUniform",EI(jD);class GD extends BD{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return BD.className}}GD.className="LeCunNormal",EI(GD);class HD extends BD{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return BD.className}}HD.className="LeCunUniform",EI(HD);class KD extends FD{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return kS((()=>{if(t.length<2)throw new v_("Shape must be at least 2D.");if("int32"!==e&&"float32"!==e&&void 0!==e)throw new TypeError("Unsupported data type ".concat(e,"."));const n=Qb(t.slice(0,-1)),r=t[t.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(a,") elements: ")+"Slowness may result.");const s=xD([Math.max(r,n),Math.min(r,n)],0,1,e,this.seed),o=xT.qr(s,!1);let i=o[0];const l=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return i=mI(i,l.sign()),n<r&&(i=i.transpose()),mI(xI(this.gain),i.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}KD.className="Orthogonal",EI(KD);const qD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function XD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return __(t,NI.getMap().classNameMap,e,"initializer")}function JD(t){return R_(t)}function YD(t){if("string"===typeof t){const e=t in qD?qD[t]:t;if("GlorotNormal"===e)return new UD;if("GlorotUniform"===e)return new WD;if("HeNormal"===e)return new VD;if("HeUniform"===e)return new jD;if("LeCunNormal"===e)return new GD;if("LeCunUniform"===e)return new HD;{const t={};return t.className=e,t.config={},XD(t)}}return t instanceof FD?t:XD(t)}function ZD(t){return Array.isArray(t)&&Array.isArray(t[0])}function QD(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function $D(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new y_("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function tO(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new y_("Expected exactly 1 Shape; got ".concat(t.length))}return t}function eO(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const nO="Variable";class rO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:nO,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=V_(),n=null==n?nO:n,this.originalName=rD(n),this.name=aD(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return aS.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function aO(t){return t.map((t=>t.read()))}function sO(t){t.forEach((t=>{t[0].write(t[1])}))}class oO{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class iO{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=V_(),null!=s&&(this.originalName=rD(s),this.name=aD(this.originalName)),this.rank=e.length}}let lO=0;class cO{constructor(t,e){this.callArgs=e,this.id=lO++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let uO=0;class hO extends II{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=uO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=C_(t)+"_"+G_(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new b_("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new y_("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return N_(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return N_(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new m_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new m_("Layer ".concat(this.name)+" is not connected, no input to return.");return N_(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new m_("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new m_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return N_(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=E_(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=E_(this.inputSpec);if(e.length!==n.length)throw new y_("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(e.length," input tensors. ")+"Input received: ".concat(t));for(let r=0;r<e.length;r++){const t=e[r],a=n[r];if(null==a)continue;const s=t.rank;if(null!=a.ndim&&s!==a.ndim)throw new y_("Input ".concat(r," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new y_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new y_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&t.dtype!==a.dtype)throw new y_("Input ".concat(r," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(t.dtype,"."));if(a.axes){const e=t.shape;for(const t in a.axes){const n=Number(t),s=a.axes[t],o=n>=0?e[n]:e[e.length+n];if(null!=s&&-1===[s,null].indexOf(o))throw new y_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(s," but got shape ").concat(e,"."))}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){const n=a.shape[e],s=t.shape[e];if(null!=n&&null!=s&&n!==s)throw new y_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(t.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=E_(t),r=function(t){let e=!0;for(const n of E_(t))if(!(n instanceof iO)){e=!1;break}return e}(t),a=function(t){let e=!0;for(const n of E_(t))if(n instanceof iO){e=!1;break}return e}(t);if(r===a)throw new y_("Arguments to apply() must be all SymbolicTensors or all Tensors");return nD(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of E_(t))e.push(n.shape);this.build(N_(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,r);const a=E_(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=N_(s),null!=this.activityRegularizer)throw new v_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=E_(t);const e=[];for(const n of t)e.push(n.shape);return N_(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new iO(s,n,this,E_(t),e,this.name,r))):new iO(s,r,this,E_(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new v_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new m_("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new m_("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new b_("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return eO(this.weights)}build(t){this.built=!0}getWeights(){return aO(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){kS((()=>{const e=this.weights;if(e.length!==t.length)throw new y_('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=aO(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!$b(s.shape,i.shape))throw new y_("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}sO(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new y_("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():YD("zeros"));const l=r.apply(e,n),c=new rO(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=E_(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const r=this.computeMask(t,n),a=E_(e),s=E_(r);if(a.length!==s.length)throw new Error("".concat(this.name," outputs ").concat(a.length," tensors ")+"but ".concat(a.length," masks for those tensors"));for(let o=0;o<a.length;o++)a[o].kerasMask=s[o]}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=E_(t);e=E_(e),n=E_(n),r=E_(r),a=QD(a),s=QD(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new cO({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function dO(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=dO(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class pO extends hO{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:G_("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new y_("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new y_("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new y_("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new iO(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new cO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new y_("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}pO.className="InputLayer",EI(pO);class fO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof fO)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new y_("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return hI(e,t.dtype)}catch(p1){throw new y_("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof iO){if(null==this.id2Value[t.id])throw new y_("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new y_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof iO){if(null==this.id2Value[t.id])throw new y_("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new y_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&SS(this.id2Mask)}}const gO=new x_,mO=new x_;function bO(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=gO.get(u);if(null==d){const t=function(t,e){Jb(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=vO(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=vO(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:yO(r)}}(o,e);d=t.sorted,h=t.recipientCounts,gO.put(u,d),mO.put(u,h)}h={},a||Object.assign(h,mO.get(u));const p=new fO(e);for(let f=0;f<d.length;++f){if(null!=r){const t=xS().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof pO)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=E_(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=wO(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||SS(u)}return p.disposeMasks(),s?l:l[0]}function yO(t){const e={};for(const n in t)e[n]=t[n].size;return e}function vO(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function wO(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}function xO(t,e){return kS((()=>bI(yE(mI(t,t),e,!0))))}Ay().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=gO&&gO.setMaxEntries(t),null!=mO&&mO.setMaxEntries(t)}));class kO extends II{getConfig(){return{}}}class SO extends kO{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return kS((()=>{const e=xO(t,this.axis),n=jN(e,0,this.maxValue);return mI(t,gI(n,pI(dD(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}SO.className="MaxNorm",EI(SO);class IO extends kO{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return kS((()=>gI(t,pI(dD(),xO(t,this.axis)))))}getConfig(){return{axis:this.axis}}}IO.className="UnitNorm",EI(IO);class NO extends kO{apply(t){return YE(t)}}NO.className="NonNeg",EI(NO);class EO extends kO{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return kS((()=>{const e=xO(t,this.axis),n=pI(mI(this.rate,jN(e,this.minValue,this.maxValue)),mI(1-this.rate,e));return mI(t,gI(n,pI(dD(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}EO.className="MinMaxNorm",EI(EO);const CO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function TO(t){return R_(t)}function AO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return __(t,NI.getMap().classNameMap,e,"constraint")}function RO(t){if(null==t)return null;if("string"===typeof t){return AO({className:t in CO?CO[t]:t,config:{}})}return t instanceof kO?t:AO(t)}async function FO(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];SS(r)}}function _O(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var DO;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(DO||(DO={}));class OO{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class zO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class LO extends OO{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=kS((()=>pI(this.totals[r],mI(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:kS((()=>{const t=mI(gI(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),IS(e[n])})))}}class MO extends OO{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class PO extends OO{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||IT,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");dy(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():bk();return function(){const s=null!=n?n():bk();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await FO(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await FO(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await FO(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await FO(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await FO(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):dy(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await FO(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await FO(t),await this.trainEnd(t))}}function BO(t,e){if(null==t&&(t={}),t instanceof OO)return[t];if(Array.isArray(t)&&t[0]instanceof OO)return t;return E_(t).map((t=>new PO(t,e)))}class WO{constructor(){}static registerCallbackConstructor(t,e){Jb(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),WO.checkForDuplicate(e),null==WO.constructors[t]&&(WO.constructors[t]=[]),WO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in WO.constructors){WO.constructors[+e].forEach((e=>{if(e===t)throw new y_("Duplicate callback constructor.")}))}}static clear(){WO.constructors={}}static createCallbacks(t){const e=[];for(const n in WO.constructors){const r=+n;t>=r&&e.push(...WO.constructors[r])}return e.map((t=>new t))}}function UO(t,e,n,r,a,s,o,i,l){const c=new MO,u=[new LO,...WO.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new zO(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function VO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return __(t,NI.getMap().classNameMap,e,"layer",n)}function jO(t,e){return kS((()=>{"float32"!==t.dtype&&(t=hI(t,"float32"));const n=yE(ID(t),e,!0),r=AI(n.shape,dD()),a=bI(PI(n,r));return gI(t,a)}))}function GO(t,e){return kS((()=>DE(ID(_I(e,t)),-1)))}function HO(t,e){return kS((()=>DE(OI(_I(e,t)),-1)))}function KO(t,e){return kS((()=>{const n=_I(t,e),r=jN(OI(t),dD(),Number.MAX_VALUE),a=OI(gI(n,r));return mI(100,DE(a,-1))}))}function qO(t,e){return kS((()=>{const n=jN(e,dD(),Number.MAX_VALUE),r=gE(pI(1,n)),a=jN(t,dD(),Number.MAX_VALUE),s=gE(pI(1,a));return DE(ID(_I(r,s)),-1)}))}function XO(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return kS((()=>{if(n)e=oC(e);else{const t=yE(e,e.shape.length-1,!0);e=gI(e,t)}return e=jN(e,dD(),1-dD()),ME(yE(mI(hI(t,"float32"),gE(e)),e.shape.length-1))}))}function JO(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return kS((()=>{const r=hI(uE(function(t){const e=[iD(t.shape)];return zN(t,e)}(t)),"int32"),a=(e=jN(e,dD(),1-dD())).shape;return XO(zN(BE(r,a[a.length-1]),a),e,n)}))}function YO(t,e){return kS((()=>{let n;return n=jN(e,dD(),1-dD()),n=gE(gI(n,_I(1,n))),DE(function(t,e){if(!$b(t.shape,e.shape))throw new y_("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return kS((()=>{const n=YE(e),r=ME(OI(e));return pI(_I(n,mI(e,t)),mE(oE(r)))}))}(t,n),-1)}))}function ZO(t,e){return kS((()=>{const n=jN(t,dD(),1),r=jN(e,dD(),1);return yE(mI(t,gE(gI(n,r))),-1)}))}function QO(t,e){return kS((()=>{const n=jO(t,-1),r=jO(e,-1),a=mI(n,r);return ME(yE(a,-1))}))}WO.constructors={};const $O={meanSquaredError:GO,meanAbsoluteError:HO,meanAbsolutePercentageError:KO,meanSquaredLogarithmicError:qO,squaredHinge:function(t,e){return kS((()=>{const n=PI(0,_I(1,mI(t,e)));return DE(ID(n),-1)}))},hinge:function(t,e){return kS((()=>{const n=PI(0,_I(1,mI(t,e)));return DE(n,-1)}))},categoricalHinge:function(t,e){return kS((()=>{const n=yE(mI(t,e),-1),r=bE(mI(_I(1,t),e),-1);return PI(0,pI(1,_I(r,n)))}))},logcosh:function(t,e){return kS((()=>{const n=Math.log(2),r=_I(e,t),a=_I(pI(r,iC(mI(-2,r))),n);return DE(a,-1)}))},categoricalCrossentropy:XO,sparseCategoricalCrossentropy:JO,binaryCrossentropy:YO,kullbackLeiblerDivergence:ZO,poisson:function(t,e){return kS((()=>{const n=gE(pI(dD(),e));return DE(_I(e,mI(t,n)),-1)}))},cosineProximity:QO};function tz(t){if("string"===typeof t){if(t in $O)return $O[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new y_(e)}return t}function ez(t,e){return kS((()=>{const n=mI(.5,VE(e)),r=pD(dE(e,n),t.dtype);return DE(sE(t,r),-1)}))}function nz(t,e){return kS((()=>pD(sE(vN(t,-1),vN(e,-1)),"float32")))}function rz(t,e){return kS((()=>hI(yE(AE(sE(t,1),sE(e,1))),"float32")))}function az(t,e){return YO(t,e)}function sz(t,e){return t.rank===e.rank&&(t=cC(t,[t.rank-1])),(e=vN(e,-1)).dtype!==t.dtype&&(e=hI(e,t.dtype)),hI(sE(t,e),"float32")}const oz=XO,iz=JO,lz={binaryAccuracy:ez,categoricalAccuracy:nz,precision:function(t,e){return kS((()=>{const n=rz(t,e),r=function(t,e){return kS((()=>hI(yE(AE(sE(t,0),sE(e,1))),"float32")))}(t,e),a=pI(n,r);return hI(mC(dE(a,0),gI(n,a),0),"float32")}))},categoricalCrossentropy:oz,sparseCategoricalCrossentropy:iz,mse:GO,MSE:GO,mae:HO,MAE:HO,mape:KO,MAPE:KO,cosine:QO};function cz(t){if("string"===typeof t&&t in lz)return lz[t];if("string"!==typeof t&&null!=t)return t;throw new y_("Unknown metric ".concat(t))}function uz(t){if(S_(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys($O))if($O[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(lz))if(lz[n]===t){e=n;break}return void 0!==e?e:t.name}}const hz=1048576;function dz(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!pz(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>hz&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(hz,"."))}}function pz(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!pz(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!pz(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function fz(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),gz(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?mz(i[u],n,r):bz(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?eO(t.collectedTrainableWeights):eO(t.trainableWeights);return e}(t),c=eO(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function gz(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function mz(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(p1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(p1){r="multiple"}const s=t.name,o=t.getClassName();gz(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function bz(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(p1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(p1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];gz(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)gz(["","","","",o[u]],e,r)}function yz(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function vz(t,e){if(null===t)return null;if("string"===typeof t)return T_(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];yz(e,a,r)?n.push(r):n.push(vz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=T_(n);e[t]=vz(r,t)}}return e}}function wz(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return C_(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];yz(e,a,r)?n.push(r):n.push(wz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=C_(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?wz(r,n):r}return e}}const xz="4.17.0";class kz extends hO{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=G_(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],O_(this.inputs).length!==this.inputs.length)throw new y_("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));O_(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;S_(0===e,"input layer has >1 nodes"),S_(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof pO))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new b_("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(kz.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(D_);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof kz&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(D_);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new b_("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new b_('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new cO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new y_("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(t=>{const e=Object.keys(t);if(0===e.length)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[t,e]of o.weights.entries()){const s=a?"".concat(e.name.split("/").slice(0,-1).join("/")+"/").concat(t):e.originalName;if(null!=n[s])throw new y_("Duplicate weight name: ".concat(s));n[s]=e,r++}const s=[];for(const o in t){let r=o;if(null==n[o]){const t=o.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[o]]);else if(e)throw new y_("Provided weight data has no target variable: ".concat(o));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new y_("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}sO(s)}parseWeights(t){for(const e in Object.keys(t)){const n=e.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((t=>t.startsWith("_")?t.slice(1):t)).filter((t=>!r.includes(t))).join("/");a!==e&&(t[a]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(xz),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=wz(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return kS((()=>{t=E_(t);const n=new fO;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return bO(this.outputs,n,e)}))}computeMask(t,e){return kS((()=>{let n;return t=E_(t),n=null==e?k_(null,t.length):E_(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=QD(t);if(e.length!==this.inputLayers.length)throw new y_("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(D_);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=QD(t.computeOutputShape(N_(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];S_(t in n),a.push(n[t])}return N_(a)}runInternalGraph(t,e){null==e&&(e=k_(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(D_);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=E_(t.call(e,c)),l=E_(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=E_(t.call(r,c)),l=E_(t.computeMask(r,o));if(t.activityRegularizer)throw new v_("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){S_(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof kz?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=kz.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new y_("Provide either a layer name or layer index");if("number"===typeof t)return this.findLayer(t);for(const n of this.layers)if(n.name===t)return n;throw new y_("No such layer: ".concat(t))}findLayer(t){if(this.layers.length<=t)throw new y_("Was asked to retrieve layer at index ".concat(t,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[t]}calculateLosses(){return kS((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=kz.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=kz.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(p1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[kz.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=kz.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=kz.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(N_(n),a)}function i(t){const a=t.name,o=VO(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new y_("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!z_(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];S_(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];S_(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new y_("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){kS((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function Sz(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Iz(t,e){return Sz(t,e,"classWeight")}async function Nz(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=kS((()=>{if(1===t.shape.length)return dI(t);if(2===t.shape.length){if(t.shape[1]>1){return vN(t,1)}if(1===t.shape[1])return zN(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());SS(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),dC(a,"float32")}return null}function Ez(t,e){return mI(t,e)}function Cz(t,e){let n,r;const a=e;n=a.xs,r=a.ys,Jb(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=Tz("input",t.inputNames,n),o=Tz("output",t.outputNames,r),i=s[0].shape[0];Jb(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),Jb(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)Jb(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)Jb(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function Tz(t,e,n){if(n instanceof Mk)return[n];if(Array.isArray(n))return Jb(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new y_("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function Az(t,e,n){const r=null!=n.batchesPerEpoch;if(Jb(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Jb(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Jb(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Jb(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Jb(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(Rz(n.validationData))Jb(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new v_("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=BO(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=UO(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=Cz(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Iz(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Nz(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);SS(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,IS(n)}await d.onBatchEnd(h,s),_O(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=Rz(n.validationData)?E_(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):E_(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Rz(t){return"function"===typeof t.iterator}function Fz(t){Jb(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function _z(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>gD(t,e,n-e))):gD(t,e,n-e)}function Dz(t,e){return kS((()=>null==t?null:Array.isArray(t)?t.map((t=>Dz(t,e))):SD(t,"int32"===e.dtype?e:hI(e,"int32"))))}function Oz(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}function zz(t){const e=[];t instanceof Mk&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(fD(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Lz(t,e){if(null==t)return;const n=[];if(e instanceof Mk)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Mk)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Mz(t){return Array.isArray(t)}function Pz(t){return!function(t){return t instanceof Mk}(t)&&!Mz(t)}function Bz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Mz(t)&&t.length>0)e=!0;else if(Pz(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new y_("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(Pz(t)){r=[];for(const n of e){if(null==t[n])throw new y_('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Mz(t)){if(t.length!==e.length)throw new y_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new y_("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=zz(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new y_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new y_("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function Wz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new y_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new y_("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new y_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new y_("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class Uz extends kz{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new y_("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");fz(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>kT.adagrad(.01),Adadelta:()=>kT.adadelta(1,.95,dD()),Adam:()=>kT.adam(.001,.9,.999,dD()),Adamax:()=>kT.adamax(.002,.9,.999,dD(),0),RMSProp:()=>kT.rmsprop(.001,.9,0,dD()),SGD:()=>kT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new y_("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof CI))throw new y_("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new y_("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>tz(t)))}else{const n=tz(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new y_('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push(tz(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nD("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};nD("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===YO?-1!==["accuracy","acc"].indexOf(o)?r=ez:-1!==["crossentropy","ce"].indexOf(o)&&(r=az):this.lossFunctions[t]===JO?-1!==["accuracy","acc"].indexOf(o)?r=sz:-1!==["crossentropy","ce"].indexOf(o)&&(r=iz):-1!==["accuracy","acc"].indexOf(o)?r=nz:-1!==["crossentropy","ce"].indexOf(o)&&(r=oz),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=cz(o);s=t,n=""+uz(o)}let e;nD(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Fz(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return N_(this.testLoop(e,t,r,n.verbose,n.steps))}finally{Lz(a[0],t),Lz(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new v_("Verbose mode is not implemented yet.");Jb(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=kS((()=>{if(e.value){const{xs:n,ys:r}=Cz(t,e.value),o=n.concat(r),c=kS((()=>a(o)));if(SS(o),0===l)for(let t=0;t<c.length;++t)s.push(xI(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=kS((()=>pI(s[t],mI(u,e)))),l>0&&SS(n)}SS(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=gI(s[c],i),SS(t)}return N_(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new y_("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new y_("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new y_("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new fO;if(t instanceof Mk&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new y_("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new y_("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=bO(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=k_(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new y_("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return kS((()=>{const r=this.checkNumSamples(t);if(n)throw new v_("Verbose predictLoop() is not implemented yet.");const a=Oz(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){kS((()=>{const n=a[e][0],r=a[e][1],s=_z(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new fO(o);return bO(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return N_(s.map((t=>GN(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=zz(t);Wz(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return Fz(t),this.predictLoop(n,t)}finally{Lz(n,t)}}predictOnBatch(t){Wz(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new b_("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===JO?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=O_(t.map((t=>t.shape[0])));r.sort();const a=O_(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new y_("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new y_("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!$b(r,a))throw new y_("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=Bz(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Bz(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[GO,YO,XO];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===XO&&1===s.shape[s.shape.length-1])throw new y_("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new y_("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new y_("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Iz(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Nz(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return kS((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new v_("Verbose mode is not implemented yet.");if(null!=a)throw new v_("steps mode in testLoop() is not implemented yet");{const r=Oz(s,n),a=dC(uD(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=gD(a,s,i-s),c=Dz(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(xI(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=pI(o[t],mI(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=gI(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(I_(t,r)>1){const e=I_(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new fO(t),i=bO(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=Ez(t,a[n]));const s=DE(t);e.push(s),l=0===n?t:pI(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=DE(e(r[a],i[a]))}IS(t),s.push(t)}return l=DE(l),this.calculateLosses().forEach((t=>{l=pI(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>kS((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new fO(s),i=bO(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=DE(r(a[t],i[t]));n=0===t?s:pI(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=DE(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){let n,r,a,s,o,i,l,c,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;Fz(d);const p=!1,f=await this.standardizeUserData(t,e,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],u=f[2];let g,m=!1;if(null!=h.validationData&&h.validationData.length>0){if(m=!0,2!==h.validationData.length)throw 3===h.validationData.length?new v_("validationData including sample weights is not supported yet."):new y_("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));o=h.validationData[0],i=h.validationData[1];const t=!0,e=await this.standardizeUserData(o,i,null,null,t,d);l=e[0],c=e[1],g=l.concat(c)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){m=!0;const t=Math.floor(n[0].shape[0]*(1-h.validationSplit)),e=n[0].shape[0];l=_z(n,t,e),a=n,n=_z(n,0,t),c=_z(r,t,e),s=r,r=_z(r,0,t),g=l.concat(c)}else null!=h.validationSteps&&(m=!0);const b=n.concat(r).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,x;m?(this.makeTestFunction(),w=this.testFunction,x=v.slice().concat(v.map((t=>"val_"+t)))):(w=null,g=[],x=v.slice());const k=BO(h.callbacks,h.yieldEvery);return await this.fitLoop(y,b,v,d,h.epochs,h.verbose,k,w,g,h.shuffle,x,h.initialEpoch,null,null)}finally{this.isTraining=!1,Lz(n,t),Lz(r,e),Lz(a,t),Lz(s,e),Lz(l,o),Lz(c,i),null!=u&&SS(u)}}async fitLoop(t,e,n,r,a,s,o,i,l,c,u,h,d,p){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0);let f=!1;if(null!=i&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new y_("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(e,r,d,"steps_per_epoch");let m;null!=g&&(m=uD(0,g)),null==s&&(s=1);const{callbackList:b,history:y}=UO(o,s,a,h,g,d,r,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<a;++v){await b.onEpochBegin(v);const a={};if(null!=d)throw new v_("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new v_("batch shuffling is not implemneted yet");c&&Hb(m);const s=dC(m),o=Oz(g,r);for(let c=0;c<o.length;++c){const u={};if(await b.onBatchBegin(c,u),kS((()=>{const h=o[c][0],d=o[c][1],p=gD(s,h,d-h);u.batch=c,u.size=d-h;const g=Dz(e,p),m=t(g);for(let t=0;t<n.length;++t){const e=n[t],r=m[t];u[e]=r,IS(r)}if(c===o.length-1&&f){const t=this.testLoop(i,l,r);for(let e=0;e<n.length;++e){const r=n[e],s=t[e];IS(s),a["val_"+r]=s}}})),await b.onBatchEnd(c,u),_O(u),this.stopTraining_)break}s.dispose()}if(await b.onEpochEnd(v,a),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Az(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return SS(s),Lz(n[0],t),Lz(n[1],e),N_(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=xS().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-xS().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=C_(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>C_(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=C_(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[C_(uz(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>C_(uz(t))));{const t={};for(const e in this.metrics)t[e]=C_(uz(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=VO(vz(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=T_(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>T_(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=T_(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>T_(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=T_(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,LS.getSaveHandlers(n));if(0===e.length)throw new y_("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new y_("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new y_("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await TS(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(xz),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await TS(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=(s=[r.data,e],vS.join(s))}var s;if(null!=this.userDefinedMetadata){const t=!0;dz(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){dz(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Uz.className="Model",EI(Uz);class Vz extends Uz{}Vz.className="Functional",EI(Vz);class jz extends Uz{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:G_("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new y_("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof jz||t instanceof Uz;let n;if(e){if(n=t,1!==n.outputs.length)throw new y_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new y_("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new y_("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new y_("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new pO({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new y_("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new y_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=dO(this.outputs[0])}this.inboundNodes=[],new cO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:k_(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(tO(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Uz({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new b_("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new b_("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new b_("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new b_("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new y_("Legacy serialization format not supported yet.");n=e}else Jb(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof jz))throw new v_("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=VO(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new y_("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new y_("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}jz.className="Sequential",EI(jz);class Gz extends II{getConfig(){return{}}}class Hz extends Gz{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new v_("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return aE(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Hz.className="elu",EI(Hz);class Kz extends Gz{apply(t){return QE(t)}}Kz.className="selu",EI(Kz);class qz extends Gz{apply(t){return YE(t)}}qz.className="relu",EI(qz);class Xz extends Gz{apply(t){return kS((()=>zE(6,YE(t))))}}Xz.className="relu6",EI(Xz);class Jz extends Gz{apply(t){return t}}Jz.className="linear",EI(Jz);class Yz extends Gz{apply(t){return tC(t)}}Yz.className="sigmoid",EI(Yz);class Zz extends Gz{apply(t){return function(t){return kS((()=>{const e=pI(.5,mI(.2,t));return jN(e,0,1)}))}(t)}}Zz.className="hardSigmoid",EI(Zz);class Qz extends Gz{apply(t){return iC(t)}}Qz.className="softplus",EI(Qz);class $z extends Gz{apply(t){return function(t){return kS((()=>gI(t,pI(OI(t),1))))}(t)}}$z.className="softsign",EI($z);class tL extends Gz{apply(t){return hC(t)}}tL.className="tanh",EI(tL);class eL extends Gz{apply(t){return oC(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}eL.className="softmax",EI(eL);class nL extends Gz{apply(t){return vE(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}nL.className="logSoftmax",EI(nL);class rL extends Gz{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return kS((()=>mI(tC(mI(t,e)),t)))}}rL.className="swish",EI(rL);class aL extends Gz{apply(t){return kS((()=>mI(t,hC(iC(t)))))}}function sL(t){return t.getClassName()}function oL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return __(t,NI.getMap().classNameMap,e,"activation")}function iL(t){if(null==t){const t={className:"linear",config:{}};return oL(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},oL(e)}return t instanceof Gz?t:oL(t)}function lL(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}aL.className="mish",EI(aL);class cL extends II{}class uL extends cL{constructor(t){super(),lL(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return kS((()=>{let e=WE([1]);return this.hasL1&&(e=pI(e,yE(mI(this.l1,OI(t))))),this.hasL2&&(e=pI(e,yE(mI(this.l2,ID(t))))),zN(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}uL.className="L1L2",EI(uL);const hL={l1l2:"L1L2"};function dL(t){return R_(t)}function pL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return __(t,NI.getMap().classNameMap,e,"regularizer")}function fL(t){if(null==t)return null;if("string"===typeof t){return pL({className:t in hL?hL[t]:t,config:{}})}return t instanceof cL?t:pL(t)}class gL extends hO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=$D(t);let n=YE(t);return null!=this.maxValue&&(n=jN(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}gL.className="ReLU",EI(gL);class mL extends hO{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=$D(t);return fE(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}mL.className="LeakyReLU",EI(mL);class bL extends hO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=YD(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fL(t.alphaRegularizer),this.alphaConstraint=RO(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new y_("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=tO(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new oO({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=$D(t),GE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:JD(this.alphaInitializer),alphaRegularizer:dL(this.alphaRegularizer),alphaConstraint:TO(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}bL.className="PReLU",EI(bL);class yL extends hO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new v_("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=$D(t);return aE(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}yL.className="ELU",EI(yL);class vL extends hO{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=$D(t);return mI(n,hI(dE(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}vL.className="ThresholdedReLU",EI(vL);class wL extends hO{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new eL).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){return kS((()=>{let n=$D(t);const r=e.mask;if(null!=r){const t=mI(_I(UE(n.shape),hI(r,n.dtype)),xI(-1e9));n=pI(n,t)}return this.axis instanceof Array?this.axis.length>1?oE(_I(n,TE(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function xL(t,e,n){if("number"===typeof t)return k_(t,e);if(t.length!==e)throw new y_("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new y_("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function kL(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function SL(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+cD([n-e,0]);else{if("same"!==r)throw new y_("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function IL(t,e){return kS((()=>(Z_(e),"channelsFirst"===e?vC(t,[0,2,3,1]):t)))}function NL(t,e){return kS((()=>(Z_(e),"channelsFirst"===e?vC(t,[0,2,3,4,1]):t)))}function EL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return kS((()=>{if(null==s&&(s="channelsLast"),Z_(s),3!==t.shape.length)throw new y_("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new y_("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new y_("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=vC(t,[0,2,1])),"causal"===a)throw new v_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=YN(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=ED(i,n)),i}))}function CL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return kS((()=>{if(null==s&&(s="channelsLast"),Z_(s),3!==t.rank&&4!==t.rank)throw new y_("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new y_("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=IL(t,s);if("causal"===a)throw new v_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=_C({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=vC(l,[0,3,1,2])),l}))}function TL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return kS((()=>{if(null==s&&(s="channelsLast"),Z_(s),4!==t.rank&&5!==t.rank)throw new y_("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new y_("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=NL(t,s);if("causal"===a)throw new v_("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=$N(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=ED(i,n)),"channelsFirst"===s&&(i=vC(i,[0,4,1,2,3])),i}))}wL.className="Softmax",EI(wL);class AL extends hO{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",AL.verifyArgs(e),this.rank=t,P_(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new v_("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=xL(e.kernelSize,t,"kernelSize"),this.strides=xL(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Q_(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Z_(this.dataFormat),this.activation=iL(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=YD(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=RO(e.biasConstraint),this.biasRegularizer=fL(e.biasRegularizer),this.activityRegularizer=fL(e.activityRegularizer),this.dilationRate=xL(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new y_("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new y_("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new y_("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(S_("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!M_(t.kernelSize,"number",1,3))throw new y_("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:sL(this.activation),useBias:this.useBias,biasInitializer:JD(this.biasInitializer),biasRegularizer:dL(this.biasRegularizer),activityRegularizer:dL(this.activityRegularizer),biasConstraint:TO(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class RL extends AL{constructor(t,e){super(t,e),this.kernel=null,RL.verifyArgs(e),this.filters=e.filters,P_(this.filters,"filters"),this.kernelInitializer=YD(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=RO(e.kernelConstraint),this.kernelRegularizer=fL(e.kernelRegularizer)}build(t){t=tO(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new y_("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return kS((()=>{let e;t=$D(t);const n=null==this.bias?null:this.bias.read(),r=W_(this.activation.getClassName());if(null!=r&&2===this.rank)e=CL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=EL(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=CL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new v_("convolutions greater than 3D are not implemented yet.");e=TL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=tO(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=kL(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:JD(this.kernelInitializer),kernelRegularizer:dL(this.kernelRegularizer),kernelConstraint:TO(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new y_("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class FL extends RL{constructor(t){super(2,t),FL.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!M_(t.kernelSize,"number",1,2))throw new y_("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}FL.className="Conv2D",EI(FL);class _L extends RL{constructor(t){super(3,t),_L.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new y_("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}_L.className="Conv3D",EI(_L);class DL extends FL{constructor(t){if(super(t),this.inputSpec=[new oO({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new y_("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=tO(t)).length)throw new y_("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new y_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oO({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return kS((()=>{let e=$D(t);if(4!==e.shape.length)throw new y_("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,SL(o,u,l,this.padding),SL(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vC(e,[0,2,3,1]));let p=QN(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=vC(p,[0,3,1,2])),null!=this.bias&&(p=ED(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=tO(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=SL(e[r],i,s,this.padding),e[a]=SL(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}DL.className="Conv2DTranspose",EI(DL);class OL extends _L{constructor(t){if(super(t),this.inputSpec=[new oO({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new y_("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=tO(t)).length)throw new y_("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new y_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oO({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return kS((()=>{let e=$D(t);if(5!==e.shape.length)throw new y_("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,SL(i,p,u,this.padding),SL(l,f,h,this.padding),SL(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vC(e,[0,2,3,4,1]));let b=eE(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=vC(b,[0,4,1,2,3])),null!==this.bias&&(b=ED(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=tO(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=SL(e[r],c,o,this.padding),e[a]=SL(e[a],u,i,this.padding),e[s]=SL(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}OL.className="Conv3DTranspose",EI(OL);class zL extends RL{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new y_("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new y_("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new y_("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=YD(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fL(e.depthwiseRegularizer),this.depthwiseConstraint=RO(e.depthwiseConstraint),this.pointwiseInitializer=YD(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fL(e.pointwiseRegularizer),this.pointwiseConstraint=RO(e.pointwiseConstraint)}build(t){if((t=tO(t)).length<this.rank+2)throw new y_("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new y_("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new oO({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return kS((()=>{let e;if(t=$D(t),1===this.rank)throw new v_("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=vC(t,[0,2,3,1])),e=$E(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=ED(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=vC(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=JD(this.depthwiseInitializer),t.pointwiseInitializer=JD(this.pointwiseInitializer),t.depthwiseRegularizer=dL(this.depthwiseRegularizer),t.pointwiseRegularizer=dL(this.pointwiseRegularizer),t.depthwiseConstraint=TO(this.depthwiseConstraint),t.pointwiseConstraint=TO(this.pointwiseConstraint),t}}zL.className="SeparableConv";class LL extends zL{constructor(t){super(2,t)}}LL.className="SeparableConv2D",EI(LL);class ML extends RL{constructor(t){super(1,t),ML.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!M_(t.kernelSize,"number",1,1))throw new y_("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}ML.className="Conv1D",EI(ML);class PL extends hO{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return kS((()=>{if(t=$D(t),"channelsLast"===this.dataFormat){const e=bD(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return bD(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=bD(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return bD(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}PL.className="Cropping2D",EI(PL);class BL extends hO{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Z_(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,L_(K_,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return kS((()=>{let e=$D(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=vC(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?wT.resizeNearestNeighbor(e,[t,r]):wT.resizeBilinear(e,[t,r]);return vC(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?wT.resizeNearestNeighbor(e,[t,r]):wT.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}BL.className="UpSampling2D",EI(BL);class WL extends AL{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=YD(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=RO(t.depthwiseConstraint),this.depthwiseRegularizer=fL(t.depthwiseRegularizer)}build(t){if((t=tO(t)).length<4)throw new y_("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new y_("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return kS((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return kS((()=>{null==a&&(a="channelsLast"),Z_(a);let o=IL(t,a);if(4!==t.rank)throw new y_("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new y_("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=rE(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=vC(o,[0,3,1,2])),o}))}(t=$D(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=ED(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=tO(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=kL(e,this.kernelSize[0],this.padding,this.strides[0]),s=kL(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=JD(this.depthwiseInitializer),t.depthwiseRegularizer=dL(this.depthwiseRegularizer),t.depthwiseConstraint=TO(this.depthwiseRegularizer),t}}function UL(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new y_("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function VL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return kS((()=>{const l=e.shape.length;if(l<3)throw new y_("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(uD(2,l));if(e=vC(e,c),null!=s)throw new v_("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=hI(hI(a,"bool"),"float32"),a.rank===l-1&&(a=iE(a,-1)),a=vC(a,c)),r&&(e=ZE(e,0),null!=a&&(a=ZE(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=gC(e);let g,m;null!=a&&(g=gC(a));for(let e=0;e<p;++e){const n=f[e],r=kS((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=kS((()=>{const t=g[e],n=_I(VE(t),t);return{output:pI(mI(r[0],t),mI(d[0],n)),newStates:d.map(((e,a)=>pI(mI(r[1][a],t),mI(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=uC(u,1)}return[h,m,d]}))}WL.className="DepthwiseConv2D",EI(WL);class jL extends hO{constructor(t){let e;if(super(t),null==t.cell)throw new y_("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new ZL({cells:t.cell}):t.cell,null==e.stateSize)throw new y_("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new oO({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return uD(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){ZD(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return kS((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new v_("Constants support is not implemented in RNN yet.");ZD(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new oO({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!$b(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new y_("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new oO({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];kS((()=>{if(!this.stateful)throw new m_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new y_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>WE([n,t]))):this.states_=[WE([n,this.cell.stateSize])];else if(null==t)SS(this.states_),null!=this.keptStates&&(SS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>WE([n,t]))):this.states_[0]=WE([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new y_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):SS(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!$b(r.shape,s))throw new y_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>IS(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=UL(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new oO({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof iO){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return kS((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=$D(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new y_("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=VL(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return kS((()=>{let e=WE(t.shape);return e=yE(e,[1,2]),e=fD(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?wD(e,[1,t]):e)):this.cell.stateSize>1?[wD(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===jL.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=VO(e.cell,n);return new t(Object.assign(e,{cell:r}))}}jL.className="RNN",EI(jL);class GL extends hO{}class HL extends GL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,P_(this.units,"units"),this.activation=iL(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=YD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=YD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=YD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fL(t.kernelRegularizer),this.recurrentRegularizer=fL(t.recurrentRegularizer),this.biasRegularizer=fL(t.biasRegularizer),this.kernelConstraint=RO(t.kernelConstraint),this.recurrentConstraint=RO(t.recurrentConstraint),this.biasConstraint=RO(t.biasConstraint),this.dropout=lD([1,cD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lD([1,cD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=tO(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return kS((()=>{if(2!==t.length)throw new y_("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=QL({ones:()=>VE(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=QL({ones:()=>VE(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=kD(null!=s?mI(t,s):t,this.kernel.read()),null!=this.bias&&(a=ED(a,this.bias.read())),null!=o&&(n=mI(n,o));let i=pI(a,kD(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sL(this.activation),useBias:this.useBias,kernelInitializer:JD(this.kernelInitializer),recurrentInitializer:JD(this.recurrentInitializer),biasInitializer:JD(this.biasInitializer),kernelRegularizer:dL(this.kernelRegularizer),recurrentRegularizer:dL(this.recurrentRegularizer),biasRegularizer:dL(this.biasRegularizer),activityRegularizer:dL(this.activityRegularizer),kernelConstraint:TO(this.kernelConstraint),recurrentConstraint:TO(this.recurrentConstraint),biasConstraint:TO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}HL.className="SimpleRNNCell",EI(HL);class KL extends jL{constructor(t){t.cell=new HL(t),super(t)}call(t,e){return kS((()=>{null!=this.cell.dropoutMask&&(SS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}KL.className="SimpleRNN",EI(KL);class qL extends GL{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new y_("GRUCell does not support reset_after parameter set to true.");this.units=t.units,P_(this.units,"units"),this.activation=iL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=iL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=YD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=YD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=YD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fL(t.kernelRegularizer),this.recurrentRegularizer=fL(t.recurrentRegularizer),this.biasRegularizer=fL(t.biasRegularizer),this.kernelConstraint=RO(t.kernelConstraint),this.recurrentConstraint=RO(t.recurrentConstraint),this.biasConstraint=RO(t.biasConstraint),this.dropout=lD([1,cD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lD([1,cD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=tO(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return kS((()=>{if(2!==t.length)throw new y_("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=QL({ones:()=>VE(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=QL({ones:()=>VE(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=mI(t,a[0]));let c=kD(t,this.kernel.read());this.useBias&&(c=ED(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mI(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=lC(u,[2*this.units,this.units],u.rank-1),p=kD(r,h),[f,g,m]=lC(c,3,c.rank-1),[b,y]=lC(p,2,p.rank-1);o=this.recurrentActivation.apply(pI(f,b)),i=this.recurrentActivation.apply(pI(g,y));const v=kD(mI(i,r),d);l=this.activation.apply(pI(m,v));const w=pI(mI(o,r),mI(pI(1,ME(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sL(this.activation),recurrentActivation:sL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:JD(this.kernelInitializer),recurrentInitializer:JD(this.recurrentInitializer),biasInitializer:JD(this.biasInitializer),kernelRegularizer:dL(this.kernelRegularizer),recurrentRegularizer:dL(this.recurrentRegularizer),biasRegularizer:dL(this.biasRegularizer),activityRegularizer:dL(this.activityRegularizer),kernelConstraint:TO(this.kernelConstraint),recurrentConstraint:TO(this.recurrentConstraint),biasConstraint:TO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}qL.className="GRUCell",EI(qL);class XL extends jL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new qL(t),super(t)}call(t,e){return kS((()=>{null!=this.cell.dropoutMask&&(SS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}XL.className="GRU",EI(XL);class JL extends GL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,P_(this.units,"units"),this.activation=iL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=iL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=YD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=YD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=YD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=fL(t.kernelRegularizer),this.recurrentRegularizer=fL(t.recurrentRegularizer),this.biasRegularizer=fL(t.biasRegularizer),this.kernelConstraint=RO(t.kernelConstraint),this.recurrentConstraint=RO(t.recurrentConstraint),this.biasConstraint=RO(t.biasConstraint),this.dropout=lD([1,cD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=lD([1,cD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=tO(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends FD{apply(e,r){const a=t.apply([n]),s=(new DD).apply([n]),o=t.apply([2*n]);return vD(vD(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return kS((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new y_("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=QL({ones:()=>VE(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=QL({ones:()=>VE(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=mI(t,s[0]));let h=kD(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=mI(r,o[0])),h=pI(h,kD(r,this.recurrentKernel.read())),this.useBias&&(h=ED(h,this.bias.read()));const[d,p,f,g]=lC(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=pI(mI(l,a),mI(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=mI(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sL(this.activation),recurrentActivation:sL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:JD(this.kernelInitializer),recurrentInitializer:JD(this.recurrentInitializer),biasInitializer:JD(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dL(this.kernelRegularizer),recurrentRegularizer:dL(this.recurrentRegularizer),biasRegularizer:dL(this.biasRegularizer),activityRegularizer:dL(this.activityRegularizer),kernelConstraint:TO(this.kernelConstraint),recurrentConstraint:TO(this.recurrentConstraint),biasConstraint:TO(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}JL.className="LSTMCell",EI(JL);class YL extends jL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new JL(t),super(t)}call(t,e){return kS((()=>{null!=this.cell.dropoutMask&&(SS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}YL.className="LSTM",EI(YL);class ZL extends GL{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return kS((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;ZD(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{nD("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(VO(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return aO(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}sO(e)}}function QL(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):CD(e(),n),i=()=>TD(o,e,r);if(!a||a<=1)return IS(i().clone());return Array(a).fill(void 0).map(i).map((t=>IS(t.clone())))}ZL.className="StackedRNNCells",EI(ZL);var $L=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class tM extends jL{constructor(t){if(t.unroll)throw new v_("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new v_("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new oO({ndim:5})]}call(t,e){return kS((()=>{if(null!=this.cell.dropoutMask&&(SS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(SS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new y_("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return kS((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=WE([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];kS((()=>{if(!this.stateful)throw new m_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new y_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>WE(a))):this.states_=[WE(a)];else if(null==t)SS(this.states_),null!=this.keptStates&&(SS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>WE(a))):this.states_[0]=WE(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new y_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):SS(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!$b(n.shape,r))throw new y_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>IS(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=kL(l,r[0],a,s[0],o[0]),h=kL(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}tM.className="ConvRNN2D";class eM extends JL{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,P_(this.filters,"filters"),this.kernelSize=xL(n,2,"kernelSize"),this.kernelSize.forEach((t=>P_(t,"kernelSize"))),this.strides=xL(r||1,2,"strides"),this.strides.forEach((t=>P_(t,"strides"))),this.padding=a||"valid",Q_(this.padding),this.dataFormat=s||"channelsLast",Z_(this.dataFormat),this.dilationRate=xL(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>P_(t,"dilationRate")))}build(t){var e;t=tO(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new y_("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends FD{apply(t,e){return yD([n.apply([r]),UE([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return kS((()=>{if(3!==t.length)throw new y_("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=QL({ones:()=>VE(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?mI(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=QL({ones:()=>VE(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=lC(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?lC(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,E,C,T]=lC(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,E),g=this.recurrentConv(g,C),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(pI(l,p)),R=this.recurrentActivation.apply(pI(c,f)),F=pI(mI(R,s),mI(A,this.activation.apply(pI(u,g)))),_=mI(this.recurrentActivation.apply(pI(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=$L(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,e,n,r){const a=JN(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?ED(a,n,this.dataFormat):a}recurrentConv(t,e){return JN(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}eM.className="ConvLSTM2DCell",EI(eM);class nM extends tM{constructor(t){const e=new eM(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}nM.className="ConvLSTM2D",EI(nM);class rM extends hO{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return TD((()=>CD(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}rM.className="Dropout",EI(rM);class aM extends rM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}aM.className="SpatialDropout1D",EI(aM);class sM extends hO{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,P_(this.units,"units"),this.activation=iL(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=YD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=YD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=RO(t.kernelConstraint),this.biasConstraint=RO(t.biasConstraint),this.kernelRegularizer=fL(t.kernelRegularizer),this.biasRegularizer=fL(t.biasRegularizer),this.activityRegularizer=fL(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=tO(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=tO(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t),r=W_(this.activation.getClassName());let a;return null!=r?a=kD(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=kD(n,this.kernel.read()),null!=this.bias&&(a=ED(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:sL(this.activation),useBias:this.useBias,kernelInitializer:JD(this.kernelInitializer),biasInitializer:JD(this.biasInitializer),kernelRegularizer:dL(this.kernelRegularizer),biasRegularizer:dL(this.biasRegularizer),activityRegularizer:dL(this.activityRegularizer),kernelConstraint:TO(this.kernelConstraint),biasConstraint:TO(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}sM.className="Dense",EI(sM);class oM extends hO{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=tO(t);for(const e of t.slice(1))if(null==e)throw new y_('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],iD(t,1)]}call(t,e){return kS((()=>{this.invokeCallHook(t,e);let n=$D(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=vC(n,t)}return function(t){if(t.rank<=1)throw new y_("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],iD(t.shape,1)];return zN(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}oM.className="Flatten",EI(oM);class iM extends hO{constructor(t){super(t),this.supportsMasking=!0,this.activation=iL(t.activation)}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t);return this.activation.apply(n)}))}getConfig(){const t={activation:sL(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}iM.className="Activation",EI(iM);class lM extends hO{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return kS((()=>{return t=$D(t),e=t,n=this.n,kS((()=>{if(2!==e.shape.length)throw new y_("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return wD(fD(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}lM.className="RepeatVector",EI(lM);class cM extends hO{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new y_("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=iD(t);if(null!==s){if(0===a||o%a!==0)throw new y_(n);r[s]=o/a}else if(o!==a)throw new y_(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return zN(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}cM.className="Reshape",EI(cM);class uM extends hO{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=uD(1,t.dims.length+1);if(!$b(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new oO({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=tO(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return vC($D(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}uM.className="Permute",EI(uM);class hM extends hO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=$D(t);return yN(PE(n,this.maskValue),-1)}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t),r=yN(PE(n,this.maskValue),-1,!0);return mI(n,hI(r,n.dtype))}))}}hM.className="Masking",EI(hM);class dM extends hO{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(E_(t.inputLength))}this.inputDim=t.inputDim,P_(this.inputDim,"inputDim"),this.outputDim=t.outputDim,P_(this.outputDim,"outputDim"),this.embeddingsInitializer=YD(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fL(t.embeddingsRegularizer),this.activityRegularizer=fL(t.activityRegularizer),this.embeddingsConstraint=RO(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return kS((()=>this.maskZero?(t=$D(t),PE(t,vI(t))):null))}computeOutputShape(t){if(t=tO(t),null==this.inputLength)return[...t,this.outputDim];const e=E_(this.inputLength);if(e.length!==t.length-1)throw new y_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new y_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return kS((()=>{this.invokeCallHook(t,e);let n=$D(t);"int32"!==n.dtype&&(n=pD(n,"int32"));const r=SD(this.embeddings.read(),zN(n,[n.size]));return zN(r,tO(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:JD(this.embeddingsInitializer),embeddingsRegularizer:dL(this.embeddingsRegularizer),activityRegularizer:dL(this.activityRegularizer),embeddingsConstraint:TO(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}dM.className="Embedding",EI(dM);class pM extends hO{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new v_}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new y_("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[tO(t)]),t.length<2)throw new y_("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=O_(e),e.length>1)throw new y_("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===O_(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return kS((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=cD(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=fD(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=zN(s,[r].concat(iD(t.slice(1))));o=vC(o,[1,0]),o=zN(o,a),e.push(o),n=!0}else if(t>1){const r=uD(1,t).concat([0]);e.push(vC(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=zN(vC(zN(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(uD(0,a-1));r=vC(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=O_(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return kS((()=>{if(null==e)return null;if(!Array.isArray(e))throw new y_("`mask` should be an Array");if(!Array.isArray(t))throw new y_("`inputs` should be an Array");if(e.length!==t.length)throw new y_("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:iE(t,0))))[0];for(let t=1;t<e.length-1;++t)n=AE(n,e[t]);return n}))}}class fM extends pM{constructor(t){super(t)}mergeFunction(t){return kS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=pI(e,t[n]);return e}))}}fM.className="Add",EI(fM);class gM extends pM{constructor(t){super(t)}mergeFunction(t){return kS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=mI(e,t[n]);return e}))}}gM.className="Multiply",EI(gM);class mM extends pM{constructor(t){super(t)}mergeFunction(t){return kS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=pI(e,t[n]);return mI(1/t.length,e)}))}}mM.className="Average",EI(mM);class bM extends pM{constructor(t){super(t)}mergeFunction(t){return kS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=PI(e,t[n]);return e}))}}bM.className="Maximum",EI(bM);class yM extends pM{constructor(t){super(t)}mergeFunction(t){return kS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=zE(e,t[n]);return e}))}}yM.className="Minimum",EI(yM);class vM extends pM{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new y_("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if($b(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new y_("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return kS((()=>yD(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new y_("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new y_("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new y_("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new y_("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return kS((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(hI(VE(t[s]),"bool")):e[s].rank<t[s].rank?r.push(iE(e[s],-1)):r.push(e[s]);const a=GN(r,this.axis);return bN(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function wM(t,e){for(;t<0;)t+=e;return t}vM.className="Concatenate",EI(vM);class xM extends pM{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Jb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new v_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new y_("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new y_("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>wM(e,t[n].shape.length))):[wM(this.axes,n.shape.length),wM(this.axes,r.shape.length)],this.normalize&&(n=jO(n,e[0]),r=jO(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new v_("batchDot is not implemented for tensors of 4D or higher rank yet");if(Jb(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),Jb(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new v_("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return kS((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=zN(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=zN(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?yE(mI(t,e),s[0]):yE(mI(vC(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=RE(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=cC(o,e)}return 1===o.shape.length&&(o=iE(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[wM(this.axes,t.length),wM(this.axes,e.length)],n}computeOutputShape(t){Jb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new v_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}xM.className="Dot",EI(xM);class kM extends hO{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t);return TD((()=>pI(xD(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}kM.className="GaussianNoise",EI(kM);class SM extends hO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return kS((()=>{this.invokeCallHook(t,e);const n=$D(t);if(this.rate>0&&this.rate<1){return TD((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return mI(n,xD(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}SM.className="GaussianDropout",EI(SM);class IM extends hO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||$D(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return kS((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=$D(t),r=-1.7580993408473766;let a=pE(XE(n),this.rate);a=pD(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=pI(mI(e,a),mI(pI(a,-1),r));return pI(mI(i,s),o)};return TD(r,(()=>$D(t)),e.training||!1)}return t}))}}function NM(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=BN(t,e,n,r,a,o);else if(3===t.rank)s=WN(t,e,n,r,a,o);else{if(4!==t.rank)throw new v_("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=UN(t,e,n,r,a,o)}return s}function EM(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return $b(r.slice().sort(),uD(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return kS((()=>{const s=LE(t,r),o=s.mean,i=s.variance;return[NM(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return kS((()=>{const s=LE(t,r),o=s.mean,i=s.variance,l=[];for(const e of uD(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=zN(o,l),u=zN(i,l),h=null==e?null:zN(e,l),d=null==n?null:zN(n,l);return[NM(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}IM.className="AlphaDropout",EI(IM);class CM extends hO{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=YD(t.betaInitializer||"zeros"),this.gammaInitializer=YD(t.gammaInitializer||"ones"),this.movingMeanInitializer=YD(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=YD(t.movingVarianceInitializer||"ones"),this.betaConstraint=RO(t.betaConstraint),this.gammaConstraint=RO(t.gammaConstraint),this.betaRegularizer=fL(t.betaRegularizer),this.gammaRegularizer=fL(t.gammaRegularizer)}build(t){t=tO(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new y_("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new oO({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return kS((()=>{const n=null!=e.training&&e.training,r=$D(t),a=r.shape,s=a.length,o=uD(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=k_(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!$b(c,uD(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=zN(this.movingMean.read(),l),e=zN(this.movingVariance.read(),l),n=this.center?zN(this.beta.read(),l):null,a=this.scale?zN(this.gamma.read(),l):null;return NM(r,t,e,n,a,this.epsilon)}return NM(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=EM(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{kS((()=>{const r=1-n,a=t.read(),s=mI(_I(a,e),r);t.write(_I(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:JD(this.betaInitializer),gammaInitializer:JD(this.gammaInitializer),movingMeanInitializer:JD(this.movingMeanInitializer),movingVarianceInitializer:JD(this.movingVarianceInitializer),betaRegularizer:dL(this.betaRegularizer),gammaRegularizer:dL(this.gammaRegularizer),betaConstraint:TO(this.betaConstraint),gammaConstraint:TO(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}CM.className="BatchNormalization",EI(CM);class TM extends hO{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=YD(t.betaInitializer||"zeros"),this.gammaInitializer=YD(t.gammaInitializer||"ones"),this.betaRegularizer=fL(t.betaRegularizer),this.gammaRegularizer=fL(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=tO(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==O_(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=$D(t),r=n.shape,a=r.length;return kS((()=>{let{mean:t,variance:e}=LE(n,this.axis,!0);const s=k_(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?zN(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=lE(t,c),e=lE(e,c),null!=i&&(i=lE(i,u)),null!=l&&(l=lE(l,u)),NM(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:JD(this.betaInitializer),gammaInitializer:JD(this.gammaInitializer),betaRegularizer:dL(this.betaRegularizer),gammaRegularizer:dL(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}TM.className="LayerNormalization",EI(TM);class AM extends hO{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new y_("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new y_("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new y_("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new oO({ndim:4})]}computeOutputShape(t){let e,n;return t=tO(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return kS((()=>{return e=$D(t),n=this.padding,r=this.dataFormat,kS((()=>{if(4!==e.rank)throw new y_("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new y_("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new y_("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],jE(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function RM(t,e,n,r,a,s){return kS((()=>{let o;Z_(a),$_(s),Q_(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=IL(t,a);const i="same"===r?"same":"valid";return o="max"===s?FE(t,e,n,i):LN(t,e,n,i),"channelsFirst"===a&&(o=vC(o,[0,3,1,2])),o}))}function FM(t,e,n,r,a,s){return kS((()=>{let o;Z_(a),$_(s),Q_(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=NL(t,a);const i="same"===r?"same":"valid";return o="max"===s?_E(t,e,n,i):MN(t,e,n,i),"channelsFirst"===a&&(o=vC(o,[0,4,1,2,3])),o}))}AM.className="ZeroPadding2D",EI(AM);class _M extends hO{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new y_("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(P_(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new y_("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}P_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Q_(this.padding),this.inputSpec=[new oO({ndim:3})]}computeOutputShape(t){const e=kL((t=tO(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return kS((()=>{this.invokeCallHook(t,e),t=fD($D(t),2);const n=this.poolingFunction($D(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return cC(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class DM extends _M{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),RM(t,e,n,r,a,"max")}}DM.className="MaxPooling1D",EI(DM);class OM extends _M{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),RM(t,e,n,r,a,"avg")}}OM.className="AveragePooling1D",EI(OM);class zM extends hO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new y_("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];P_(this.poolSize,"poolSize"),P_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Z_(this.dataFormat),Q_(this.padding),this.inputSpec=[new oO({ndim:4})]}computeOutputShape(t){t=tO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=kL(e,this.poolSize[0],this.padding,this.strides[0]),n=kL(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return kS((()=>(this.invokeCallHook(t,e),this.poolingFunction($D(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class LM extends zM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),RM(t,e,n,r,a,"max")}}LM.className="MaxPooling2D",EI(LM);class MM extends zM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),RM(t,e,n,r,a,"avg")}}MM.className="AveragePooling2D",EI(MM);class PM extends hO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new y_("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];P_(this.poolSize,"poolSize"),P_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Z_(this.dataFormat),Q_(this.padding),this.inputSpec=[new oO({ndim:5})]}computeOutputShape(t){t=tO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=kL(e,this.poolSize[0],this.padding,this.strides[0]),n=kL(n,this.poolSize[1],this.padding,this.strides[1]),r=kL(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return kS((()=>(this.invokeCallHook(t,e),this.poolingFunction($D(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class BM extends PM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),FM(t,e,n,r,a,"max")}}BM.className="MaxPooling3D",EI(BM);class WM extends PM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Z_(a),Q_(r),FM(t,e,n,r,a,"avg")}}WM.className="AveragePooling3D",EI(WM);class UM extends hO{constructor(t){super(t),this.inputSpec=[new oO({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new v_}}class VM extends UM{constructor(t){super(t||{})}call(t,e){return kS((()=>{const e=$D(t);return DE(e,1)}))}}VM.className="GlobalAveragePooling1D",EI(VM);class jM extends UM{constructor(t){super(t||{})}call(t,e){return kS((()=>{const e=$D(t);return bE(e,1)}))}}jM.className="GlobalMaxPooling1D",EI(jM);class GM extends hO{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Z_(this.dataFormat),this.inputSpec=[new oO({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new v_}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class HM extends GM{call(t,e){return kS((()=>{const e=$D(t);return"channelsLast"===this.dataFormat?DE(e,[1,2]):DE(e,[2,3])}))}}HM.className="GlobalAveragePooling2D",EI(HM);class KM extends GM{call(t,e){return kS((()=>{const e=$D(t);return"channelsLast"===this.dataFormat?bE(e,[1,2]):bE(e,[2,3])}))}}KM.className="GlobalMaxPooling2D",EI(KM);class qM extends hO{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=VO(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class XM extends qM{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=tO(t)).length<3)throw new y_("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=tO(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return kS((()=>VL(((t,n)=>[$D(this.layer.call(t,e)),[]]),t=$D(t),[],!1,null,null,!1,!0)[1]))}}XM.className="TimeDistributed",EI(XM);class JM extends qM{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=VO(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=VO(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,L_(J_,"BidirectionalMergeMode",a),t.weights)throw new v_("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):N_(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=UL(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new y_("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new oO({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new v_("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof iO;for(const l of s)if(l instanceof iO!==i)throw new y_("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return kS((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=ZE(a,1)),"concat"===this.mergeMode?o=yD([r,a]):"sum"===this.mergeMode?o=pI(r,a):"ave"===this.mergeMode?o=mI(.5,pI(r,a)):"mul"===this.mergeMode?o=mI(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){nD(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),nD(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=VO(e.layer);if(delete e.layer,null!=e.numConstants)throw new v_("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}JM.className="Bidirectional",EI(JM);class YM extends hO{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return kS((()=>("float32"!==(t=$D(t)).dtype&&(t=pD(t,"float32")),pI(mI(t,this.scale),this.offset))))}}YM.className="Rescaling",EI(YM);const{resizeBilinear:ZM,cropAndResize:QM}=wT;class $M extends hO{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,r,a,s,o,i){return kS((()=>{let l,c=!1;const u=[e/s,n/o,(r+e)/s,(a+n)/o],h=[];3===t.rank?(c=!0,l=uC([t])):l=t;for(let t=0;t<l.shape[0];t++)h.push(u);const d=yS(h,[h.length,4]),p=JE(0,h.length,1,"int32"),f=QM(l,d,p,[r,a],"nearest");return pD(c?$D(gC(f)):f,i)}))}upsize(t,e,n,r){return kS((()=>pD(ZM(t,[e,n]),r)))}call(t,e){return kS((()=>{const e=$D(t),n=e.dtype,r=e.shape,a=r[r.length-3],s=r[r.length-2];let o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let i=0;return s!==this.width&&(i=Math.floor((s-this.width)/2),0===i&&(i=1)),o>=0&&i>=0?this.centerCrop(e,o,i,this.height,this.width,a,s,n):this.upsize(t,this.height,this.width,n)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=tO(t)).length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}}$M.className="CenterCrop",EI($M);class tP extends hO{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=tO(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return kS((()=>{let n;if("int32"!==(t=$D(t)).dtype&&(t=pD(t,"int32")),"undefined"!==typeof e.countWeights){if("count"!==this.outputMode)throw new y_("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(e.countWeights));n=$D(e.countWeights)}const r=bE(t),a=OE(t),s=dE(this.numTokens,r).bufferSync().get(0),o=pE(a,0).bufferSync().get(0);if(!s||!o)throw new y_("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(t,e,n,r){let a=$D(t);if("int32"!==a.dtype&&(a=pD(a,"int32")),"int"===e)return a;const s=a.shape;if(0===a.rank&&(a=iE(a,-1)),"oneHot"===e&&1!==a.shape[a.shape.length-1]&&(a=iE(a,-1)),a.rank>2)throw new y_("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(e," and input shape ").concat(s)+" which would result in output rank ".concat(a.rank,"."));const o=["multiHot","oneHot"].includes(e),i=a;let l;if(l=nE(i,"undefined"!==typeof r&&"count"===e?r:[],n,o),"tfIdf"!==e)return l;if(r)return mI(l,r);throw new y_("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,n)}))}}tP.className="CategoryEncoding",EI(tP);const eP=new Set(["bilinear","nearest"]);class nP extends hO{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!eP.has(t.interpolation))throw new y_("Invalid interpolation parameter: ".concat(t.interpolation," is not implemented"));this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=tO(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return kS((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return wT.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return wT.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...eP]," are supported"))}))}}nP.className="Resizing",EI(nP);class rP{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}rP.className="RandomSeed";class aP extends hO{constructor(t){super(t),this.randomGenerator=new rP(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}aP.className="BaseRandomLayer";const sP=new Set(["bilinear","nearest"]);class oP extends aP{constructor(t){super(t);const{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new y_("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new y_("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new y_("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!sP.has(n))throw new y_("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=tO(t))[2];return[this.imgHeight,-1,e]}call(t,e){return kS((()=>{const e=$D(t);this.imgHeight=e.shape[e.shape.length-3];const n=e.shape[e.shape.length-2];this.widthFactor=XE([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return wT.resizeBilinear(t,a);case"nearest":return wT.resizeNearestNeighbor(t,a);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...sP]," are supported"))}}))}}oP.className="RandomWidth",EI(oP);var iP,lP;Ay().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(iP||(iP={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(lP||(lP={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function cP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(pP(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=cP(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function uP(t){return hP(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:dP)}function hP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(pP(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=hP(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function dP(t){return null===t?null:pP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function pP(t){let e=!1;if(Ay().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(4222);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Mk)&&!(t instanceof Promise)&&!e)}function fP(t){return function(t,e){return cP(t,e)}(t,gP)}function gP(t){return t instanceof Mk?{value:t.clone(),recurse:!1}:pP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class mP{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class bP extends mP{constructor(){super(bP.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function yP(t){return new kP(t)}function vP(t,e){return new DP(t,e)}bP.INITIAL_CAPACITY=32;class wP{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new AP(this,t)}filter(t){return new CP(this,t)}map(t){return new TP(this,t)}mapAsync(t){return new RP(this,t)}serialMapAsync(t){return new RP(this,t).serial()}flatmap(t){return new _P(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new EP(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dP;return this.rowMajorBatch(t,e).map((t=>uP(t,n)))}concatenate(t,e){return new DP(new xP([this,t]),e)}take(t){return t<0||null==t?this:new NP(this,t)}skip(t){return t<0||null==t?this:new IP(this,t)}prefetch(t){return new zP(this,t)}shuffle(t,e){return new LP(this,t,e)}serial(){return new SP(this)}}class xP extends wP{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:fP(t),done:!1}}}class kP extends wP{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(d1){throw d1.message="Error thrown while iterating through a dataset: ".concat(d1.message),d1}}}class SP extends wP{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class IP extends wP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;SS(t.value)}return this.upstream.next()}}class NP extends wP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class EP extends wP{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class CP extends wP{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;SS(t.value)}}}class TP extends wP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Qk(t.value),n=this.transform(t.value),r=Qk(n);for(const a of e)Zk(a,r)||a.dispose();return{value:n,done:!1}}}class AP extends wP{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(d1){if(!this.handler(d1))return{value:null,done:!0}}}}class RP extends wP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Qk(t.value),n=await this.transform(t.value),r=Qk(n);for(const a of e)Zk(a,r)||a.dispose();return{value:n,done:!1}}}class FP extends wP{constructor(){super(),this.outputQueue=new bP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class _P extends FP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Qk(t.value),n=this.transform(t.value),r=Qk(n);this.outputQueue.pushAll(n);for(const a of e)Zk(a,r)||a.dispose();return!0}}class DP extends wP{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var OP;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(OP||(OP={}));class zP extends wP{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new mP(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class LP extends zP{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Vo.alea(n||bk().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class MP{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Jb(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),PP((async()=>(await n.iterator()).columnMajorBatch(t,e,BP)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,PP((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,PP((async()=>(await e.iterator()).filter((e=>kS((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return PP((async()=>(await e.iterator()).map((e=>kS((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return PP((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return PP((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,PP((async()=>vP(yP((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,PP((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Vo.alea(e||bk().toString());return PP((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,PP((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function PP(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends MP{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function BP(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Mk||wk(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Mk?uC(t):yS(t)}(t),recurse:!1}}return{value:null,recurse:!0}}MP.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function WP(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Jb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors in the CPU backend.")))}))}const UP=OA;class VP extends jb{nextDataId(){return VP.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Vb(this,wS())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Ay().get("IS_NODE")&&Hx("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&hy(n[0])){const a=n.map((t=>yk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){if(this.data.has(t)){return this.data.get(t).refCount}return 0}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,n,r,a){this.data.set(t,{values:e,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){return QT(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(t,e){if(Array.isArray(t))return t;if("float32"===e)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===e)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===e||"string"===e)return Uint8Array.from(new Int32Array(t));throw new Error("Unknown dtype ".concat(e))}(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>vk(t)));return uI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return uI(t.shape,t.dtype,e)}makeOutput(t,e,n){return wS().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=bk();t();return{kernelMs:bk()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){WP([t],"where");const e=this.readSync(t.dataId);return UP(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}VP.nextDataId=0;function jP(t){return(e,n,r)=>{const a=ly(n,e.length);for(let s=0;s<e.length;++s)a[s]=t(e[s],r);return a}}function GP(t,e,n){return HP(t,jP(e),n)}function HP(t,e,n){return r=>{let{inputs:a,attrs:s,backend:o}=r;const{x:i}=a;WP(i,t);const l=o,c=l.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=_A(c)}else u=c;const h=n||i.dtype,d=e(u,h,s);return l.makeTensorInfo(i.shape,h,d)}}NS("cpu",(()=>new VP),1);const KP=GP(_v,(t=>t>=0?t:Math.exp(t)-1)),qP={kernelName:_v,backendName:"cpu",kernelFunc:KP};function XP(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const JP={kernelName:Jv,backendName:"cpu",kernelFunc:XP};function YP(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r;WP([a],"leakyRelu");const o=Qb(a.shape),i=n.data.get(a.dataId).values,l=iy("float32",o);for(let c=0;c<i.length;c++)l[c]=i[c]<0?s*i[c]:i[c];return n.makeTensorInfo(a.shape,"float32",l)}const ZP={kernelName:ew,backendName:"cpu",kernelFunc:YP};function QP(t){return(e,n,r,a,s)=>{const o=MI(e,n),i=o.length,l=my(o),c=iy(s,Qb(o)),u=e.length,h=n.length,d=my(e),p=my(n),f=zI(e,o),g=zI(n,o);if(f.length+g.length===0)for(let m=0;m<c.length;++m)c[m]=t(r[m%r.length],a[m%a.length]);else for(let m=0;m<c.length;++m){const e=Iy(m,i,l),n=e.slice(-u);f.forEach((t=>n[t]=0));const s=Sy(n,u,d),o=e.slice(-h);g.forEach((t=>o[t]=0));const b=Sy(o,h,p);c[m]=t(r[s],a[b])}return[c,o]}}const $P=QP(((t,e)=>t<0?e*t:t));function tB(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e;WP([r,a],"prelu");const s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[i,l]=$P(r.shape,a.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",i)}const eB={kernelName:Lw,backendName:"cpu",kernelFunc:tB},nB=GP(Gw,(t=>Math.max(0,t))),rB={kernelName:Gw,backendName:"cpu",kernelFunc:nB},aB=GP(Yw,(t=>Math.min(Math.max(0,t),6))),sB={kernelName:Yw,backendName:"cpu",kernelFunc:aB},oB=jP((t=>1/(1+Math.exp(-t)))),iB=GP(cx,(t=>1/(1+Math.exp(-t)))),lB={kernelName:cx,backendName:"cpu",kernelFunc:iB};function cB(t,e,n,r,a){if("linear"===n)return XP({inputs:{x:e},backend:t});if("relu"===n)return nB({inputs:{x:e},backend:t});if("elu"===n)return KP({inputs:{x:e},backend:t});if("relu6"===n)return aB({inputs:{x:e},backend:t});if("prelu"===n)return tB({inputs:{x:e,alpha:r},backend:t});if("leakyrelu"===n)return YP({inputs:{x:e},backend:t,attrs:{alpha:a}});if("sigmoid"===n)return iB({inputs:{x:e},backend:t});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function uB(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}const hB={kernelName:ov,backendName:"cpu",kernelFunc:uB};function dB(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return uB({inputs:{real:dB(t,e,"float32"),imag:dB(t,e,"float32")},backend:t})}const r=wy(Qb(e),n);return t.makeTensorInfo(e,n,r)}function pB(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const fB={kernelName:Vw,backendName:"cpu",kernelFunc:pB};function gB(t,e,n,r){if("int32"===r){return[e,"int32",Int32Array.from(t)]}if("bool"===r){const r=mk([0],n),[a,s]=QP(((t,e)=>t!==e?1:0))(e,[],t,r,"bool");return[s,"bool",a]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(r))}function mB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return XP({inputs:{x:a},backend:n});const t=dB(n,a.shape,a.dtype),e=mB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=uB({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),r}if("complex64"===a.dtype){const t=pB({inputs:{input:a},backend:n}),e=mB({inputs:{x:t},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(t),e}if(!cy(a.dtype,s)){const t=XP({inputs:{x:a},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:s}}const o=n.data.get(a.dataId).values,[i,l,c]=gB(o,a.shape,a.dtype,s);return n.makeTensorInfo(i,l,c)}const bB={kernelName:rv,backendName:"cpu",kernelFunc:mB};function yB(t,e,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:o,b:i}=a,l=s;WP([o,i],t);const c=l.data.get(o.dataId).values,u=l.data.get(i.dataId).values,h="string"===o.dtype?_A(c):c,d="string"===o.dtype?_A(u):u,p=r||o.dtype,[f,g]=e(o.shape,i.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:t=>{let{inputs:a,backend:s}=t;const{a:o,b:i}=a,l=s;if("complex64"===o.dtype||"complex64"===i.dtype){const t=mB({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),e=l.data.get(t.dataId),r=e.complexTensorInfos.real,a=e.complexTensorInfos.imag,s=l.data.get(r.dataId).values,c=l.data.get(a.dataId).values,u=mB({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,[m,b,y]=n(o.shape,i.shape,s,c,f,g),v=l.makeTensorInfo(y,"float32",m),w=l.makeTensorInfo(y,"float32",b),x=uB({inputs:{real:v,imag:w},backend:l});return l.disposeIntermediateTensorInfo(t),l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(w),x}{const t=l.data.get(o.dataId).values,n=l.data.get(i.dataId).values,a=r||o.dtype,[s,c]=e(o.shape,i.shape,t,n,a);return l.makeTensorInfo(c,a,s)}}}function vB(t){return(e,n,r,a,s,o)=>{const i=MI(e,n),l=Qb(i),c=i.length,u=my(i),h=iy("float32",l),d=iy("float32",l),p=zI(e,i),f=zI(n,i),g=QT(r,a),m=QT(s,o),b=e.length,y=my(e),v=n.length,w=my(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const e=x%g.length,n=x%m.length,r=t(g[2*e],g[2*e+1],m[2*n],m[2*n+1]);h[x]=r.real,d[x]=r.imag}else for(let x=0;x<h.length;x++){const e=Iy(x,c,u),n=e.slice(-b);p.forEach((t=>n[t]=0));const r=Sy(n,b,y),a=e.slice(-v);f.forEach((t=>a[t]=0));const s=Sy(a,v,w),o=t(g[2*r],g[2*r+1],m[2*s],m[2*s+1]);h[x]=o.real,d[x]=o.imag}return[h,d,i]}}const wB=QP(((t,e)=>t+e)),xB=vB(((t,e,n,r)=>({real:t+n,imag:e+r}))),kB=yB(My,wB,xB),SB={kernelName:My,backendName:"cpu",kernelFunc:kB};function IB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=Qb(a.shape),i=ay(s,o),l=Qb(i);Jb(o===l,(()=>"The new shape (".concat(i,") has ").concat(l," elements and the old ")+"shape (".concat(a.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(a.dataId);const c=n.data.get(a.dataId);if(null!=c.complexTensorInfos){const t=c.complexTensorInfos.real,e=c.complexTensorInfos.imag;t.shape=i,e.shape=i}return{dataId:a.dataId,shape:i,dtype:a.dtype}}const NB={kernelName:Hw,backendName:"cpu",kernelFunc:IB};function EB(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;WP([a,s],"matMul");const l=a.shape.length,c=s.shape.length,u=o?a.shape[l-2]:a.shape[l-1],h=i?s.shape[c-1]:s.shape[c-2],d=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[c-2]:s.shape[c-1],f=a.shape.slice(0,-2),g=s.shape.slice(0,-2),m=Qb(f),b=Qb(g),y=MI(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);Jb(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(a.shape," and ")+"".concat(s.shape," and transposeA=").concat(o)+" and transposeB=".concat(i," must match.")));const v=i?[b,p,h]:[b,h,p],w=IB({inputs:{x:a},backend:n,attrs:{shape:o?[m,u,d]:[m,d,u]}}),x=IB({inputs:{x:s},backend:n,attrs:{shape:v}}),k=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],I=i?x.shape[1]:x.shape[2],N=Math.max(m,b),E=n.data.get(w.dataId).values,C=n.data.get(x.dataId).values,T=my(w.shape),A=my(x.shape),[R,F,_]=o?[T[0],1,T[1]]:[T[0],T[1],1],[D,O,z]=i?[1,A[1],A[0]]:[A[1],1,A[0]],L=S*I,M=uI([N,S,I],w.dtype),P=M.values,B=n.blockSize;for(let W=0;W<N;W++){const t=W%m,e=W%b;for(let n=0;n<S;n+=B){const r=Math.min(n+B,S);for(let a=0;a<I;a+=B){const s=Math.min(a+B,I);for(let o=0;o<k;o+=B){const i=Math.min(o+B,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=o;a<i;a++){r+=E[t*R+l*F+a*_]*C[a*D+n*O+e*z]}P[W*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(y,M.dtype,M.values)}const CB={kernelName:Qy,backendName:"cpu",kernelFunc:EB};const TB={kernelName:Vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let d,p,f;const g=[];d=EB({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=kB({inputs:{a:d,b:o},backend:n}),g.push(d),d=p),u&&(f=cB(n,d,u,i,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}};function AB(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const RB={kernelName:Oy,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;WP(e,"abs");let r=new Float32Array(Qb(e.shape));return r=AB(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,e.dtype)}},FB=GP(zy,(t=>Math.acos(t))),_B={kernelName:zy,backendName:"cpu",kernelFunc:FB},DB=GP(Ly,(t=>Math.acosh(t))),OB={kernelName:Ly,backendName:"cpu",kernelFunc:DB};const zB={kernelName:Py,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,r=e;WP(e,"addN");const a=r.map((t=>n.data.get(t.dataId).values)),s=uI(r[0].shape,r[0].dtype),o=s.values;for(let i=0;i<r.length;i++){const t=a[i];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function LB(t,e,n,r,a){const s=e.length,o=Qb(e),i=my(e),l=my(a),c=iy(n,Qb(a));for(let u=0;u<o;++u){const e=Iy(u,s,i),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];c[Sy(n,s,l)]=t[u]}return c}function MB(t){const{inputs:e,attrs:n,backend:r}=t,{x:a}=e,{perm:s}=n;WP(a,"transpose");const o=a.shape.length,i=new Array(o);for(let c=0;c<i.length;c++)i[c]=a.shape[s[c]];const l=LB(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:r.write(l,i,a.dtype),shape:i,dtype:a.dtype}}const PB={kernelName:Ox,backendName:"cpu",kernelFunc:MB};const BB={kernelName:By,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;WP(a,"all");const i=sy(s,a.shape);let l=i;const c=NE(l,a.shape.length);let u=a;null!=c&&(u=MB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=CE(l.length,a.shape.length)),IE("all",l,u.shape.length);const[h,d]=kE(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e&&r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=IB({inputs:{x:m},backend:n,attrs:{shape:SE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const WB={kernelName:Wy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;WP(a,"any");const i=sy(s,a.shape);let l=i;const c=NE(l,a.shape.length);let u=a;null!=c&&(u=MB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=CE(l.length,a.shape.length)),IE("any",l,u.shape.length);const[h,d]=kE(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e||r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=IB({inputs:{x:m},backend:n,attrs:{shape:SE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const UB={kernelName:Uy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;WP(a,"argMax");let o=sy(s,a.shape);const i=NE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=MB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=CE(o.length,l.shape.length)),o=[o[0]],IE("argMax",o,l.shape.length);const[u,h]=kE(l.shape,o),d=wy(Qb(u),"int32"),p=Qb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a>e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}};const VB={kernelName:Vy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;WP(a,"argMin");let o=sy(s,a.shape);const i=NE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=MB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=CE(o.length,l.shape.length)),o=[o[0]],IE("argMin",o,l.shape.length);const[u,h]=kE(l.shape,o),d=wy(Qb(u),"int32"),p=Qb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a<e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}},jB=GP(jy,(t=>Math.asin(t))),GB={kernelName:jy,backendName:"cpu",kernelFunc:jB},HB=GP(Gy,(t=>Math.asinh(t))),KB={kernelName:Gy,backendName:"cpu",kernelFunc:HB},qB=GP(Hy,(t=>Math.atan(t))),XB={kernelName:Hy,backendName:"cpu",kernelFunc:qB},JB=QP(((t,e)=>Math.atan2(t,e))),YB=yB(qy,JB),ZB={kernelName:qy,backendName:"cpu",kernelFunc:YB},QB=GP(Ky,(t=>Math.atanh(t))),$B={kernelName:Ky,backendName:"cpu",kernelFunc:QB};function tW(t,e,n,r,a,s){const o=a.strideHeight,i=a.strideWidth,l=a.dilationHeight,c=a.dilationWidth,u=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=uI(a.outShape,n),m=g.values,b=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let w=0;w<a.batchSize;++w){const e=w*b,n=w*r[0];for(let g=0;g<a.inChannels;++g)for(let b=0;b<a.outHeight;++b){const w=b*o-d,x=Math.max(0,w),k=Math.min(a.inHeight,u+w),S=e+b*y;for(let e=0;e<a.outWidth;++e){const o=e*i-p,u=Math.max(0,o),d=Math.min(a.inWidth,h+o);let b=f,y=0,w=0;for(let e=x;e<k;e+=l){const a=n+e*r[1];for(let e=u;e<d;e+=c){const n=t[a+e*r[2]+g];"max"===s&&n>b?b=n:"avg"===s&&(y+=n,w++)}if(isNaN(b))break}m[S+e*v+g]="avg"===s?y/w:b}}}return g}function eW(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=uI(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=uI(e,n,t);for(let m=0;m<r.batchSize;++m)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*i-p;let b=n;for(;b<0;)b+=c;const y=Math.min(r.inHeight,h+n);for(let i=0;i<r.outWidth;++i){const h=i*l-f;let p=h;for(;p<0;)p+=u;const v=Math.min(r.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let e=b;e<y;e+=c){const o=e-n;for(let n=p;n<v;n+=u){const i=n-h,l=g.get(m,e,n,t);l>w&&(w=l,x=a?s?((m*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+i)}}o.set(x,m,e,i,t)}}return o}function nW(t,e,n,r,a,s){const o=a.strideDepth,i=a.strideHeight,l=a.strideWidth,c=a.dilationDepth,u=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,g=a.padInfo.front,m=a.padInfo.top,b=a.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=uI(a.outShape,n),w=v.values,x=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){const e=N*x,n=N*r[0];for(let v=0;v<a.inChannels;++v)for(let x=0;x<a.outDepth;++x){const N=x*o-g;let E=N;for(;E<0;)E+=c;const C=Math.min(a.inDepth,d+N),T=e+x*k;for(let e=0;e<a.outHeight;++e){const o=e*i-m;let d=o;for(;d<0;)d+=u;const g=Math.min(a.inHeight,p+o),x=T+e*S;for(let e=0;e<a.outWidth;++e){const o=e*l-b;let i=o;for(;i<0;)i+=h;const p=Math.min(a.inWidth,f+o),m=x+e*I;let k=y,S=0,N=0;for(let e=E;e<C;e+=c){const a=n+e*r[1];for(let e=d;e<g;e+=u){const n=a+e*r[2];for(let e=i;e<p;e+=h){const a=t[n+e*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[m+v]="avg"===s?S/Math.max(N,1):k}}}}return v}const rW={kernelName:Xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;WP(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(FN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=xN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))u=XP({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=my(a.shape),r=tW(t,a.shape,a.dtype,e,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const aW={kernelName:Yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;WP(a,"avgPool3d");const u=kN(a.shape,s,o,1,i,l,c),h=nW(n.data.get(a.dataId).values,a.shape,a.dtype,my(a.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const sW={kernelName:Zy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;WP([a,s],"avgPool3DGrad");const u=kN(s.shape,o,i,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,w=u.effectiveFilterDepth,x=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=w-1-u.padInfo.front,I=k-1-u.padInfo.left,N=x-1-u.padInfo.top,E=uI(s.shape,"float32"),C=1/(f*g*m),T=n.bufferSync(a);for(let A=0;A<u.batchSize;++A)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-S,s=n-N,o=r-I;let i=0;for(let e=0;e<w;e+=b){const n=(a+e)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let e=0;e<x;e+=y){const r=(s+e)/d;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let e=0;e<k;e+=v){const a=(o+e)/p;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;i+=T.get(A,n,r,a,t)}}}E.set(i*C,A,e,n,r,t)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}};const oW={kernelName:Jy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;WP([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=xN(o.shape,i,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,w=b-1-u.padInfo.top,x=uI(o.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=uI(a.shape,"float32",S);for(let N=0;N<u.batchSize;++N)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inHeight;++e)for(let n=0;n<u.inWidth;++n){const r=e-w,a=n-v;let s=0;for(let e=0;e<b;e+=g){const n=(r+e)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let e=0;e<y;e+=m){const r=(a+e)/d;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;s+=I.get(N,n,r,t)}}x.set(s*k,N,e,n,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const iW={kernelName:Gv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,scale:s,offset:o,mean:i,variance:l}=e;Jb(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),WP([a,i,l,s,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,b=p.length,y=d.length,v=h.length;let w=0,x=0,k=0,S=0;for(let I=0;I<u.length;++I)g[I]=f[w++]+(u[I]-h[x++])*p[k++]/Math.sqrt(d[S++]+c),w>=m&&(w=0),x>=v&&(x=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,g)}};function lW(t,e,n,r,a){const s=dN(r,e,n),o=Qb(n),i=my(r);if(s){const n=pN(e,i);return"string"===a?t.slice(n,n+o):t.subarray(n,n+o)}const l=uI(r,a,"string"===a?_A(t):t),c=uI(n,a);for(let u=0;u<c.size;++u){const t=c.indexToLoc(u),n=t.map(((t,n)=>t+e[n]));c.set(l.get(...n),...t)}return"string"===a?DA(c.values):c.values}function cW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r;WP(a,"slice");const[i,l]=fN(a,s,o);tN(a,i,l);const c=lW(n.data.get(a.dataId).values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}const uW={kernelName:sx,backendName:"cpu",kernelFunc:cW};const hW={kernelName:$y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;WP([a],"batchToSpaceND");const i=s.reduce(((t,e)=>t*e)),l=zT(a.shape,s,i),c=LT(l.length,s.length),u=MT(a.shape,s,i),h=PT(o,s.length),d=BT(u,o,s.length),p=IB({inputs:{x:a},backend:n,attrs:{shape:l}}),f=MB({inputs:{x:p},backend:n,attrs:{perm:c}}),g=IB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=cW({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function dW(t,e,n,r,a){const s=Qb(r),o=wy(a,n);for(let i=0;i<t.length;i++){const n=t[i];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(o[n]+=s>0?e[i]:1)}return o}function pW(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=t.shape[0],s=t.shape[1],o=uI([a,n],e.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=t.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):e.size>0?o.set(o.get(i,s)+e.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}const fW={kernelName:tv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=dW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}},gW=QP(((t,e)=>t&e)),mW={kernelName:ev,backendName:"cpu",kernelFunc:yB(ev,gW)};const bW={kernelName:nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=MI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},yW=jP((t=>Math.ceil(t))),vW=HP(av,yW),wW={kernelName:av,backendName:"cpu",kernelFunc:vW},xW=GP(sv,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),kW={kernelName:sv,backendName:"cpu",kernelFunc:xW},SW={kernelName:iv,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Qb(e.shape)),a=n.data.get(e.dataId),s=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let c=0;c<i.length;c++){const t=i[c],e=l[c];r[c]=Math.hypot(t,e)}return n.makeOutput(r,e.shape,"float32")}};function IW(t,e,n,r){const a=ly(n,Qb(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=Qb(t.shape);a.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const s="string"===n?_A(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const i=n*e[1]+r;for(let e=0;e<t.shape[1];++e)a[i+e]=s[o++]}r+=t.shape[1]}))}return a}function NW(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const EW={kernelName:Zv,backendName:"cpu",kernelFunc:NW};function CW(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=sy(a,e[0].shape)[0];NT(e.map((t=>t.shape)),s);let o=ET(e.map((t=>t.shape)),s);if(0===Qb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Qb(t.shape)>0));if(1===i.length)return XP({inputs:{x:i[0]},backend:n});if("complex64"===i[0].dtype){const t=i.map((t=>pB({inputs:{input:t},backend:n}))),e=i.map((t=>NW({inputs:{input:t},backend:n}))),r=CW({inputs:t,backend:n,attrs:{axis:s}}),a=CW({inputs:e,backend:n,attrs:{axis:s}}),o=uB({inputs:{real:r,imag:a},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}const l=i.map((t=>{const e=Qb(t.shape.slice(s));return IB({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),c=l.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));o=ET(l.map((t=>t.shape)),1);const u=1===l[0].shape[0],h=IW(c,o,e[0].dtype,u),d=ET(i.map((t=>t.shape)),s),p=n.makeTensorInfo(d,e[0].dtype,h);return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}const TW={kernelName:lv,backendName:"cpu",kernelFunc:CW};function AW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r;WP([a,s],"conv2d");const h=DN(l),d=SN(a.shape,s.shape,o,c,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new Dk(d.outShape,a.dtype),x=my(a.shape),k=my(s.shape),S=x[0],I=v?x[1]:x[2],N=v?x[2]:1,E=v?1:x[1],C=w.strides[0],T=v?w.strides[1]:w.strides[2],A=v?w.strides[2]:1,R=v?1:w.strides[1],F=n.data.get(a.dataId).values,_=n.data.get(s.dataId).values,D=w.values;for(let O=0;O<d.batchSize;++O){const t=O*S,e=O*C;for(let n=0;n<d.outHeight;++n){const r=e+n*T,a=n*d.strideHeight-y;for(let e=0;e<p;++e){const n=a+e*g;if(n<0||n>=d.inHeight)continue;const s=e*k[0],o=t+n*I;for(let t=0;t<d.outWidth;++t){const e=r+t*A,n=t*d.strideWidth-b;for(let t=0;t<f;++t){const r=n+t*m;if(r<0||r>=d.inWidth)continue;const a=o+r*N;let i=s+t*k[1];for(let t=0;t<d.inChannels;++t){const n=F[a+t*E];for(let t=0;t<d.outChannels;++t)D[e+t*R]+=n*_[i+t];i+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,D)}const RW={kernelName:cv,backendName:"cpu",kernelFunc:AW};const FW={kernelName:uv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;WP([a,s],"conv2dBackpropFilter");const h=DN(l),d=SN(a.shape,u,o,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,y=new Dk(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new Dk(a.shape,a.dtype,x),I=new Dk(s.shape,s.dtype,k);for(let N=0;N<g;++N){const t=Math.max(0,Math.ceil((w-N)/p)),e=Math.min(d.outHeight,(d.inHeight+w-N)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let s=0;s<d.inChannels;++s)for(let o=0;o<d.outChannels;++o){let i=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<e;++c){const t=N+c*p-w;for(let e=r;e<a;++e){const r=n+e*f-v;i+=b?S.get(l,t,r,s)*I.get(l,c,e,o):S.get(l,s,t,r)*I.get(l,o,c,e)}}y.set(i,N,n,s,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const _W={kernelName:hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r;WP([a,s],"conv2dBackpropInput");const h=my(s.shape),d=my(a.shape);let p=DN(c);const f=SN(o,s.shape,i,1,l,u,!1,p),g=new Dk(f.inShape,"float32"),m=g.values,b=n.data.get(a.dataId).values,y=n.data.get(s.dataId).values,[v,w,x]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:E,inWidth:C,outChannels:T,outHeight:A,outWidth:R,strideHeight:F,strideWidth:_}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,O=I-1-f.padInfo.left,z="channelsLast"===p,L=g.strides[0],M=z?g.strides[1]:g.strides[2],P=z?g.strides[2]:1,B=z?1:g.strides[1],W=d[0],U=z?d[1]:d[2],V=z?d[2]:1,j=z?1:d[1];for(let G=0;G<k;++G)for(let t=0;t<N;++t)for(let e=0;e<E;++e){const n=e-D,r=Math.max(0,Math.ceil(n/F)),a=Math.min(A,(S+n)/F);for(let s=0;s<C;++s){const o=s-O,i=Math.max(0,Math.ceil(o/_)),l=Math.min(R,(I+o)/_);let c=0;for(let e=r;e<a;++e){const r=e*F-n;for(let n=i;n<l;++n){const a=W*G+U*e+V*n,s=v*(S-1-r)+w*(I-1-(n*_-o))+x*t;for(let t=0;t<T;++t){c+=b[a+j*t]*y[s+t]}}}m[L*G+M*e+P*s+B*t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const DW={kernelName:dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r;WP([a,s],"conv3d");const c=IN(a.shape,s.shape,o,l,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,b=m.front,y=m.left,v=m.top,w=new Dk(c.outShape,a.dtype),x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=w.values,I=my(a.shape),N=my(s.shape);for(let E=0;E<c.batchSize;++E){const t=E*I[0],e=E*w.strides[0];for(let n=0;n<c.outDepth;++n){const r=e+n*w.strides[1],a=n*c.strideDepth-b;for(let e=0;e<u;++e){const n=a+e*p;if(n<0||n>=c.inDepth)continue;const s=e*N[0],o=t+n*I[1];for(let t=0;t<c.outHeight;++t){const e=r+t*w.strides[2],n=t*c.strideHeight-v;for(let t=0;t<h;++t){const r=n+t*f;if(r<0||r>=c.inHeight)continue;const a=s+t*N[1],i=o+r*I[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,r=t*c.strideWidth-y;for(let t=0;t<d;++t){const e=r+t*g;if(e<0||e>=c.inWidth)continue;const s=a+t*N[2],o=i+e*c.inChannels;let l=s;for(let t=0;t<c.inChannels;++t){const e=x[o+t];for(let t=0;t<c.outChannels;++t)S[n+t]+=e*k[l+t];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const OW={kernelName:pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r;WP([a,s],"conv3dBackpropFilterV2");const c=my(a.shape),u=my(s.shape),h=IN(a.shape,l,o,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,y=new Dk(h.filterShape,"float32"),v=y.values,[w,x,k,S]=y.strides,I=n.data.get(s.dataId).values,[N,E,C,T]=u,A=n.data.get(a.dataId).values,[R,F,_,D]=c,O=h.padInfo.front,z=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<g;++M){const t=Math.max(0,Math.ceil((O-M)/d)),e=Math.min(h.outDepth,(h.inDepth+O-M)/d),n=M*w;for(let r=0;r<m;++r){const a=Math.max(0,Math.ceil((L-r)/p)),s=Math.min(h.outHeight,(h.inHeight+L-r)/p),o=r*x+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((z-n)/f)),l=Math.min(h.outWidth,(h.inWidth+z-n)/f),c=n*k+o;for(let o=0;o<h.inChannels;++o){const u=o*S+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let u=0;u<h.batchSize;++u){const h=u*R,m=u*N;for(let u=t;u<e;++u){const t=(M+u*d-O)*F+h,e=u*E+m;for(let u=a;u<s;++u){const a=(r+u*p-L)*_+t,s=u*C+e;for(let t=i;t<l;++t){const e=t*T+s;g+=A[(n+t*f-z)*D+a+o]*I[e+c]}}}}v[u+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const zW={kernelName:fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r;WP([a],"conv3dBackpropInputV2");const c=my(a.shape),u=my(s.shape),h=IN(l,s.shape,i,1,o),d=new Dk(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,y=n.data.get(a.dataId).values,[v,w,x,k]=c,S=n.data.get(s.dataId).values,[I,N,E,C]=u,{batchSize:T,filterDepth:A,filterHeight:R,filterWidth:F,inChannels:_,inDepth:D,inHeight:O,inWidth:z,outChannels:L,outDepth:M,outHeight:P,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,j=A-1-h.padInfo.front,G=R-1-h.padInfo.top,H=F-1-h.padInfo.left;for(let K=0;K<T;++K)for(let t=0;t<_;++t)for(let e=0;e<D;++e){const n=e-j,r=Math.max(0,Math.ceil(n/W)),a=Math.min(M,(A+n)/W);for(let s=0;s<O;++s){const o=s-G,i=Math.max(0,Math.ceil(o/U)),l=Math.min(P,(R+o)/U);for(let c=0;c<z;++c){const u=c-H,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(F+u)/V);let T=0;for(let e=r;e<a;++e){const r=e*W-n;for(let n=i;n<l;++n){const a=n*U-o;for(let s=h;s<d;++s){const o=v*K+w*e+x*n+k*s,i=I*(A-1-r)+N*(R-1-a)+E*(F-1-(s*V-u))+C*t;for(let t=0;t<L;++t){T+=y[o+t]*S[i+t]}}}}p[f*K+g*e+m*s+b*c+t]=T}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},LW=GP(gv,(t=>Math.cos(t))),MW={kernelName:gv,backendName:"cpu",kernelFunc:LW},PW=GP(mv,(t=>Math.cosh(t))),BW={kernelName:mv,backendName:"cpu",kernelFunc:PW};const WW={kernelName:vv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,[u,h,d,p]=a.shape,f=s.shape[0],[g,m]=i,b=uI([f,g,m,p],"float32"),y=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(a.dataId).values,x=my(a.shape),k=my(b.shape);for(let S=0;S<f;S++){const t=4*S,e=y[t],n=y[t+1],r=y[t+2],a=y[t+3],s=v[S];if(s>=u)continue;const o=g>1?(r-e)*(h-1)/(g-1):0,i=m>1?(a-n)*(d-1)/(m-1):0;for(let u=0;u<g;u++){const t=g>1?e*(h-1)+u*o:.5*(e+r)*(h-1);if(t<0||t>h-1)for(let e=0;e<m;e++)for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}else if("bilinear"===l){const e=Math.floor(t),r=Math.ceil(t),o=t-e;for(let t=0;t<m;t++){const l=m>1?n*(d-1)+t*i:.5*(n+a)*(d-1);if(l<0||l>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let a=n+h*x[2]+e*x[1]+s*x[0];const i=w[a];a=n+f*x[2]+e*x[1]+s*x[0];const l=w[a];a=n+h*x[2]+r*x[1]+s*x[0];const c=w[a];a=n+f*x[2]+r*x[1]+s*x[0];const d=i+(l-i)*g,p=c+(w[a]-c)*g;a=n+t*k[2]+u*k[1]+S*k[0],b.values[a]=d+(p-d)*o}}}else for(let e=0;e<m;++e){const r=m>1?n*(d-1)+e*i:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const o=Math.round(r),l=Math.round(t);for(let t=0;t<p;t++){const n=t+o*x[2]+l*x[1]+s*x[0],r=t+e*k[2]+u*k[1]+S*k[0];b.values[r]=w[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const UW={kernelName:bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;WP(a,"cumprod");const l=NE([s],a.shape.length);let c=a;null!=l&&(c=MB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=CE(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Kk(c.dtype,"int32"),d=vy(Qb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?1:p[e];else{const n=g(b,t-1);d[e]=o?p[n]*d[n]:p[e]*d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=MB({inputs:{x:m},backend:n,attrs:{perm:EE(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const VW={kernelName:yv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;WP(a,"cumsum");const l=NE([s],a.shape.length);let c=a;null!=l&&(c=MB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=CE(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Kk(c.dtype,"int32"),d=wy(Qb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?0:p[e];else{const n=g(b,t-1);d[e]=o?p[n]+d[n]:p[e]+d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=MB({inputs:{x:m},backend:n,attrs:{perm:EE(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const jW={kernelName:wv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=dW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,t)}if(2===a.shape.length){const t=pW(n.bufferSync(a),n.bufferSync(s),o,i);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};const GW={kernelName:xv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r;Jb("NHWC"===o,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)));const i=a.shape[0],l=a.shape[1],c=a.shape[2],u=a.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(a.dataId).values,g=new Float32Array(i*h*d*p);let m=0;for(let b=0;b<i;++b)for(let t=0;t<h;++t){const e=Math.floor(t/s),n=t%s;for(let t=0;t<d;++t){const r=Math.floor(t/s),a=(n*s+t%s)*p;for(let t=0;t<p;++t){const n=t+a+u*(r+c*(e+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],a.dtype,g)}};function HW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;WP([a,s],"depthwiseConv2DNative");const u=my(a.shape),h=my(s.shape);let d=l;null==d&&(d=[1,1]),Jb(FN(o,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'")));const p=SN(a.shape,s.shape,o,d,i,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:y}=p,v=y.left,w=y.top,x=p.outChannels/p.inChannels,k=new Dk(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let E=0;E<p.batchSize;++E){const t=E*u[0],e=E*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=e+n*k.strides[1],a=n*p.strideHeight-w;for(let e=0;e<f;++e){const n=a+e*m;if(n<0||n>=p.inHeight)continue;const s=e*h[0],o=t+n*u[1];for(let t=0;t<p.outWidth;++t){const e=r+t*k.strides[2],n=t*p.strideWidth-v;for(let t=0;t<g;++t){const r=n+t*b;if(r<0||r>=p.inWidth)continue;const a=s+t*h[1],i=o+r*p.inChannels;let l=e,c=a;for(let t=0;t<p.inChannels;++t){const e=S[i+t];for(let t=0;t<x;++t)N[l+t]+=e*I[c+t];l+=x,c+=x}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const KW={kernelName:kv,backendName:"cpu",kernelFunc:HW};const qW={kernelName:Sv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r;WP([a,s],"depthwiseConv2dNativeBackpropFilter");const h=SN(a.shape,u,o,i,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new Dk(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(a.dataId).values,x=new Dk(a.shape,a.dtype,w),k=n.data.get(s.dataId).values,S=new Dk(s.shape,s.dtype,k);for(let I=0;I<f;++I){const t=Math.max(0,Math.ceil((y-I)/d)),e=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((b-n)/p)),a=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/v),i=s%v;let l=0;for(let c=0;c<h.batchSize;++c)for(let i=t;i<e;++i){const t=I+i*d-y;for(let e=r;e<a;++e){const r=n+e*p-b;l+=x.get(c,t,r,o)*S.get(c,i,e,s)}}m.set(l,I,n,o,i)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const XW={kernelName:Iv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r;WP([a,s],"depthwiseConv2DNativeBackpropInput");const h=my(a.shape),d=my(s.shape),p=SN(u,s.shape,o,i,l,c,!0),f=new Dk(p.inShape,"float32"),g=f.values,[m,b,y]=f.strides,v=n.data.get(a.dataId).values,[w,x,k]=h,S=n.data.get(s.dataId).values,[I,N,E]=d,{batchSize:C,filterHeight:T,filterWidth:A,inChannels:R,inHeight:F,inWidth:_,outChannels:D,outHeight:O,outWidth:z,strideHeight:L,strideWidth:M}=p,P=T-1-p.padInfo.top,B=A-1-p.padInfo.left,W=D/R;for(let U=0;U<C;++U)for(let t=0;t<R;++t)for(let e=0;e<F;++e){const n=e-P,r=Math.max(0,Math.ceil(n/L)),a=Math.min(O,(T+n)/L);for(let s=0;s<_;++s){const o=s-B,i=Math.max(0,Math.ceil(o/M)),l=Math.min(z,(A+o)/M);let c=0;for(let e=r;e<a;++e){const r=e*L-n;for(let n=i;n<l;++n){const a=w*U+x*e+k*n,s=I*(T-1-r)+N*(A-1-(n*M-o))+E*t;for(let e=0;e<W;++e){c+=v[a+(t*W+e)]*S[s+e]}}}g[m*U+b*e+y*s+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const JW={kernelName:Nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=Qb(r.shape),s=n.data.get(r.dataId).values,o=uI([a,a],r.dtype),i=o.values;for(let c=0;c<s.length;c++)i[c*a+c]=s[c];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},YW={kernelName:Ev,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=n,u=c.data.get(a.dataId).values,h=a.shape.length,d=c.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:b,outHeight:y,outWidth:v,padInfo:w,strideHeight:x,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:E,outShape:C}=wN(a.shape,s.shape,o,i,"NHWC",l),T=Qb(C),A=C.length,R=ly(a.dtype,T);for(let F=0;F<f;++F)for(let t=0;t<y;++t){const e=t*x-w.top;for(let n=0;n<v;++n){const r=n*k-w.left;for(let o=0;o<b;++o){let i=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*N;if(n>=0&&n<g)for(let e=0;e<I;++e){const l=r+e*E;if(l>=0&&l<m){const r=Sy([F,n,l,o],h,my(a.shape)),c=Sy([t,e,o],p,my(s.shape)),f=u[r]+d[c];f>i&&(i=f)}}}R[Sy([F,t,n,o],A,my(C))]=i}}}return{dataId:c.write(mk(R,a.dtype),C,a.dtype),shape:C,dtype:a.dtype}}},ZW={kernelName:Tv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=yy(a.shape,u.data.get(a.dataId).values),d=yy(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:E}=wN(a.shape,s.shape,i,l,"NHWC",c);Jb(o.rank===E.length,(()=>"Error in ".concat(Tv,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(o.rank)));const C=yy(E,u.data.get(o.dataId).values),T=xy(s.shape,s.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=t,i=e)}}}T[o][i][a]+=C[A][t][n][a]}}}return{dataId:u.write(mk(T,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},QW={kernelName:Cv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=yy(a.shape,u.data.get(a.dataId).values),d=yy(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:E}=wN(a.shape,s.shape,i,l,"NHWC",c);Jb(o.rank===E.length,(()=>"Error in ".concat(Cv,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(o.rank)));const C=yy(E,u.data.get(o.dataId).values),T=xy(a.shape,a.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=e<0?0:e,i=r<0?0:r;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=n,i=l)}}}T[A][o][i][a]+=C[A][t][n][a]}}}return{dataId:u.write(mk(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const $W={kernelName:Av,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a}=e,{canvas:s,options:o}=r,{contextOptions:i,imageOptions:l}=o||{},c=(null===l||void 0===l?void 0:l.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const h=s.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],g=n.data.get(a.dataId).values,m="float32"===a.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const t=[0,0,0,255*c];for(let n=0;n<f;n++){const e=g[v*f+n];if("float32"===a.dtype){if(e<0||e>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(e,"."))}else if("int32"===a.dtype&&(e<0||e>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(e,"."));1===f?(t[0]=e*m,t[1]=e*m,t[2]=e*m):t[n]=e*m}const e=4*v;b[e+0]=Math.round(t[0]),b[e+1]=Math.round(t[1]),b[e+2]=Math.round(t[2]),b[e+3]=Math.round(t[3])}s.width=p,s.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),a}},tU=QP(((t,e)=>t*e)),eU=vB(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),nU=yB(Nw,tU,eU),rU={kernelName:Nw,backendName:"cpu",kernelFunc:nU};function aU(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;let i;WP(a,"sum"),i="bool"===a.dtype?mB({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):XP({inputs:{x:a},backend:n});const l=i.shape.length,c=sy(s,i.shape),u=NE(c,l);let h=c,d=i;null!=u&&(d=MB({inputs:{x:i},backend:n,attrs:{perm:u}}),h=CE(h.length,l)),IE("sum",h,d.shape.length);const[p,f]=kE(d.shape,h);let g=dB(n,p,Kk(d.dtype,"int32"));const m=Qb(f),b=n.data.get(g.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const t=v*m;let e=0;for(let n=0;n<m;++n)e+=y[t+n];b[v]=e}if(o){const t=g;g=IB({inputs:{x:g},backend:n,attrs:{shape:SE(g.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),g}const sU={kernelName:dx,backendName:"cpu",kernelFunc:aU};const oU={kernelName:Fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=uA(a,s.length);dA(o.length,l,s);const{path:c,steps:u}=pA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=hA(p,l[t]);let a;fA(e)?a=s[t]:(a=MB({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);$b(a.shape,o)||(a=IB({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=nU({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=aU({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}};const iU={kernelName:Dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:a}=e;WP([r,a],"eluGrad");const s=new Float32Array(Qb(a.shape)),o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const t=o[l];s[l]=t>=0?i[l]:i[l]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},lU=QP(((t,e)=>t===e?1:0)),cU=yB(zv,lU,null,"bool"),uU={kernelName:zv,backendName:"cpu",kernelFunc:cU},hU=KT,dU=qT,pU=XT,fU=JT,gU=YT,mU=ZT,bU=GP(Ov,(t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+hU*n);return e*(1-((((mU*r+gU)*r+fU)*r+pU)*r+dU)*r*Math.exp(-n*n))})),yU={kernelName:Ov,backendName:"cpu",kernelFunc:bU},vU=jP((t=>Math.exp(t))),wU=HP(Lv,vU,"float32"),xU={kernelName:Lv,backendName:"cpu",kernelFunc:wU};function kU(t){const{inputs:e,backend:n,attrs:r}=t,{input:a}=e,{dim:s}=r,o=a.shape.length,i=a.shape.slice();let l=s;return s<0&&(Jb(-(o+1)<=s,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+s+1),i.splice(l,0,1),IB({inputs:{x:a},backend:n,attrs:{shape:i}})}const SU={kernelName:Mv,backendName:"cpu",kernelFunc:kU},IU=jP((t=>Math.expm1(t))),NU=HP(Pv,IU),EU={kernelName:Pv,backendName:"cpu",kernelFunc:NU},CU=QP(((t,e)=>t/e)),TU=yB(Rv,CU),AU={kernelName:Rv,backendName:"cpu",kernelFunc:TU},RU=QP(((t,e)=>t-e)),FU=vB(((t,e,n,r)=>({real:t-n,imag:e-r}))),_U=yB(Tx,RU,FU),DU={kernelName:Tx,backendName:"cpu",kernelFunc:_U};function OU(t,e,n){const r=t.shape,a=r[0],s=r[1],o=n.data.get(t.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[a,s],u=Qb(c),h=iy("float32",u),d=iy("float32",u);for(let m=0;m<a;m++){const t=cW({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,s]}}),r=cW({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,s]}}),a=uB({inputs:{real:t,imag:r},backend:n}),{real:o,imag:c}=zU(a,e,n),u=QT(o,c);for(let e=0;e<s;e++){const t=nA(u,e);h[m*s+e]=t.real,d[m*s+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),g=uB({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function zU(t,e,n){const r=Qb(t.shape),a=n.data.get(t.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((i=r)&i-1)){const a=LU(s,o,r,e,n),i=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(i,"float32",a.real),e=n.makeTensorInfo(i,"float32",a.imag),s=n.makeTensorInfo([],"float32",gk(r,"float32")),o=XP({inputs:{x:s},backend:n}),l=AU.kernelFunc({inputs:{a:t,b:s},backend:n}),c=AU.kernelFunc({inputs:{a:e,b:o},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return a}{const t=function(t,e,n){const r=new Float32Array(2*e);for(let a=0;a<e;a++){let s=0,o=0;for(let r=0;r<e;r++){const i=sA(a*r,e,n),l=nA(t,r);s+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(s/=e,o/=e),rA(r,s,o,a)}return r}(QT(s,o),r,e);return $T(t)}var i}function LU(t,e,n,r,a){if(1===n)return{real:t,imag:e};const s=QT(t,e),o=n/2,i=tA(s),l=i.real,c=i.imag,u=[l.length],h=a.makeTensorInfo(u,"float32",l),d=a.makeTensorInfo(u,"float32",c),p=uB({inputs:{real:h,imag:d},backend:a}),f=eA(s),g=f.real,m=f.imag,b=[g.length],y=a.makeTensorInfo(b,"float32",g),v=a.makeTensorInfo(b,"float32",m),w=uB({inputs:{real:y,imag:v},backend:a}),x=LU(l,c,o,r,a),k=x.real,S=x.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),E=a.makeTensorInfo(I,"float32",S),C=uB({inputs:{real:N,imag:E},backend:a}),T=LU(g,m,o,r,a),A=T.real,R=T.imag,F=[A.length],_=a.makeTensorInfo(F,"float32",A),D=a.makeTensorInfo(F,"float32",R),O=uB({inputs:{real:_,imag:D},backend:a}),z=aA(n,r),L=[z.real.length],M=a.makeTensorInfo(L,"float32",z.real),P=a.makeTensorInfo(L,"float32",z.imag),B=uB({inputs:{real:M,imag:P},backend:a}),W=nU({inputs:{a:B,b:O},backend:a}),U=kB({inputs:{a:C,b:W},backend:a}),V=_U({inputs:{a:C,b:W},backend:a}),j=pB({inputs:{input:U},backend:a}),G=pB({inputs:{input:V},backend:a}),H=NW({inputs:{input:U},backend:a}),K=NW({inputs:{input:V},backend:a}),q=CW({inputs:[j,G],backend:a,attrs:{axis:0}}),X=CW({inputs:[H,K],backend:a,attrs:{axis:0}}),J=a.data.get(q.dataId).values,Y=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(O),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(X),{real:J,imag:Y}}const MU={kernelName:Bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Qb(r.shape),s=r.shape[r.shape.length-1],o=IB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=OU(o,!1,n),l=IB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}};function PU(t){const{backend:e,attrs:n}=t,{shape:r,value:a,dtype:s}=n,o=s||py(a),i=ly(o,Qb(r));return function(t,e,n){t.fill(e)}(i,a),e.makeTensorInfo(r,o,i)}const BU={kernelName:Wv,backendName:"cpu",kernelFunc:PU};const WU={kernelName:Uv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,s=r,o=iy(a.dtype,Qb(a.shape)),[i,l,c,u]=a.shape,h=s.data.get(a.dataId).values;for(let d=0;d<i;d++){const t=d*c*l*u;for(let e=0;e<l;e++){const n=e*(c*u);for(let e=0;e<c;e++){const r=e*u;for(let a=0;a<u;a++){const s=Math.round(c-e-1),i=t+n+r+a;let l=h[i];if(s>=0&&s<c){l=h[t+n+s*u+a]}o[i]=l}}}}return{dataId:s.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},UU=jP((t=>Math.floor(t))),VU=HP(Vv,UU),jU={kernelName:Vv,backendName:"cpu",kernelFunc:VU},GU=QP(((t,e)=>Math.floor(t/e))),HU=yB(jv,GU,null,"int32"),KU={kernelName:jv,backendName:"cpu",kernelFunc:HU};const qU={kernelName:jx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=AW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const t=IB({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=kB({inputs:{a:g,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else g=kB({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=g;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const t=IB({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=cB(n,g,p,t,f),n.disposeIntermediateTensorInfo(t)}else g=cB(n,g,p,i,f);n.disposeIntermediateTensorInfo(t)}return g}};const XU={kernelName:Gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=HW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;g=kB({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=g;g=cB(n,g,p,i,f),n.disposeIntermediateTensorInfo(t)}return g}};function JU(t,e,n,r,a,s,o,i,l){const c=uI([r,s],n);for(let u=0;u<r;u++){const n=[];let r=0;for(let e=0;e<a;e++){const s=t[u*a+e];r+=s*o[e],n.push(s)}if(r<0||r>=l/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let t=0;t<s;t++)c.values[u*s+t]=e.get(...e.indexToLoc(r*s+t))}return c}const YU={kernelName:Kv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=Qb(r.shape),o=a.shape,i=o[o.length-1],[l,c,u,h]=WT(r,a);if(0===c)return n.makeTensorInfo(l,r.dtype,[]);const d=JU(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,c,i,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}};function ZU(t,e,n){const r=uI(n,t.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],o=n[2],i=e.locToIndex([s,o]);n[2]=e.values[i];const l=t.locToIndex(n);0<=l&&l<t.values.length&&(r.values[a]=t.values[l])}return r}const QU={kernelName:Hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r;WP([a,s],"gatherV2");const l=sy(o,a.shape)[0],c=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<c.length;++v){const t=c[v];Jb(t<=u-1&&t>=0,(()=>"GatherV2: the index value ".concat(t," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=Qb(s.shape),p=FA(a,s,l,h),f=IB({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=IB({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),y=ZU(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},$U=QP(((t,e)=>t>e?1:0)),tV=yB(qv,$U,null,"bool"),eV={kernelName:qv,backendName:"cpu",kernelFunc:tV},nV=QP(((t,e)=>t>=e?1:0)),rV=yB(Xv,nV,null,"bool"),aV={kernelName:Xv,backendName:"cpu",kernelFunc:rV};const sV={kernelName:Yv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Qb(r.shape),s=r.shape[r.shape.length-1],o=IB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=OU(o,!0,n),l=IB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}},oV=GP(Qv,(t=>Number.isFinite(t)?1:0),"bool"),iV={kernelName:Qv,backendName:"cpu",kernelFunc:oV},lV=GP($v,(t=>Math.abs(t)===1/0?1:0),"bool"),cV={kernelName:$v,backendName:"cpu",kernelFunc:lV},uV=GP(tw,(t=>Number.isNaN(t)?1:0),"bool"),hV={kernelName:tw,backendName:"cpu",kernelFunc:uV},dV=QP(((t,e)=>t<e?1:0)),pV=yB(nw,dV,null,"bool"),fV={kernelName:nw,backendName:"cpu",kernelFunc:pV},gV=QP(((t,e)=>t<=e?1:0)),mV=yB(rw,gV,null,"bool"),bV={kernelName:rw,backendName:"cpu",kernelFunc:mV};function yV(t,e,n){const r=(e-t)/(n-1),a=wy(n,"float32");a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const vV={kernelName:aw,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=yV(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},wV=jP((t=>Math.log(t))),xV=HP(sw,wV),kV={kernelName:sw,backendName:"cpu",kernelFunc:xV},SV=GP(ow,(t=>Math.log1p(t))),IV={kernelName:ow,backendName:"cpu",kernelFunc:SV},NV=QP(((t,e)=>t&&e)),EV=yB(iw,NV,null,"bool"),CV={kernelName:iw,backendName:"cpu",kernelFunc:EV},TV=GP(lw,(t=>t?0:1),"bool"),AV={kernelName:lw,backendName:"cpu",kernelFunc:TV},RV=QP(((t,e)=>t||e)),FV=yB(cw,RV,null,"bool"),_V={kernelName:cw,backendName:"cpu",kernelFunc:FV};const DV={kernelName:uw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r;WP(a,"LRN");const c=a.shape[3],u=c-1,h=n.data.get(a.dataId).values,d=Qb(a.shape),p=new Float32Array(d);function f(t){const e=t%c;let n=t-e+Math.max(0,e-s);const r=t-e+Math.min(e+s,u);let a=0;for(;n<=r;n++){const t=h[n];a+=t*t}return a}for(let g=0;g<d;g++){const t=f(g),e=h[g]*Math.pow(o+i*t,-l);p[g]=e}return n.makeTensorInfo(a.shape,a.dtype,p)}};const OV={kernelName:hw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r;WP(o,"LRNGrad");const h=Qb(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(a.dataId).values,g=n.data.get(s.dataId).values,m=new Float32Array(h),b=h;for(let y=0;y<b;y++){const t=y%d,e=y-t+Math.max(0,t-i),n=y-t+Math.min(d,t+i+1);let r=0;for(let a=e;a<n;a++)r+=Math.pow(f[a],2);r=c*r+l;for(let a=e;a<n;a++){let t=-2*c*u*f[a]*g[y]/r;y===a&&(t+=Math.pow(r,-u)),t*=p[y],m[a]+=t}}return n.makeTensorInfo(o.shape,a.dtype,m)}};function zV(t,e,n,r){const a=iy(r,Qb(n));for(let s=0;s<a.length;++s){const n=s*e;let r=t[n];for(let a=0;a<e;++a){const e=t[n+a];(Number.isNaN(e)||e>r)&&(r=e)}a[s]=r}return a}function LV(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=n;let l=a.shape;const c=l.length,u=sy(s,l);let h=u;const d=NE(h,c);let p=i.data.get(a.dataId).values;if(null!=d){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=LB(p,l,a.dtype,d,t),h=CE(h.length,c),l=t}WP(a,"max"),IE("max",h,c);const[f,g]=kE(l,h),m=zV(p,Qb(g),f,a.dtype),b=i.write(m,f,a.dtype);let y=f;if(o){y=SE(f,u)}return{dataId:b,shape:y,dtype:a.dtype}}const MV={kernelName:dw,backendName:"cpu",kernelFunc:LV},PV=QP(((t,e)=>Math.max(t,e))),BV=yB(pw,PV),WV={kernelName:pw,backendName:"cpu",kernelFunc:BV};const UV={kernelName:fw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;WP(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(FN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=xN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))u=XP({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=my(a.shape),r=tW(t,a.shape,a.dtype,e,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const VV={kernelName:mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;WP(a,"maxPool3d");const u=kN(a.shape,s,o,1,i,l,c),h=nW(n.data.get(a.dataId).values,a.shape,a.dtype,my(a.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const jV={kernelName:bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;WP([a,s],"maxPool3DGrad");const u=kN(s.shape,o,i,1,l,c),h=function(t,e){const n=uI(e.outShape,"int32"),r=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let b=0;b<e.outDepth;++b){const y=b*r-d;let v=y;for(;v<0;)v+=o;const w=Math.min(e.inDepth,c+y);for(let r=0;r<e.outHeight;++r){const c=r*a-p;let d=c;for(;d<0;)d+=i;const x=Math.min(e.inHeight,u+c);for(let a=0;a<e.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(e.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let e=v;e<w;e+=o){const n=e-y;for(let r=d;r<x;r+=i){const a=r-c;for(let s=k;s<S;s+=l){const o=s-p,i=t.get(g,e,r,s,m);i>=I&&(I=i,N=n*u*h+a*u+o)}}}n.set(N,g,b,r,a,m)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,m=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,x=y-1-u.padInfo.front,k=w-1-u.padInfo.left,S=v-1-u.padInfo.top,I=uI(s.shape,"float32"),N=n.bufferSync(a);for(let E=0;E<u.batchSize;++E)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-x,s=n-S,o=r-k;let i=0;for(let e=0;e<y;e+=g){const n=(a+e)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=m){const a=(s+r)/p;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let s=0;s<w;s+=b){const l=(o+s)/f;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const c=y*v*w-1-h.get(E,n,a,l,t)===e*v*w+r*w+s?1:0;if(0===c)continue;i+=N.get(E,n,a,l,t)*c}}}I.set(i,E,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const GV={kernelName:gw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;WP([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=xN(i.shape,l,c,1,u,h),p=n.data.get(i.dataId).values,f=uI(d.outShape,i.dtype,eW(p,i.shape,i.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,k=v-1-d.padInfo.top,S=uI(i.shape,"float32"),I=n.data.get(a.dataId).values,N=uI(a.shape,"float32",I);for(let E=0;E<d.batchSize;++E)for(let t=0;t<d.inChannels;++t)for(let e=0;e<d.inHeight;++e)for(let n=0;n<d.inWidth;++n){const r=e-k,a=n-x;let s=0;for(let e=0;e<v;e+=b){const n=(r+e)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<w;r+=y){const o=(a+r)/m;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const i=v*w-1-f.get(E,n,o,t)===e*w+r?1:0;if(0===i)continue;s+=N.get(E,n,o,t)*i}}S.set(s,E,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const HV={kernelName:yw,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;WP(a,"MaxPoolWithArgmax");const u=c.data.get(a.dataId).values,h=xN(a.shape,s,o,[1,1],i),[d,p]=function(t,e,n,r,a){const s=tW(t,0,n,my(e),a,"max"),o=eW(t,e,n,a,!0,r);return[s.values,o.values]}(u,a.shape,a.dtype,l,h),f=c.write(d,h.outShape,a.dtype),g=c.write(p,h.outShape,a.dtype);return[{dataId:f,shape:h.outShape,dtype:a.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const KV={kernelName:vw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=sy(s,a.shape),l=Qb(kE(a.shape,i)[1]),c=[],u=n.makeTensorInfo([],"float32",new Float32Array([l]));c.push(u);const h=mB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const d=TU({inputs:{a:h,b:u},backend:n});c.push(d);const p=aU({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}};const qV={kernelName:ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;WP(a,"min");const i=sy(s,a.shape);let l=i;const c=NE(l,a.shape.length);let u=a;null!=c&&(u=MB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=CE(l.length,a.shape.length)),IE("min",l,u.shape.length);const[h,d]=kE(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];(Number.isNaN(r)||r<e)&&(e=r)}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=IB({inputs:{x:m},backend:n,attrs:{shape:SE(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}},XV=QP(((t,e)=>Math.min(t,e))),JV=yB(xw,XV),YV={kernelName:xw,backendName:"cpu",kernelFunc:JV};const ZV={kernelName:kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,mode:o}=r;WP(a,"mirrorPad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=s.map(((t,e)=>t[0]+a.shape[e])),u="reflect"===o?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=my(a.shape),f=Qb(i),g=i.length,m=my(i),b=iy(a.dtype,f);for(let y=0;y<f;y++){let t=Iy(y,g,m);for(let n=0;n<g;n++)t[n]<l[n]?t[n]=2*l[n]-t[n]-u:t[n]>=c[n]&&(t[n]=2*(c[n]-1)-t[n]+u);t=t.map(((t,e)=>t-l[e]));const e=Sy(t,d,p);b[y]=h[e]}return{dataId:n.write(b,i,a.dtype),shape:i,dtype:a.dtype}}},QV=QP(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),$V=yB(Sw,QV),tj={kernelName:Sw,backendName:"cpu",kernelFunc:$V};function ej(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=a.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(i));const l=sy([i],a.shape),c=LV({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=SE(c.shape,l),h=IB({inputs:{x:c},backend:n,attrs:{shape:u}}),d=_U({inputs:{a:a,b:h},backend:n}),p=wU({inputs:{x:d},backend:n}),f=aU({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=IB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=TU({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const nj={kernelName:gx,backendName:"cpu",kernelFunc:ej};const rj={kernelName:Iw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r;WP(a,"multinomial");const l=i?a:ej({inputs:{logits:a},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=wy(Qb(d),"int32");for(let f=0;f<c;++f){const t=f*u,e=new Float32Array(u-1);e[0]=h[t];for(let a=1;a<e.length;++a)e[a]=e[a-1]+h[t+a];const n=Vo.alea(o.toString()),r=f*s;for(let a=0;a<s;++a){const t=n();p[r+a]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){p[r+a]=n;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function aj(t,e,n){const r=gk(-1,n);return tU([],e,r,t,n)}const sj={kernelName:Ew,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;WP(r,"neg");const a=n.data.get(r.dataId).values,[s,o]=aj(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}},oj=KC;const ij={kernelName:Tw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r;WP(a,"NonMaxSuppression");const c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=oj(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},lj=qC;const cj={kernelName:Aw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r;WP(a,"NonMaxSuppressionPadded");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=lj(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},uj=XC;const hj={kernelName:Rw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r;WP(a,"NonMaxSuppressionWithScore");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=uj(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},dj=QP(((t,e)=>t!==e?1:0)),pj=yB(Cw,dj,null,"bool"),fj={kernelName:Cw,backendName:"cpu",kernelFunc:pj};const gj={kernelName:_w,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r;WP(a,"oneHot");const c=Qb(a.shape),u=new Float32Array(c*o);u.fill(l);const h=n.data.get(a.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=i);return n.makeTensorInfo([...a.shape,o],s,u)}};function mj(t){const{inputs:e,backend:n}=t,{x:r}=e;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const t=pB({inputs:{input:r},backend:n}),e=mj({inputs:{x:t},backend:n}),a=NW({inputs:{input:r},backend:n}),s=mj({inputs:{x:a},backend:n}),o=uB({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return PU({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const bj={kernelName:Px,backendName:"cpu",kernelFunc:mj};const yj={kernelName:Fw,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const e=pB({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=NW({inputs:{input:a},backend:r}),o=mj({inputs:{x:s},backend:r}),i=uB({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return PU({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function vj(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return kU({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Yb(s,t.shape,"All tensors passed to stack must have matching shapes"),Jb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=CW({inputs:e.map((t=>{const e=kU({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}const wj={kernelName:Dw,backendName:"cpu",kernelFunc:vj};const xj={kernelName:Ow,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;WP(a,"pad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=n.data.get(a.dataId).values,u=Qb(a.shape),h=a.shape.length,d=my(a.shape),p=Qb(i),f=i.length,g=my(i),m=iy(a.dtype,p);0!==o&&m.fill(o);for(let b=0;b<u;b++){m[Sy(Iy(b,h,d).map(((t,e)=>t+l[e])),f,g)]=c[b]}return{dataId:n.write(m,i,a.dtype),shape:i,dtype:a.dtype}}},kj=QP(((t,e)=>Math.pow(t,e))),Sj=yB(zw,kj),Ij={kernelName:zw,backendName:"cpu",kernelFunc:Sj};function Nj(t,e,n,r){const[a,s]=kE(t,r),o=Kk(e,"int32"),i=wy(Qb(a),o),l=Qb(s);for(let c=0;c<i.length;++c){const t=c*l;let e=1;for(let r=0;r<l;++r)e*=n[t+r];i[c]=e}return{outVals:i,outShape:a,outDtype:o}}const Ej={kernelName:Mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;WP(a,"prod");const i=a.shape.length,l=sy(s,a.shape),c=NE(l,i);let u=l,h=a;const d=[];null!=c&&(h=MB({inputs:{x:a},backend:n,attrs:{perm:c}}),d.push(h),u=CE(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=Nj(h.shape,h.dtype,p,u);let b=g;return o&&(b=SE(g,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(b,m,f)}};function Cj(t,e,n,r){const a=[];let s=0;const o=e.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const r=t[n],a=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const t=e[c+1];for(let e=1;e<l+1;++e)i[c].push(e*t)}for(let c=0;c<t.length;++c){let r=t[c],o=t[c]+1;for(let t=0;t<n.length;++t){const a=n[t],s=t+e.length-1;if(s>=0){const t=i[s],e=t[t.length-1]-a[r];for(let n=r;n<o;++n)i[s].push(a[n+1]+e)}r=a[r],o=a[o]}o!==r&&(a.push([r,o]),s+=o-r)}return{outSplits:i,valueSlices:a,numValues:s}}function Tj(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function Aj(t,e,n,r,a){const s=e.slice();s[0]=a;const o=ly(n,Qb(s)),i=t.length;return function(t,e,n,r,a,s){const o=Tj(e,2)[1],i=Tj(s,2)[1];let l=0;for(const c of n)for(let e=c[0];e<c[1];++e){for(let n=0;n<r;++n)a[l*i+n]=t[e*o+n];++l}}(t,e,r,0===i?0:i/e[0],o,s),[o,s]}function Rj(t,e,n,r,a,s,o,i){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,r)=>{if(t<0||t>=n){const a=Iy(r,e.length,my(e)).join(",");throw new Error("indices[".concat(a,"] = ").concat(t," is not in [0, ").concat(n,")"))}}))}(s,o,e[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:u,numValues:h}=Cj(s,o,t,l),d=function(t){const e=[];for(let n=0;n<t.length;++n){const r=ly("int32",t[n].length);e.push(r),t[n].forEach(((t,e)=>r[e]=t))}return e}(c),p=Aj(n,r,a,u,h);return[d,p[0],p[1]]}const Fj={kernelName:Pw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.data.get(t.dataId).values)),c=a.map((t=>t.shape)),u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,[d,p,f]=Rj(l,c,u,s.shape,s.dtype,h,o.shape),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}},_j=2147483647;function Dj(t,e,n,r,a,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=0===e.length,l=0===a.length,c=0===o.length,u=[];i||u.push(e[0]),l||u.push(a[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=ly("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const e=i?t[0]:t[g],n=l?r[0]:r[g],a=c?s[0]:s[g];if(0===a)throw new Error("Requires delta != 0");let o;if(a>0&&n<e||a<0&&n>e)o=0;else if(o=Math.ceil(Math.abs((n-e)/a)),o>_j)throw new Error("Requires ((limit - start) / delta) <= ".concat(_j));d[g+1]=d[g]+o}const p=ly(n,d[h]);let f=0;for(let g=0;g<h;++g){const e=d[g+1]-d[g];let n=i?t[0]:t[g];const r=c?s[0]:s[g];for(let t=0;t<e;++t)p[f++]=n,n+=r}return[d,p]}const Oj={kernelName:Bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=Dj(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};var zj=CT;class Lj{constructor(t,e,n,r,a,s,o,i,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=AT(c),this.raggedRank=RT(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===zj.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===zj.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case zj.VALUE_ROWIDS:return Lj.getMaxWidthValueRowID(e);case zj.ROW_SPLITS:return Lj.getMaxWidthRowSplit(e);default:throw new Error("Cannot handle partition type ".concat(zj[this.getRowPartitionTypeByDimension(t-1)]))}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let r=0;r<e-1;++r){const e=t[r+1]-t[r];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,r=t[0],a=0;for(let s=1;s<e;++s){const e=t[s];e!==r&&(r=e,a=Math.max(s-n,a),n=s)}return Math.max(e-n,a)}tensorShapeFromTensor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Pj(t,n)}calculateOutputSize(t){const e=this.valuesShape;FT(this.defaultValueShape,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=TT(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(t,e,n){const r=Math.min(t,n),a=[];let s=0;for(let o=0;o<r;++o,s+=e)a.push(s);for(let o=r;o<t;++o)a.push(-1);return Jb(a.length===t,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(t,e,n,r){const a=t.length,s=[];for(let o=0;o<a-1;++o){const a=t[o+1]-t[o];let i=Math.min(r,a),l=e[o];-1===l&&(i=0);for(let t=0;t<i;++t)s.push(l),l+=n;for(let t=0;t<a-i;++t)s.push(-1)}if(a>0&&s.length!==t[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,r){const a=t.length,s=[];if(0===a)return[];let o=0,i=t[0];if(i>=e.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(e.length));let l=e[i];s.push(l);for(let c=1;c<a;++c){const a=t[c];if(a===i)l>=0&&(++o,o<r?l+=n:l=-1);else{if(o=0,i=a,a>=e.length)throw new Error("Got nextValueRowId=".concat(a," which is not less than ").concat(e.length));l=e[a]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,r){const a=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case zj.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,e,n,r);case zj.ROW_SPLITS:if(a.length-1>e.length)throw new Error("Row partition size is greater than output size: ".concat(a.length-1," > ").concat(e.length));return this.calculateOutputIndexRowSplit(a,e,n,r);default:throw new Error("Unsupported partition type: ".concat(zj[s]))}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case zj.FIRST_DIM_SIZE:return t[0];case zj.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zj.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(zj[e]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*e[s+1];const r=Pj(e,!1),a=ly(this.valuesDType,Qb(r));if(n[0]*e[0]>0){let s=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t){s=this.calculateOutputIndex(t-1,s,n[t],e[t])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(t,e,n,r){if(0===n.length)return;const a=this.values,s=n;let o=r.slice();o=o.slice(t+1);const i=Qb(o),l=e.length;let c=this.defaultValue;if(c.length!==i&&1!==c.length){const t=this.defaultValueShape;kS((()=>{const e=zN(c,t),n=VN(e,o);c=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=l;++p){let t=p<l?e[p]:-1;if(t!==d){if(h<d){const t=a.subarray(u*i);Mj(s.subarray(h*i),t,(d-h)*i)}if(p>=l){const e=n.length;t=Math.floor(e/i)}if(t>d)if(1===this.defaultValue.length)s.subarray(d*i,t*i).fill(this.defaultValue[0]),d=t;else for(;t>d;){Mj(s.slice(d*i),c,i),++d}t<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function Mj(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function Pj(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error("Dimension ".concat(r," must be >= 0"));if(r<-1)throw new Error("Dimension ".concat(r," must be >= -1"));r=-1}n.push(r)}return n}function Bj(t,e,n,r,a,s,o,i,l,c){return new Lj(t,e,n,r,a,s,o,i,l,c).compute()}const Wj={kernelName:Ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=i.map((t=>n.data.get(t.dataId).values)),p=i.map((t=>t.shape)),[f,g]=Bj(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}};function Uj(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return wy(0,r);const a=wy(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const Vj={kernelName:Uw,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,dtype:s,step:o}=n,i=Uj(r,a,o,s);return e.makeTensorInfo([i.length],s,i)}},jj=GP(jw,(t=>1/t)),Gj={kernelName:jw,backendName:"cpu",kernelFunc:jj};const Hj={kernelName:Xw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;WP(a,"resizeBilinear");const l=my(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(Qb([h,c,u,f])),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u];let v=0;const w=b[0]/y[0],x=b[1]/y[1];for(let k=0;k<h;k++)for(let t=0;t<c;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,a=Math.min(d-1,Math.ceil(e)),s=k*l[0]+n*l[1],i=k*l[0]+a*l[1];for(let t=0;t<u;t++){let e;e=o?x*(t+.5)-.5:x*t;const n=Math.max(0,Math.floor(e)),a=e-n,c=Math.min(p-1,Math.ceil(e)),u=s+n*l[2],h=i+n*l[2],d=s+c*l[2],b=i+c*l[2];for(let t=0;t<f;t++){const e=g[u+t],n=g[h+t],s=e+(g[d+t]-e)*a,o=s+(n+(g[b+t]-n)*a-s)*r;m[v++]=o}}}return n.makeTensorInfo([h,c,u,f],"float32",m)}};const Kj={kernelName:Jw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;WP([s,a],"resizeBilinearGrad");const i=my(a.shape),[l,c,u,h]=a.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),g=[o&&d>1?c-1:c,o&&p>1?u-1:u],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],b=g[0]/m[0],y=g[1]/m[1],v=n.data.get(s.dataId).values;let w=0;for(let x=0;x<l;x++){const t=x*i[0];for(let e=0;e<d;e++){const n=e*b,r=Math.floor(n),a=Math.min(Math.ceil(n),c-1),s=t+r*i[1],o=t+a*i[1],l=n-r,d=1-l;for(let t=0;t<p;t++){const e=t*y,n=Math.floor(e),r=Math.min(Math.ceil(e),u-1),a=e-n,c=1-a,p=s+n*i[2],g=s+r*i[2],m=o+n*i[2],b=o+r*i[2],x=d*c,k=d*a,S=l*c,I=l*a;for(let t=0;t<h;t++){const e=v[w++];f[p+t]+=e*x,f[g+t]+=e*k,f[m+t]+=e*S,f[b+t]+=e*I}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}};const qj={kernelName:Kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;WP(a,"resizeNearestNeighbor");const l=my(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(h*c*u*f),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u],v=b[0]/y[0],w=b[1]/y[1];let x=0;for(let k=0;k<h;k++){const t=k*l[0];for(let e=0;e<c;e++){const n=o?v*(e+.5):v*e;let r=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));const a=t+r*l[1];for(let t=0;t<u;t++){const e=o?w*(t+.5):w*t;let n=Math.min(p-1,s?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const r=a+n*l[2];for(let t=0;t<f;t++){const e=g[r+t];m[x++]=e}}}}return n.makeTensorInfo([h,c,u,f],a.dtype,m)}};const Xj={kernelName:qw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;WP([s,a],"resizeNearestNeighborGrad");const i=my(a.shape),l=my(s.shape),[c,u,h,d]=a.shape,[,p,f]=s.shape,g=new Float32Array(c*u*h*d),m=n.data.get(s.dataId).values,b=[o&&p>1?u-1:u,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=b[0]/y[0],w=b[1]/y[1],x=1/v,k=1/w,S=2*Math.ceil(x)+2,I=2*Math.ceil(k)+2;for(let N=0;N<c;N++){const t=N*i[0];for(let e=0;e<u;e++){const n=t+e*i[1],r=Math.floor(e*x),a=Math.floor(r-S/2);for(let s=0;s<h;s++){const r=n+s*i[2],c=Math.floor(s*k),b=Math.floor(c-I/2);for(let n=0;n<d;n++){let i=0;for(let r=0;r<S;r++){const c=r+a;if(c<0||c>=p)continue;const d=t+c*l[1],g=c*v;if(e===Math.min(u-1,o?Math.round(g):Math.floor(g)))for(let t=0;t<I;t++){const e=t+b;if(e<0||e>=f)continue;const r=d+e*l[2],a=e*w;s===Math.min(h-1,o?Math.round(a):Math.floor(a))&&(i+=m[r+n])}}g[r+n]=i}}}}return n.makeTensorInfo(a.shape,a.dtype,g)}};const Jj={kernelName:Zw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r;WP(a,"reverse");const o=a.shape.length,i=sy(s,a.shape);if(0===o)return XP({inputs:{x:a},backend:n});const l=new Dk(a.shape,a.dtype),c=n.bufferSync(a);for(let u=0;u<l.size;u++){const t=l.indexToLoc(u),e=t.slice();i.forEach((t=>e[t]=a.shape[t]-1-e[t])),l.set(c.get(...e),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},Yj={kernelName:Ux,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=iy(a.dtype,Qb(a.shape)),[u,h,d,p]=a.shape,[f,g]=OT(i,h,d),m=Math.sin(s),b=Math.cos(s),y=l.data.get(a.dataId).values;for(let v=0;v<u;v++){const t=v*d*h*p;for(let e=0;e<h;e++){const n=e*(d*p);for(let r=0;r<d;r++){const a=r*p;for(let s=0;s<p;s++){const i=[u,e,r,s],l=i[2],v=i[1];let w=(l-f)*b-(v-g)*m,x=(l-f)*m+(v-g)*b;w=Math.round(w+f),x=Math.round(x+g);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),w>=0&&w<d&&x>=0&&x<h){k=y[t+x*(d*p)+w*p+s]}c[t+n+a+s]=k}}}}return{dataId:l.write(c,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Zj=GP(Qw,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1})),Qj={kernelName:Qw,backendName:"cpu",kernelFunc:Zj},$j=jP((t=>1/Math.sqrt(t))),tG=HP($w,$j),eG={kernelName:$w,backendName:"cpu",kernelFunc:tG};function nG(t,e,n,r,a,s,o,i,l,c){const u=[r/a,a],h=t.values,d=e.values;if(0===r)return uI(n,e.dtype);const p=l instanceof Dk?l:uI(u,e.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const t=[];let s=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),s+=n*i[e]}if(s<0||s>=r/a)throw new Error("Invalid indices: ".concat(t," does not index into ").concat(n));for(let n=0;n<a;n++)c?p.values[s*a+n]+=d[f*a+n]:p.values[s*a+n]=0===e.rank?d[0]:d[f*a+n]}return p}const rG={kernelName:tx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=jT(0,a,o),d=nG(n.bufferSync(a),n.bufferSync(s),o,h,c,l,i,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};function aG(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<e?n=a+1:r=a;return r}function sG(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<=e?n=a+1:r=a;return r}const oG={kernelName:nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=function(t,e,n,r,a,s){const o=ly("int32",n*a);for(let i=0;i<n;++i){const n=t.slice(i*r,(i+1)*r),l=i*a;for(let t=0;t<a;++t)o[l+t]="left"===s?aG(n,e[t+l]):sG(n,e[t+l])}return o}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};const iG={kernelName:rx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e;WP([r,a,s],"select");const o=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=Kk(a.dtype,s.dtype),h=wy(Qb(a.shape),u);let d=0;const p=0===o||o>1||1===a.shape.length?1:Qb(a.shape.slice(1));for(let f=0;f<i.length;f++)for(let t=0;t<p;t++)1===i[f]?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(a.shape,u,h)}},lG=GT,cG=HT,uG=GP(ax,(t=>t>=0?cG*t:lG*(Math.exp(t)-1))),hG={kernelName:ax,backendName:"cpu",kernelFunc:uG},dG=GP(lx,(t=>t<0?-1:t>0?1:0)),pG={kernelName:lx,backendName:"cpu",kernelFunc:dG},fG=GP(ox,(t=>Math.sin(t))),gG={kernelName:ox,backendName:"cpu",kernelFunc:fG},mG=GP(ix,(t=>Math.sinh(t))),bG={kernelName:ix,backendName:"cpu",kernelFunc:mG},yG=Math.log(1.1920928955078125e-7)+2,vG=GP(ux,(t=>{const e=t>-yG,n=t<yG,r=Math.exp(t);let a;return a=n?r:e?t:Math.log(1+r),a})),wG={kernelName:ux,backendName:"cpu",kernelFunc:vG};const xG={kernelName:px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;WP([a],"spaceToBatchND");const i=Qb(s),l=[[0,0]];l.push(...o);for(let m=1+s.length;m<a.shape.length;++m)l.push([0,0]);const c=xj.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=zT(c.shape,s,i,!1),h=LT(u.length,s.length,!1),d=MT(c.shape,s,i,!1),p=IB({inputs:{x:c},backend:n,attrs:{shape:u}}),f=MB({inputs:{x:p},backend:n,attrs:{perm:h}}),g=IB({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function kG(t,e,n,r,a,s,o){const i=e[0],l=s[0],c=new Array(l),u=new Array(i),h=e[1];if(0===l){if(0!==i)throw new Error(bA(i));return[ly(n,0),[0,h],ly(a,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<i;++m){const e=t[m*h];if(e<0)throw new Error(yA(m,e));if(e>=l)throw new Error(vA(m,e,l));++f[e],d=d&&e>=p,p=e}let g=!0;for(let m=0;m<l;++m){const t=0===f[m];c[m]=t,g=g&&!t,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const e=t,n=r;for(let t=0;t<i;++t)u[t]=t;return[e,[i,h],n,c,u]}{const e=f[l-1],s=ly(n,e*h),d=ly(a,e),p=new Array(l).fill(0);for(let n=0;n<i;++n){const e=t[n*h],a=p[e],o=(0===e?0:f[e-1])+a;p[e]++;for(let r=0;r<h;++r)s[o*h+r]=t[n*h+r];d[o]=r[n],u[n]=o}for(let t=0;t<l;++t){if(0===p[t]){const e=0===t?0:f[t-1];s[e*h+0]=t;for(let t=1;t<h;++t)s[e*h+t]=0;d[e]=o}}return[s,[e,h],d,c,u]}}const SG={kernelName:mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,g]=kG(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function IG(t,e,n,r,a){const s=Qb(r),o=e[0],i=a.length,l=[];let c=1,u=-1;for(let g=0;g<i;++g){const t=a[g];if(-1===t){if(-1!==u)throw new Error(wA(u,g));u=g,l.push(1)}else{if(t<0)throw new Error(xA(g,t));c*=t,l.push(t)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(s/c);if(c*t!==s)throw new Error(SA(r,l));l[u]=t}if(Qb(l)!==s)throw new Error(IA(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t)d[t]=d[t+1]*r[t+1]}const p=[];if(i>0){p[i-1]=1;for(let t=i-2;t>=0;--t)p[t]=p[t+1]*l[t+1]}const f=ly(n,o*i);for(let g=0;g<o;++g){let e=0;for(let n=0;n<h;++n)e+=t[g*h+n]*d[n];for(let t=0;t<i;++t)f[g*i+t]=Math.trunc(e/p[t]),e%=p[t]}return[f,[o,i],l]}const NG={kernelName:bx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.data.get(a.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=IG(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function EG(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=r.length,l=[e[0],t.length/e[0]],c=l[1],u=i>0?a[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=u;const d=ly(n,h.reduce(((t,e)=>t*e),1));if(0===i)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=a[p];for(;;){let e=0;if(f<i){if(e=a[f],m===e){++f;continue}if(m>=e)throw new Error("segment ids are not increasing")}if(m<0||m>=u)throw new Error(CA(m,u));m>g&&d.fill(o,g*c,m*c);for(let n=p;n<f;++n){const e=r[n];if(e<0||e>=l[0])throw new Error(TA(n,r[n],l[0]));for(let n=0;n<c;n++)d[m*c+n]+=t[e*c+n]}if(s)for(let t=0;t<c;t++)d[m*c+t]/=f-p;if(p=f,++f,g=m+1,m=e,f>i)break}return g<u&&d.fill(o,g*c,u*c),[d,h]}const CG={kernelName:yx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=EG(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const TG={kernelName:vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=EG(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const AG={kernelName:wx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=jT(0,a,i),p=!1,f=n.bufferSync(a);let g;switch(s.dtype){case"bool":g=nG(f,n.bufferSync(s),i,d,u,c,l,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":g=nG(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"int32":g=nG(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"string":g=nG(f,n.bufferSync(s),i,d,u,c,l,h,vk(n.data.get(o.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(s.dtype))}return n.makeTensorInfo(i,g.dtype,g.values)}};const RG={kernelName:fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=sy(o,a.shape)[0],l=mA(a,s,i),c=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map((t=>{const e=[...u];e[i]=t;const r=cW({inputs:{x:a},backend:n,attrs:{begin:c,size:e}});return c[i]+=t,r}))}},FG=jP((t=>Math.sqrt(t))),_G=GP(hx,(t=>Math.sqrt(t))),DG={kernelName:hx,backendName:"cpu",kernelFunc:_G},OG={kernelName:kx,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{x:r}=e,a=n;WP(r,"square");const s=a.data.get(r.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const t=s[i];o[i]=t*t}return{dataId:a.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zG=QP(((t,e)=>{const n=t-e;return n*n})),LG=yB(xx,zG),MG={kernelName:xx,backendName:"cpu",kernelFunc:LG},PG=jP(((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=e;return t.replace(new RegExp(n,r?"g":""),a)})),BG=HP(Sx,PG),WG={kernelName:Sx,backendName:"cpu",kernelFunc:BG},UG=GP(Bx,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),VG={kernelName:Bx,backendName:"cpu",kernelFunc:UG};function jG(t,e,n,r){const a=uI(t,e.dtype);for(let s=0;s<a.size;s++){const t=a.indexToLoc(s),o=new Array(t.length);for(let e=0;e<o.length;e++)o[e]=t[e]*n[e]+r[e];a.set(e.get(...o),...t)}return a}const GG={kernelName:Ix,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;WP(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=gN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=IB({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Jb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=nN(y,v,w),e=cW({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=IB({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{const t=jG(p,n.bufferSync(a),w,y);x=n.makeTensorInfo(f,t.dtype,t.values)}return x}};class HG{constructor(t,e,n,r,a,s){this.separator=yk(t),this.nGramWidths=e,this.leftPad=yk(n),this.rightPad=yk(r),this.padWidth=a,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),l=Math.max(0,i-o),c=Math.max(0,i-(a-(o+1))),u=s-(l+c),h=e+(l>0?0:o-i);let d=0;d+=l*this.leftPad.length;for(let e=0;e<u;++e)d+=t[h+e].length;d+=c*this.rightPad.length;d+=(l+c+u-1)*this.separator.length,n[r+o]=new Uint8Array(d);const p=n[r+o];let f=0;const g=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)g(this.leftPad),g(this.separator);for(let e=0;e<u-1;++e)g(t[h+e]),g(this.separator);if(u>0){g(t[h+u-1]);for(let t=0;t<c;++t)g(this.separator),g(this.rightPad)}else{for(let t=0;t<c-1;++t)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error("First split value must be 0, got ".concat(t));for(let a=1;a<r;++a){let r=e[a]>=t;if(r=r&&e[a]<=n,!r)throw new Error("Invalid split value ".concat(e[a],", must be in [").concat(t,", ").concat(n,"]"));t=e[a]}if(t!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(t))}const a=r-1,s=ly("int32",r);if(0===n||0===r){const t=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[t,s]}s[0]=0;for(let i=1;i<=a;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach((e=>{n+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[a]);for(let i=0;i<a;++i){const n=e[i];let r=s[i];if(this.nGramWidths.forEach((a=>{const s=e[i+1]-e[i],l=this.getNumNGrams(s,a);this.createNGrams(t,n,o,r,l,a),r+=l})),this.preserveShort&&r===s[i]){const a=e[i+1]-e[i];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(t,n,o,r,l,s)}}return[o,s]}}function KG(t,e,n,r,a,s,o,i){return new HG(n,r,a,s,o,i).compute(t,e)}const qG={kernelName:Nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,g]=KG(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};function XG(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const a=e[0];let s=t.indexOf(a);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(a)}return void(n&&0===t.length||r.push(t))}let a=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(a,s);n&&0===e.length||r.push(e),a=s+1}}function JG(t,e,n){const r=t.length,a=[];let s=0,o=0;const i=new Array(r);for(let d=0;d<r;++d){const r=a.length;XG(t[d],e,n,a);const l=a.length-r;i[d]=l,s+=l,o=Math.max(o,l)}const l=ly("int32",2*s),c=new Array(s),u=[r,o];let h=0;for(let d=0;d<r;++d)for(let t=0;t<i[d];++t)l[2*h]=d,l[2*h+1]=t,c[h]=a[h],++h;return[l,c,u]}const YG={kernelName:Ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[c,u,h]=JG(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function ZG(t,e){const n=ly("int32",t.length);for(let r=0;r<t.length;++r)n[r]=fk(t[r]).modulo(e).getLowBitsUnsigned();return n}const QG={kernelName:Cx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=ZG(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",o)}},$G=GP(Ax,(t=>Math.tan(t))),tH={kernelName:Ax,backendName:"cpu",kernelFunc:$G},eH=GP(Rx,(t=>Math.tanh(t)));const nH={kernelName:ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{tensor:r,indices:a,updates:s}=e,{sliceRank:o,numUpdates:i,sliceSize:l,strides:c,outputSize:u}=jT(0,a,r.shape),h=n.bufferSync(a),d=n.bufferSync(s),p=n.bufferSync(r),f=nG(h,d,r.shape,u,l,i,o,c,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function rH(t,e){const n=new Array(t.rank);for(let a=0;a<n.length;a++)n[a]=t.shape[a]*e[a];const r=uI(n,t.dtype);for(let a=0;a<r.values.length;++a){const e=r.indexToLoc(a),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const s=t.locToIndex(n);r.values[a]=t.values[s]}return r}const aH={kernelName:Fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;WP(a,"tile");const o=rH(n.bufferSync(a),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},sH=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function oH(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=e-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2);oH(t,e,Math.max(n,Math.floor(e-s*i/a+l)),Math.min(r,Math.floor(e+(a-s)*i/a+l)))}const a=t[e];let s=n,o=r;for(Xb(t,n,e),sH(t[r],a)>0&&Xb(t,n,r);s<o;){for(Xb(t,s,o),s++,o--;sH(t[s],a)<0;)s+=1;for(;sH(t[o],a)>0;)o-=1}0===sH(t[n],a)?Xb(t,n,o):(o+=1,Xb(t,o,r)),o<=e&&(n=o+1),e<=o&&(r=o-1)}}function iH(t,e,n,r,a){const s=e[e.length-1],[o,i]=[t.length/s,s],l=iy(n,o*r),c=iy("int32",o*r);for(let h=0;h<o;h++){const e=h*i,n=t.subarray(e,e+i);let s=new Array(n.length);n.forEach(((t,e)=>s[e]={value:t,index:e})),r<s.length&&(oH(s,r),s=s.slice(0,r)),a&&s.sort(sH);const o=h*r,u=l.subarray(o,o+r),d=c.subarray(o,o+r);for(let t=0;t<r;t++)u[t]=s[t].value,d[t]=s[t].index}const u=e.slice();return u[u.length-1]=r,[uI(u,n,l),uI(u,"int32",c)]}const lH={kernelName:_x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r;WP(a,"topk");const i=n.data.get(a.dataId).values,[l,c]=iH(i,a.shape,a.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const cH={kernelName:Dx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=n,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=[u,f,g,p],b=my(a.shape),y=b[0],v=b[1],w=b[2],x=my(m),k=x[0],S=x[1],I=x[2],N=iy(a.dtype,Qb(m));N.fill(l);const E=r.data.get(a.dataId).values,C=r.data.get(s.dataId).values;for(let T=0;T<u;++T){const t=1===s.shape[0]?C:C.subarray(8*T,8*T+8);for(let e=0;e<f;++e)for(let n=0;n<g;++n)for(let r=0;r<p;++r){let a;const s=t[6]*n+t[7]*e+1;if(0===s)continue;const c=(t[0]*n+t[1]*e+t[2])/s,u=(t[3]*n+t[4]*e+t[5])/s,p=uH(c,d,i),f=uH(u,h,i);switch(o){case"nearest":a=dH(E,h,d,y,v,w,T,f,p,r,l);break;case"bilinear":a=pH(E,h,d,y,v,w,T,f,p,r,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}N[T*k+e*S+n*I+r]=a}return r.makeTensorInfo(m,a.dtype,N)}return{dataId:r.write(N,m,a.dtype),shape:a.shape,dtype:a.dtype}}};function uH(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return Kb(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return Kb(0,n,e-1)}(t,e);case"nearest":return function(t,e){return Kb(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function hH(t,e,n,r,a,s,o,i,l,c,u){return 0<=i&&i<e&&0<=l&&l<n?t[o*r+i*a+l*s+c]:u}function dH(t,e,n,r,a,s,o,i,l,c,u){return hH(t,e,n,r,a,s,o,Math.round(i),Math.round(l),c,u)}function pH(t,e,n,r,a,s,o,i,l,c,u){const h=Math.floor(i),d=Math.floor(l),p=h+1,f=d+1;return(p-i)*((f-l)*hH(t,e,n,r,a,s,o,h,d,c,u)+(l-d)*hH(t,e,n,r,a,s,o,h,f,c,u))+(i-h)*((f-l)*hH(t,e,n,r,a,s,o,p,d,c,u)+(l-d)*hH(t,e,n,r,a,s,o,p,f,c,u))}function fH(t,e,n,r){const a=sy(e,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const o=new Map,i=new Int32Array(n[a]),l=new Dk(s,r,t),c=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let e;if(u)e=t[f].toString();else{const t=[];for(let e=0;e<s[0];e++)for(let n=0;n<s[2];n++)t.push(l.get(e,f,n));e=t.join(",")}const n=o.get(e);if(null!=n)i[f]=n;else{const t=o.size;o.set(e,t),i[f]=t,c.push(f)}}const h=s.slice();h[1]=o.size;const d=new Dk(h,r);c.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,t,r),n,e,r)}));const p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const gH={kernelName:zx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;WP(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:c}=fH(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const mH={kernelName:Lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape.length,i=a.shape[s],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=a.shape[p]);const u=new Array(o).fill(0),h=a.shape.slice();h[s]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[s]=p;const t=cW({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});d[p]=IB({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}};const bH={kernelName:Mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r;WP(a,"unsortedSegmentSum");const i=[],l=[],c=a.shape.length-s.shape.length;let u=s;for(let d=0;d<c;++d){const t=kU({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=t,l.push(t)}for(let d=0;d<o;++d){const t=gk(d,"int32"),e=n.makeTensorInfo([],"int32",t),r=cU({inputs:{a:e,b:u},backend:n}),s=mB({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=nU({inputs:{a:s,b:a},backend:n}),c=aU({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(c),l.push(e),l.push(r),l.push(s),l.push(o),l.push(c)}const h=vj({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},yH=[TB,RB,_B,OB,SB,zB,BB,WB,UB,VB,GB,KB,XB,ZB,$B,rW,aW,sW,oW,CB,iW,hW,fW,mW,bW,bB,wW,kW,hB,SW,TW,RW,FW,_W,DW,OW,zW,MW,BW,WW,UW,VW,jW,GW,KW,qW,XW,JW,YW,ZW,QW,$W,oU,qP,iU,uU,yU,xU,SU,EU,MU,BU,WU,jU,KU,qU,XU,YU,QU,eV,aV,JP,sV,EW,iV,cV,hV,ZP,fV,bV,vV,kV,IV,CV,AV,_V,DV,OV,MV,WV,UV,VV,jV,GV,HV,KV,qV,YV,ZV,tj,rj,rU,sj,ij,cj,hj,fj,gj,yj,wj,xj,Ij,eB,Ej,Fj,Oj,Wj,Vj,fB,AU,Gj,rB,sB,NB,Hj,Kj,qj,Xj,Jj,Yj,Qj,eG,rG,oG,iG,hG,lB,pG,gG,bG,uW,nj,wG,xG,SG,NG,CG,TG,AG,RG,DG,OG,MG,WG,VG,GG,qG,YG,QG,DU,sU,tH,{kernelName:Rx,backendName:"cpu",kernelFunc:eH},nH,aH,lH,cH,PB,gH,mH,bH,bj];for(const n of yH)Qx(n);const vH={},wH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xH(t,e){if(!(t in vH)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if(Ay().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==t){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(t):e;n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete vH[t]}),!1),Ay().getBool("SOFTWARE_WEBGL_ENABLED")&&(wH.failIfMajorPerformanceCaveat=!1);if(1===t)return n.getContext("webgl",wH)||n.getContext("experimental-webgl",wH);return n.getContext("webgl2",wH)}(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;vH[t]=n}const n=vH[t];return null==n||n.isContextLost()?(delete vH[t],xH(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),vH[t])}var kH,SH,IH;function NH(t,e){return[e,t]}function EH(t){const e=Qb(t);return ey(Math.ceil(e/4))}function CH(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function TH(t,e){const n=t;let r,a,s,o,i,l,c,u,h,d;return 2===Ay().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,a=t.RGBA,s=t.RGBA,o=n.RGBA,i=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function AH(t,e){const n=e();return Ay().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(e)}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(kH||(kH={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(SH||(SH={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(IH||(IH={}));function RH(t){return!!(Ay().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function FH(t,e){return WH(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}const _H=/ERROR: [0-9]+:([0-9]+):/g;function DH(t,e){const n=_H.exec(e);if(null==n)return console.log("Couldn't parse line number in error: ".concat(e)),void console.log(t);const r=+n[1],a=t.split("\n"),s=a.length.toString().length+2,o=a.map(((t,e)=>ny((e+1).toString(),s)+t));let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c ".concat(ny(c[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function OH(t,e){if(AH(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function zH(t,e,n,r,a,s,o){const i=t.getAttribLocation(e,n);return-1!==i&&(AH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),AH(t,(()=>t.vertexAttribPointer(i,a,t.FLOAT,!1,s,o))),AH(t,(()=>t.enableVertexAttribArray(i))),!0)}function LH(t,e,n,r){AH(t,(()=>function(t,e,n){UH(t,n),AH(t,(()=>t.activeTexture(t.TEXTURE0+n))),AH(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),AH(t,(()=>t.uniform1i(n,r)))}function MH(t,e,n){AH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),AH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function PH(t,e){AH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),AH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function BH(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(e)}}(t,e))}function WH(t,e,n){const r=AH(t,(()=>e()));if(null==r)throw new Error(n);return r}function UH(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const t="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(t,"."))}}function VH(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Qb(t.slice(0,t.length-e))}function jH(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function GH(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[VH(t),...jH(t)]),e}function HH(t){return t%2===0}function KH(t,e){if($b(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r)return!0;if(HH(n)&&HH(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&HH(t[0])&&HH(e[0])}let qH,XH;function JH(t,e){return null!=t.getExtension(e)}function YH(t){try{if(null!=xH(t))return!0}catch(d1){return console.log("Error when getting WebGL context: ",d1),!1}return!1}function ZH(t){if(0===t)return!1;const e=xH(t);if(1!==t){if(JH(e,"EXT_color_buffer_float"))return QH(e);const t="EXT_color_buffer_half_float";if(JH(e,t)){const n=e.getExtension(t);return function(t,e){const n=TH(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);const a=1,s=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),i}(e,n)}return!1}if(!JH(e,"OES_texture_float"))return!1;if(!JH(e,"WEBGL_color_buffer_float"))return!1;return QH(e)}function QH(t){const e=TH(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),a}function $H(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Jb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors ")+"in the WebGL backend."))}))}const tK=Ay();function eK(){let t,e,n,r,a,s,o,i,l,c;return 2===Ay().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=Ay().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}function nK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=my(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(e),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(e):"index -= ".concat(t[a]," * ").concat(e);return"".concat(s,"; ").concat(o,";")})).join("")}function rK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=my(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / outShapeStrides[").concat(a,"]"),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * outShapeStrides[").concat(a,"]"):"index -= ".concat(t[a]," * outShapeStrides[").concat(a,"]");return"".concat(s,"; ").concat(o,";")})).join("")}function aK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(t,e){const n=t.length,r=t.map((t=>"".concat(e,"[").concat(t,"]"))),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]="(".concat(a[s+1]," * ").concat(r[s+1],")");return a}(t.map(((t,e)=>e)),e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(r[a]),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(r[a]):"index -= ".concat(t[a]," * ").concat(r[a]);return"".concat(s,"; ").concat(o,";")})).join("")}function sK(t){const e=my(t).map((t=>t.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(e[0]," + coords.y * ").concat(e[1]," + coords.z;\n  }\n")}tK.registerFlag("HAS_WEBGL",(()=>tK.getNumber("WEBGL_VERSION")>0)),tK.registerFlag("WEBGL_VERSION",(()=>YH(2)?2:YH(1)?1:0)),tK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),tK.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===tK.get("WEBGL_VERSION"))),tK.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),tK.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),tK.registerFlag("WEBGL_PACK",(()=>tK.getBool("HAS_WEBGL"))),tK.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_CLIP",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_REDUCE",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_LAZILY_UNPACK",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_CONV_IM2COL",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>tK.getBool("WEBGL_PACK"))),tK.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==qH){const e=xH(t);qH=e.getParameter(e.MAX_TEXTURE_SIZE)}return qH}(tK.getNumber("WEBGL_VERSION")))),tK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==XH){const e=xH(t);XH=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,XH)}(tK.getNumber("WEBGL_VERSION")))),tK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=tK.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=xH(t);return e=JH(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:JH(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),tK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>tK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!iS())),tK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=xH(t);if(1===t){if(!JH(e,"OES_texture_float"))return!1}else if(!JH(e,"EXT_color_buffer_float"))return!1;return QH(e)}(tK.getNumber("WEBGL_VERSION")))),tK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!tK.getBool("WEBGL_FORCE_F16_TEXTURES")&&tK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),tK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>ZH(tK.getNumber("WEBGL_VERSION")))),tK.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=tK.getNumber("WEBGL_VERSION"))&&null!=xH(t).fenceSync;var t})),tK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>tK.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),tK.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(t,"."))})),tK.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>iS()?1:-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(t,"."))})),tK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),tK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),tK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),tK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),tK.registerFlag("WEBGL_EXP_CONV",(()=>!1)),tK.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>tK.getBool("IS_TEST"))),tK.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),tK.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),tK.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),tK.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const oK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:iK}=r;function lK(t,e,n){const r=[];if(t.forEach((t=>{const e=Qb(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push("uniform float ".concat(t.name).concat(e>1?"[".concat(e,"]"):"",";")):(r.push("uniform sampler2D ".concat(t.name,";")),r.push("uniform int offset".concat(t.name,";"))),n.enableShapeUniforms){const{uniformShape:e}=yK(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push("uniform int ".concat(t.name,"Shape;"));break;case 2:r.push("uniform ivec2 ".concat(t.name,"Shape;"));break;case 3:r.push("uniform ivec3 ".concat(t.name,"Shape;"));break;case 4:r.push("uniform ivec4 ".concat(t.name,"Shape;"))}r.push("uniform ivec2 ".concat(t.name,"TexShape;"))}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{r.push("uniform ".concat(t.type," ").concat(t.name).concat(t.arrayIndex?"[".concat(t.arrayIndex,"]"):"",";"))}));const a=r.join("\n"),s=t.map((t=>function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?uK(t,r):cK(t,r);const s=t.shapeInfo.logicalShape,o=e.logicalShape;s.length<=o.length&&(a+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=iK(t.shapeInfo.logicalShape,e.logicalShape),l=bK(o),c=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((t=>"coords.".concat(h[t+c]," = 0;"))).join("\n");let d="";d=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(h[e+c]))).join(", ");let p="return outputValue;";const f=1===Qb(t.shapeInfo.logicalShape),g=Qb(e.logicalShape),m=1===g;if(1!==s||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const t=s-2,e=s-1;i.indexOf(t)>-1&&i.indexOf(e)>-1?p="return vec4(outputValue.x);":i.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(a,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(r,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.texShape,o=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&null==t.shapeInfo.flatOffset&&$b(o,s))return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const c=bK(l),u=iK(t.shapeInfo.logicalShape,e.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":l<2&&u.length>=1?"coords = 0;":u.map((t=>"coords.".concat(p[t+h]," = 0;"))).join("\n");let f="";f=l<2&&i>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(p[e+h]))).join(", ");return"\n    float ".concat(a,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(r,"(").concat(f,");\n    }\n  ")}(t,e));return a}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=e.texShape,i=eK(),l=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(t.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let c,u,h=function(t){const e="".concat(t.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(t.varyingFs," vec2 resultUV;\n    ").concat(t.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(t.defineSpecialNaN,"\n    ").concat(t.defineSpecialInf,"\n    ").concat(t.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(hK,"\n    ").concat(dK,"\n    ").concat(pK,"\n  ");return e}(i);e.isPacked?(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1],".0);\n      }\n    ");if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      return 2 * (resTexRC.x * ").concat(r[1]," + resTexRC.y);\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if($b(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0],", ").concat(r[1],"));\n      }\n    ");const a=Math.ceil(t[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[2]/2),s=a*Math.ceil(t[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[t.length-1]/2),s=a*Math.ceil(t[t.length-2]/2);let o=s,i="",l="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],i="\n      int b".concat(c," = index / ").concat(o,";\n      index -= b").concat(c," * ").concat(o,";\n    ")+i,l="b".concat(c,", ")+l;return"\n    ivec".concat(t.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(t.length,"(").concat(l,");\n    }\n  ")}(t,e,n)}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(vec4 val) {\n      ".concat(t.output," = val;\n    }\n  ")}(i)):(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){if(1===e[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(e[1],".0);\n      }\n    ");if(1===e[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(e[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      return resTexRC.x * ").concat(e[1]," + resTexRC.y;\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){if($b(t,e))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(e[0],", ").concat(e[1],"));\n      }\n    ");if(1===t[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===t[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      int r = index / ").concat(t[1],";\n      int c = index - r * ").concat(t[1],";\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n){const e=rK(["r","c","d"],t);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(e,"\n    return ivec3(r, c, d);\n  }\n")}const r=nK(["r","c","d"],t);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,e,n);case 4:return function(t,e,n){if(n){const e=rK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(e,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const r=nK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(t,e,n);case 5:return function(t,e){const n=nK(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(e[0],",\n                             ").concat(e[1],"));\n\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(t,e);case 6:return function(t,e){const n=nK(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(t,e);default:throw new Error("".concat(t.length,"-D output sampling is not yet supported"))}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(float val) {\n      ".concat(t.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=fK);return[h,l,u,a,c,s,n.userCode].join("\n")}function cK(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"float ".concat(r,"() {return ").concat(n,";}");const[a,s]=t.shapeInfo.texShape;if(1===a&&1===s)return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=gK(n);if(e)return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,l]=t.shapeInfo.texShape;return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(l,", ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int index) {\n        ").concat(mK(t),"\n      }\n    ");const a=t.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return"\n      float ".concat(r,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=gK(n);if(1===o)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===s)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(e)return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&$b(n,s)){if(e)return"\n      float ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const t=s[0],n=s[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(t,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}const{newShape:o,keptDims:i}=oy(n),l=o;if(l.length<n.length){const n=vK(t,l),r=["row","col"];return"\n      ".concat(cK(n,e),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(wK(r,i),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(mK(t),"\n      }\n    ");const c=s[0],u=s[1],h=gK(r);if(1===u)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r,"TexShape[0]));\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(c,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(1===c)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(e)return"\n      float ".concat(a,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(c,", ").concat(u,", index);\n    return sampleTexture(").concat(r,", uv);\n  }\n")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:l}=oy(n),c=i;if(c.length<n.length){const n=vK(t,c),r=["row","col","depth"];return"\n        ".concat(cK(n,e),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(wK(r,l),");\n        }\n      ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(o,", 1)));\n        ").concat(mK(t),"\n      }\n    ");const u=t.shapeInfo.texShape,h=u[0],d=u[1],p=t.shapeInfo.flatOffset;if(d===s&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        int stride1 = ").concat(r,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(r,", uv);\n        }\n      ");if(d===o&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");const f=gK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r,"Shape[1] * ").concat(r,"Shape[2];\n      int stride1 = ").concat(r,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n      return sampleTexture(").concat(r,", uv);\n    }\n    ");return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(o," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(r,", uv);\n      }\n  ")}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:l,keptDims:c}=oy(n);if(l.length<n.length){const n=vK(t,l),r=["row","col","depth","depth2"];return"\n      ".concat(cK(n,e),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(wK(r,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(o,", ").concat(s,", 1)));\n        ").concat(mK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(r,"Shape[3];"),g="int stride1 = ".concat(r,"Shape[2] * stride2;"),m="int stride0 = ".concat(r,"Shape[1] * stride1;");if(p===i&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");if(p===s&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r,"Shape[1] * ").concat(r,"Shape[2], ").concat(r,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const b=gK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(g,"\n      ").concat(m,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e[4],s=e[3]*a,o=e[2]*s,i=e[1]*o,{newShape:l,keptDims:c}=oy(e);if(l.length<e.length){const e=vK(t,l),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(cK(e),"\n      float ").concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r,"(").concat(wK(n,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(o,", ").concat(s,", ").concat(a,")) +\n          depth3;\n        ").concat(mK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(s,", ").concat(a,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===a&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3],",\n               ").concat(e[2]*e[3],", ").concat(e[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=gK(n);return"\n    float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," + depth * ").concat(s," +\n          depth2 * ").concat(a," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=oy(e);if(a.length<e.length){const e=vK(t,a),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(cK(e),"\n      float ").concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r,"(").concat(wK(n,s),");\n      }\n    ")}const o=e[5],i=e[4]*o,l=e[3]*i,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(c,", ").concat(l,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(mK(t),"\n      }\n    ");const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(c,", ").concat(l,", ").concat(i,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===o&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3]*e[4],",\n               ").concat(e[2]*e[3]*e[4],",\n               ").concat(e[3]*e[4],",\n               ").concat(e[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=gK(n);return"\n    float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(c," + depth * ").concat(l," +\n          depth2 * ").concat(i," + depth3 * ").concat(o," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function uK(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=eK();return"\n    vec4 ".concat(n,"() {\n      return ").concat(r.texture2D,"(").concat(e,", halfCR);\n    }\n  ")}(t);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t.shapeInfo.texShape,s=eK();if(e)return"\n    vec4 ".concat(r,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(r,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0],", ").concat(o[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],i=s[1],l=eK();if(null!=s&&$b(n,s))return e?"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    "):"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(o,".0);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    ");if(e)return"\n    vec4 ".concat(a,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ");const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(c[0],", ").concat(c[1],", row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=vK(t,n.slice(1)),o=["b","row","col"];return"\n        ".concat(uK(s,e),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(wK(o,r),");\n        }\n      ")}const i=eK();if(e)return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ");const l=o[0],c=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l,", ").concat(c,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);default:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=eK();if(e)return"\n    vec4 ".concat(r,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=t.shapeInfo.logicalShape,o=s.length,i=t.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let g=2;g<o-1;g++)p="int b".concat(g,", ")+p,d*=s[o-g-1],f="b".concat(g," * ").concat(d," + ")+f;return"\n    vec4 ".concat(r,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(c,");\n      return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e)}}const hK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",dK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",pK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",fK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function gK(t){return"offset".concat(t)}function mK(t){const e=t.name,n=Qb(t.shapeInfo.logicalShape);return n<2?"return ".concat(e,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(e,"[i];\n      }\n    }\n  ")}function bK(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank ".concat(t," is not yet supported"))}function yK(t,e,n){const{newShape:r,keptDims:a}=oy(e),s=e.length,o=t&&3===s&&1===e[0],i=o?e.slice(1):r,l=!t&&s>1&&!$b(e,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:a}}function vK(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function wK(t,e){return e.map((e=>t[e])).join(", ")}function xK(t,e,n,r){const a=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=a.map((t=>t.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=lK(a,o,e),l=function(t,e){const n=WH(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(AH(t,(()=>t.shaderSource(n,e))),AH(t,(()=>t.compileShader(n))),Ay().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw DH(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,i),c=t.createProgram(l);return Ay().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},kK(t,e,c)))}function kK(t,e,n){const r=[],a=[];let s,o,i,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),1===Ay().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const a={name:h,uniform:t.getUniformLocation(n,h,u),offset:t.getUniformLocation(n,"offset".concat(h),u)};e.enableShapeUniforms&&(a.shape=t.getUniformLocation(n,"".concat(h,"Shape"),u),a.texShape=t.getUniformLocation(n,"".concat(h,"TexShape"),u)),r.push(a)}if(e.enableShapeUniforms&&(s=t.getUniformLocation(n,"outShape",u),i=t.getUniformLocation(n,"outShapeStrides",u),o=t.getUniformLocation(n,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)a.push(t.getUniformLocation(n,h.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}}function SK(t,e){if(t.length!==e.length)throw Error("Binary was compiled with ".concat(t.length," inputs, but ")+"was executed with ".concat(e.length," inputs"));t.forEach(((t,n)=>{const r=t.logicalShape,a=e[n],s=a.shape;if(!$b(r,s))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(r," and ").concat(s," must match"));if(t.isUniform&&a.isUniform)return;const o=t.texShape,i=a.isUniform?null:a.texData.texShape;if(!$b(o,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(i," must match"))}))}function IK(t){return Ay().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class NK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=kH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=eK();this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?rK(["r","c","d"],t):nK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class EK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=kH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=eK();this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?rK(["r","c","d"],t):nK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class CK{constructor(t){this.variableNames=["A"],this.outTexUsage=SH.DOWNLOAD;const e=eK();this.outputShape=t,this.userCode="\n      ".concat(oK,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}class TK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=SH.DOWNLOAD;const e=eK();this.outputShape=t,this.userCode="\n      ".concat(oK,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}const AK={R:0,G:1,B:2,A:3};class RK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=eK();this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length);let a="result";e&&(a="floor(result * 255. + 0.5)");let s="";for(let o=0;o<n.length;o++){const t=n[o];s+="\n          if(offset == ".concat(o,") {\n            result = values[").concat(AK[t],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sK(t),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(r.texture2D,"(A, uv);\n          ").concat(s,"\n        }\n        ").concat(r.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class FK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=eK();this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length);let r="",a="result";e&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let e=0;e<=1;e++){const a=2*s+e;r+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(e," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(t[2]),") {\n          localCoords[2] += ").concat(e,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(t[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(a,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(a,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(a,"] = values[2];\n            } else {\n              result[").concat(a,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sK(t),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(r,"\n\n          ").concat(n.output," = ").concat(a,";\n        }\n    ")}}function _K(t){const e=eK();return function(t,e){const n=WH(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(AH(t,(()=>t.shaderSource(n,e))),AH(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,"".concat(e.version,"\n    precision highp float;\n    ").concat(e.attribute," vec3 clipSpacePos;\n    ").concat(e.attribute," vec2 uv;\n    ").concat(e.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function DK(t){return function(t,e){const n=WH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return AH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),AH(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function OK(t){return function(t,e){const n=WH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return AH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),AH(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}function zK(t,e,n,r,a,s){!function(t,e){const n=Ay().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const n="[".concat(t,"x").concat(e,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(t>n||e>n){const r="[".concat(t,"x").concat(e,"]"),a="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}(e,n);const o=function(t){return WH(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),i=t.TEXTURE_2D;return AH(t,(()=>t.bindTexture(i,o))),AH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),AH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),AH(t,(()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST))),AH(t,(()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Ay().getNumber("WEBGL_VERSION")?AH(t,(()=>t.texImage2D(i,0,r,e,n,0,a,s,null))):AH(t,(()=>t.texStorage2D(i,1,r,e,n))),AH(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:o,texShape:[n,e]}}function LK(t){return t.internalFormatFloat}function MK(t){return t.internalFormatHalfFloat}function PK(t){return t.downloadTextureFormat}function BK(t){return t.internalFormatPackedFloat}function WK(t){return t.internalFormatPackedHalfFloat}function UK(t,e,n,r,a,s,o,i){const l=t,c=new Float32Array(function(t,e){const[n,r]=CH(t,e);return n*r*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}class VK{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Ay().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function(t,e){vH[t]=e}(e,t)):this.gl=xH(e),t=this.gl,2===Ay().getNumber("WEBGL_VERSION")){const e=t;this.createVertexArray=()=>AH(e,(()=>e.createVertexArray())),this.bindVertexArray=t=>AH(e,(()=>e.bindVertexArray(t))),this.deleteVertexArray=t=>AH(e,(()=>e.deleteVertexArray(t))),this.getVertexArray=()=>AH(e,(()=>e.getParameter(e.VERTEX_ARRAY_BINDING)))}else if(null!=t){const e=t.getExtension("OES_vertex_array_object");if(null==e)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>AH(t,(()=>e.createVertexArrayOES())),this.bindVertexArray=n=>AH(t,(()=>e.bindVertexArrayOES(n))),this.deleteVertexArray=n=>AH(t,(()=>e.deleteVertexArrayOES(n))),this.getVertexArray=()=>AH(t,(()=>t.getParameter(e.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ay().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=FH(this.gl,t),JH(this.gl,e))this.textureHalfFloatExtension=FH(this.gl,e);else if(Ay().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),JH(this.gl,r))this.colorBufferHalfFloatExtension=FH(this.gl,r);else if(Ay().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",JH(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!JH(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=DK(this.gl),this.indexBuffer=OK(this.gl),this.framebuffer=function(t){return WH(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=TH(this.gl,this.textureHalfFloatExtension)}get debug(){return Ay().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;AH(t,(()=>t.finish())),AH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),AH(t,(()=>t.deleteFramebuffer(this.framebuffer))),AH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),AH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),AH(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=NH(e,n);return zK(t,a,s,LK(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=NH(e,n);return zK(t,a,s,MK(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=NH(e,n);return zK(t,a,s,PK(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){AH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Ay().getNumber("WEBGL_VERSION")?AH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):AH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Ay().getNumber("WEBGL_VERSION")?AH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):AH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),AH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,a,s){let o,i,l;AH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),i=t.FLOAT,l=s.internalFormatPackedFloat),o.set(a),2===Ay().getNumber("WEBGL_VERSION")?AH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,i,o))):AH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,i,o))),AH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=CH(e,n);return zK(t,a,s,WK(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=CH(e,n);return zK(t,a,s,BK(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(PH(this.gl,this.framebuffer),this.outputTexture=null),AH(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[a,s]=NH(e,n),o=new Uint8Array(e*n*4);return AH(t,(()=>t.readPixels(0,0,a,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,a,s){return UK(this.gl,t,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const a=t.createBuffer();AH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,a)));const s=16*e*n;return AH(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),AH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),AH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),a}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Ay().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(a,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=a}else Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return AH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=_K(e));const n=function(t){return WH(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);AH(e,(()=>e.attachShader(n,this.vertexShader))),AH(e,(()=>e.attachShader(n,t))),function(t,e){if(AH(t,(()=>t.linkProgram(e))),!Ay().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&OH(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;AH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(t,e,n){AH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),zH(t,e,"clipSpacePos",n,3,20,0)&&zH(t,e,"uv",n,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(AH(this.gl,(()=>this.gl.deleteProgram(t))),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&OH(this.gl,this.program),AH(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(t,e,n){return WH(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),AH(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),LH(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,a]=CH(e,n);this.setOutputMatrixTextureDriver(t,r,a)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&OH(this.gl,this.program),BH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}AH(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),AH(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=FH(this.gl,2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await ry((()=>this.disposed||this.isQueryAvailable(t,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ay().platform&&(n=Ay().platform.setTimeoutCustom.bind(Ay().platform)),ry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),MH(this.gl,t,this.framebuffer),this.debug&&BH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(MH(this.gl,this.outputTexture,this.framebuffer),this.debug&&BH(this.gl)):PH(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;MH(r,t,this.framebuffer),this.debug&&BH(r),this.outputTexture=t,AH(r,(()=>r.viewport(0,0,e,n))),AH(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),AH(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:jK,bincountImpl:GK,bincountReduceImpl:HK,bitwiseAndImpl:KK,castImpl:qK,ceilImpl:XK,concatImpl:JK,equalImpl:YK,expImpl:ZK,expm1Impl:QK,floorImpl:$K,gatherNdImpl:tq,gatherV2Impl:eq,greaterImpl:nq,greaterEqualImpl:rq,lessImpl:aq,lessEqualImpl:sq,linSpaceImpl:oq,logImpl:iq,maxImpl:lq,maximumImpl:cq,minimumImpl:uq,multiplyImpl:hq,negImpl:dq,notEqualImpl:pq,prodImpl:fq,raggedGatherImpl:gq,raggedRangeImpl:mq,raggedTensorToTensorImpl:bq,rangeImpl:yq,rsqrtImpl:vq,scatterImpl:wq,sigmoidImpl:xq,simpleAbsImpl:kq,sliceImpl:Sq,sparseFillEmptyRowsImpl:Iq,sparseReshapeImpl:Nq,sparseSegmentReductionImpl:Eq,sqrtImpl:Cq,staticRegexReplaceImpl:Tq,stridedSliceImpl:Aq,stringNGramsImpl:Rq,stringSplitImpl:Fq,stringToHashBucketFastImpl:_q,subImpl:Dq,tileImpl:Oq,topKImpl:zq,transposeImpl:Lq,uniqueImpl:Mq}=a;function Pq(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>"".concat(t,".").concat(e)))}function Bq(t,e){return 1===e?[t]:Pq(t,e)}class Wq{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=IK(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=Bq("rc",this.rank),e=bK(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode="\n        void main() {\n          ".concat(e," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(a,"));\n          }\n        }\n      ")}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a="".concat(0===n?"r":"rp1",", ").concat(0===r?"c":"cp1");for(let e=2;e<this.rank;e++)a="".concat(t[t.length-1-e],",")+a;e.push(a)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let e="";for(let n=this.rank-2;n<this.rank;n++)e+="".concat(t[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],r=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(e[0],";\n      int c = ").concat(e[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(r,";\n    ")}getOutput(t){const e=this.getSourceCoordsArr(t);if(1===this.rank){const t=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(t," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(e[0],"),\n            cEdge ? 0. : getA(").concat(e[1],"),\n            rEdge ? 0. : getA(").concat(e[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(e[3],")")}}class Uq{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length);let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2===1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+="\n        ".concat(t,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(t,e){const n=e?aK(["r","c","d"],"inputShape"):nK(["r","c","d"],t);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sK(t),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":t[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":t[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class Vq{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const r=Gq(e,n),a=Hq(t,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=jq(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[a].pop();return this.usedTextures[a].push(t),t}let o;return r===IH.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===IH.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===IH.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===IH.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===IH.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const a=Gq(n,r),s=Hq(e,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=jq(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=Ay().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l&&l.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(t,")"));const e=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*e),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function jq(t,e,n,r,a){const s=function(t,e){switch(t){case IH.PACKED_2X2_FLOAT32:return BK(e);case IH.PACKED_2X2_FLOAT16:return WK(e);case IH.UNPACKED_FLOAT32:return LK(e);case IH.UNPACKED_FLOAT16:return MK(e);case IH.PACKED_4X1_UNSIGNED_BYTE:return PK(e);default:throw new Error("Unknown physical texture type ".concat(t))}}(e,r);let o;if(a){const[e,n]=CH(t[0],t[1]);o=e*n}else{const[e,n]=NH(t[0],t[1]);o=e*n}const i=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(e))}(n,s);return o*i}function Gq(t,e){if(t===SH.UPLOAD)return IH.PACKED_2X2_FLOAT32;if(t===SH.RENDER||null==t)return function(t){return Ay().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?IH.PACKED_2X2_FLOAT32:IH.UNPACKED_FLOAT32:t?IH.PACKED_2X2_FLOAT16:IH.UNPACKED_FLOAT16}(e);if(t===SH.DOWNLOAD||t===SH.PIXELS)return IH.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(t))}function Hq(t,e,n){return"".concat(t[0],"_").concat(t[1],"_").concat(e,"_").concat(n)}class Kq{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const qq="if (isnan(x)) return x;",Xq="return x;",Jq="return abs(x);";const Yq="return (x >= 0.0) ? x : (exp(x) - 1.0);",Zq=qq+"\n  return (x < 0.0) ? 0.0 : x;\n",Qq=qq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",$q="return x;",tX="return 1.0 / (1.0 + exp(-1.0 * x));",eX="return x;",nX="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",rX="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",aX="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",sX="return 1.0 / (1.0 + exp(-1.0 * x));";class oX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class iX{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length);const e=t.length,n=Bq("rc",e),r=bK(e),a=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(a,");\n\n        setOutput(getChannel(packedInput, ").concat(o,"));\n      }\n    ")}}const lX=OA,cX={};const uX=Ay().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class hX extends jb{nextDataId(){return hX.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ay().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(null!=t){if(t instanceof VK)e=t;else{const n=xH(Ay().getNumber("WEBGL_VERSION"),t);e=new VK(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=xH(Ay().getNumber("WEBGL_VERSION"));e=new VK(t),this.binaryCache=((n=Ay().getNumber("WEBGL_VERSION"))in cX||(cX[n]={}),cX[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Vq(this.gpgpu),this.numMBBeforeWarning=null==Ay().global.screen?1024:Ay().global.screen.height*Ay().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Vb(this,wS())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,n,r,a,s){const o=this.makeTensorInfo(e,n),i=this.texData.get(o.dataId);i.isPacked=!1,i.texture={texture:t,texShape:[r,a]},i.texShape=[r,a];const l=GH(e),c=new RK(l,!1,s),u=this.runWebGLProgram(c,[o],n,[[r,a]]);return u.shape=e,i.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(t,e,n){if((Ay().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ay().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:SH.UPLOAD,refCount:1}),r}refCount(t){if(this.texData.has(t)){return this.texData.get(t).refCount}return 0}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,r,a){if(Ay().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:SH.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=e;if(null!=s){let e;e=i?new oX(o,$q):new Kq(o,$q);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=bk()),"complex64"===r){u=QT(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else u=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=bk()-c),this.convertAndCacheOnCPU(t,u)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=e;if(null!=a){let e;e=i?new oX(r,$q):new Kq(r,$q);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if(Ay().getBool("DEBUG")&&!Ay().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ay().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==s&&Ay().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(e.texture.texture,...EH(r))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=QT(t[0],t[1])}else if(null==u)c=this.getValuesFromTexture(t);else{const t=Qb(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const t=this.gpgpu.gl;AH(t,(()=>t.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(t,c),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&wS().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new oX(a,$q):new Kq(a,$q);const r=this.runWebGLProgram(n,[{dataId:t,shape:a,dtype:o}],o),s=this.readToGPU(r,e);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,e.customTexShape),u=wS().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>vk(t)));return uI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return uI(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!RH(n)){if(Ay().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),a=Qb(e);if(Ay().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...EH(e)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=Ay().getBool("WEBGL_PACK")&&!0===r,o=s?GH(e):e,i=s?new TK(o):new CK(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const a=xk(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=xk(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(a);o.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),o.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>"".concat(t.name,": ").concat(t.ms))).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:bk(),endMs:null}}endTimer(t){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=bk(),t)}async getQueryTime(t){if(Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(t),i=o&&o.origDataId||t,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,a,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:uX;return Ay().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&Qb(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){Hx("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return lX(t.shape,e)}packedUnaryOp(t,e,n){const r=new oX(t.shape,e),a=this.compileAndRun(r,[t],n);return wS().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=kq(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Jq,t.dtype);const e=new Kq(t.shape,Jq),n=this.compileAndRun(e,[t]);return wS().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&hy(n[0])){const a=n.map((t=>yk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return wS().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new iX(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Wq(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[VH(t.shape),...jH(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},a=[VH(e),...jH(e)],s=new Uq(a,n),o=[n],i=this.runWebGLProgram(s,[r],t.dtype,o,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:a,dtype:s}=n;if(null!=e){Jb(Qb(a)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=GH(a);let i;i=r?new EK(o):new NK(o);const l=[null!=e?e:EH(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:t}],s,l,!0,e).dataId}}runWebGLProgram(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(t.outputShape,n),i=this.texData.get(o.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===kH.DENSE){const e=null!=s?s:EH(t.outputShape);i.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(i.usage=t.outTexUsage),0===Qb(o.shape))return i.values=iy(o.dtype,0),o;const l=[],c=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&Qb(e.shape)<=Ay().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!==!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!KH(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((e=>{const a=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const s=e.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:l}=yK(t.packedInputs,e.shape,s);let c="",u="",h="";if(1===i.length&&t.packedInputs){const t=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c="".concat(t[0]>1,"_").concat(t[1]>1)}else if(2!==i.length||t.packedInputs){if(i.length>2&&!t.packedInputs){const t=my(i);h="".concat(t[0]===s[1],"_").concat(t[t.length-1]===s[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=e.shape.length,p=2===i.length&&$b(e.shape,s),f=1===Qb(e.shape),g=zI(e.shape,n.shape),m=!t.packedInputs&&d===n.shape.length&&$b(s,n.texData.texShape),b=t.packedInputs||i.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);r+="".concat(d,"_").concat(m,"_").concat(o?l:"","_").concat(i.length,"_").concat(f,"_").concat(g,"_").concat(p,"_").concat(c,"_").concat(u,"_").concat(h,"_").concat(b,"_").concat(a)}else{const t=e.isUniform?"uniform":e.texData.texShape;r+="".concat(e.shape,"_").concat(t,"_").concat(a)}}));const a=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+a+"".concat(Ay().getNumber("WEBGL_VERSION")),s}(t,c,u),d=this.getAndSaveBinary(h,(()=>xK(this.gpgpu,t,c,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Ay().get("ENGINE_COMPILE_ONLY")||function(t,e,n,r,a){e.program.enableShapeUniforms||(SK(e.inShapeInfos,n),SK([e.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),1===Ay().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:o,texShape:i}=e.variablesLocations[l];if(o){const{uniformShape:n}=yK(e.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:t.gl.uniform1iv(o,new Int32Array(n));break;case 2:t.gl.uniform2iv(o,new Int32Array(n));break;case 3:t.gl.uniform3iv(o,new Int32Array(n));break;case 4:t.gl.uniform4iv(o,new Int32Array(n))}}if(i&&t.gl.uniform2i(i,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Qb(r.shape)<2)t.gl.uniform1f(a,r.uniformValues[0]);else{let e=r.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=r.texData.slice&&null!=s&&t.gl.uniform1i(s,r.texData.slice.flatOffset),t.setInputMatrixTexture(r.texData.texture.texture,a,l)}const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:t.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(i,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=my(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&a)for(let l=0;l<e.program.customUniforms.length;++l){const n=e.program.customUniforms[l],r=e.customUniformLocations[l],s=a[l];if("float"===n.type)t.gl.uniform1fv(r,s);else if("vec2"===n.type)t.gl.uniform2fv(r,s);else if("vec3"===n.type)t.gl.uniform3fv(r,s);else if("vec4"===n.type)t.gl.uniform4fv(r,s);else if("int"===n.type)t.gl.uniform1iv(r,s);else if("ivec2"===n.type)t.gl.uniform2iv(r,s);else if("ivec3"===n.type)t.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));t.gl.uniform4iv(r,s)}}t.executeProgram()}(this.gpgpu,d,c,u,r),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const g=Ay().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const t=bk();t-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Ay().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===a){const t=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),t}return o}compileAndRun(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||e[0].dtype;return this.runWebGLProgram(t,e,n,r,a)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Ay().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=kS((()=>{if(!Ay().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ay().getBool("DEBUG");Ay().set("DEBUG",!1);const e=this.abs(xI(1e-8)).dataSync()[0];if(Ay().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=e;if(null!=s)return;const l=null!=this.activeTimers;let c;l&&(c=bk());let u=e.texShape;if(null==u&&(u=function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Ay().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ay().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Ay().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n*=2,r*=2,1===(t=t.map(((e,n)=>n>=t.length-2?qb(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=oy(t);t=e.newShape}let a=Qb(t),s=null;t.length<=1&&a<=n?s=[1,a]:2===t.length&&t[0]<=n&&t[1]<=n?s=t:3===t.length&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(null==s||o)if(e){const e=VH(t);let n=2,r=2;t.length&&([n,r]=jH(t)),a=e*(n/2)*(r/2),s=ey(a).map((t=>2*t))}else s=ey(a);return s}(n,i),e.texShape=u),null!=a){const t=GH(n);let s,o=u[1],h=u[0];const d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!i&&d||([o,h]=CH(u[0],u[1])),s=i?new FK(t,d):new RK(t,d);const p=d?[h,o]:u,f=this.makeTensorInfo(p,r),g=this.texData.get(f.dataId);g.usage=d?SH.PIXELS:SH.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,h,a);const m=[[h,o]],b=!0,y=this.runWebGLProgram(s,[f],r,m,b),v=this.texData.get(y.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Ay().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=bk()-c)}else{const t=this.acquireTexture(u,o,r,i);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype ".concat(e))}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(t," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*uy(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(n){throw n}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await IT(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw DH(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}=kK(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=a,t.outShapeLocation=s,t.outShapeStridesLocation=o,t.outTexShapeLocation=i}}createTensorFromGPUData(t,e,n){t.channels=t.channels||"RGBA";const{texture:r,height:a,width:s,channels:o}=t,i=wS().backend;if(!i.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=i.writeTexture(r,e,n,a,s,o);return wS().makeTensorFromDataId(l,e,n,i)}}hX.nextDataId=0;lS()&&NS("webgl",(()=>new hX),2);const dX="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class pX{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=MI(e,n),this.enableShapeUniforms=IK(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const fX="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class gX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=MI(e,n);const a=this.outputShape.length;this.enableShapeUniforms=IK(a);let s="";if(r)if(0===a||1===Qb(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const t=bK(a);if(s="\n          ".concat(t," coords = getOutputCoords();\n        "),1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const t=Bq("coords",a);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= outShape[").concat(a," - 2];\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= outShape[").concat(a," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= ").concat(this.outputShape[a-2],";\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= ").concat(this.outputShape[a-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}}function mX(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const bX={kernelName:Jv,backendName:"webgl",kernelFunc:mX};function yX(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=mX({inputs:{x:r},backend:n}),l=mX({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:l},s}const vX={kernelName:ov,backendName:"webgl",kernelFunc:yX},wX="return (a < 0.) ? b * a : a;",xX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const kX={kernelName:ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r,o=n.makeTensorInfo([],"float32",gk(s,"float32")),i=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gX(xX,a.shape,o.shape):new pX(wX,a.shape,o.shape),l=n.runWebGLProgram(i,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},SX="return (a < 0.) ? b * a : a;",IX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const NX={kernelName:Lw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gX(IX,r.shape,a.shape):new pX(SX,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},EX="if (isnan(x)) return x;";function CX(t){let{opSnippet:e,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=t;return t=>{let{inputs:s,backend:o}=t;const{x:i}=s,l=o,c=a||i.dtype;if(l.shouldExecuteOnCPU([i])&&null!=r){const t=l.texData.get(i.dataId),e=r(t.values,c);return l.makeTensorInfo(i.shape,c,e)}let u;return u=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new oX(i.shape,n):new Kq(i.shape,e),l.runWebGLProgram(u,[i],c)}}function TX(t){let{opSnippet:e,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:o}=t;return t=>{let{inputs:i,backend:l}=t;const{a:c,b:u}=i,h=l;if(a&&"complex64"===c.dtype){const t=h.texData.get(c.dataId),n=h.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:c.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},o=new pX(e,c.shape,u.shape);return h.runWebGLProgram(o,[a,s],Kk(n.dtype,r.dtype))})),s=yX({inputs:{real:r,imag:a},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(a),s}const d=o||Kk(c.dtype,u.dtype);if(("string"===c.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([c,u]))&&null!=s){const t=h.texData.get(c.dataId).values,e=h.texData.get(u.dataId).values,n="string"===c.dtype?_A(t):t,r="string"===c.dtype?_A(e):e,[a,o]=s(c.shape,u.shape,n,r,d),i=h.makeTensorInfo(o,d);return h.texData.get(i.dataId).values=a,i}let p;return p=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new gX(n,c.shape,u.shape,r):new pX(e,c.shape,u.shape),h.runWebGLProgram(p,[c,u],d)}}function AX(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===t)return e?eX:Xq;if("relu"===t)return e?rX:Zq;if("elu"===t)return e?nX:Yq;if("relu6"===t)return e?aX:Qq;if("prelu"===t)return e?IX:SX;if("leakyrelu"===t)return e?xX:wX;if("sigmoid"===t)return e?sX:tX;throw new Error("Activation ".concat(t," has not been implemented for the WebGL backend."))}class RX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=IK(this.outputShape.length);const c=r?t[1]:t[2],u=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";o&&(g=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(o,"\n        }"):l?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(o,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(o,"\n        }"),m="result = activation(result);");const b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y="imod(rc.x, ".concat(t[0],")"):e[0]<t[0]&&(v="imod(rc.x, ".concat(e[0],")")),this.userCode="\n      ".concat(g,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(m,"\n\n        setOutput(result);\n      }\n    ")}}const FX={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class _X{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=MI(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const DX="return a * b;";function OX(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Kk(r.dtype,a.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),s=new _X(FX.REAL,r.shape,a.shape),o=new _X(FX.IMAG,r.shape,a.shape),i=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,i,"float32"),c=n.runWebGLProgram(o,i,"float32"),u=yX({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([r,a])){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),[o,i]=hq(r.shape,a.shape,t.values,e.values,s),l=n.makeTensorInfo(i,s);return n.texData.get(l.dataId).values=o,l}let o;return o=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gX(DX,r.shape,a.shape):new pX(DX,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const zX={kernelName:Nw,backendName:"webgl",kernelFunc:OX};function LX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=n,i=Qb(a.shape),l=ay(s,i),c=Qb(l);Jb(i===c,(()=>"The new shape (".concat(l,") has ").concat(c," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=o.texData.get(a.dataId);return!u.isPacked||KH(a.shape,l)||null!==u.texture&&KH(u.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(t,e,n){const r=[VH(t.shape),...jH(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[VH(e),...jH(e)],o=new Uq(s,r),i=[r],l=n.runWebGLProgram(o,[a],t.dtype,i,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(a,l,o)}const MX={kernelName:Hw,backendName:"webgl",kernelFunc:LX};class PX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l="sumValue += dot(values * ".concat(ty(t)?t.toPrecision(2):t,", ones);")}let c="";a%n>0&&(c="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class BX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];let o="0.0",i="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",i="min"):"max"===e&&(o="-1.0 / 1e-20",i="max");let l="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===e,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===e,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===e," || ").concat("max"===e,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";a%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(o,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(o,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(l,");\n      }\n    ")}}function WX(t,e,n,r){const a=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=DT(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let s=t;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:l,outSize:c}=a[o];let u,h;u="mean"===n?0===o?new PX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},i):new PX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c}):new BX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},n),h=s,s=r.runWebGLProgram(u,[s],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return s}class UX{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;const r=bK(this.rank),a=function(t){const e=t.length;if(e>6)throw Error("Transpose for rank ".concat(e," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let a=0;a<t.length;a++)r[t[a]]=n[a];return r.join()}(e);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(a,"));\n    }\n    ")}}class VX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const r=bK(this.rank),a=Pq("rc",this.rank),s=new Array(this.rank);for(let c=0;c<e.length;c++)s[e[c]]=a[c];const o="vec2(".concat(s.slice(-2).join(),")"),i="++".concat(a[this.rank-1]," < ").concat(n[this.rank-1]),l="getChannel(getA(".concat(s.join(),"), ").concat(o,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l,";\n      if(").concat(i,") {\n        result[1] = ").concat(l,";\n      }\n      --").concat(a[this.rank-1],";\n      if(++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(l,";\n        if(").concat(i,") {\n          result[3] = ").concat(l,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function jX(t,e,n){const r=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VX(t.shape,e):new UX(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function GX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;return function(t,e,n,r){const a=e,s=t.shape.length,o=sy(a,t.shape);let i=o;const l=NE(i,s),c=null!=l;let u=t;c&&(u=jX(t,l,r),i=CE(i.length,s)),IE("sum",i,s);const[h,d]=kE(u.shape,i);let p=h;n&&(p=SE(h,o));const f=Qb(d),g=LX({inputs:{x:u},attrs:{shape:[Qb(t.shape)/f,f]},backend:r}),m=WX(g,qk(t.dtype),"sum",r),b=LX({inputs:{x:m},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(m),c&&r.disposeIntermediateTensorInfo(u),b}(a,s,o,n)}const HX={kernelName:dx,backendName:"webgl",kernelFunc:GX};function KX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{perm:s}=r,o=n,i=a.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let c;if(o.shouldExecuteOnCPU([a])){const t=o.texData.get(a.dataId).values,e=Lq(t,a.shape,a.dtype,s,l);c=o.makeTensorInfo(l,a.dtype);o.texData.get(c.dataId).values=e}else c=jX(a,s,o);return c}const qX={kernelName:Ox,backendName:"webgl",kernelFunc:KX},XX=1e3;function JX(t){let{a:e,b:n,transposeA:r,transposeB:a,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:c=null}=t;const u=e.shape.length,h=n.shape.length,d=r?e.shape[u-2]:e.shape[u-1],p=a?n.shape[h-1]:n.shape[h-2],f=r?e.shape[u-1]:e.shape[u-2],g=a?n.shape[h-2]:n.shape[h-1],m=e.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Qb(m),v=Qb(b),w=MI(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);Jb(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(e.shape," and ")+"".concat(n.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const x=r?[y,d,f]:[y,f,d],k=a?[v,g,p]:[v,p,g],S=LX({inputs:{x:e},backend:s,attrs:{shape:x}}),I=LX({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],E=Math.max(y,v),C=r?S.shape[1]:S.shape[2],T=null!=o,A=null!=i,R="leakyrelu"===c,F=null!=c?AX(c,!0):null;let _;if((1===f||1===g)&&C>XX&&!1===(T||A||R||null!=F)){let t=S,e=I;r&&(t=KX({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(t)),a&&(e=KX({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e));const n=1===g;let o=t;1!==g&&(o=LX({inputs:{x:t},backend:s,attrs:{shape:[E,C,1]}}),N.push(o));const i=1===g?2:1;let l=e;n&&(l=LX({inputs:{x:e},backend:s,attrs:{shape:[E,1,C]}}),N.push(l));const c=OX({inputs:{a:o,b:l},backend:s});_=GX({inputs:{x:c},backend:s,attrs:{axis:i,keepDims:!0}}),N.push(c)}else{const t=Kk(e.dtype,n.dtype),c=new RX(x,k,[E,f,g],r,a,T,F,A,R),u=[S,I];if(null!=o&&u.push(o),A&&u.push(i),R){const t=s.makeTensorInfo([],"float32",gk(l,"float32"));u.push(t),N.push(t)}_=s.runWebGLProgram(c,u,t)}const D=LX({inputs:{x:_},backend:s,attrs:{shape:w}});N.push(_);for(const O of N)s.disposeIntermediateTensorInfo(O);return D}const YX={kernelName:Vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return JX({a:a,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},ZX="return abs(x);";const QX={kernelName:Oy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const t=n.texData.get(r.dataId),e=kq(t.values);return n.makeTensorInfo(r.shape,r.dtype,e)}let a;return a=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new oX(r.shape,ZX):new Kq(r.shape,ZX),n.runWebGLProgram(a,[r],r.dtype)}},$X=CX({opSnippet:qq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),tJ={kernelName:zy,backendName:"webgl",kernelFunc:$X},eJ=CX({opSnippet:qq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),nJ={kernelName:Ly,backendName:"webgl",kernelFunc:eJ},rJ="return a + b;",aJ=TX({opSnippet:rJ,packedOpSnippet:rJ,supportsComplex:!0,cpuKernelImpl:jK}),sJ={kernelName:My,backendName:"webgl",kernelFunc:aJ};class oJ{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("float v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}class iJ{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("vec4 v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}const lJ={kernelName:Py,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,a=n;if(1===a.length)return mX({inputs:{x:a[0]},backend:r});if(a.length>Ay().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(a.length/2),n=t({inputs:a.slice(0,e),backend:r}),s=t({inputs:a.slice(e),backend:r});return t({inputs:[n,s],backend:r})}const s=a.map((t=>t.dtype)).reduce(((t,e)=>Kk(t,e))),o=a.map((t=>t.shape)),i=Ay().getBool("WEBGL_PACK")?new iJ(a[0].shape,o):new oJ(a[0].shape,o);return r.runWebGLProgram(i,a,s)}};const cJ={kernelName:By,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=NE(c,i);let h=a;null!=u&&(h=KX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=CE(c.length,i)),IE("all",c,i);const[d,p]=kE(h.shape,c),f=LX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=WX(f,f.dtype,"all",n);let m;if(o){m=LX({inputs:{x:g},backend:n,attrs:{shape:SE(d,l)}})}else m=LX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};const uJ={kernelName:Wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=NE(c,i);let h=a;null!=u&&(h=KX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=CE(c.length,i)),IE("any",c,i);const[d,p]=kE(h.shape,c),f=LX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=WX(f,f.dtype,"any",n);let m;if(o){m=LX({inputs:{x:g},backend:n,attrs:{shape:SE(d,l)}})}else m=LX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};class hJ{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===e?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(o," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class dJ{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Jb(t.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const a=t[t.length-1],s=Math.ceil(a/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=bK(i),c=Bq("coords",i);let u,h;if(1===s){h=i+1;const t=bK(h);u="\n        ".concat(t," sourceLocR = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-1],";\n        ").concat(t," sourceLocG = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-2],";\n        ").concat(t," sourceLocA = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-1],";\n        ").concat(t," sourceLocB = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-2],";")}else h=i,u="\n        ".concat(l," sourceLocR = coords;\n        ++").concat(c[i-1],";\n        ").concat(l," sourceLocG = coords;\n        ++").concat(c[i-2],";\n        ").concat(l," sourceLocA = coords;\n        --").concat(c[i-1],";\n        ").concat(l," sourceLocB = coords;\n        --").concat(c[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((t=>"int "+t)),g=Bq("sourceLocR",h-1).concat("inIdx.r"),m=Bq("sourceLocG",h-1).concat("inIdx.g"),b=Bq("sourceLocB",h-1).concat("inIdx.b"),y=Bq("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",w=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),x="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(m.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=r?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(l," coords = getOutputCoords();\n        bool hasNextCol = ").concat(c[i-1]," < ").concat(o[i-1]-1,";\n        bool hasNextRow = ").concat(c[i-2]," < ").concat(o[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(e,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(x,";\n\n        for (int i = 0; i < ").concat(e,"; i++) {\n          inIdx = srcIdx;\n          ").concat(w,"\n          vec4 candidate = ").concat(x,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function pJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=e.shape[0],s=e.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=DT(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},l=new hJ(i,n,null==r),c=[e];null!=r&&c.push(r);const u=t.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=pJ(t,e,n,u);return t.disposeIntermediateTensorInfo(u),h}function fJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:e.shape,s=DT(a[a.length-1]),o=new dJ(a,s,n,null==r),i=null==r?[e]:[e,r],l=t.runWebGLProgram(o,i,"int32");if(l.shape.length===e.shape.length){const r=fJ(t,e,n,l);return t.disposeIntermediateTensorInfo(l),r}return l}function gJ(t,e,n,r){const a=[n];if(IE("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,e.shape.length),!Ay().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],s=t.texData.get(e.dataId);let o=e;null!==s&&s.isPacked&&(o=t.unpackTensor(e),n.push(o));const[i,l]=kE(o.shape,a),c=Qb(l),u=LX({inputs:{x:o},backend:t,attrs:{shape:[-1,c]}});n.push(u);const h=pJ(t,u,r);n.push(h);const d=LX({inputs:{x:h},backend:t,attrs:{shape:i}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),d}return fJ(t,e,r)}const mJ={kernelName:Uy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=sy(s,a.shape);const i=NE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=KX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=CE(o.length,l.shape.length)),IE("argMax",[o[0]],l.shape.length);const u=gJ(n,l,o[0],"max");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}};const bJ={kernelName:Vy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=sy(s,a.shape);const i=NE(o,a.shape.length);let l=a;const c=[];null!=i&&(l=KX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=CE(o.length,l.shape.length)),IE("argMin",[o[0]],l.shape.length);const u=gJ(n,l,o[0],"min");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}},yJ=CX({opSnippet:qq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),vJ={kernelName:jy,backendName:"webgl",kernelFunc:yJ},wJ=CX({opSnippet:qq+"return log(x + sqrt(x * x + 1.0));"}),xJ={kernelName:Gy,backendName:"webgl",kernelFunc:wJ},kJ=CX({opSnippet:qq+"\n  return atan(x);\n"}),SJ={kernelName:Hy,backendName:"webgl",kernelFunc:kJ},IJ=TX({opSnippet:dX+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+fX+"\n  return result;\n"}),NJ={kernelName:qy,backendName:"webgl",kernelFunc:IJ},EJ=CX({opSnippet:qq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),CJ={kernelName:Ky,backendName:"webgl",kernelFunc:EJ};class TJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,g="((batch  * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + d"),m="(xR * ".concat(t.inWidth," + xC) * ").concat(t.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(c,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(e," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?a?g:m:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(y="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),w=s%4,x="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(l,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(c,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              getValue(batch, xR, xC + 3 * ").concat(c,", d)\n            );\n\n            ").concat(x,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(2===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(3===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              initializationValue\n            );\n\n            ").concat(x,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class AJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,i=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=t.padInfo.front,m=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(c,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(e," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?a?"(((batch * ".concat(t.inDepth," + xD) * ").concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"((xD * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let w="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(s/4),k=s%4,S="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(c,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(x,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(w,");\n      }\n    ")}}const RJ={kernelName:Xy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;$H(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(FN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=xN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))return mX({inputs:{x:a},backend:n});const u=new TJ(c,"avg",!1);return n.runWebGLProgram(u,[a],"float32")}};const FJ={kernelName:Yy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r,u=kN(a.shape,s,o,[1,1,1],i,l,c),h=new AJ(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}};class _J{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=i-1-t.padInfo.top,u=l-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(l,";\n            wC+= ").concat(o,") {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class DJ{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=u-1-t.padInfo.front,f=h-1-t.padInfo.top,g=d-1-t.padInfo.left,m=1/(e*n*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(g,");\n      const float avgMultiplier = float(").concat(m,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(a,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(l,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const OJ={kernelName:Zy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=kN(o.shape,i,l,[1,1,1],c,u),d=new DJ(h);return n.runWebGLProgram(d,[a],o.dtype)}};const zJ={kernelName:Jy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;$H([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=xN(o.shape,i,l,1,c),h=new _J(u);return n.runWebGLProgram(h,[a],o.dtype)}};const LJ={kernelName:Qy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;return JX({a:a,b:s,transposeA:o,transposeB:i,backend:n})}};class MJ{constructor(t,e,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],MI(t,e),MI(t,n);let o="0.0";null!=r&&(MI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(MI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class PJ{constructor(t,e,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],MI(t,e),MI(t,n);let o="vec4(0.0)";null!=r&&(MI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(MI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const BJ={kernelName:Gv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,mean:s,variance:o,offset:i,scale:l}=e;Jb(s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=[a,s,o];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=l&&(d=l.shape,u.push(l));const p=Ay().getBool("WEBGL_PACK_NORMALIZATION")?new PJ(a.shape,s.shape,o.shape,h,d,c):new MJ(a.shape,s.shape,o.shape,h,d,c);return n.runWebGLProgram(p,u,u[0].dtype)}};class WJ{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=bK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return UJ.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error("Slicing for rank ".concat(t," is not yet supported"))}(this.rank);let r;const a=t.map(((t,e)=>"sourceLoc.".concat(UJ[e]," = start[").concat(e,"] + coords.").concat(UJ[e],";")));r="\n        ".concat(e," sourceLoc;\n        ").concat(e," coords = getOutputCoords();\n        ").concat(a.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(r,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const UJ=["x","y","z","w","u","v"];class VJ{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=bK(this.rank),n=Bq("coords",this.rank),r=Bq("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),s="getChannel(getSource(".concat(r.join(),"), ").concat(a,")"),o="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(r[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(t[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),l=this.rank<=4?"sourceLoc = coords +\n            ".concat(e,"(").concat(t.map(((t,e)=>"start[".concat(e,"]"))).join(),");"):t.map(((t,e)=>"".concat(r[e]," = ").concat(n[e]," + start[").concat(e,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(e," coords = getOutputCoords();\n        ").concat(e," sourceLoc;\n        ").concat(l,"\n        vec4 result = vec4(0.);\n        ").concat(o,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function jJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r,[i,l]=fN(a,s,o);if(tN(a,i,l),0===Qb(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const t=n.texData.get(a.dataId),e=Sq(t.values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,e)}const{isPacked:c}=n.texData.get(a.dataId),u=dN(a.shape,i,l);if(c||!u){const t=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VJ(l):new WJ(l),e=[i];return n.runWebGLProgram(t,[a],a.dtype,e)}return n.uploadToGPU(a.dataId),function(t,e,n,r){const a=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=t.dtype;let i=pN(e,my(t.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||t.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}(a,i,l,n)}const GJ={kernelName:sx,backendName:"webgl",kernelFunc:jJ},HJ={kernelName:$y,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;Jb(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=zT(a.shape,s,i),c=LT(l.length,s.length),u=MT(a.shape,s,i),h=PT(o,s.length),d=BT(u,o,s.length),p=[],f=LX({inputs:{x:a},backend:n,attrs:{shape:l}}),g=KX({inputs:{x:f},backend:n,attrs:{perm:c}}),m=LX({inputs:{x:g},backend:n,attrs:{shape:u}}),b=jJ({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}};const KJ={kernelName:tv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=n.readSync(a.dataId),l=n.readSync(s.dataId),c=GK(i,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}};const qJ={kernelName:ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ay().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===o){const t=n.texData.get(r.dataId).values,e=n.texData.get(a.dataId).values,[s,o]=KK(r.shape,a.shape,t,e,r.dtype),i=n.makeTensorInfo(o,r.dtype);return n.texData.get(i.dataId).values=s,i}let i;return i=s?new gX("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new pX("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(i,[r,a],r.dtype)}};const XJ={kernelName:nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.readSync(r.dataId),o=n.readSync(a.dataId),i=MI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},JJ=TX({opSnippet:"return float(a != b);",cpuKernelImpl:pq,dtype:"bool"}),YJ={kernelName:Cw,backendName:"webgl",kernelFunc:JJ};function ZJ(t){const{inputs:e,backend:n}=t,{input:r}=e;return mX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const QJ={kernelName:Vw,backendName:"webgl",kernelFunc:ZJ},$J="return float(int(x));";const tY={kernelName:rv,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return mX({inputs:{x:s},backend:r});const e=WE(s.shape),n=t({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=yX({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const e=ZJ({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),n}if(!cy(s.dtype,o)){const t=mX({inputs:{x:s},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const t=r.texData.get(s.dataId).values,[e,n,a]=qK(t,s.shape,s.dtype,o);return r.makeTensorInfo(e,n,a)}if("int32"===o)return function(t,e){const n=new Kq(t.shape,$J),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const t=r.makeTensorInfo([],"bool",iy("bool",1)),e=JJ({inputs:{a:s,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(o))}},eY="return ceil(x);",nY=CX({opSnippet:eY,packedOpSnippet:eY,cpuKernelImpl:XK}),rY={kernelName:av,backendName:"webgl",kernelFunc:nY};class aY{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class sY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const oY={kernelName:sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{clipValueMin:s,clipValueMax:o}=r;let i;i=Ay().getBool("WEBGL_PACK_CLIP")?new sY(a.shape):new aY(a.shape);const l=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,l)}};class iY{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function lY(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const cY={kernelName:iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=n.texData.get(r.dataId),s=new iY(r.shape),o=[lY(r,a.complexTensorInfos.real),lY(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class uY{constructor(t){this.outputShape=[],this.outputShape=ET(t,1),this.variableNames=t.map(((t,e)=>"T".concat(e)));const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=["if (yC < ".concat(e[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<e.length;s++){const t=e[s-1];n.push("else if (yC < ".concat(e[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(t,"));"))}const r=e.length,a=e[e.length-1];n.push("else setOutput(getT".concat(r,"(yR, yC-").concat(a,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class hY{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ET(t,e);const n=this.outputShape,r=n.length,a=bK(r),s=Bq("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>"T".concat(e)));const i=new Array(t.length-1);i[0]=t[0][e];for(let f=1;f<i.length;f++)i[f]=i[f-1]+t[f][e];const l=o[e],c=o.slice(-2),u=o.join();let h="if (".concat(l," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(c.join(),"));\n        }");for(let f=1;f<i.length;f++){const t=i[f-1];h+="\n        if (".concat(l," < ").concat(i[f],"  && ").concat(l," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(dY(o,l,t),"),\n            vec2(").concat(dY(c,l,t),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(dY(o,l,p),"),\n          vec2(").concat(dY(c,l,p),"));"),this.userCode="\n      float getValue(".concat(o.map((t=>"int "+t)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(a," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," + 1;\n        if (").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-2]," = ").concat(s[r-2]," + 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," - 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2]," &&\n            ").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}function dY(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?"".concat(t," - ").concat(n):t)).join()}function pY(t){const{inputs:e,backend:n}=t,{input:r}=e;return mX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const fY={kernelName:Zv,backendName:"webgl",kernelFunc:pY};function gY(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>ZJ({inputs:{input:t},backend:n}))),a=t.map((t=>pY({inputs:{input:t},backend:n}))),s=gY(r,e,n),o=gY(a,e,n),i=yX({inputs:{real:s,imag:o},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),a.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(t);if("string"===r&&(a=!0),a){const a=t.map((t=>{const r=Qb(t.shape.slice(e));return LX({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),o=ET(a.map((t=>t.shape)),1),i=1===a[0].shape[0],l=JK(s,o,r,i),c=ET(t.map((t=>t.shape)),e),u=n.makeTensorInfo(c,r,l);return a.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}const s=t.filter((t=>Qb(t.shape)>0)),o=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const e=o?new Kq(t[0].shape,$q):new oX(t[0].shape,$q);return n.runWebGLProgram(e,t,r)}const i=Ay().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){const t=[];for(let a=0;a<s.length;a+=i){const r=s.slice(a,a+i);t.push(gY(r,e,n))}const r=gY(t,e,n);for(const e of t)n.disposeIntermediateTensorInfo(e);return r}if(o){const t=new hY(s.map((t=>t.shape)),e);return n.runWebGLProgram(t,s,r)}const{tensors2D:l,outShape:c}=function(t,e,n){const r=ET(t.map((t=>t.shape)),e),a=t.map((t=>LX({inputs:{x:t},attrs:{shape:[-1,Qb(t.shape.slice(e))]},backend:n})));return{tensors2D:a,outShape:r}}(s,e,n),u=new uY(l.map((t=>t.shape))),h=n.runWebGLProgram(u,l,r);l.forEach((t=>n.disposeIntermediateTensorInfo(t)));const d=LX({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function mY(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=sy(a,e[0].shape)[0];NT(e.map((t=>t.shape)),s);const o=ET(e.map((t=>t.shape)),s);if(0===Qb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Qb(t.shape)>0));return 1===i.length?mX({inputs:{x:i[0]},backend:n}):gY(i,s,n)}const bY={kernelName:lv,backendName:"webgl",kernelFunc:mY};class yY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,o=t.padInfo.left,i=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,g="channelsLast"===t.dataFormat,m=g?1:2,b=g?2:3,y=g?3:1;let v="",w="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),w="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(l,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(c,";\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(t.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(x,"\n        ").concat(w,"\n        setOutput(result);\n      }\n    ")}}class vY{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(a,", ").concat(s,", ").concat(o,");\n      const ivec3 pads = ivec3(").concat(e,", ").concat(n,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(l,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(c,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class wY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=IK(this.outputShape.length);const s=t.padInfo.left,o=t.strideWidth,i=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,u=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+="\n           vec4 xTexelC".concat(2*g,";\n           int xTexelC").concat(2*g,"Ready;\n           vec4 xTexelC").concat(2*g+1,";\n           int xTexelC").concat(2*g+1,"Ready;\n           vec4 xC").concat(g,";");h+="\n     for (int r = 0; r < ".concat(l,"; r++) {\n      for (int d1 = 0; d1 < ").concat(t.inChannels,"; d1 += 2) {\n       ");for(let g=0;g<c;g++)h+="\n           xTexelC".concat(2*g," = vec4(0.0);\n           xTexelC").concat(2*g,"Ready = 0;\n           xTexelC").concat(2*g+1," = vec4(0.0);\n           xTexelC").concat(2*g+1,"Ready = 0;\n           xC").concat(g," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const e=2*g;if(h+="\n           xC = xCCorner + ".concat(e*i,";\n           "),1===o){if(e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n               "),h+=1===i&&e>0?"\n                 xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                   } else {\n                     xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xC").concat(e," = xTexelC").concat(e,";\n                 "),e+1<c)){const t=s%2===0?qb(i):i;i%2===0&&s%2===1||i%2!==0&&s%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                     xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(e+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(e+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                     } else {\n                      xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                     }\n                     "):"\n                     xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                     ")):h+=1===t?"\n                     xC".concat(e+1," = xTexelC").concat(e,";\n                     "):"\n                     xCOffset = xC + ".concat(t,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                       xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(e+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(e+1,"Ready = 1;\n                     }\n\n                     xC").concat(e+1," = xTexelC").concat(e+1,";\n                     ")}}else e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n               "),e+1<c&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(\n                   xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n               "),e+1<c&&(h+="\n                   xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                 "))));e<c&&(h+="\n             wTexel = getW(r, ".concat(e,", d1, d2);\n             dotProd += xC").concat(e,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(t.inChannels,") {\n               dotProd += xC").concat(e,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),e+1<c&&(h+="\n               wTexel = getW(r, ".concat(e+1,", d1, d2);\n               dotProd += xC").concat(e+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(t.inChannels,") {\n                 dotProd += xC").concat(e+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):a?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class xY{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=IK(this.outputShape.length);const{dataFormat:n}=e,r=eK(),a="channelsLast"===n,s=a?1:2,o=a?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(t[2]," && pos < ").concat(t[1],") {");let l="";for(let c=0;c<=1;c++)for(let t=0;t<=1;t++)l+="\n          blockIndex = rc.z + ".concat(t,";\n          pos = rc.y + ").concat(c,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(o,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(a,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(l,"\n\n        ").concat(r.output," = result;\n      }\n    ")}}function kY(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function SY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const c=e.shape,u=a.texData.get(e.dataId),h=r.inChannels,d=c[0]*c[1]*c[2],p=r.outChannels,f="channelsLast"===r.dataFormat;let g;const m=[];if(null!=o){const t=kY(o.shape,f);null!=t&&(o=LX({inputs:{x:o},backend:a,attrs:{shape:t}}),m.push(o))}if(null!=s){const t=kY(s.shape,f);null!=t&&(s=LX({inputs:{x:s},backend:a,attrs:{shape:t}}),m.push(s))}if(!((1===d||1===p)&&h>XX)&&u.isPacked&&f&&null!=u.texture&&c[2]%2!==0&&$b(u.shape.slice(-3),c.slice(-3))){const t=c[0]*c[1]*(c[2]+1),h={dataId:e.dataId,shape:[1,t,r.inChannels],dtype:e.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Jb(KH(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=LX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});m.push(p);const f=JX({a:h,b:p,backend:a,transposeA:false,transposeB:false,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i}),b=a.texData.get(f.dataId);Jb(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,b.shape=r.outShape,g=mX({inputs:{x:f},backend:a}),g.shape=r.outShape,m.push(f)}else{const t=r.outHeight*r.outWidth,c=LX({inputs:{x:e},backend:a,attrs:{shape:f?[r.batchSize,t,r.inChannels]:[r.batchSize,r.inChannels,t]}}),u=LX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=JX({a:f?c:u,b:f?u:c,transposeA:!f,transposeB:false,backend:a,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i});g=LX({inputs:{x:h},backend:a,attrs:{shape:r.outShape}}),m.push(c),m.push(u),m.push(h)}for(const b of m)a.disposeIntermediateTensorInfo(b);return g}function IY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const{filterWidth:c,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,g="channelsLast"===f,m=c*u*h,b=p*d,y=[r.batchSize,m,b],v=[];if(null!=o){const t=kY(o.shape,g);null!=t&&(o=LX({inputs:{x:o},backend:a,attrs:{shape:t}}),v.push(o))}if(null!=s){const t=kY(s.shape,g);null!=t&&(s=LX({inputs:{x:s},backend:a,attrs:{shape:t}}),v.push(s))}const w=LX({inputs:{x:n},backend:a,attrs:{shape:[1,m,Qb(n.shape)/m]}});v.push(w);const x=new xY(y,r),k=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(x,[e],"float32",k),I=LX({inputs:{x:S},backend:a,attrs:{shape:y}});v.push(S),v.push(I);const N=null!=s,E=null!=o,C="leakyrelu"===l,T=l?AX(l,!0):null,A=new RX(g?I.shape:w.shape,g?w.shape:I.shape,g?[r.batchSize,b,r.outChannels]:[r.batchSize,r.outChannels,b],!0,!1,N,T,E,C),R=g?[I,w]:[w,I];if(s&&R.push(s),E&&R.push(o),C){const t=a.makeTensorInfo([],"float32",gk(i,"float32"));R.push(t),v.push(t)}const F=a.runWebGLProgram(A,R,"float32"),_=LX({inputs:{x:F},backend:a,attrs:{shape:r.outShape}});v.push(F);for(const D of v)a.disposeIntermediateTensorInfo(D);return _}const NY={kernelName:cv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=DN(l),d=SN(a.shape,s.shape,o,c,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Ay().getBool("WEBGL_EXP_CONV")){const t=new wY(d),e=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(t,[a,s],"float32",e)}else if(Ay().getBool("WEBGL_CONV_IM2COL"))p=IY({x:a,filter:s,convInfo:d,backend:n});else{const t=new yY(d);p=n.runWebGLProgram(t,[a,s],"float32")}else p=SY({x:a,filter:s,convInfo:d,backend:n});const f=LX({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class EY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              ").concat(s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class CY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s="channelsLast"===t.dataFormat,o=e-1-t.padInfo.top,i=n-1-t.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(l,"], coords[").concat(c,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class TY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.padInfo.front,s=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(t.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(e," - ").concat(a,";\n\n            if (xF < 0 || xF >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(o,";\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class AY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(l,", ").concat(c,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(e,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(a,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(t.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(e," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const RY={kernelName:uv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=DN(l),d=SN(a.shape,u,o,1,i,c,!1,h),p=new EY(d);return n.runWebGLProgram(p,[a,s],"float32")}};class FY{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=IK(this.outputShape.length);const e=t.filterHeight,n=t.filterWidth,r=e-1-t.padInfo.top,a=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(a,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(t.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(t.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const _Y={kernelName:hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=DN(c),d=SN(o,s.shape,i,1,l,u,!1,h);if(Ay().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const t=[[d.strideHeight,d.strideWidth]],e=new FY(d);return n.runWebGLProgram(e,[a,s],"float32",t)}{const t=new CY(d);return n.runWebGLProgram(t,[a,s],"float32")}}};const DY={kernelName:dv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=IN(a.shape,s.shape,o,l,i),u=new vY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const OY={kernelName:pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r,c=IN(a.shape,l,o,1,i),u=new TY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const zY={kernelName:fv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r,c=IN(l,s.shape,i,1,o),u=new AY(c);return n.runWebGLProgram(u,[a,s],"float32")}},LY=CX({opSnippet:EX+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(fX,"\n  return result;\n")}),MY={kernelName:gv,backendName:"webgl",kernelFunc:LY},PY=CX({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),BY={kernelName:mv,backendName:"webgl",kernelFunc:PY};class WY{constructor(t,e,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===r?1:0,[p,f]=["".concat(o-1,".0"),"".concat(i-1,".0")],[g,m,b]=u>1?["".concat((o-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,w]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(g,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(m,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n        float in_x = ").concat(w,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const UY={kernelName:vv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,u=new WY(a.shape,s.shape,i,l,c);return n.runWebGLProgram(u,[a,s,o],"float32")}};var VY;!function(t){t.Prod="*",t.Sum="+"}(VY||(VY={}));class jY{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===VY.Prod?"1.0":"0.0",o=n?s:"getX(".concat(GY(a,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=r?"end != ".concat(i-1):"end != 0",c=r?"end + 1":"end - 1"):(l=r?"end + pow2 < ".concat(i):"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(bK(a)," coords = getOutputCoords();\n        int end = ").concat(HY(a,"coords",this.op),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(l,") {\n          int idx = ").concat(c,";\n          ").concat(HY(a,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(GY(a,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function GY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".x, ").concat(e,".y");if(3===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z");if(4===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z, ").concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function HY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".y");if(3===t)return"".concat(e,".z");if(4===t)return"".concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function KY(t,e,n,r,a,s){const o=e.shape.length,i=NE([r],o);let l=e;null!=i&&(l=KX({inputs:{x:e},backend:n,attrs:{perm:i}}));const c=CE(1,o)[0];if(c!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(e.shape.length-1," ")+"but got axis=".concat(r));const u=l.shape[c];let h=mX({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const e=new jY(t,l.shape,!1,s),r=[[d]],a=h;h=n.runWebGLProgram(e,[h],h.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const e=new jY(t,l.shape,a,s),r=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=i){const t=KX({inputs:{x:h},backend:n,attrs:{perm:EE(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}const qY={kernelName:bv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return KY(VY.Prod,a,n,s,o,i)}};const XY={kernelName:yv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return KY(VY.Sum,a,n,s,o,i)}};const JY={kernelName:wv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=n.readSync(a.dataId),e=n.readSync(s.dataId),r=GK(t,e,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const t=n.bufferSync(a),e=n.bufferSync(s),r=HK(t,e,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};class YY{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(e,";\n      int offset_h = imod(h, ").concat(e,");\n      int in_w = w / ").concat(e,";\n      int offset_w = imod(w, ").concat(e,");\n      int offset_d = (offset_h * ").concat(e," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ZY={kernelName:xv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,c=("NHWC"===o?a.shape[2]:a.shape[3])*s,u=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),h=new YY("NHWC"===o?[i,l,c,u]:[i,u,l,c],s,o);return n.runWebGLProgram(h,[a],a.dtype)}};class QY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=IK(this.outputShape.length);const s=t.filterHeight,o=t.filterWidth,i=t.outChannels/t.inChannels;let l="",c="";n&&(l=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),c="result = activation(result);");const u=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(l,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")}}class $Y{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=IK(this.outputShape.length);const s=t.outChannels/t.inChannels,o=t.padInfo.left,i=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+="\n          vec4 xTexelC".concat(2*m,";\n          int xTexelC").concat(2*m,"Ready;\n          vec4 xTexelC").concat(2*m+1,";\n          int xTexelC").concat(2*m+1,"Ready;\n          vec4 xC").concat(m,";");d+="\n    for (int r = 0; r < ".concat(c,"; r++) {\n      ");for(let m=0;m<u;m++)d+="\n          xTexelC".concat(2*m," = vec4(0.0);\n          xTexelC").concat(2*m,"Ready = 0;\n          xTexelC").concat(2*m+1," = vec4(0.0);\n          xTexelC").concat(2*m+1,"Ready = 0;\n          xC").concat(m," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const t=2*m;if(d+="\n          xC = xCCorner + ".concat(t*l,";\n          "),1===i){if(t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n              "),d+=1===l&&t>0?"\n                xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                  } else {\n                    xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xC").concat(t," = xTexelC").concat(t,";\n                "),t+1<u)){const e=o%2===0?qb(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                    xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(t+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(t+1,"Ready = 1;\n                  }\n                  "),d+=l>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                    } else {\n                     xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                    }\n                    "):"\n                    xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                    ")):d+=1===e?"\n                    xC".concat(t+1," = xTexelC").concat(t,";\n                    "):"\n                    xCOffset = xC + ".concat(e,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                      xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(t+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(t+1,"Ready = 1;\n                    }\n\n                    xC").concat(t+1," = xTexelC").concat(t+1,";\n                    ")}}else t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n              "),t+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(\n                  xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n              "),t+1<u&&(d+="\n                  xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                "))));t<u&&(d+="\n            wTexel = getW(r, ".concat(t,", d1, q);\n            dotProd += xC").concat(t," * vec4(wTexel.xz, wTexel.xz);\n          "),t+1<u&&(d+="\n              wTexel = getW(r, ".concat(t+1,", d1, q);\n              dotProd += xC").concat(t+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const tZ={kernelName:kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),Jb(FN(o,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(u,"'")));const h=SN(a.shape,s.shape,o,u,i,c,!0);let d;d=Ay().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new $Y(h):new QY(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}};class eZ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class nZ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=e-1-t.padInfo.top,o=n-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const rZ={kernelName:Sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r,h=SN(a.shape,u,o,i,l,c,!0),d=new eZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};const aZ={kernelName:Iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r,h=SN(u,s.shape,o,i,l,c,!0),d=new nZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};class sZ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const oZ={kernelName:Nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=[...r.shape,...r.shape],s=Qb(r.shape),o=LX({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new sZ(s),l=n.runWebGLProgram(i,[o],o.dtype),c=LX({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}};class iZ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:l,dilationWidth:c}=t,{top:u,left:h}=r;this.userCode="\n      const ivec2 strides = ivec2(".concat(a,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(o,"; h++) {\n          int hIn = hBeg + h * ").concat(l,";\n\n          if (hIn >= 0 && hIn < ").concat(e,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(c,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const lZ={kernelName:Ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=wN(a.shape,s.shape,o,i,"NHWC",l);let u;const h=new iZ(c);u=n.runWebGLProgram(h,[a,s],"float32");const d=LX({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const cZ={kernelName:Fv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=uA(a,s.length);dA(o.length,l,s);const{path:c,steps:u}=pA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=hA(p,l[t]);let a;fA(e)?a=s[t]:(a=KX({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);$b(a.shape,o)||(a=LX({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=OX({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=GX({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},uZ=CX({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),hZ={kernelName:_v,backendName:"webgl",kernelFunc:uZ},dZ={kernelName:Dv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:r,y:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gX("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new pX("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},pZ=TX({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:YK}),fZ={kernelName:zv,backendName:"webgl",kernelFunc:pZ},gZ=CX({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(KT,";\n  float a1 = ").concat(qT,";\n  float a2 = ").concat(XT,";\n  float a3 = ").concat(JT,";\n  float a4 = ").concat(YT,";\n  float a5 = ").concat(ZT,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),mZ={kernelName:Ov,backendName:"webgl",kernelFunc:gZ},bZ=CX({opSnippet:EX+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ZK,dtype:"float32"}),yZ={kernelName:Lv,backendName:"webgl",kernelFunc:bZ};function vZ(t){const{inputs:e,attrs:n,backend:r}=t,{dim:a}=n,{input:s}=e,o=s.shape.length,i=s.shape.slice();let l=a;return a<0&&(Jb(-(o+1)<=a,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+a+1),i.splice(l,0,1),LX({inputs:{x:s},backend:r,attrs:{shape:i}})}const wZ={kernelName:Mv,backendName:"webgl",kernelFunc:vZ},xZ="return exp(x) - 1.0;",kZ=CX({opSnippet:xZ,packedOpSnippet:xZ,cpuKernelImpl:QK}),SZ={kernelName:Pv,backendName:"webgl",kernelFunc:kZ};class IZ{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const a=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(r,".0"):"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error('FFT component must be either "real" or "imag", got '.concat(t,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(a,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function NZ(t,e,n){const r=n.texData.get(t.dataId),a=Qb(t.shape),s=t.shape[t.shape.length-1],o=LX({inputs:{x:t},backend:n,attrs:{shape:[a/s,s]}}),i=o.shape,l=new IZ("real",i,e),c=new IZ("imag",i,e),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(l,u,"float32"),d=n.runWebGLProgram(c,u,"float32"),p=yX({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=LX({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const EZ={kernelName:Bv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return NZ(r,!1,n)}};class CZ{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function TZ(t){const{backend:e,attrs:n}=t,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||py(a),"string"===s){const t=ly(s,Qb(r));return t.fill(a),e.makeTensorInfo(r,s,t)}{const t=new CZ(r,a),n=[[a]];return e.runWebGLProgram(t,[],s,n)}}const AZ={kernelName:Wv,backendName:"webgl",kernelFunc:TZ};class RZ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(e," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(e,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const FZ={kernelName:Uv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{image:r}=e,a=n,s=new RZ(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},_Z="return floor(x);",DZ=CX({opSnippet:_Z,packedOpSnippet:_Z,cpuKernelImpl:$K}),OZ={kernelName:Vv,backendName:"webgl",kernelFunc:DZ},zZ=TX({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),LZ={kernelName:jv,backendName:"webgl",kernelFunc:zZ};class MZ{constructor(t){this.variableNames=["A"];const e=eK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(e.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class PZ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=eK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(n,".0);\n            vec4 values = ").concat(e.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}const BZ={kernelName:Wx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:a}=e;const{numChannels:s}=r,o="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,c]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[c,l],h=[c,l,s];if(i||o){const t=Ay().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=WZ&&t===UZ||(UZ=t,WZ=document.createElement("canvas").getContext("2d",{willReadFrequently:UZ})),WZ.canvas.width=l,WZ.canvas.height=c,WZ.drawImage(a,0,0,l,c),a=WZ.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=SH.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);const p=Ay().getBool("WEBGL_PACK")?new PZ(h):new MZ(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let WZ,UZ=Ay().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const VZ={kernelName:jx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,g=DN(u),m=SN(a.shape,s.shape,l,h,c,d,!1,g);let b;const y=[],v=null!=o,w=null!=i,x="leakyrelu"===p,k=()=>{const t=[a,s],e=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=LX({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return y.push(e),e}return t};if(v&&t.push(e(o,u)),w&&t.push(e(i,u)),x){const e=n.makeTensorInfo([],"float32",gk(f,"float32"));t.push(e),y.push(e)}return t};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&Ay().getBool("WEBGL_EXP_CONV")){const t=p?AX(p,!0):null,e=new wY(m,v,t,w,x),r=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],a=k();b=n.runWebGLProgram(e,a,"float32",r)}else if(Ay().getBool("WEBGL_CONV_IM2COL"))b=IY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const t=p?AX(p,!1):null,e=new yY(m,v,t,w,x),r=k();b=n.runWebGLProgram(e,r,"float32")}else b=SY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=LX({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return y.push(b),y.forEach((t=>n.disposeIntermediateTensorInfo(t))),S}};const jZ={kernelName:Gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let g=u;null==g&&(g=[1,1]),Jb(FN(l,g),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(l," and dilations '").concat(g,"'")));const m=SN(a.shape,s.shape,l,g,c,h,!0),b=Ay().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,y=d?AX(d,b):null,v=[a,s],w=null!=o,x=null!=i,k="leakyrelu"===d;if(w&&v.push(o),x&&v.push(i),k){const t=n.makeTensorInfo([],"float32",gk(p,"float32"));v.push(t),f.push(t)}let S;S=b?new $Y(m,w,y,x,k):new QY(m,w,y,x,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((t=>n.disposeIntermediateTensorInfo(t))),N}};class GZ{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=bK(n.length);let s="\n    int index;";for(let o=0;o<this.sliceDim;o++)s+="\n          index = round(getIndices(coords[0], ".concat(o,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[o],";\n          flattenIndex += index * ").concat(this.strides[o],";");this.userCode="\n         void main() {\n          ".concat(a," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const HZ={kernelName:Kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=a.shape,o=s[s.length-1],i=Qb(r.shape),[l,c,u,h]=WT(r,a),d=LX({inputs:{x:a},backend:n,attrs:{shape:[c,o]}}),p=LX({inputs:{x:r},backend:n,attrs:{shape:[Qb(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const t=n.readSync(a.dataId),e=n.bufferSync(r),s=tq(t,e,r.dtype,c,o,u,h,r.shape,i);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new GZ(o,h,[c,u],r.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=LX({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class KZ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=bK(this.rank),r=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<t.length;a++)2===a?r.push("index"):r.push("".concat(n[a]));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(t[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(r,"));\n      }\n    ")}}function qZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r,l=sy(o,a.shape)[0];if(Ay().get("DEBUG")){const t=n.readSync(s.dataId),e=a.shape[l];for(let n=0;n<t.length;++n){const r=t[n];Jb(r<=e-1&&r>=0,(()=>"GatherV2: the index value ".concat(r," is not in [0, ").concat(e-1,"]")))}}const c=FA(a,s,l,i),u=Qb(s.shape),h=[],d=LX({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=LX({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const t=n.bufferSync(p),e=n.bufferSync(d),r=eq(e,t,f);return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const g=new KZ(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=LX({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}const XZ={kernelName:Hv,backendName:"webgl",kernelFunc:qZ},JZ=TX({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:nq,dtype:"bool"}),YZ={kernelName:qv,backendName:"webgl",kernelFunc:JZ},ZZ=TX({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:rq}),QZ={kernelName:Xv,backendName:"webgl",kernelFunc:ZZ};const $Z={kernelName:Yv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return NZ(r,!0,n)}},tQ=CX({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),eQ={kernelName:Qv,backendName:"webgl",kernelFunc:tQ},nQ=CX({opSnippet:"return float(isinf(x));",dtype:"bool"}),rQ={kernelName:$v,backendName:"webgl",kernelFunc:nQ},aQ=CX({opSnippet:"return float(isnan(x));",dtype:"bool"}),sQ={kernelName:tw,backendName:"webgl",kernelFunc:aQ},oQ=TX({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:aq,dtype:"bool"}),iQ={kernelName:nw,backendName:"webgl",kernelFunc:oQ},lQ=TX({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:sq,dtype:"bool"}),cQ={kernelName:rw,backendName:"webgl",kernelFunc:lQ};const uQ={kernelName:aw,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=oq(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},hQ=CX({opSnippet:EX+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:iq}),dQ={kernelName:sw,backendName:"webgl",kernelFunc:hQ},pQ=CX({opSnippet:EX+"\n  return log(1.0 + x);\n"}),fQ={kernelName:ow,backendName:"webgl",kernelFunc:pQ},gQ=TX({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),mQ={kernelName:iw,backendName:"webgl",kernelFunc:gQ},bQ=CX({opSnippet:"return float(!(x >= 1.0));"}),yQ={kernelName:lw,backendName:"webgl",kernelFunc:bQ},vQ=TX({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),wQ={kernelName:cw,backendName:"webgl",kernelFunc:vQ};class xQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(o,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class kQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(o,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const SQ={kernelName:uw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r,c=Ay().getBool("WEBGL_PACK_NORMALIZATION")?new kQ(a.shape,s,o,i,l):new xQ(a.shape,s,o,i,l);return n.runWebGLProgram(c,[a],a.dtype)}};class IQ{constructor(t,e,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(e,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(e," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(a,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(a,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const NQ={kernelName:hw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r,h=new IQ(a.shape,i,l,c,u);return n.runWebGLProgram(h,[a,s,o],a.dtype)}};function EQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=NE(c,i),h=null!=u,d=n.shouldExecuteOnCPU([a]);let p=a;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(i);for(let n=0;n<e.length;n++)e[n]=a.shape[u[n]];const r=Lq(t,a.shape,a.dtype,u,e);p=n.makeTensorInfo(e,a.dtype);n.texData.get(p.dataId).values=r}else p=jX(a,u,n);c=CE(c.length,i)}IE("max",c,i);const[f,g]=kE(p.shape,c);let m,b=f;if(o&&(b=SE(f,l)),d){const t=n.texData.get(p.dataId).values,e=lq(t,Qb(g),b,a.dtype);m=n.makeTensorInfo(b,a.dtype);n.texData.get(m.dataId).values=e}else m=function(t,e,n,r){const a=Qb(e),s=LX({inputs:{x:t},attrs:{shape:[Qb(t.shape)/a,a]},backend:r}),o=WX(s,t.dtype,"max",r),i=LX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const CQ={kernelName:dw,backendName:"webgl",kernelFunc:EQ},TQ=TX({opSnippet:dX+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+fX+"\n  return result;\n",cpuKernelImpl:cq}),AQ={kernelName:pw,backendName:"webgl",kernelFunc:TQ};const RQ={kernelName:fw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;$H(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(FN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=xN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))return mX({inputs:{x:a},backend:n});const u=new TJ(c,"max",!1);return n.runWebGLProgram(u,[a],a.dtype)}};const FQ={kernelName:mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dataFormat:l,dimRoundingMode:c}=r,u=kN(a.shape,s,o,[1,1,1],i,c,l),h=new AJ(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}};class _Q{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,a=t.effectiveFilterHeight,s=t.effectiveFilterWidth,o=a-1-t.padInfo.top,i=s-1-t.padInfo.left,l=a*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(a,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(e,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(l," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class DQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.dilationDepth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=i-1-t.padInfo.front,h=l-1-t.padInfo.top,d=c-1-t.padInfo.left,p=i*l*c-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(a,") {\n          float dyD = float(dyDCorner + wD) / ").concat(e,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(c,";\n                wC += ").concat(o,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(l," * ").concat(c," +\n                  wR * ").concat(c," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const OQ={kernelName:bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=kN(o.shape,i,l,[1,1,1],c,u),d=new AJ(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new DQ(h),g=n.runWebGLProgram(f,[a,p],o.dtype);return n.disposeIntermediateTensorInfo(p),g}};const zQ={kernelName:gw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;$H([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=xN(i.shape,l,c,1,u,h),p=new TJ(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),g=new _Q(d),m=n.runWebGLProgram(g,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),m}};const LQ={kernelName:yw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;Jb(4===a.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length,".")));const u=[1,1];Jb(FN(o,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(u,"'")));const h=xN(a.shape,s,o,u,i),[d,p]=function(t,e,n,r){let a=new TJ(n,"max",!1);const s=r.runWebGLProgram(a,[t],"float32");return a=new TJ(n,"max",!0,!0,e),[s,r.runWebGLProgram(a,[t],"float32")]}(a,l,h,c);return[d,p]}};const MQ={kernelName:vw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{keepDims:s,axis:o}=n,i=r,l=a.shape.length,c=sy(o,a.shape);let u=c;const h=NE(u,l),d=null!=h,p=i.shouldExecuteOnCPU([a]),f=[];let g=a;if(d){if(p){const t=i.texData.get(g.dataId).values,e=new Array(l);for(let r=0;r<e.length;r++)e[r]=a.shape[h[r]];const n=Lq(t,a.shape,a.dtype,h,e);g=i.makeTensorInfo(e,a.dtype);i.texData.get(g.dataId).values=n}else g=jX(a,h,i);f.push(g),u=CE(u.length,l)}IE("sum",u,l);const[m,b]=kE(g.shape,u);let y=m;s&&(y=SE(m,c));const v=function(t,e,n,r){const a=Qb(e),s=LX({inputs:{x:t},attrs:{shape:[Qb(t.shape)/a,a]},backend:r}),o=WX(s,"float32","mean",r),i=LX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(g,b,y,i);for(const w of f)i.disposeIntermediateTensorInfo(w);return v}};const PQ={kernelName:ww,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=NE(c,i);let h=a;null!=u&&(h=KX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=CE(c.length,a.shape.length)),IE("min",c,i);const[d,p]=kE(h.shape,c),f=LX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=WX(f,f.dtype,"min",n);let m;if(o){m=LX({inputs:{x:g},backend:n,attrs:{shape:SE(d,l)}})}else m=LX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}},BQ=TX({opSnippet:dX+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+fX+"\n  return result;\n",cpuKernelImpl:uq}),WQ={kernelName:xw,backendName:"webgl",kernelFunc:BQ};class UQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=bK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l,";\n          }\n        }\n        ").concat(a," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class VQ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=bK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Bq("rc",r),l=Bq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===r){const t="\n        ".concat(a," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ")}else{const t="\n        ".concat(a," source = rc;\n        ").concat(a," lt = ").concat(a,"(lessThan(source, start));\n        ").concat(a," gte = ").concat(a,"(greaterThanEqual(source, end));\n        ").concat(a," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[r-2]," += 1;\n        if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(t,"\n          result[2] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          ").concat(i[r-1]," += 1;\n          if(").concat(c,") {\n            ").concat(t,"\n            result[3] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const jQ={kernelName:kw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a}=e,{paddings:s,mode:o}=r,i=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VQ(a.shape,s,o):new UQ(a.shape,s,o);return n.runWebGLProgram(i,[a],a.dtype)}},GQ=TX({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+fX+"\n  return result;\n"}),HQ={kernelName:Sw,backendName:"webgl",kernelFunc:GQ};class KQ{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(e-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(e-1,"));\n      }\n    ")}}const qQ=TX({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),XQ={kernelName:Rv,backendName:"webgl",kernelFunc:qQ},JQ="return a - b;",YQ=TX({opSnippet:JQ,packedOpSnippet:JQ,supportsComplex:!0,cpuKernelImpl:Dq}),ZQ={kernelName:Tx,backendName:"webgl",kernelFunc:YQ};function QQ(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=sy([s],a.shape),i=EQ({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=SE(i.shape,o),c=LX({inputs:{x:i},backend:n,attrs:{shape:l}}),u=YQ({inputs:{a:a,b:c},backend:n}),h=bZ({inputs:{x:u},backend:n}),d=GX({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=LX({inputs:{x:d},backend:n,attrs:{shape:l}}),f=qQ({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const $Q={kernelName:gx,backendName:"webgl",kernelFunc:QQ};const t$={kernelName:Iw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r,l=i?a:QQ({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new KQ(c,u,s),d=[[o]],p=n.runWebGLProgram(h,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),p}},e$=qq+"\n  return -x;\n";const n$={kernelName:Ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const t=n.texData.get(r.dataId),[e,a]=dq(t.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,e)}let a;return a=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new oX(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Kq(r.shape,e$),n.runWebGLProgram(a,[r],r.dtype)}},r$=KC;const a$={kernelName:Tw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=r$(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},s$=qC;const o$={kernelName:Aw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=s$(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},i$=XC;const l$={kernelName:Rw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=i$(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class c${constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const u$={kernelName:_w,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r,c=Qb(a.shape),u=new c$(c,o,i,l),h=LX({inputs:{x:a},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const p=LX({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function h$(t){const{inputs:e,backend:n}=t,{x:r}=e;if("complex64"===r.dtype){const t=ZJ({inputs:{input:r},backend:n}),e=h$({inputs:{x:t},backend:n}),a=pY({inputs:{input:r},backend:n}),s=h$({inputs:{x:a},backend:n}),o=yX({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return TZ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const d$={kernelName:Px,backendName:"webgl",kernelFunc:h$};const p$={kernelName:Fw,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const e=ZJ({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=pY({inputs:{input:a},backend:r}),o=h$({inputs:{x:s},backend:r}),i=yX({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return TZ({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const f$={kernelName:Dw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return vZ({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Yb(s,t.shape,"All tensors passed to stack must have matching shapes"),Jb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=mY({inputs:e.map((t=>{const e=vZ({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}};class g${constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=bK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(a," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class m${constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=bK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Bq("rc",r),l=Bq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h=["".concat(a," rc = outputLoc;"),"".concat(i[r-1]," += 1;\n       if(").concat(c,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(i[r-2]," += 1;\n       if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(i[r-1]," += 1;\n         if(").concat(c,") {")],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===r?2:4;f<g;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(a," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ");p+=1===r?"} ":"}}",this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const b$=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;if(0===Qb(a.shape)){const t=s.map(((t,e)=>t[0]+a.shape[e]+t[1]));return TZ({backend:n,attrs:{shape:t,value:o,dtype:a.dtype}})}const i=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new m$(a.shape,s,o):new g$(a.shape,s,o),l=[[o]];return n.runWebGLProgram(i,[a],a.dtype,l)},y$={kernelName:Ow,backendName:"webgl",kernelFunc:b$},v$=TX({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+fX+"\n  return result;\n"}),w$={kernelName:zw,backendName:"webgl",kernelFunc:v$};const x$={kernelName:Mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=[],c=sy(s,a.shape);let u=c;const h=NE(u,i);let d,p=a;if(null!=h&&(p=KX({inputs:{x:a},backend:n,attrs:{perm:h}}),u=CE(u.length,i),l.push(p)),IE("prod",u,i),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:r,outDtype:a}=fq(p.shape,p.dtype,t,u);d=n.makeTensorInfo(r,a,e)}else{const[t,e]=kE(p.shape,u),r=Qb(e),s=LX({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),o=WX(s,qk(a.dtype),"prod",n);d=LX({inputs:{x:o},backend:n,attrs:{shape:t}}),l.push(s),l.push(o)}if(o){l.push(d);const t=SE(d.shape,c);d=LX({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),d}};const k$={kernelName:Pw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.readSync(t.dataId))),c=a.map((t=>t.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=gq(l,c,u,s.shape,s.dtype,h,o.shape,i),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}};const S$={kernelName:Bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=mq(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};const I$={kernelName:Ww,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i.map((t=>n.readSync(t.dataId))),p=i.map((t=>t.shape)),[f,g]=bq(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}},N$=t=>{const{backend:e,attrs:n}=t,{start:r,stop:a,step:s,dtype:o}=n,i=yq(r,a,s,o);return e.makeTensorInfo([i.length],o,i)},E$={kernelName:Uw,backendName:"webgl",kernelFunc:N$},C$=CX({opSnippet:"return 1.0 / x;"}),T$={kernelName:jw,backendName:"webgl",kernelFunc:C$},A$=CX({opSnippet:qq+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),R$={kernelName:Gw,backendName:"webgl",kernelFunc:A$},F$=CX({opSnippet:qq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_$={kernelName:Yw,backendName:"webgl",kernelFunc:F$};class D${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class O${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const z$={kernelName:Xw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ay().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new O$(a.shape,l,c,s,o):new D$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],"float32")}};class L${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(a-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const M$={kernelName:Jw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new L$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class P${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class B${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const W$={kernelName:Kw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ay().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new B$(a.shape,l,c,s,o):new P$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],a.dtype)}};class U${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(l[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(l[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const V$={kernelName:qw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new U$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class j${constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=t,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(t[0]," - coord - 1));\n        }\n      "));const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(r))).join(","),a=bK(n);this.userCode="\n      void main() {\n        ".concat(a," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}}class G${constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=t;const r=Bq("rc",n),a="".concat(r[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(r[n-2]," + 1 < ").concat(this.outputShape[n-2]),o=bK(n);function i(n){const r=t.map(((r,a)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - ").concat(r[n]," - 1"):"".concat(r[n])}(a,n))),a=r.join(","),s=r.slice(-2).join(",");return"getChannel(getX(".concat(a,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(t[0]," - rc - 1),\n            ").concat(t[0]," - rc - 1);\n          if(").concat(a,"){\n              result.g = getChannel(getX(").concat(t[0]," - (rc  + 1) - 1),\n                ").concat(t[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(o," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(t){return i(t)}(r.slice()),";\n          if(").concat(a,"){\n            result.g = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",i(t)}(r.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(t){return t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            if(").concat(a,") {\n              result.a = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const H$={kernelName:Zw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r,o=a.shape.length,i=sy(s,a.shape);if(0===o)return mX({inputs:{x:a},backend:n});const l=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G$(a.shape,i):new j$(a.shape,i);return n.runWebGLProgram(l,[a],a.dtype)}};class K${constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let a="";a="number"===typeof e?"float outputValue = ".concat(e.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(e.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(a,"\n          if(coordX >= 0 && coordX < ").concat(r," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const q$={kernelName:Ux,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=new K$(a.shape,o),[u,h]=OT(i,a.shape[1],a.shape[2]),d=[[u,h,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(c,[a],a.dtype,d)}},X$=CX({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),J$={kernelName:Qw,backendName:"webgl",kernelFunc:X$},Y$=CX({opSnippet:"return inversesqrt(x);",cpuKernelImpl:vq}),Z$={kernelName:$w,backendName:"webgl",kernelFunc:Y$};class Q${constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=bK(a.length),l=bK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(t,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(e,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(g,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class $${constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const i=bK(a.length),l=bK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides",m=e>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(t,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(e,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(g,";\n              if (j + 1 < ").concat(e,") {\n                flattenedIndex += index.yw * ").concat(m,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const t0={kernelName:tx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=jT(0,a,o),d=[h/c,c];if(0===h)return n.makeTensorInfo(o,a.dtype);const p=LX({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),f=LX({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=Ay().getBool("WEBGL_PACK")?new $$(l,i,p.shape.length,f.shape.length,u,d):new Q$(l,i,p.shape.length,f.shape.length,u,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),y=LX({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class e0{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const a="for (int i = 0; i < ".concat(Math.ceil(Math.log2(e+1)),"; ++i) { if (left >= right) break;"),s=2===Ay().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const n0={kernelName:nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=new e0(a.shape[0],a.shape[1],s.shape[1],o),l=[[a.shape[1]]];return n.runWebGLProgram(i,[a,s],"int32",l)}};class r0{constructor(t,e,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<e.length;r++)o.push("".concat(n[r])),r<t&&s.push("".concat(n[r]));r=s.join(),a=o.join()}const s=bK(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(a,"));\n        } else {\n          setOutput(getB(").concat(a,"));\n        }\n      }\n    ")}}const a0={kernelName:rx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e,o=new r0(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],Kk(a.dtype,s.dtype))}},s0=CX({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(GT,";\n  float scale = ").concat(HT,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),o0={kernelName:ax,backendName:"webgl",kernelFunc:s0},i0=CX({opSnippet:EX+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:xq}),l0={kernelName:cx,backendName:"webgl",kernelFunc:i0},c0=CX({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),u0={kernelName:lx,backendName:"webgl",kernelFunc:c0},h0=CX({opSnippet:EX+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(fX,"\n  return result;\n")}),d0={kernelName:ox,backendName:"webgl",kernelFunc:h0},p0=CX({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),f0={kernelName:ix,backendName:"webgl",kernelFunc:p0},g0=CX({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),m0={kernelName:ux,backendName:"webgl",kernelFunc:g0},b0={kernelName:px,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;Jb(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...o);for(let b=1+s.length;b<a.shape.length;++b)l.push([0,0]);const c=[],u=b$({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=zT(u.shape,s,i,!1),d=LT(h.length,s.length,!1),p=MT(u.shape,s,i,!1),f=LX({inputs:{x:u},backend:n,attrs:{shape:h}}),g=KX({inputs:{x:f},backend:n,attrs:{perm:d}}),m=LX({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(g),c.forEach((t=>n.disposeIntermediateTensorInfo(t))),m}};const y0={kernelName:mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,g]=Iq(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const v0={kernelName:bx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=Nq(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};const w0={kernelName:yx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Eq(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const x0={kernelName:vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Eq(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const k0={kernelName:wx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=jT(0,a,i);if("string"===s.dtype){const t=n.bufferSync(a),e=n.bufferSync(s),r=vk(n.readSync(o.dataId)[0]),p=wq(t,e,i,d,u,c,l,h,r,false);return n.makeTensorInfo(i,p.dtype,p.values)}const p=new Q$(c,l,a.shape.length,s.shape.length,h,[d,1],false),f=n.runWebGLProgram(p,[s,a,o],s.dtype),g=LX({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),g}};const S0={kernelName:fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=sy(o,a.shape)[0],l=mA(a,s,i),c=a.shape.length,u=new Array(c).fill(0),h=a.shape.slice();return l.map((t=>{const e=[...h];e[i]=t;const r=jJ({inputs:{x:a},backend:n,attrs:{begin:u,size:e}});return u[i]+=t,r}))}},I0="return sqrt(x);",N0=CX({opSnippet:I0,packedOpSnippet:I0,cpuKernelImpl:Cq}),E0={kernelName:hx,backendName:"webgl",kernelFunc:N0},C0={kernelName:kx,backendName:"webgl",kernelFunc:CX({opSnippet:"return x * x;"})},T0="return (a - b) * (a - b);",A0=TX({opSnippet:T0,packedOpSnippet:T0}),R0={kernelName:xx,backendName:"webgl",kernelFunc:A0};const F0={kernelName:Sx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=_A(n.readSync(a.dataId)),o=Tq(s,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};const _0={kernelName:Bx,backendName:"webgl",kernelFunc:function(t){let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,s=qq+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),o=new Kq(a.shape,s);return r.runWebGLProgram(o,[a],a.dtype)}};class D0{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=bK(n.length),s=bK(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map(((e,r)=>(t++,1===n.length?"coords * strides[".concat(r,"] + begin[").concat(r,"]"):"coords[".concat(t-1,"] * strides[").concat(r,"] + begin[").concat(r,"]")))).join(",")}this.userCode="\n      ".concat(a," begin = ").concat(a,"(").concat(t,");\n      ").concat(a," strides = ").concat(a,"(").concat(e,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(o,"));\n      }\n    ")}}const O0={kernelName:Ix,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=gN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=LX({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Jb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=nN(y,v,w),e=jJ({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=LX({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{if(n.shouldExecuteOnCPU([a])){const t=n.readSync(a.dataId),e=uI(a.shape,a.dtype,t),r=Aq(p,e,w,y);x=n.makeTensorInfo(f,a.dtype,r.values)}else{const t=new D0(y,w,p);x=n.runWebGLProgram(t,[a],a.dtype)}}const k=LX({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),k}};const z0={kernelName:Nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,g]=Rq(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};const L0={kernelName:Ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,h]=Fq(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const M0={kernelName:Cx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=_q(o,a);return n.makeTensorInfo(s.shape,"int32",i)}},P0=CX({opSnippet:"return tan(x);"}),B0={kernelName:Ax,backendName:"webgl",kernelFunc:P0},W0=CX({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),U0={kernelName:Rx,backendName:"webgl",kernelFunc:W0};const V0={kernelName:ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:a,indices:s,updates:o}=e,{}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=jT(0,s,a.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,s.dtype);const p=LX({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),f=LX({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=LX({inputs:{x:a},backend:n,attrs:{shape:d}}),m=new Q$(l,i,p.shape.length,f.shape.length,u,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),y=LX({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class j0{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;const r=bK(this.rank),a=function(t){const e=t.length;if(e>5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"imod(resRC, ".concat(t[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<t.length;a++)r.push("imod(".concat(n[a],", ").concat(t[a],")"));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(a,"));\n      }\n    ")}}function G0(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const t=n.readSync(a.dataId),e="string"===a.dtype?t.map((t=>vk(t))):t,r=uI(a.shape,a.dtype,e),o=Oq(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new j0(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}const H0={kernelName:Fx,backendName:"webgl",kernelFunc:G0};class K0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class q0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function X0(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function J0(t){let e=1;for(;e<t;)e*=2;return e}const Y0={kernelName:_x,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r,i=Ay().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ay().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([a])||u<i||s>l){const t=n.readSync(a.dataId),[e,r]=zq(t,c,a.dtype,s,o);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[a,TZ({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(a.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(a):a,f=Qb(c)/u,g=LX({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&X0(n,p);const m=J0(s),b=J0(u);let y=null;const v=()=>null===y?[g,g]:[g,y],w=(t,e,r)=>{const a=v(),s=new K0(r),o=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],i=y;y=n.runWebGLProgram(s,a,"int32",o),X0(n,i)};for(let N=1;N<m;N*=2){const t=2*N;for(let e=N;e>=1;e/=2)w(t,e,[f,b])}for(let N=b;N>m;N/=2){const t=v(),e=new q0([f,N/2]),r=[[u],[null===y?1:0],[m]],a=y;y=n.runWebGLProgram(e,t,"int32",r),X0(n,a);const s=m/2,o=2*s;for(let n=s;n>=1;n/=2)w(o,n,y.shape)}let x=y;y=jJ({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),X0(n,x);let k=qZ({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});X0(n,g);const S=c.slice(0,-1);S.push(s),x=y,y=LX({inputs:{x:y},attrs:{shape:S},backend:n}),X0(n,x);const I=k;return k=LX({inputs:{x:k},attrs:{shape:S},backend:n}),X0(n,I),[k,y]}};class Z0{constructor(t,e,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(t," && 0 <= coordX && coordX < ").concat(e,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(a,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(a,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(e,"));\n                float mapY = mapCoord(inY, float(").concat(t,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const Q0={kernelName:Dx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=r,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=new Z0(h,d,o,i,l,[u,f,g,p]);return n.runWebGLProgram(m,[a,s],"float32")}};const $0={kernelName:zx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;$H(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:l,indices:c}=Mq(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const t1={kernelName:Lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,l=a.shape[s],c=new Array(i-1);let u=0;for(let g=0;g<i;g++)g!==s&&(c[u++]=o.shape[g]);const h=[],d=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[s]=g;const t=jJ({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),e=LX({inputs:{x:t},backend:n,attrs:{shape:c}});f[g]=e,h.push(t)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};class e1{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,a=t.inSize,s=t.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";a%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      "));let h="";a%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(c,"\n        } else if (").concat(2===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(c,"\n        } else if (").concat(3===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(c,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const n1={kernelName:Mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r,i=a.shape.length,l=[];let c=0;const u=NE([c],i);let h=a;null!=u&&(h=KX({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(h),c=CE(1,i)[0]);const d=RA(h.shape,c,o),p=Qb([h.shape[c]]),f=LX({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=qk(a.dtype),m=(t,e,r,a,s)=>{const o=t.shape[0],i=t.shape[1],c=AA(i,s),u=new e1({windowSize:c,inSize:i,batchSize:o,numSegments:s},e),h=n.compileAndRun(u,[t,r],a);if(l.push(h),h.shape[1]===s)return h;const d=N$({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=G0({inputs:{x:d},backend:n,attrs:{reps:[i/c]}});l.push(d),l.push(p);return m(h,e,p,a,s)},b=LX({inputs:{x:m(f,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:d}});let y=b;if(null!=u){l.push(b);const t=EE(u);y=KX({inputs:{x:y},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}},r1=[YX,QX,tJ,nJ,sJ,lJ,cJ,uJ,mJ,bJ,vJ,xJ,SJ,NJ,CJ,RJ,FJ,OJ,zJ,LJ,BJ,HJ,KJ,qJ,XJ,tY,rY,oY,vX,cY,bY,NY,RY,_Y,DY,OY,zY,MY,BY,UY,qY,XY,JY,ZY,tZ,rZ,aZ,oZ,lZ,cZ,hZ,dZ,fZ,mZ,yZ,wZ,SZ,EZ,AZ,FZ,OZ,LZ,BZ,VZ,jZ,HZ,XZ,YZ,QZ,bX,$Z,fY,eQ,rQ,sQ,kX,iQ,cQ,uQ,dQ,fQ,mQ,yQ,wQ,SQ,NQ,CQ,AQ,RQ,FQ,OQ,zQ,LQ,MQ,PQ,WQ,jQ,HQ,t$,zX,n$,a$,o$,l$,YJ,u$,p$,f$,y$,w$,NX,x$,k$,S$,I$,E$,QJ,XQ,T$,R$,_$,MX,z$,M$,W$,V$,H$,q$,J$,Z$,t0,n0,a0,o0,l0,u0,d0,f0,GJ,$Q,m0,b0,y0,v0,w0,x0,k0,S0,E0,C0,R0,F0,_0,O0,z0,L0,M0,ZQ,HX,B0,U0,V0,H0,Y0,Q0,qX,$0,t1,n1,d$];for(const n of r1)Qx(n);const a1=function(){const[t,e]=(0,o.useState)(null),[n,r]=(0,o.useState)(null),[a,s]=(0,o.useState)(null),i=window.innerWidth;new jz(l);var l,c=360;i>=360&&(c=720),i>720&&(c=1280);var u=.55*c,h=c/2,d=(u+240)/2;const p=Math.floor(201*Math.random())-100,f=Math.floor(201*Math.random())-100,[g,m]=(0,o.useState)(!1),[b,y]=(0,o.useState)(h),[v,w]=(0,o.useState)(d);function x(t){return t.map(((t,e)=>[t,e])).reduce(((t,e)=>e[0]>t[0]?e:t))[1]}(0,o.useEffect)((()=>{k();const t=setInterval((()=>{g&&(b>=0&&b<=c&&v>=240&&v<=u?(y(b+p),w(v+f)):(y(h),w(d)))}),1e3);return()=>clearInterval(t)}),[b,v,g]);const k=async()=>{const t=function(t,e,n,r){if(ae(null==n&&null==r||null!=n&&null!=r,(function(){return"customModelURL and customMetadataURL must be both provided or both not provided."})),null!=n&&ae(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided."})),"BROWSER_FFT"===t)return new Bb(e,n,r);throw"SOFT_FFT"===t?new Error("SOFT_FFT SpeechCommandRecognizer has not been implemented yet."):new Error("Invalid fftType: '"+t+"'")}("BROWSER_FFT",void 0);console.log("Model Loaded"),await t.ensureModelLoaded(),console.log(t.wordLabels()),s(t.wordLabels()),e(t)},S=async()=>{console.log("listening. . . .. "),t.listen((t=>{console.log(a[x(Object.values(t.scores))]),"go"==a[x(Object.values(t.scores))]?(m(!0),console.log("----------------GO---------------------------"),console.log(n)):"stop"==a[x(Object.values(t.scores))]&&(m(!1),console.log("----------------STOP---------------------------"),console.log(n))}),{includeSpectrogram:!0,probabilityThreshold:.75})};return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsx)("div",{className:"img-container",children:(0,Ht.jsx)("img",{src:"/supercircle/images/white-bear-img.png",alt:"white-bear",className:"img-component",style:{position:"absolute",left:"".concat(b,"px"),top:"".concat(v,"px")}})}),(0,Ht.jsxs)("div",{className:"btn-container",children:[(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STARTED. . ."),S()},children:"Start Listening"})}),(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STOPPED"),t.stopListening()},children:"Stop Listening"})})]})]})};const s1=function(){return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsxs)("div",{style:{"text-align":"center"},children:[(0,Ht.jsx)("h1",{children:"Press the start button to start"}),(0,Ht.jsx)("h2",{children:'Control the bear by saying "GO" and "STOP"'})]}),(0,Ht.jsx)(a1,{})]})};const o1=function(){return(0,Ht.jsx)(Ht.Fragment,{})};function i1(t){return Wt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M64.264 44.704c-88.765 25.213-39.73 158.676-2.108 161.887-8.506 42.218-13.32 84.645-12.642 127.824.355 22.67 51.374 58.424 105.35 86.035C186.48 466.787 238.98 466.876 256 467.296c17.02-.42 69.52-.51 101.137-46.846 53.975-27.61 104.994-63.364 105.35-86.035.677-43.179-4.137-85.606-12.643-127.824 37.623-3.211 86.657-136.674-2.108-161.887-28.433 1.462-55.606 16.152-82.172 37.223C317.64 62.233 293.164 61.296 256 61.296c-37.163 0-61.639.937-109.564 20.63-26.566-21.07-53.739-35.76-82.172-37.222zm4.927 49.928c6.057-.096 17.237 5.625 26.809 14.664 3.362 3.175-22.916 51.05-26.818 50.158-4.59-1.05-14.985-48.285-3.725-63.318.745-.994 2.039-1.477 3.734-1.504zm373.618 0c1.695.027 2.99.51 3.734 1.504 11.26 15.033.865 62.268-3.725 63.318-3.902.893-30.18-46.983-26.818-50.158 9.572-9.04 20.752-14.76 26.809-14.664zm-260.85 82.088c17.457-.304 30.686 24.445 42.041 44.576-53.57 15.878-82.575-17.11-57.752-37.777 5.603-4.665 10.823-6.714 15.711-6.8zm148.082 0c4.888.085 10.108 2.134 15.711 6.799 24.823 20.667-4.181 53.655-57.752 37.777 11.355-20.13 24.584-44.88 42.041-44.576zM256 251.548c17.32.223 36.826 9.567 30.197 36.517-1.444 5.872-12.516 8.617-21.197 9.7v8.972c99.884 41.126 79.565 138.559-9 138.559s-108.884-97.433-9-138.559v-8.972c-8.68-1.083-19.753-3.828-21.197-9.7-6.629-26.95 12.877-36.294 30.197-36.517z"},child:[]}]})(t)}const l1=function(){return(0,Ht.jsxs)("div",{className:"projects-page",children:[(0,Ht.jsx)(Tt,{to:"/Project1",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(i1,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Project: NLP"})]})}),(0,Ht.jsx)(Tt,{to:"/No-project",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(Xt,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Underconstruction"})]})}),(0,Ht.jsx)(Tt,{to:"/No-project",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(Xt,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Underconstruction"})]})}),(0,Ht.jsx)(Tt,{to:"/No-project",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(Xt,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Underconstruction"})]})})]})};const c1=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(l1,{})})};const u1=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)("div",{style:{"background-color":"rgb(28, 27, 27)",width:"100vw",height:"80vh",display:"flex"},children:(0,Ht.jsx)("h1",{style:{"text-align":"center",color:"white",width:"100vw"},children:"Underconstruction . . . . . . . . . . . . ."})})})};const h1=function(){return(0,Ht.jsx)("div",{className:"App",children:(0,Ht.jsxs)(Nt,{children:[(0,Ht.jsx)(Kt,{}),(0,Ht.jsxs)(vt,{children:[(0,Ht.jsx)(bt,{path:"/supercircle",exact:!0,element:(0,Ht.jsx)($t,{})}),(0,Ht.jsx)(bt,{path:"/",exact:!0,element:(0,Ht.jsx)($t,{})}),(0,Ht.jsx)(bt,{path:"/projects",exact:!0,element:(0,Ht.jsx)(c1,{})}),(0,Ht.jsx)(bt,{path:"/contact",exact:!0,element:(0,Ht.jsx)(Yt,{})}),(0,Ht.jsx)(bt,{path:"/project1",exact:!0,element:(0,Ht.jsx)(s1,{})}),(0,Ht.jsx)(bt,{path:"/project2",exact:!0,element:(0,Ht.jsx)(o1,{})}),(0,Ht.jsx)(bt,{path:"/no-project",exact:!0,element:(0,Ht.jsx)(u1,{})})]})]})})};l.createRoot(document.getElementById("root")).render((0,Ht.jsx)(o.StrictMode,{children:(0,Ht.jsx)(h1,{})}))})()})();
//# sourceMappingURL=main.1aa86f55.js.map