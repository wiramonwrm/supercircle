/*! For license information please see main.2ea2cab4.js.LICENSE.txt */
(()=>{var t={2028:(t,e,n)=>{"use strict";var r=n(2),a=n(1712),s=a(r("String.prototype.indexOf"));t.exports=function(t,e){var n=r(t,!!e);return"function"===typeof n&&s(t,".prototype.")>-1?a(n):n}},1712:(t,e,n)=>{"use strict";var r=n(3864),a=n(2),s=n(5438),o=n(4902),i=a("%Function.prototype.apply%"),l=a("%Function.prototype.call%"),c=a("%Reflect.apply%",!0)||r.call(l,i),u=n(2090),h=a("%Math.max%");t.exports=function(t){if("function"!==typeof t)throw new o("a function is required");var e=c(r,l,arguments);return s(e,1+h(0,t.length-(arguments.length-1)),!0)};var d=function(){return c(r,i,arguments)};u?u(t.exports,"apply",{value:d}):t.exports.apply=d},4992:(t,e,n)=>{"use strict";var r=n(2090),a=n(2557),s=n(4902),o=n(5558);t.exports=function(t,e,n){if(!t||"object"!==typeof t&&"function"!==typeof t)throw new s("`obj` must be an object or a function`");if("string"!==typeof e&&"symbol"!==typeof e)throw new s("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!==typeof arguments[3]&&null!==arguments[3])throw new s("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!==typeof arguments[4]&&null!==arguments[4])throw new s("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!==typeof arguments[5]&&null!==arguments[5])throw new s("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!==typeof arguments[6])throw new s("`loose`, if provided, must be a boolean");var i=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,u=arguments.length>6&&arguments[6],h=!!o&&o(t,e);if(r)r(t,e,{configurable:null===c&&h?h.configurable:!c,enumerable:null===i&&h?h.enumerable:!i,value:n,writable:null===l&&h?h.writable:!l});else{if(!u&&(i||l||c))throw new a("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");t[e]=n}}},2090:(t,e,n)=>{"use strict";var r=n(2)("%Object.defineProperty%",!0)||!1;if(r)try{r({},"a",{value:1})}catch(a){r=!1}t.exports=r},9820:t=>{"use strict";t.exports=EvalError},9304:t=>{"use strict";t.exports=Error},1725:t=>{"use strict";t.exports=RangeError},5077:t=>{"use strict";t.exports=ReferenceError},2557:t=>{"use strict";t.exports=SyntaxError},4902:t=>{"use strict";t.exports=TypeError},3094:t=>{"use strict";t.exports=URIError},1903:(t,e,n)=>{"use strict";var r=n(8799),a=Object.prototype.toString,s=Object.prototype.hasOwnProperty;t.exports=function(t,e,n){if(!r(e))throw new TypeError("iterator must be a function");var o;arguments.length>=3&&(o=n),"[object Array]"===a.call(t)?function(t,e,n){for(var r=0,a=t.length;r<a;r++)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o):"string"===typeof t?function(t,e,n){for(var r=0,a=t.length;r<a;r++)null==n?e(t.charAt(r),r,t):e.call(n,t.charAt(r),r,t)}(t,e,o):function(t,e,n){for(var r in t)s.call(t,r)&&(null==n?e(t[r],r,t):e.call(n,t[r],r,t))}(t,e,o)}},7724:t=>{"use strict";var e=Object.prototype.toString,n=Math.max,r=function(t,e){for(var n=[],r=0;r<t.length;r+=1)n[r]=t[r];for(var a=0;a<e.length;a+=1)n[a+t.length]=e[a];return n};t.exports=function(t){var a=this;if("function"!==typeof a||"[object Function]"!==e.apply(a))throw new TypeError("Function.prototype.bind called on incompatible "+a);for(var s,o=function(t,e){for(var n=[],r=e||0,a=0;r<t.length;r+=1,a+=1)n[a]=t[r];return n}(arguments,1),i=n(0,a.length-o.length),l=[],c=0;c<i;c++)l[c]="$"+c;if(s=Function("binder","return function ("+function(t,e){for(var n="",r=0;r<t.length;r+=1)n+=t[r],r+1<t.length&&(n+=e);return n}(l,",")+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof s){var e=a.apply(this,r(o,arguments));return Object(e)===e?e:this}return a.apply(t,r(o,arguments))})),a.prototype){var u=function(){};u.prototype=a.prototype,s.prototype=new u,u.prototype=null}return s}},3864:(t,e,n)=>{"use strict";var r=n(7724);t.exports=Function.prototype.bind||r},2:(t,e,n)=>{"use strict";var r,a=n(9304),s=n(9820),o=n(1725),i=n(5077),l=n(2557),c=n(4902),u=n(3094),h=Function,d=function(t){try{return h('"use strict"; return ('+t+").constructor;")()}catch(e){}},p=Object.getOwnPropertyDescriptor;if(p)try{p({},"")}catch(z){p=null}var f=function(){throw new c},g=p?function(){try{return f}catch(t){try{return p(arguments,"callee").get}catch(e){return f}}}():f,m=n(2108)(),b=n(951)(),y=Object.getPrototypeOf||(b?function(t){return t.__proto__}:null),v={},w="undefined"!==typeof Uint8Array&&y?y(Uint8Array):r,x={__proto__:null,"%AggregateError%":"undefined"===typeof AggregateError?r:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"===typeof ArrayBuffer?r:ArrayBuffer,"%ArrayIteratorPrototype%":m&&y?y([][Symbol.iterator]()):r,"%AsyncFromSyncIteratorPrototype%":r,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"===typeof Atomics?r:Atomics,"%BigInt%":"undefined"===typeof BigInt?r:BigInt,"%BigInt64Array%":"undefined"===typeof BigInt64Array?r:BigInt64Array,"%BigUint64Array%":"undefined"===typeof BigUint64Array?r:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"===typeof DataView?r:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":a,"%eval%":eval,"%EvalError%":s,"%Float32Array%":"undefined"===typeof Float32Array?r:Float32Array,"%Float64Array%":"undefined"===typeof Float64Array?r:Float64Array,"%FinalizationRegistry%":"undefined"===typeof FinalizationRegistry?r:FinalizationRegistry,"%Function%":h,"%GeneratorFunction%":v,"%Int8Array%":"undefined"===typeof Int8Array?r:Int8Array,"%Int16Array%":"undefined"===typeof Int16Array?r:Int16Array,"%Int32Array%":"undefined"===typeof Int32Array?r:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":m&&y?y(y([][Symbol.iterator]())):r,"%JSON%":"object"===typeof JSON?JSON:r,"%Map%":"undefined"===typeof Map?r:Map,"%MapIteratorPrototype%":"undefined"!==typeof Map&&m&&y?y((new Map)[Symbol.iterator]()):r,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"===typeof Promise?r:Promise,"%Proxy%":"undefined"===typeof Proxy?r:Proxy,"%RangeError%":o,"%ReferenceError%":i,"%Reflect%":"undefined"===typeof Reflect?r:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"===typeof Set?r:Set,"%SetIteratorPrototype%":"undefined"!==typeof Set&&m&&y?y((new Set)[Symbol.iterator]()):r,"%SharedArrayBuffer%":"undefined"===typeof SharedArrayBuffer?r:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":m&&y?y(""[Symbol.iterator]()):r,"%Symbol%":m?Symbol:r,"%SyntaxError%":l,"%ThrowTypeError%":g,"%TypedArray%":w,"%TypeError%":c,"%Uint8Array%":"undefined"===typeof Uint8Array?r:Uint8Array,"%Uint8ClampedArray%":"undefined"===typeof Uint8ClampedArray?r:Uint8ClampedArray,"%Uint16Array%":"undefined"===typeof Uint16Array?r:Uint16Array,"%Uint32Array%":"undefined"===typeof Uint32Array?r:Uint32Array,"%URIError%":u,"%WeakMap%":"undefined"===typeof WeakMap?r:WeakMap,"%WeakRef%":"undefined"===typeof WeakRef?r:WeakRef,"%WeakSet%":"undefined"===typeof WeakSet?r:WeakSet};if(y)try{null.error}catch(z){var k=y(y(z));x["%Error.prototype%"]=k}var S=function t(e){var n;if("%AsyncFunction%"===e)n=d("async function () {}");else if("%GeneratorFunction%"===e)n=d("function* () {}");else if("%AsyncGeneratorFunction%"===e)n=d("async function* () {}");else if("%AsyncGenerator%"===e){var r=t("%AsyncGeneratorFunction%");r&&(n=r.prototype)}else if("%AsyncIteratorPrototype%"===e){var a=t("%AsyncGenerator%");a&&y&&(n=y(a.prototype))}return x[e]=n,n},I={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},N=n(3864),C=n(4384),E=N.call(Function.call,Array.prototype.concat),T=N.call(Function.apply,Array.prototype.splice),A=N.call(Function.call,String.prototype.replace),R=N.call(Function.call,String.prototype.slice),F=N.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,D=/\\(\\)?/g,O=function(t,e){var n,r=t;if(C(I,r)&&(r="%"+(n=I[r])[0]+"%"),C(x,r)){var a=x[r];if(a===v&&(a=S(r)),"undefined"===typeof a&&!e)throw new c("intrinsic "+t+" exists, but is not available. Please file an issue!");return{alias:n,name:r,value:a}}throw new l("intrinsic "+t+" does not exist!")};t.exports=function(t,e){if("string"!==typeof t||0===t.length)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!==typeof e)throw new c('"allowMissing" argument must be a boolean');if(null===F(/^%?[^%]*%?$/,t))throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var n=function(t){var e=R(t,0,1),n=R(t,-1);if("%"===e&&"%"!==n)throw new l("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==e)throw new l("invalid intrinsic syntax, expected opening `%`");var r=[];return A(t,_,(function(t,e,n,a){r[r.length]=n?A(a,D,"$1"):e||t})),r}(t),r=n.length>0?n[0]:"",a=O("%"+r+"%",e),s=a.name,o=a.value,i=!1,u=a.alias;u&&(r=u[0],T(n,E([0,1],u)));for(var h=1,d=!0;h<n.length;h+=1){var f=n[h],g=R(f,0,1),m=R(f,-1);if(('"'===g||"'"===g||"`"===g||'"'===m||"'"===m||"`"===m)&&g!==m)throw new l("property names with quotes must have matching quotes");if("constructor"!==f&&d||(i=!0),C(x,s="%"+(r+="."+f)+"%"))o=x[s];else if(null!=o){if(!(f in o)){if(!e)throw new c("base intrinsic for "+t+" exists, but the property is not available.");return}if(p&&h+1>=n.length){var b=p(o,f);o=(d=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:o[f]}else d=C(o,f),o=o[f];d&&!i&&(x[s]=o)}}return o}},5558:(t,e,n)=>{"use strict";var r=n(2)("%Object.getOwnPropertyDescriptor%",!0);if(r)try{r([],"length")}catch(a){r=null}t.exports=r},2101:(t,e,n)=>{"use strict";var r=n(2090),a=function(){return!!r};a.hasArrayLengthDefineBug=function(){if(!r)return null;try{return 1!==r([],"length",{value:1}).length}catch(t){return!0}},t.exports=a},951:t=>{"use strict";var e={__proto__:null,foo:{}},n=Object;t.exports=function(){return{__proto__:e}.foo===e.foo&&!(e instanceof n)}},2108:(t,e,n)=>{"use strict";var r="undefined"!==typeof Symbol&&Symbol,a=n(9534);t.exports=function(){return"function"===typeof r&&("function"===typeof Symbol&&("symbol"===typeof r("foo")&&("symbol"===typeof Symbol("bar")&&a())))}},9534:t=>{"use strict";t.exports=function(){if("function"!==typeof Symbol||"function"!==typeof Object.getOwnPropertySymbols)return!1;if("symbol"===typeof Symbol.iterator)return!0;var t={},e=Symbol("test"),n=Object(e);if("string"===typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(e in t[e]=42,t)return!1;if("function"===typeof Object.keys&&0!==Object.keys(t).length)return!1;if("function"===typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(t).length)return!1;var r=Object.getOwnPropertySymbols(t);if(1!==r.length||r[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(t,e))return!1;if("function"===typeof Object.getOwnPropertyDescriptor){var a=Object.getOwnPropertyDescriptor(t,e);if(42!==a.value||!0!==a.enumerable)return!1}return!0}},4635:(t,e,n)=>{"use strict";var r=n(9534);t.exports=function(){return r()&&!!Symbol.toStringTag}},4384:(t,e,n)=>{"use strict";var r=Function.prototype.call,a=Object.prototype.hasOwnProperty,s=n(3864);t.exports=s.call(r,a)},6329:t=>{"function"===typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}}},8317:(t,e,n)=>{"use strict";var r=n(4635)(),a=n(2028)("Object.prototype.toString"),s=function(t){return!(r&&t&&"object"===typeof t&&Symbol.toStringTag in t)&&"[object Arguments]"===a(t)},o=function(t){return!!s(t)||null!==t&&"object"===typeof t&&"number"===typeof t.length&&t.length>=0&&"[object Array]"!==a(t)&&"[object Function]"===a(t.callee)},i=function(){return s(arguments)}();s.isLegacyArguments=o,t.exports=i?s:o},8799:t=>{"use strict";var e,n,r=Function.prototype.toString,a="object"===typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"===typeof a&&"function"===typeof Object.defineProperty)try{e=Object.defineProperty({},"length",{get:function(){throw n}}),n={},a((function(){throw 42}),null,e)}catch(p){p!==n&&(a=null)}else a=null;var s=/^\s*class\b/,o=function(t){try{var e=r.call(t);return s.test(e)}catch(n){return!1}},i=function(t){try{return!o(t)&&(r.call(t),!0)}catch(e){return!1}},l=Object.prototype.toString,c="function"===typeof Symbol&&!!Symbol.toStringTag,u=!(0 in[,]),h=function(){return!1};if("object"===typeof document){var d=document.all;l.call(d)===l.call(document.all)&&(h=function(t){if((u||!t)&&("undefined"===typeof t||"object"===typeof t))try{var e=l.call(t);return("[object HTMLAllCollection]"===e||"[object HTML document.all class]"===e||"[object HTMLCollection]"===e||"[object Object]"===e)&&null==t("")}catch(n){}return!1})}t.exports=a?function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;try{a(t,null,e)}catch(r){if(r!==n)return!1}return!o(t)&&i(t)}:function(t){if(h(t))return!0;if(!t)return!1;if("function"!==typeof t&&"object"!==typeof t)return!1;if(c)return i(t);if(o(t))return!1;var e=l.call(t);return!("[object Function]"!==e&&"[object GeneratorFunction]"!==e&&!/^\[object HTML/.test(e))&&i(t)}},1583:(t,e,n)=>{"use strict";var r,a=Object.prototype.toString,s=Function.prototype.toString,o=/^\s*(?:function)?\*/,i=n(4635)(),l=Object.getPrototypeOf;t.exports=function(t){if("function"!==typeof t)return!1;if(o.test(s.call(t)))return!0;if(!i)return"[object GeneratorFunction]"===a.call(t);if(!l)return!1;if("undefined"===typeof r){var e=function(){if(!i)return!1;try{return Function("return function*() {}")()}catch(t){}}();r=!!e&&l(e)}return l(t)===r}},9849:(t,e,n)=>{"use strict";var r=n(8004);t.exports=function(t){return!!r(t)}},7353:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function o(t,e){var n,r,o;return e?(o=0<=(t>>>=0)&&t<256)&&(r=s[t])?r:(n=l(t,(0|t)<0?-1:0,!0),o&&(s[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(r=a[t])?r:(n=l(t,t<0?-1:0,!1),o&&(a[t]=n),n)}function i(t,e){if(isNaN(t))return e?b:m;if(e){if(t<0)return b;if(t>=p)return k}else{if(t<=-f)return S;if(t+1>=f)return x}return t<0?i(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=o,n.fromNumber=i,n.fromBits=l;var c=Math.pow;function u(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return m;if("number"===typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(t.substring(1),e,n).neg();for(var a=i(c(n,8)),s=m,o=0;o<t.length;o+=8){var l=Math.min(8,t.length-o),h=parseInt(t.substring(o,o+l),n);if(l<8){var d=i(c(n,l));s=s.mul(d).add(i(h))}else s=(s=s.mul(a)).add(i(h))}return s.unsigned=e,s}function h(t,e){return"number"===typeof t?i(t,e):"string"===typeof t?u(t,e):l(t.low,t.high,"boolean"===typeof e?e:t.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=o(1<<24),m=o(0);n.ZERO=m;var b=o(0,!0);n.UZERO=b;var y=o(1);n.ONE=y;var v=o(1,!0);n.UONE=v;var w=o(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var e=i(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var a=i(c(t,6),this.unsigned),s=this,o="";;){var l=s.div(a),u=(s.sub(l.mul(a)).toInt()>>>0).toString(t);if((s=l).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!==1||t.high>>>31!==1)&&(this.high===t.high&&this.low===t.low)},I.eq=I.equals,I.notEquals=function(t){return!this.eq(t)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(t){return this.comp(t)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(t){return this.comp(t)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(t){return this.comp(t)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(t){return this.comp(t)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(y)},I.neg=I.negate,I.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,o=t.high>>>16,i=65535&t.high,c=t.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&t.low))>>>16,d+=(p+=a+c)>>>16,u+=(d+=n+i)>>>16,u+=e+o,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},I.sub=I.subtract,I.multiply=function(t){if(this.isZero())return m;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return m;if(this.eq(S))return t.isOdd()?S:m;if(t.eq(S))return this.isOdd()?S:m;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return i(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,o=65535&this.low,c=t.high>>>16,u=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,b=0,y=0,v=0;return y+=(v+=o*p)>>>16,b+=(y+=s*p)>>>16,y&=65535,b+=(y+=o*d)>>>16,f+=(b+=a*p)>>>16,b&=65535,f+=(b+=s*d)>>>16,b&=65535,f+=(b+=o*u)>>>16,f+=n*p+a*d+s*u+o*c,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,a,s;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return b;if(t.gt(this.shru(1)))return v;s=b}else{if(this.eq(S))return t.eq(y)||t.eq(w)?S:t.eq(S)?y:(n=this.shr(1).div(t).shl(1)).eq(m)?t.isNegative()?y:w:(a=this.sub(t.mul(n)),s=n.add(a.div(t)));if(t.eq(S))return this.unsigned?b:m;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=m}for(a=this;a.gte(t);){n=Math.max(1,Math.floor(a.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),u=o<=48?1:c(2,o-48),d=i(n),p=d.mul(t);p.isNegative()||p.gt(a);)p=(d=i(n-=u,this.unsigned)).mul(t);d.isZero()&&(d=y),s=s.add(d),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},I.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},I.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},I.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(t){return r(t)&&(t=t.toInt()),0===(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0===(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},I.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},7163:t=>{"use strict";t.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},2730:(t,e,n)=>{"use strict";var r=n(5043),a=n(8853);function s(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=new Set,i={};function l(t,e){c(t,e),c(t+"Capture",e)}function c(t,e){for(i[t]=e,t=0;t<e.length;t++)o.add(e[t])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function g(t,e,n,r,a,s,o){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t){m[t]=new g(t,0,!1,t,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(t){var e=t[0];m[e]=new g(e,1,!1,t[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(t){m[t]=new g(t,2,!1,t.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(t){m[t]=new g(t,2,!1,t,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t){m[t]=new g(t,3,!1,t.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(t){m[t]=new g(t,3,!0,t,null,!1,!1)})),["capture","download"].forEach((function(t){m[t]=new g(t,4,!1,t,null,!1,!1)})),["cols","rows","size","span"].forEach((function(t){m[t]=new g(t,6,!1,t,null,!1,!1)})),["rowSpan","start"].forEach((function(t){m[t]=new g(t,5,!1,t.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(t){return t[1].toUpperCase()}function v(t,e,n,r){var a=m.hasOwnProperty(e)?m[e]:null;(null!==a?0!==a.type:r||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(t,e,n,r){if(null===e||"undefined"===typeof e||function(t,e,n,r){if(null!==n&&0===n.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(t=t.toLowerCase().slice(0,5))&&"aria-"!==t);default:return!1}}(t,e,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,n,a,r)&&(n=null),r||null===a?function(t){return!!h.call(f,t)||!h.call(p,t)&&(d.test(t)?f[t]=!0:(p[t]=!0,!1))}(e)&&(null===n?t.removeAttribute(e):t.setAttribute(e,""+n)):a.mustUseProperty?t[a.propertyName]=null===n?3!==a.type&&"":n:(e=a.attributeName,r=a.attributeNamespace,null===n?t.removeAttribute(e):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(t){var e=t.replace(b,y);m[e]=new g(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!1,!1)})),m.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(t){m[t]=new g(t,1,!1,t.toLowerCase(),null,!0,!0)}));var w=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),C=Symbol.for("react.provider"),E=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),_=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function z(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=O&&t[O]||t["@@iterator"])?t:null}var L,M=Object.assign;function P(t){if(void 0===L)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);L=e&&e[1]||""}return"\n"+L+t}var B=!1;function W(t,e){if(!t||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var r=c}Reflect.construct(t,[],e)}else{try{e.call()}catch(c){r=c}t.call(e.prototype)}else{try{throw Error()}catch(c){r=c}t()}}catch(c){if(c&&r&&"string"===typeof c.stack){for(var a=c.stack.split("\n"),s=r.stack.split("\n"),o=a.length-1,i=s.length-1;1<=o&&0<=i&&a[o]!==s[i];)i--;for(;1<=o&&0<=i;o--,i--)if(a[o]!==s[i]){if(1!==o||1!==i)do{if(o--,0>--i||a[o]!==s[i]){var l="\n"+a[o].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}}while(1<=o&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?P(t):""}function U(t){switch(t.tag){case 5:return P(t.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return t=W(t.type,!1);case 11:return t=W(t.type.render,!1);case 1:return t=W(t.type,!0);default:return""}}function V(t){if(null==t)return null;if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t;switch(t){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case A:return"Suspense";case R:return"SuspenseList"}if("object"===typeof t)switch(t.$$typeof){case E:return(t.displayName||"Context")+".Consumer";case C:return(t._context.displayName||"Context")+".Provider";case T:var e=t.render;return(t=t.displayName)||(t=""!==(t=e.displayName||e.name||"")?"ForwardRef("+t+")":"ForwardRef"),t;case F:return null!==(e=t.displayName||null)?e:V(t.type)||"Memo";case _:e=t._payload,t=t._init;try{return V(t(e))}catch(n){}}return null}function j(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=(t=e.render).displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(e);case 8:return e===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function G(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":case"object":return t;default:return""}}function H(t){var e=t.type;return(t=t.nodeName)&&"input"===t.toLowerCase()&&("checkbox"===e||"radio"===e)}function K(t){t._valueTracker||(t._valueTracker=function(t){var e=H(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return a.call(this)},set:function(t){r=""+t,s.call(this,t)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(t){r=""+t},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}(t))}function q(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=H(t)?t.checked?"true":"false":t.value),(t=r)!==n&&(e.setValue(t),!0)}function X(t){if("undefined"===typeof(t=t||("undefined"!==typeof document?document:void 0)))return null;try{return t.activeElement||t.body}catch(e){return t.body}}function J(t,e){var n=e.checked;return M({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:t._wrapperState.initialChecked})}function Y(t,e){var n=null==e.defaultValue?"":e.defaultValue,r=null!=e.checked?e.checked:e.defaultChecked;n=G(null!=e.value?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function Z(t,e){null!=(e=e.checked)&&v(t,"checked",e,!1)}function Q(t,e){Z(t,e);var n=G(e.value),r=e.type;if(null!=n)"number"===r?(0===n&&""===t.value||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if("submit"===r||"reset"===r)return void t.removeAttribute("value");e.hasOwnProperty("value")?tt(t,e.type,n):e.hasOwnProperty("defaultValue")&&tt(t,e.type,G(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(t.defaultChecked=!!e.defaultChecked)}function $(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!("submit"!==r&&"reset"!==r||void 0!==e.value&&null!==e.value))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}""!==(n=t.name)&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,""!==n&&(t.name=n)}function tt(t,e,n){"number"===e&&X(t.ownerDocument)===t||(null==n?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var et=Array.isArray;function nt(t,e,n,r){if(t=t.options,e){e={};for(var a=0;a<n.length;a++)e["$"+n[a]]=!0;for(n=0;n<t.length;n++)a=e.hasOwnProperty("$"+t[n].value),t[n].selected!==a&&(t[n].selected=a),a&&r&&(t[n].defaultSelected=!0)}else{for(n=""+G(n),e=null,a=0;a<t.length;a++){if(t[a].value===n)return t[a].selected=!0,void(r&&(t[a].defaultSelected=!0));null!==e||t[a].disabled||(e=t[a])}null!==e&&(e.selected=!0)}}function rt(t,e){if(null!=e.dangerouslySetInnerHTML)throw Error(s(91));return M({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function at(t,e){var n=e.value;if(null==n){if(n=e.children,e=e.defaultValue,null!=n){if(null!=e)throw Error(s(92));if(et(n)){if(1<n.length)throw Error(s(93));n=n[0]}e=n}null==e&&(e=""),n=e}t._wrapperState={initialValue:G(n)}}function st(t,e){var n=G(e.value),r=G(e.defaultValue);null!=n&&((n=""+n)!==t.value&&(t.value=n),null==e.defaultValue&&t.defaultValue!==n&&(t.defaultValue=n)),null!=r&&(t.defaultValue=""+r)}function ot(t){var e=t.textContent;e===t._wrapperState.initialValue&&""!==e&&null!==e&&(t.value=e)}function it(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lt(t,e){return null==t||"http://www.w3.org/1999/xhtml"===t?it(e):"http://www.w3.org/2000/svg"===t&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":t}var ct,ut,ht=(ut=function(t,e){if("http://www.w3.org/2000/svg"!==t.namespaceURI||"innerHTML"in t)t.innerHTML=e;else{for((ct=ct||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ct.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(t,e,n,r){MSApp.execUnsafeLocalFunction((function(){return ut(t,e)}))}:ut);function dt(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&3===n.nodeType)return void(n.nodeValue=e)}t.textContent=e}var pt={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ft=["Webkit","ms","Moz","O"];function gt(t,e,n){return null==e||"boolean"===typeof e||""===e?"":n||"number"!==typeof e||0===e||pt.hasOwnProperty(t)&&pt[t]?(""+e).trim():e+"px"}function mt(t,e){for(var n in t=t.style,e)if(e.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=gt(n,e[n],r);"float"===n&&(n="cssFloat"),r?t.setProperty(n,a):t[n]=a}}Object.keys(pt).forEach((function(t){ft.forEach((function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),pt[e]=pt[t]}))}));var bt=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function yt(t,e){if(e){if(bt[t]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(s(137,t));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(s(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(s(62))}}function vt(t,e){if(-1===t.indexOf("-"))return"string"===typeof e.is;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wt=null;function xt(t){return(t=t.target||t.srcElement||window).correspondingUseElement&&(t=t.correspondingUseElement),3===t.nodeType?t.parentNode:t}var kt=null,St=null,It=null;function Nt(t){if(t=va(t)){if("function"!==typeof kt)throw Error(s(280));var e=t.stateNode;e&&(e=xa(e),kt(t.stateNode,t.type,e))}}function Ct(t){St?It?It.push(t):It=[t]:St=t}function Et(){if(St){var t=St,e=It;if(It=St=null,Nt(t),e)for(t=0;t<e.length;t++)Nt(e[t])}}function Tt(t,e){return t(e)}function At(){}var Rt=!1;function Ft(t,e,n){if(Rt)return t(e,n);Rt=!0;try{return Tt(t,e,n)}finally{Rt=!1,(null!==St||null!==It)&&(At(),Et())}}function _t(t,e){var n=t.stateNode;if(null===n)return null;var r=xa(n);if(null===r)return null;n=r[e];t:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(t=t.type)||"input"===t||"select"===t||"textarea"===t)),t=!r;break t;default:t=!1}if(t)return null;if(n&&"function"!==typeof n)throw Error(s(231,e,typeof n));return n}var Dt=!1;if(u)try{var Ot={};Object.defineProperty(Ot,"passive",{get:function(){Dt=!0}}),window.addEventListener("test",Ot,Ot),window.removeEventListener("test",Ot,Ot)}catch(ut){Dt=!1}function zt(t,e,n,r,a,s,o,i,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var Lt=!1,Mt=null,Pt=!1,Bt=null,Wt={onError:function(t){Lt=!0,Mt=t}};function Ut(t,e,n,r,a,s,o,i,l){Lt=!1,Mt=null,zt.apply(Wt,arguments)}function Vt(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do{0!==(4098&(e=t).flags)&&(n=e.return),t=e.return}while(t)}return 3===e.tag?n:null}function jt(t){if(13===t.tag){var e=t.memoizedState;if(null===e&&(null!==(t=t.alternate)&&(e=t.memoizedState)),null!==e)return e.dehydrated}return null}function Gt(t){if(Vt(t)!==t)throw Error(s(188))}function Ht(t){return null!==(t=function(t){var e=t.alternate;if(!e){if(null===(e=Vt(t)))throw Error(s(188));return e!==t?null:t}for(var n=t,r=e;;){var a=n.return;if(null===a)break;var o=a.alternate;if(null===o){if(null!==(r=a.return)){n=r;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===n)return Gt(a),t;if(o===r)return Gt(a),e;o=o.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=o;else{for(var i=!1,l=a.child;l;){if(l===n){i=!0,n=a,r=o;break}if(l===r){i=!0,r=a,n=o;break}l=l.sibling}if(!i){for(l=o.child;l;){if(l===n){i=!0,n=o,r=a;break}if(l===r){i=!0,r=o,n=a;break}l=l.sibling}if(!i)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?t:e}(t))?Kt(t):null}function Kt(t){if(5===t.tag||6===t.tag)return t;for(t=t.child;null!==t;){var e=Kt(t);if(null!==e)return e;t=t.sibling}return null}var qt=a.unstable_scheduleCallback,Xt=a.unstable_cancelCallback,Jt=a.unstable_shouldYield,Yt=a.unstable_requestPaint,Zt=a.unstable_now,Qt=a.unstable_getCurrentPriorityLevel,$t=a.unstable_ImmediatePriority,te=a.unstable_UserBlockingPriority,ee=a.unstable_NormalPriority,ne=a.unstable_LowPriority,re=a.unstable_IdlePriority,ae=null,se=null;var oe=Math.clz32?Math.clz32:function(t){return t>>>=0,0===t?32:31-(ie(t)/le|0)|0},ie=Math.log,le=Math.LN2;var ce=64,ue=4194304;function he(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&t;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&t;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function de(t,e){var n=t.pendingLanes;if(0===n)return 0;var r=0,a=t.suspendedLanes,s=t.pingedLanes,o=268435455&n;if(0!==o){var i=o&~a;0!==i?r=he(i):0!==(s&=o)&&(r=he(s))}else 0!==(o=n&~a)?r=he(o):0!==s&&(r=he(s));if(0===r)return 0;if(0!==e&&e!==r&&0===(e&a)&&((a=r&-r)>=(s=e&-e)||16===a&&0!==(4194240&s)))return e;if(0!==(4&r)&&(r|=16&n),0!==(e=t.entangledLanes))for(t=t.entanglements,e&=r;0<e;)a=1<<(n=31-oe(e)),r|=t[n],e&=~a;return r}function pe(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function fe(t){return 0!==(t=-1073741825&t.pendingLanes)?t:1073741824&t?1073741824:0}function ge(){var t=ce;return 0===(4194240&(ce<<=1))&&(ce=64),t}function me(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function be(t,e,n){t.pendingLanes|=e,536870912!==e&&(t.suspendedLanes=0,t.pingedLanes=0),(t=t.eventTimes)[e=31-oe(e)]=n}function ye(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-oe(n),a=1<<r;a&e|t[r]&e&&(t[r]|=e),n&=~a}}var ve=0;function we(t){return 1<(t&=-t)?4<t?0!==(268435455&t)?16:536870912:4:1}var xe,ke,Se,Ie,Ne,Ce=!1,Ee=[],Te=null,Ae=null,Re=null,Fe=new Map,_e=new Map,De=[],Oe="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ze(t,e){switch(t){case"focusin":case"focusout":Te=null;break;case"dragenter":case"dragleave":Ae=null;break;case"mouseover":case"mouseout":Re=null;break;case"pointerover":case"pointerout":Fe.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":_e.delete(e.pointerId)}}function Le(t,e,n,r,a,s){return null===t||t.nativeEvent!==s?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==e&&(null!==(e=va(e))&&ke(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,null!==a&&-1===e.indexOf(a)&&e.push(a),t)}function Me(t){var e=ya(t.target);if(null!==e){var n=Vt(e);if(null!==n)if(13===(e=n.tag)){if(null!==(e=jt(n)))return t.blockedOn=e,void Ne(t.priority,(function(){Se(n)}))}else if(3===e&&n.stateNode.current.memoizedState.isDehydrated)return void(t.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}t.blockedOn=null}function Pe(t){if(null!==t.blockedOn)return!1;for(var e=t.targetContainers;0<e.length;){var n=Je(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(null!==n)return null!==(e=va(n))&&ke(e),t.blockedOn=n,!1;var r=new(n=t.nativeEvent).constructor(n.type,n);wt=r,n.target.dispatchEvent(r),wt=null,e.shift()}return!0}function Be(t,e,n){Pe(t)&&n.delete(e)}function We(){Ce=!1,null!==Te&&Pe(Te)&&(Te=null),null!==Ae&&Pe(Ae)&&(Ae=null),null!==Re&&Pe(Re)&&(Re=null),Fe.forEach(Be),_e.forEach(Be)}function Ue(t,e){t.blockedOn===e&&(t.blockedOn=null,Ce||(Ce=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,We)))}function Ve(t){function e(e){return Ue(e,t)}if(0<Ee.length){Ue(Ee[0],t);for(var n=1;n<Ee.length;n++){var r=Ee[n];r.blockedOn===t&&(r.blockedOn=null)}}for(null!==Te&&Ue(Te,t),null!==Ae&&Ue(Ae,t),null!==Re&&Ue(Re,t),Fe.forEach(e),_e.forEach(e),n=0;n<De.length;n++)(r=De[n]).blockedOn===t&&(r.blockedOn=null);for(;0<De.length&&null===(n=De[0]).blockedOn;)Me(n),null===n.blockedOn&&De.shift()}var je=w.ReactCurrentBatchConfig,Ge=!0;function He(t,e,n,r){var a=ve,s=je.transition;je.transition=null;try{ve=1,qe(t,e,n,r)}finally{ve=a,je.transition=s}}function Ke(t,e,n,r){var a=ve,s=je.transition;je.transition=null;try{ve=4,qe(t,e,n,r)}finally{ve=a,je.transition=s}}function qe(t,e,n,r){if(Ge){var a=Je(t,e,n,r);if(null===a)Gr(t,e,r,Xe,n),ze(t,r);else if(function(t,e,n,r,a){switch(e){case"focusin":return Te=Le(Te,t,e,n,r,a),!0;case"dragenter":return Ae=Le(Ae,t,e,n,r,a),!0;case"mouseover":return Re=Le(Re,t,e,n,r,a),!0;case"pointerover":var s=a.pointerId;return Fe.set(s,Le(Fe.get(s)||null,t,e,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,_e.set(s,Le(_e.get(s)||null,t,e,n,r,a)),!0}return!1}(a,t,e,n,r))r.stopPropagation();else if(ze(t,r),4&e&&-1<Oe.indexOf(t)){for(;null!==a;){var s=va(a);if(null!==s&&xe(s),null===(s=Je(t,e,n,r))&&Gr(t,e,r,Xe,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else Gr(t,e,r,null,n)}}var Xe=null;function Je(t,e,n,r){if(Xe=null,null!==(t=ya(t=xt(r))))if(null===(e=Vt(t)))t=null;else if(13===(n=e.tag)){if(null!==(t=jt(e)))return t;t=null}else if(3===n){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return Xe=t,null}function Ye(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qt()){case $t:return 1;case te:return 4;case ee:case ne:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ze=null,Qe=null,$e=null;function tn(){if($e)return $e;var t,e,n=Qe,r=n.length,a="value"in Ze?Ze.value:Ze.textContent,s=a.length;for(t=0;t<r&&n[t]===a[t];t++);var o=r-t;for(e=1;e<=o&&n[r-e]===a[s-e];e++);return $e=a.slice(t,1<e?1-e:void 0)}function en(t){var e=t.keyCode;return"charCode"in t?0===(t=t.charCode)&&13===e&&(t=13):t=e,10===t&&(t=13),32<=t||13===t?t:0}function nn(){return!0}function rn(){return!1}function an(t){function e(e,n,r,a,s){for(var o in this._reactName=e,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,t)t.hasOwnProperty(o)&&(e=t[o],this[o]=e?e(a):a[o]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return M(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():"unknown"!==typeof t.returnValue&&(t.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():"unknown"!==typeof t.cancelBubble&&(t.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),e}var sn,on,ln,cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=an(cn),hn=M({},cn,{view:0,detail:0}),dn=an(hn),pn=M({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(t){return void 0===t.relatedTarget?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==ln&&(ln&&"mousemove"===t.type?(sn=t.screenX-ln.screenX,on=t.screenY-ln.screenY):on=sn=0,ln=t),sn)},movementY:function(t){return"movementY"in t?t.movementY:on}}),fn=an(pn),gn=an(M({},pn,{dataTransfer:0})),mn=an(M({},hn,{relatedTarget:0})),bn=an(M({},cn,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=M({},cn,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),vn=an(yn),wn=an(M({},cn,{data:0})),xn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):!!(t=Sn[t])&&!!e[t]}function Nn(){return In}var Cn=M({},hn,{key:function(t){if(t.key){var e=xn[t.key]||t.key;if("Unidentified"!==e)return e}return"keypress"===t.type?13===(t=en(t))?"Enter":String.fromCharCode(t):"keydown"===t.type||"keyup"===t.type?kn[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(t){return"keypress"===t.type?en(t):0},keyCode:function(t){return"keydown"===t.type||"keyup"===t.type?t.keyCode:0},which:function(t){return"keypress"===t.type?en(t):"keydown"===t.type||"keyup"===t.type?t.keyCode:0}}),En=an(Cn),Tn=an(M({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),An=an(M({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),Rn=an(M({},cn,{propertyName:0,elapsedTime:0,pseudoElement:0})),Fn=M({},pn,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),_n=an(Fn),Dn=[9,13,27,32],On=u&&"CompositionEvent"in window,zn=null;u&&"documentMode"in document&&(zn=document.documentMode);var Ln=u&&"TextEvent"in window&&!zn,Mn=u&&(!On||zn&&8<zn&&11>=zn),Pn=String.fromCharCode(32),Bn=!1;function Wn(t,e){switch(t){case"keyup":return-1!==Dn.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(t){return"object"===typeof(t=t.detail)&&"data"in t?t.data:null}var Vn=!1;var jn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Gn(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return"input"===e?!!jn[t.type]:"textarea"===e}function Hn(t,e,n,r){Ct(r),0<(e=Kr(e,"onChange")).length&&(n=new un("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var Kn=null,qn=null;function Xn(t){Pr(t,0)}function Jn(t){if(q(wa(t)))return t}function Yn(t,e){if("change"===t)return e}var Zn=!1;if(u){var Qn;if(u){var $n="oninput"in document;if(!$n){var tr=document.createElement("div");tr.setAttribute("oninput","return;"),$n="function"===typeof tr.oninput}Qn=$n}else Qn=!1;Zn=Qn&&(!document.documentMode||9<document.documentMode)}function er(){Kn&&(Kn.detachEvent("onpropertychange",nr),qn=Kn=null)}function nr(t){if("value"===t.propertyName&&Jn(qn)){var e=[];Hn(e,qn,t,xt(t)),Ft(Xn,e)}}function rr(t,e,n){"focusin"===t?(er(),qn=n,(Kn=e).attachEvent("onpropertychange",nr)):"focusout"===t&&er()}function ar(t){if("selectionchange"===t||"keyup"===t||"keydown"===t)return Jn(qn)}function sr(t,e){if("click"===t)return Jn(e)}function or(t,e){if("input"===t||"change"===t)return Jn(e)}var ir="function"===typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t===1/e)||t!==t&&e!==e};function lr(t,e){if(ir(t,e))return!0;if("object"!==typeof t||null===t||"object"!==typeof e||null===e)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!h.call(e,a)||!ir(t[a],e[a]))return!1}return!0}function cr(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function ur(t,e){var n,r=cr(t);for(t=0;r;){if(3===r.nodeType){if(n=t+r.textContent.length,t<=e&&n>=e)return{node:r,offset:e-t};t=n}t:{for(;r;){if(r.nextSibling){r=r.nextSibling;break t}r=r.parentNode}r=void 0}r=cr(r)}}function hr(t,e){return!(!t||!e)&&(t===e||(!t||3!==t.nodeType)&&(e&&3===e.nodeType?hr(t,e.parentNode):"contains"in t?t.contains(e):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(e))))}function dr(){for(var t=window,e=X();e instanceof t.HTMLIFrameElement;){try{var n="string"===typeof e.contentWindow.location.href}catch(r){n=!1}if(!n)break;e=X((t=e.contentWindow).document)}return e}function pr(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&("input"===e&&("text"===t.type||"search"===t.type||"tel"===t.type||"url"===t.type||"password"===t.type)||"textarea"===e||"true"===t.contentEditable)}function fr(t){var e=dr(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&hr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(e=r.start,void 0===(t=r.end)&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if((t=(e=n.ownerDocument||document)&&e.defaultView||window).getSelection){t=t.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!t.extend&&s>r&&(a=r,r=s,s=a),a=ur(n,s);var o=ur(n,r);a&&o&&(1!==t.rangeCount||t.anchorNode!==a.node||t.anchorOffset!==a.offset||t.focusNode!==o.node||t.focusOffset!==o.offset)&&((e=e.createRange()).setStart(a.node,a.offset),t.removeAllRanges(),s>r?(t.addRange(e),t.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),t.addRange(e)))}for(e=[],t=n;t=t.parentNode;)1===t.nodeType&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<e.length;n++)(t=e[n]).element.scrollLeft=t.left,t.element.scrollTop=t.top}}var gr=u&&"documentMode"in document&&11>=document.documentMode,mr=null,br=null,yr=null,vr=!1;function wr(t,e,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==mr||mr!==X(r)||("selectionStart"in(r=mr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},yr&&lr(yr,r)||(yr=r,0<(r=Kr(br,"onSelect")).length&&(e=new un("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=mr)))}function xr(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var kr={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},Sr={},Ir={};function Nr(t){if(Sr[t])return Sr[t];if(!kr[t])return t;var e,n=kr[t];for(e in n)if(n.hasOwnProperty(e)&&e in Ir)return Sr[t]=n[e];return t}u&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Cr=Nr("animationend"),Er=Nr("animationiteration"),Tr=Nr("animationstart"),Ar=Nr("transitionend"),Rr=new Map,Fr="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function _r(t,e){Rr.set(t,e),l(e,[t])}for(var Dr=0;Dr<Fr.length;Dr++){var Or=Fr[Dr];_r(Or.toLowerCase(),"on"+(Or[0].toUpperCase()+Or.slice(1)))}_r(Cr,"onAnimationEnd"),_r(Er,"onAnimationIteration"),_r(Tr,"onAnimationStart"),_r("dblclick","onDoubleClick"),_r("focusin","onFocus"),_r("focusout","onBlur"),_r(Ar,"onTransitionEnd"),c("onMouseEnter",["mouseout","mouseover"]),c("onMouseLeave",["mouseout","mouseover"]),c("onPointerEnter",["pointerout","pointerover"]),c("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var zr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Lr=new Set("cancel close invalid load scroll toggle".split(" ").concat(zr));function Mr(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,function(t,e,n,r,a,o,i,l,c){if(Ut.apply(this,arguments),Lt){if(!Lt)throw Error(s(198));var u=Mt;Lt=!1,Mt=null,Pt||(Pt=!0,Bt=u)}}(r,e,void 0,t),t.currentTarget=null}function Pr(t,e){e=0!==(4&e);for(var n=0;n<t.length;n++){var r=t[n],a=r.event;r=r.listeners;t:{var s=void 0;if(e)for(var o=r.length-1;0<=o;o--){var i=r[o],l=i.instance,c=i.currentTarget;if(i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}else for(o=0;o<r.length;o++){if(l=(i=r[o]).instance,c=i.currentTarget,i=i.listener,l!==s&&a.isPropagationStopped())break t;Mr(a,i,c),s=l}}}if(Pt)throw t=Bt,Pt=!1,Bt=null,t}function Br(t,e){var n=e[ga];void 0===n&&(n=e[ga]=new Set);var r=t+"__bubble";n.has(r)||(jr(e,t,2,!1),n.add(r))}function Wr(t,e,n){var r=0;e&&(r|=4),jr(n,t,r,e)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function Vr(t){if(!t[Ur]){t[Ur]=!0,o.forEach((function(e){"selectionchange"!==e&&(Lr.has(e)||Wr(e,!1,t),Wr(e,!0,t))}));var e=9===t.nodeType?t:t.ownerDocument;null===e||e[Ur]||(e[Ur]=!0,Wr("selectionchange",!1,e))}}function jr(t,e,n,r){switch(Ye(e)){case 1:var a=He;break;case 4:a=Ke;break;default:a=qe}n=a.bind(null,e,n,t),a=void 0,!Dt||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(a=!0),r?void 0!==a?t.addEventListener(e,n,{capture:!0,passive:a}):t.addEventListener(e,n,!0):void 0!==a?t.addEventListener(e,n,{passive:a}):t.addEventListener(e,n,!1)}function Gr(t,e,n,r,a){var s=r;if(0===(1&e)&&0===(2&e)&&null!==r)t:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var i=r.stateNode.containerInfo;if(i===a||8===i.nodeType&&i.parentNode===a)break;if(4===o)for(o=r.return;null!==o;){var l=o.tag;if((3===l||4===l)&&((l=o.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;o=o.return}for(;null!==i;){if(null===(o=ya(i)))return;if(5===(l=o.tag)||6===l){r=s=o;continue t}i=i.parentNode}}r=r.return}Ft((function(){var r=s,a=xt(n),o=[];t:{var i=Rr.get(t);if(void 0!==i){var l=un,c=t;switch(t){case"keypress":if(0===en(n))break t;case"keydown":case"keyup":l=En;break;case"focusin":c="focus",l=mn;break;case"focusout":c="blur",l=mn;break;case"beforeblur":case"afterblur":l=mn;break;case"click":if(2===n.button)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=gn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=An;break;case Cr:case Er:case Tr:l=bn;break;case Ar:l=Rn;break;case"scroll":l=dn;break;case"wheel":l=_n;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Tn}var u=0!==(4&e),h=!u&&"scroll"===t,d=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=r;null!==f;){var g=(p=f).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==d&&(null!=(g=_t(f,d))&&u.push(Hr(f,g,p)))),h)break;f=f.return}0<u.length&&(i=new l(i,c,null,n,a),o.push({event:i,listeners:u}))}}if(0===(7&e)){if(l="mouseout"===t||"pointerout"===t,(!(i="mouseover"===t||"pointerover"===t)||n===wt||!(c=n.relatedTarget||n.fromElement)||!ya(c)&&!c[fa])&&(l||i)&&(i=a.window===a?a:(i=a.ownerDocument)?i.defaultView||i.parentWindow:window,l?(l=r,null!==(c=(c=n.relatedTarget||n.toElement)?ya(c):null)&&(c!==(h=Vt(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=r),l!==c)){if(u=fn,g="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==t&&"pointerover"!==t||(u=Tn,g="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==l?i:wa(l),p=null==c?i:wa(c),(i=new u(g,f+"leave",l,n,a)).target=h,i.relatedTarget=p,g=null,ya(a)===r&&((u=new u(d,f+"enter",c,n,a)).target=p,u.relatedTarget=h,g=u),h=g,l&&c)t:{for(d=c,f=0,p=u=l;p;p=qr(p))f++;for(p=0,g=d;g;g=qr(g))p++;for(;0<f-p;)u=qr(u),f--;for(;0<p-f;)d=qr(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break t;u=qr(u),d=qr(d)}u=null}else u=null;null!==l&&Xr(o,i,l,u,!1),null!==c&&null!==h&&Xr(o,h,c,u,!0)}if("select"===(l=(i=r?wa(r):window).nodeName&&i.nodeName.toLowerCase())||"input"===l&&"file"===i.type)var m=Yn;else if(Gn(i))if(Zn)m=or;else{m=ar;var b=rr}else(l=i.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(m=sr);switch(m&&(m=m(t,r))?Hn(o,m,n,a):(b&&b(t,i,r),"focusout"===t&&(b=i._wrapperState)&&b.controlled&&"number"===i.type&&tt(i,"number",i.value)),b=r?wa(r):window,t){case"focusin":(Gn(b)||"true"===b.contentEditable)&&(mr=b,br=r,yr=null);break;case"focusout":yr=br=mr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,wr(o,n,a);break;case"selectionchange":if(gr)break;case"keydown":case"keyup":wr(o,n,a)}var y;if(On)t:{switch(t){case"compositionstart":var v="onCompositionStart";break t;case"compositionend":v="onCompositionEnd";break t;case"compositionupdate":v="onCompositionUpdate";break t}v=void 0}else Vn?Wn(t,n)&&(v="onCompositionEnd"):"keydown"===t&&229===n.keyCode&&(v="onCompositionStart");v&&(Mn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(y=tn()):(Qe="value"in(Ze=a)?Ze.value:Ze.textContent,Vn=!0)),0<(b=Kr(r,v)).length&&(v=new wn(v,t,null,n,a),o.push({event:v,listeners:b}),y?v.data=y:null!==(y=Un(n))&&(v.data=y))),(y=Ln?function(t,e){switch(t){case"compositionend":return Un(e);case"keypress":return 32!==e.which?null:(Bn=!0,Pn);case"textInput":return(t=e.data)===Pn&&Bn?null:t;default:return null}}(t,n):function(t,e){if(Vn)return"compositionend"===t||!On&&Wn(t,e)?(t=tn(),$e=Qe=Ze=null,Vn=!1,t):null;switch(t){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Mn&&"ko"!==e.locale?null:e.data}}(t,n))&&(0<(r=Kr(r,"onBeforeInput")).length&&(a=new wn("onBeforeInput","beforeinput",null,n,a),o.push({event:a,listeners:r}),a.data=y))}Pr(o,e)}))}function Hr(t,e,n){return{instance:t,listener:e,currentTarget:n}}function Kr(t,e){for(var n=e+"Capture",r=[];null!==t;){var a=t,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=_t(t,n))&&r.unshift(Hr(t,s,a)),null!=(s=_t(t,e))&&r.push(Hr(t,s,a))),t=t.return}return r}function qr(t){if(null===t)return null;do{t=t.return}while(t&&5!==t.tag);return t||null}function Xr(t,e,n,r,a){for(var s=e._reactName,o=[];null!==n&&n!==r;){var i=n,l=i.alternate,c=i.stateNode;if(null!==l&&l===r)break;5===i.tag&&null!==c&&(i=c,a?null!=(l=_t(n,s))&&o.unshift(Hr(n,l,i)):a||null!=(l=_t(n,s))&&o.push(Hr(n,l,i))),n=n.return}0!==o.length&&t.push({event:e,listeners:o})}var Jr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Zr(t){return("string"===typeof t?t:""+t).replace(Jr,"\n").replace(Yr,"")}function Qr(t,e,n){if(e=Zr(e),Zr(t)!==e&&n)throw Error(s(425))}function $r(){}var ta=null,ea=null;function na(t,e){return"textarea"===t||"noscript"===t||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,oa="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(t){return sa.resolve(null).then(t).catch(ia)}:ra;function ia(t){setTimeout((function(){throw t}))}function la(t,e){var n=e,r=0;do{var a=n.nextSibling;if(t.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return t.removeChild(a),void Ve(e);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Ve(e)}function ca(t){for(;null!=t;t=t.nextSibling){var e=t.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=t.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return t}function ua(t){t=t.previousSibling;for(var e=0;t;){if(8===t.nodeType){var n=t.data;if("$"===n||"$!"===n||"$?"===n){if(0===e)return t;e--}else"/$"===n&&e++}t=t.previousSibling}return null}var ha=Math.random().toString(36).slice(2),da="__reactFiber$"+ha,pa="__reactProps$"+ha,fa="__reactContainer$"+ha,ga="__reactEvents$"+ha,ma="__reactListeners$"+ha,ba="__reactHandles$"+ha;function ya(t){var e=t[da];if(e)return e;for(var n=t.parentNode;n;){if(e=n[fa]||n[da]){if(n=e.alternate,null!==e.child||null!==n&&null!==n.child)for(t=ua(t);null!==t;){if(n=t[da])return n;t=ua(t)}return e}n=(t=n).parentNode}return null}function va(t){return!(t=t[da]||t[fa])||5!==t.tag&&6!==t.tag&&13!==t.tag&&3!==t.tag?null:t}function wa(t){if(5===t.tag||6===t.tag)return t.stateNode;throw Error(s(33))}function xa(t){return t[pa]||null}var ka=[],Sa=-1;function Ia(t){return{current:t}}function Na(t){0>Sa||(t.current=ka[Sa],ka[Sa]=null,Sa--)}function Ca(t,e){Sa++,ka[Sa]=t.current,t.current=e}var Ea={},Ta=Ia(Ea),Aa=Ia(!1),Ra=Ea;function Fa(t,e){var n=t.type.contextTypes;if(!n)return Ea;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=e[a];return r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=s),s}function _a(t){return null!==(t=t.childContextTypes)&&void 0!==t}function Da(){Na(Aa),Na(Ta)}function Oa(t,e,n){if(Ta.current!==Ea)throw Error(s(168));Ca(Ta,e),Ca(Aa,n)}function za(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in e))throw Error(s(108,j(t)||"Unknown",a));return M({},n,r)}function La(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Ea,Ra=Ta.current,Ca(Ta,t),Ca(Aa,Aa.current),!0}function Ma(t,e,n){var r=t.stateNode;if(!r)throw Error(s(169));n?(t=za(t,e,Ra),r.__reactInternalMemoizedMergedChildContext=t,Na(Aa),Na(Ta),Ca(Ta,t)):Na(Aa),Ca(Aa,n)}var Pa=null,Ba=!1,Wa=!1;function Ua(t){null===Pa?Pa=[t]:Pa.push(t)}function Va(){if(!Wa&&null!==Pa){Wa=!0;var t=0,e=ve;try{var n=Pa;for(ve=1;t<n.length;t++){var r=n[t];do{r=r(!0)}while(null!==r)}Pa=null,Ba=!1}catch(a){throw null!==Pa&&(Pa=Pa.slice(t+1)),qt($t,Va),a}finally{ve=e,Wa=!1}}return null}var ja=[],Ga=0,Ha=null,Ka=0,qa=[],Xa=0,Ja=null,Ya=1,Za="";function Qa(t,e){ja[Ga++]=Ka,ja[Ga++]=Ha,Ha=t,Ka=e}function $a(t,e,n){qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ja=t;var r=Ya;t=Za;var a=32-oe(r)-1;r&=~(1<<a),n+=1;var s=32-oe(e)+a;if(30<s){var o=a-a%5;s=(r&(1<<o)-1).toString(32),r>>=o,a-=o,Ya=1<<32-oe(e)+a|n<<a|r,Za=s+t}else Ya=1<<s|n<<a|r,Za=t}function ts(t){null!==t.return&&(Qa(t,1),$a(t,1,0))}function es(t){for(;t===Ha;)Ha=ja[--Ga],ja[Ga]=null,Ka=ja[--Ga],ja[Ga]=null;for(;t===Ja;)Ja=qa[--Xa],qa[Xa]=null,Za=qa[--Xa],qa[Xa]=null,Ya=qa[--Xa],qa[Xa]=null}var ns=null,rs=null,as=!1,ss=null;function os(t,e){var n=_c(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,null===(e=t.deletions)?(t.deletions=[n],t.flags|=16):e.push(n)}function is(t,e){switch(t.tag){case 5:var n=t.type;return null!==(e=1!==e.nodeType||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(t.stateNode=e,ns=t,rs=ca(e.firstChild),!0);case 6:return null!==(e=""===t.pendingProps||3!==e.nodeType?null:e)&&(t.stateNode=e,ns=t,rs=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(n=null!==Ja?{id:Ya,overflow:Za}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},(n=_c(18,null,null,0)).stateNode=e,n.return=t,t.child=n,ns=t,rs=null,!0);default:return!1}}function ls(t){return 0!==(1&t.mode)&&0===(128&t.flags)}function cs(t){if(as){var e=rs;if(e){var n=e;if(!is(t,e)){if(ls(t))throw Error(s(418));e=ca(n.nextSibling);var r=ns;e&&is(t,e)?os(r,n):(t.flags=-4097&t.flags|2,as=!1,ns=t)}}else{if(ls(t))throw Error(s(418));t.flags=-4097&t.flags|2,as=!1,ns=t}}}function us(t){for(t=t.return;null!==t&&5!==t.tag&&3!==t.tag&&13!==t.tag;)t=t.return;ns=t}function hs(t){if(t!==ns)return!1;if(!as)return us(t),as=!0,!1;var e;if((e=3!==t.tag)&&!(e=5!==t.tag)&&(e="head"!==(e=t.type)&&"body"!==e&&!na(t.type,t.memoizedProps)),e&&(e=rs)){if(ls(t))throw ds(),Error(s(418));for(;e;)os(t,e),e=ca(e.nextSibling)}if(us(t),13===t.tag){if(!(t=null!==(t=t.memoizedState)?t.dehydrated:null))throw Error(s(317));t:{for(t=t.nextSibling,e=0;t;){if(8===t.nodeType){var n=t.data;if("/$"===n){if(0===e){rs=ca(t.nextSibling);break t}e--}else"$"!==n&&"$!"!==n&&"$?"!==n||e++}t=t.nextSibling}rs=null}}else rs=ns?ca(t.stateNode.nextSibling):null;return!0}function ds(){for(var t=rs;t;)t=ca(t.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(t){null===ss?ss=[t]:ss.push(t)}var gs=w.ReactCurrentBatchConfig;function ms(t,e){if(t&&t.defaultProps){for(var n in e=M({},e),t=t.defaultProps)void 0===e[n]&&(e[n]=t[n]);return e}return e}var bs=Ia(null),ys=null,vs=null,ws=null;function xs(){ws=vs=ys=null}function ks(t){var e=bs.current;Na(bs),t._currentValue=e}function Ss(t,e,n){for(;null!==t;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,null!==r&&(r.childLanes|=e)):null!==r&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function Is(t,e){ys=t,ws=vs=null,null!==(t=t.dependencies)&&null!==t.firstContext&&(0!==(t.lanes&e)&&(wi=!0),t.firstContext=null)}function Ns(t){var e=t._currentValue;if(ws!==t)if(t={context:t,memoizedValue:e,next:null},null===vs){if(null===ys)throw Error(s(308));vs=t,ys.dependencies={lanes:0,firstContext:t}}else vs=vs.next=t;return e}var Cs=null;function Es(t){null===Cs?Cs=[t]:Cs.push(t)}function Ts(t,e,n,r){var a=e.interleaved;return null===a?(n.next=n,Es(e)):(n.next=a.next,a.next=n),e.interleaved=n,As(t,r)}function As(t,e){t.lanes|=e;var n=t.alternate;for(null!==n&&(n.lanes|=e),n=t,t=t.return;null!==t;)t.childLanes|=e,null!==(n=t.alternate)&&(n.childLanes|=e),n=t,t=t.return;return 3===n.tag?n.stateNode:null}var Rs=!1;function Fs(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function _s(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function Ds(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Os(t,e,n){var r=t.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Al)){var a=r.pending;return null===a?e.next=e:(e.next=a.next,a.next=e),r.pending=e,As(t,n)}return null===(a=r.interleaved)?(e.next=e,Es(r)):(e.next=a.next,a.next=e),r.interleaved=e,As(t,n)}function zs(t,e,n){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&n))){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}function Ls(t,e){var n=t.updateQueue,r=t.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=o:s=s.next=o,n=n.next}while(null!==n);null===s?a=s=e:s=s.next=e}else a=s=e;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(t.updateQueue=n)}null===(t=n.lastBaseUpdate)?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Ms(t,e,n,r){var a=t.updateQueue;Rs=!1;var s=a.firstBaseUpdate,o=a.lastBaseUpdate,i=a.shared.pending;if(null!==i){a.shared.pending=null;var l=i,c=l.next;l.next=null,null===o?s=c:o.next=c,o=l;var u=t.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==o&&(null===i?u.firstBaseUpdate=c:i.next=c,u.lastBaseUpdate=l))}if(null!==s){var h=a.baseState;for(o=0,u=c=l=null,i=s;;){var d=i.lane,p=i.eventTime;if((r&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});t:{var f=t,g=i;switch(d=e,p=n,g.tag){case 1:if("function"===typeof(f=g.payload)){h=f.call(p,h,d);break t}h=f;break t;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=g.payload)?f.call(p,h,d):f)||void 0===d)break t;h=M({},h,d);break t;case 2:Rs=!0}}null!==i.callback&&0!==i.lane&&(t.flags|=64,null===(d=a.effects)?a.effects=[i]:d.push(i))}else p={eventTime:p,lane:d,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(c=u=p,l=h):u=u.next=p,o|=d;if(null===(i=i.next)){if(null===(i=a.shared.pending))break;i=(d=i).next,d.next=null,a.lastBaseUpdate=d,a.shared.pending=null}}if(null===u&&(l=h),a.baseState=l,a.firstBaseUpdate=c,a.lastBaseUpdate=u,null!==(e=a.shared.interleaved)){a=e;do{o|=a.lane,a=a.next}while(a!==e)}else null===s&&(a.shared.lanes=0);Ml|=o,t.lanes=o,t.memoizedState=h}}function Ps(t,e,n){if(t=e.effects,e.effects=null,null!==t)for(e=0;e<t.length;e++){var r=t[e],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var Bs=(new r.Component).refs;function Ws(t,e,n,r){n=null===(n=n(r,e=t.memoizedState))||void 0===n?e:M({},e,n),t.memoizedState=n,0===t.lanes&&(t.updateQueue.baseState=n)}var Us={isMounted:function(t){return!!(t=t._reactInternals)&&Vt(t)===t},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=ec(),a=nc(t),s=Ds(r,a);s.tag=1,s.payload=e,void 0!==n&&null!==n&&(s.callback=n),null!==(e=Os(t,s,a))&&(rc(e,t,a,r),zs(e,t,a))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=ec(),r=nc(t),a=Ds(n,r);a.tag=2,void 0!==e&&null!==e&&(a.callback=e),null!==(e=Os(t,a,r))&&(rc(e,t,r,n),zs(e,t,r))}};function Vs(t,e,n,r,a,s,o){return"function"===typeof(t=t.stateNode).shouldComponentUpdate?t.shouldComponentUpdate(r,s,o):!e.prototype||!e.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function js(t,e,n){var r=!1,a=Ea,s=e.contextType;return"object"===typeof s&&null!==s?s=Ns(s):(a=_a(e)?Ra:Ta.current,s=(r=null!==(r=e.contextTypes)&&void 0!==r)?Fa(t,a):Ea),e=new e(n,s),t.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=Us,t.stateNode=e,e._reactInternals=t,r&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,t.__reactInternalMemoizedMaskedChildContext=s),e}function Gs(t,e,n,r){t=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(n,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&Us.enqueueReplaceState(e,e.state,null)}function Hs(t,e,n,r){var a=t.stateNode;a.props=n,a.state=t.memoizedState,a.refs=Bs,Fs(t);var s=e.contextType;"object"===typeof s&&null!==s?a.context=Ns(s):(s=_a(e)?Ra:Ta.current,a.context=Fa(t,s)),a.state=t.memoizedState,"function"===typeof(s=e.getDerivedStateFromProps)&&(Ws(t,e,s,n),a.state=t.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(e=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),e!==a.state&&Us.enqueueReplaceState(a,a.state,null),Ms(t,n,a,r),a.state=t.memoizedState),"function"===typeof a.componentDidMount&&(t.flags|=4194308)}function Ks(t,e,n){if(null!==(t=n.ref)&&"function"!==typeof t&&"object"!==typeof t){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,t));var a=r,o=""+t;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===o?e.ref:(e=function(t){var e=a.refs;e===Bs&&(e=a.refs={}),null===t?delete e[o]:e[o]=t},e._stringRef=o,e)}if("string"!==typeof t)throw Error(s(284));if(!n._owner)throw Error(s(290,t))}return t}function qs(t,e){throw t=Object.prototype.toString.call(e),Error(s(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function Xs(t){return(0,t._init)(t._payload)}function Js(t){function e(e,n){if(t){var r=e.deletions;null===r?(e.deletions=[n],e.flags|=16):r.push(n)}}function n(n,r){if(!t)return null;for(;null!==r;)e(n,r),r=r.sibling;return null}function r(t,e){for(t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(t,e){return(t=Oc(t,e)).index=0,t.sibling=null,t}function o(e,n,r){return e.index=r,t?null!==(r=e.alternate)?(r=r.index)<n?(e.flags|=2,n):r:(e.flags|=2,n):(e.flags|=1048576,n)}function i(e){return t&&null===e.alternate&&(e.flags|=2),e}function l(t,e,n,r){return null===e||6!==e.tag?((e=Pc(n,t.mode,r)).return=t,e):((e=a(e,n)).return=t,e)}function c(t,e,n,r){var s=n.type;return s===S?h(t,e,n.props.children,r,n.key):null!==e&&(e.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===_&&Xs(s)===e.type)?((r=a(e,n.props)).ref=Ks(t,e,n),r.return=t,r):((r=zc(n.type,n.key,n.props,null,t.mode,r)).ref=Ks(t,e,n),r.return=t,r)}function u(t,e,n,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==n.containerInfo||e.stateNode.implementation!==n.implementation?((e=Bc(n,t.mode,r)).return=t,e):((e=a(e,n.children||[])).return=t,e)}function h(t,e,n,r,s){return null===e||7!==e.tag?((e=Lc(n,t.mode,r,s)).return=t,e):((e=a(e,n)).return=t,e)}function d(t,e,n){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=Pc(""+e,t.mode,n)).return=t,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case x:return(n=zc(e.type,e.key,e.props,null,t.mode,n)).ref=Ks(t,null,e),n.return=t,n;case k:return(e=Bc(e,t.mode,n)).return=t,e;case _:return d(t,(0,e._init)(e._payload),n)}if(et(e)||z(e))return(e=Lc(e,t.mode,n,null)).return=t,e;qs(t,e)}return null}function p(t,e,n,r){var a=null!==e?e.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(t,e,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===a?c(t,e,n,r):null;case k:return n.key===a?u(t,e,n,r):null;case _:return p(t,e,(a=n._init)(n._payload),r)}if(et(n)||z(n))return null!==a?null:h(t,e,n,r,null);qs(t,n)}return null}function f(t,e,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(e,t=t.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case x:return c(e,t=t.get(null===r.key?n:r.key)||null,r,a);case k:return u(e,t=t.get(null===r.key?n:r.key)||null,r,a);case _:return f(t,e,n,(0,r._init)(r._payload),a)}if(et(r)||z(r))return h(e,t=t.get(n)||null,r,a,null);qs(e,r)}return null}function g(a,s,i,l){for(var c=null,u=null,h=s,g=s=0,m=null;null!==h&&g<i.length;g++){h.index>g?(m=h,h=null):m=h.sibling;var b=p(a,h,i[g],l);if(null===b){null===h&&(h=m);break}t&&h&&null===b.alternate&&e(a,h),s=o(b,s,g),null===u?c=b:u.sibling=b,u=b,h=m}if(g===i.length)return n(a,h),as&&Qa(a,g),c;if(null===h){for(;g<i.length;g++)null!==(h=d(a,i[g],l))&&(s=o(h,s,g),null===u?c=h:u.sibling=h,u=h);return as&&Qa(a,g),c}for(h=r(a,h);g<i.length;g++)null!==(m=f(h,a,g,i[g],l))&&(t&&null!==m.alternate&&h.delete(null===m.key?g:m.key),s=o(m,s,g),null===u?c=m:u.sibling=m,u=m);return t&&h.forEach((function(t){return e(a,t)})),as&&Qa(a,g),c}function m(a,i,l,c){var u=z(l);if("function"!==typeof u)throw Error(s(150));if(null==(l=u.call(l)))throw Error(s(151));for(var h=u=null,g=i,m=i=0,b=null,y=l.next();null!==g&&!y.done;m++,y=l.next()){g.index>m?(b=g,g=null):b=g.sibling;var v=p(a,g,y.value,c);if(null===v){null===g&&(g=b);break}t&&g&&null===v.alternate&&e(a,g),i=o(v,i,m),null===h?u=v:h.sibling=v,h=v,g=b}if(y.done)return n(a,g),as&&Qa(a,m),u;if(null===g){for(;!y.done;m++,y=l.next())null!==(y=d(a,y.value,c))&&(i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return as&&Qa(a,m),u}for(g=r(a,g);!y.done;m++,y=l.next())null!==(y=f(g,a,m,y.value,c))&&(t&&null!==y.alternate&&g.delete(null===y.key?m:y.key),i=o(y,i,m),null===h?u=y:h.sibling=y,h=y);return t&&g.forEach((function(t){return e(a,t)})),as&&Qa(a,m),u}return function t(r,s,o,l){if("object"===typeof o&&null!==o&&o.type===S&&null===o.key&&(o=o.props.children),"object"===typeof o&&null!==o){switch(o.$$typeof){case x:t:{for(var c=o.key,u=s;null!==u;){if(u.key===c){if((c=o.type)===S){if(7===u.tag){n(r,u.sibling),(s=a(u,o.props.children)).return=r,r=s;break t}}else if(u.elementType===c||"object"===typeof c&&null!==c&&c.$$typeof===_&&Xs(c)===u.type){n(r,u.sibling),(s=a(u,o.props)).ref=Ks(r,u,o),s.return=r,r=s;break t}n(r,u);break}e(r,u),u=u.sibling}o.type===S?((s=Lc(o.props.children,r.mode,l,o.key)).return=r,r=s):((l=zc(o.type,o.key,o.props,null,r.mode,l)).ref=Ks(r,s,o),l.return=r,r=l)}return i(r);case k:t:{for(u=o.key;null!==s;){if(s.key===u){if(4===s.tag&&s.stateNode.containerInfo===o.containerInfo&&s.stateNode.implementation===o.implementation){n(r,s.sibling),(s=a(s,o.children||[])).return=r,r=s;break t}n(r,s);break}e(r,s),s=s.sibling}(s=Bc(o,r.mode,l)).return=r,r=s}return i(r);case _:return t(r,s,(u=o._init)(o._payload),l)}if(et(o))return g(r,s,o,l);if(z(o))return m(r,s,o,l);qs(r,o)}return"string"===typeof o&&""!==o||"number"===typeof o?(o=""+o,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,o)).return=r,r=s):(n(r,s),(s=Pc(o,r.mode,l)).return=r,r=s),i(r)):n(r,s)}}var Ys=Js(!0),Zs=Js(!1),Qs={},$s=Ia(Qs),to=Ia(Qs),eo=Ia(Qs);function no(t){if(t===Qs)throw Error(s(174));return t}function ro(t,e){switch(Ca(eo,e),Ca(to,t),Ca($s,Qs),t=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lt(null,"");break;default:e=lt(e=(t=8===t?e.parentNode:e).namespaceURI||null,t=t.tagName)}Na($s),Ca($s,e)}function ao(){Na($s),Na(to),Na(eo)}function so(t){no(eo.current);var e=no($s.current),n=lt(e,t.type);e!==n&&(Ca(to,t),Ca($s,n))}function oo(t){to.current===t&&(Na($s),Na(to))}var io=Ia(0);function lo(t){for(var e=t;null!==e;){if(13===e.tag){var n=e.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var co=[];function uo(){for(var t=0;t<co.length;t++)co[t]._workInProgressVersionPrimary=null;co.length=0}var ho=w.ReactCurrentDispatcher,po=w.ReactCurrentBatchConfig,fo=0,go=null,mo=null,bo=null,yo=!1,vo=!1,wo=0,xo=0;function ko(){throw Error(s(321))}function So(t,e){if(null===e)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!ir(t[n],e[n]))return!1;return!0}function Io(t,e,n,r,a,o){if(fo=o,go=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ho.current=null===t||null===t.memoizedState?ii:li,t=n(r,a),vo){o=0;do{if(vo=!1,wo=0,25<=o)throw Error(s(301));o+=1,bo=mo=null,e.updateQueue=null,ho.current=ci,t=n(r,a)}while(vo)}if(ho.current=oi,e=null!==mo&&null!==mo.next,fo=0,bo=mo=go=null,yo=!1,e)throw Error(s(300));return t}function No(){var t=0!==wo;return wo=0,t}function Co(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===bo?go.memoizedState=bo=t:bo=bo.next=t,bo}function Eo(){if(null===mo){var t=go.alternate;t=null!==t?t.memoizedState:null}else t=mo.next;var e=null===bo?go.memoizedState:bo.next;if(null!==e)bo=e,mo=t;else{if(null===t)throw Error(s(310));t={memoizedState:(mo=t).memoizedState,baseState:mo.baseState,baseQueue:mo.baseQueue,queue:mo.queue,next:null},null===bo?go.memoizedState=bo=t:bo=bo.next=t}return bo}function To(t,e){return"function"===typeof e?e(t):e}function Ao(t){var e=Eo(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=mo,a=r.baseQueue,o=n.pending;if(null!==o){if(null!==a){var i=a.next;a.next=o.next,o.next=i}r.baseQueue=a=o,n.pending=null}if(null!==a){o=a.next,r=r.baseState;var l=i=null,c=null,u=o;do{var h=u.lane;if((fo&h)===h)null!==c&&(c=c.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:t(r,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===c?(l=c=d,i=r):c=c.next=d,go.lanes|=h,Ml|=h}u=u.next}while(null!==u&&u!==o);null===c?i=r:c.next=l,ir(r,e.memoizedState)||(wi=!0),e.memoizedState=r,e.baseState=i,e.baseQueue=c,n.lastRenderedState=r}if(null!==(t=n.interleaved)){a=t;do{o=a.lane,go.lanes|=o,Ml|=o,a=a.next}while(a!==t)}else null===a&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function Ro(t){var e=Eo(),n=e.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=t;var r=n.dispatch,a=n.pending,o=e.memoizedState;if(null!==a){n.pending=null;var i=a=a.next;do{o=t(o,i.action),i=i.next}while(i!==a);ir(o,e.memoizedState)||(wi=!0),e.memoizedState=o,null===e.baseQueue&&(e.baseState=o),n.lastRenderedState=o}return[o,r]}function Fo(){}function _o(t,e){var n=go,r=Eo(),a=e(),o=!ir(r.memoizedState,a);if(o&&(r.memoizedState=a,wi=!0),r=r.queue,Go(zo.bind(null,n,r,t),[t]),r.getSnapshot!==e||o||null!==bo&&1&bo.memoizedState.tag){if(n.flags|=2048,Bo(9,Oo.bind(null,n,r,a,e),void 0,null),null===Rl)throw Error(s(349));0!==(30&fo)||Do(n,e,a)}return a}function Do(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.stores=[t]):null===(n=e.stores)?e.stores=[t]:n.push(t)}function Oo(t,e,n,r){e.value=n,e.getSnapshot=r,Lo(e)&&Mo(t)}function zo(t,e,n){return n((function(){Lo(e)&&Mo(t)}))}function Lo(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ir(t,n)}catch(r){return!0}}function Mo(t){var e=As(t,1);null!==e&&rc(e,t,1,-1)}function Po(t){var e=Co();return"function"===typeof t&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:To,lastRenderedState:t},e.queue=t,t=t.dispatch=ni.bind(null,go,t),[e.memoizedState,t]}function Bo(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},null===(e=go.updateQueue)?(e={lastEffect:null,stores:null},go.updateQueue=e,e.lastEffect=t.next=t):null===(n=e.lastEffect)?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t),t}function Wo(){return Eo().memoizedState}function Uo(t,e,n,r){var a=Co();go.flags|=t,a.memoizedState=Bo(1|e,n,void 0,void 0===r?null:r)}function Vo(t,e,n,r){var a=Eo();r=void 0===r?null:r;var s=void 0;if(null!==mo){var o=mo.memoizedState;if(s=o.destroy,null!==r&&So(r,o.deps))return void(a.memoizedState=Bo(e,n,s,r))}go.flags|=t,a.memoizedState=Bo(1|e,n,s,r)}function jo(t,e){return Uo(8390656,8,t,e)}function Go(t,e){return Vo(2048,8,t,e)}function Ho(t,e){return Vo(4,2,t,e)}function Ko(t,e){return Vo(4,4,t,e)}function qo(t,e){return"function"===typeof e?(t=t(),e(t),function(){e(null)}):null!==e&&void 0!==e?(t=t(),e.current=t,function(){e.current=null}):void 0}function Xo(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Vo(4,4,qo.bind(null,e,t),n)}function Jo(){}function Yo(t,e){var n=Eo();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function Zo(t,e){var n=Eo();e=void 0===e?null:e;var r=n.memoizedState;return null!==r&&null!==e&&So(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function Qo(t,e,n){return 0===(21&fo)?(t.baseState&&(t.baseState=!1,wi=!0),t.memoizedState=n):(ir(n,e)||(n=ge(),go.lanes|=n,Ml|=n,t.baseState=!0),e)}function $o(t,e){var n=ve;ve=0!==n&&4>n?n:4,t(!0);var r=po.transition;po.transition={};try{t(!1),e()}finally{ve=n,po.transition=r}}function ti(){return Eo().memoizedState}function ei(t,e,n){var r=nc(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},ri(t))ai(e,n);else if(null!==(n=Ts(t,e,n,r))){rc(n,t,r,ec()),si(n,e,r)}}function ni(t,e,n){var r=nc(t),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(ri(t))ai(e,a);else{var s=t.alternate;if(0===t.lanes&&(null===s||0===s.lanes)&&null!==(s=e.lastRenderedReducer))try{var o=e.lastRenderedState,i=s(o,n);if(a.hasEagerState=!0,a.eagerState=i,ir(i,o)){var l=e.interleaved;return null===l?(a.next=a,Es(e)):(a.next=l.next,l.next=a),void(e.interleaved=a)}}catch(c){}null!==(n=Ts(t,e,a,r))&&(rc(n,t,r,a=ec()),si(n,e,r))}}function ri(t){var e=t.alternate;return t===go||null!==e&&e===go}function ai(t,e){vo=yo=!0;var n=t.pending;null===n?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function si(t,e,n){if(0!==(4194240&n)){var r=e.lanes;n|=r&=t.pendingLanes,e.lanes=n,ye(t,n)}}var oi={readContext:Ns,useCallback:ko,useContext:ko,useEffect:ko,useImperativeHandle:ko,useInsertionEffect:ko,useLayoutEffect:ko,useMemo:ko,useReducer:ko,useRef:ko,useState:ko,useDebugValue:ko,useDeferredValue:ko,useTransition:ko,useMutableSource:ko,useSyncExternalStore:ko,useId:ko,unstable_isNewReconciler:!1},ii={readContext:Ns,useCallback:function(t,e){return Co().memoizedState=[t,void 0===e?null:e],t},useContext:Ns,useEffect:jo,useImperativeHandle:function(t,e,n){return n=null!==n&&void 0!==n?n.concat([t]):null,Uo(4194308,4,qo.bind(null,e,t),n)},useLayoutEffect:function(t,e){return Uo(4194308,4,t,e)},useInsertionEffect:function(t,e){return Uo(4,2,t,e)},useMemo:function(t,e){var n=Co();return e=void 0===e?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=Co();return e=void 0!==n?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=ei.bind(null,go,t),[r.memoizedState,t]},useRef:function(t){return t={current:t},Co().memoizedState=t},useState:Po,useDebugValue:Jo,useDeferredValue:function(t){return Co().memoizedState=t},useTransition:function(){var t=Po(!1),e=t[0];return t=$o.bind(null,t[1]),Co().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=go,a=Co();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=e(),null===Rl)throw Error(s(349));0!==(30&fo)||Do(r,e,n)}a.memoizedState=n;var o={value:n,getSnapshot:e};return a.queue=o,jo(zo.bind(null,r,o,t),[t]),r.flags|=2048,Bo(9,Oo.bind(null,r,o,n,e),void 0,null),n},useId:function(){var t=Co(),e=Rl.identifierPrefix;if(as){var n=Za;e=":"+e+"R"+(n=(Ya&~(1<<32-oe(Ya)-1)).toString(32)+n),0<(n=wo++)&&(e+="H"+n.toString(32)),e+=":"}else e=":"+e+"r"+(n=xo++).toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},li={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:Go,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ao,useRef:Wo,useState:function(){return Ao(To)},useDebugValue:Jo,useDeferredValue:function(t){return Qo(Eo(),mo.memoizedState,t)},useTransition:function(){return[Ao(To)[0],Eo().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1},ci={readContext:Ns,useCallback:Yo,useContext:Ns,useEffect:Go,useImperativeHandle:Xo,useInsertionEffect:Ho,useLayoutEffect:Ko,useMemo:Zo,useReducer:Ro,useRef:Wo,useState:function(){return Ro(To)},useDebugValue:Jo,useDeferredValue:function(t){var e=Eo();return null===mo?e.memoizedState=t:Qo(e,mo.memoizedState,t)},useTransition:function(){return[Ro(To)[0],Eo().memoizedState]},useMutableSource:Fo,useSyncExternalStore:_o,useId:ti,unstable_isNewReconciler:!1};function ui(t,e){try{var n="",r=e;do{n+=U(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:t,source:e,stack:a,digest:null}}function hi(t,e,n){return{value:t,source:null,stack:null!=n?n:null,digest:null!=e?e:null}}function di(t,e){try{console.error(e.value)}catch(n){setTimeout((function(){throw n}))}}var pi="function"===typeof WeakMap?WeakMap:Map;function fi(t,e,n){(n=Ds(-1,n)).tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){Hl||(Hl=!0,Kl=r),di(0,e)},n}function gi(t,e,n){(n=Ds(-1,n)).tag=3;var r=t.type.getDerivedStateFromError;if("function"===typeof r){var a=e.value;n.payload=function(){return r(a)},n.callback=function(){di(0,e)}}var s=t.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){di(0,e),"function"!==typeof r&&(null===ql?ql=new Set([this]):ql.add(this));var t=e.stack;this.componentDidCatch(e.value,{componentStack:null!==t?t:""})}),n}function mi(t,e,n){var r=t.pingCache;if(null===r){r=t.pingCache=new pi;var a=new Set;r.set(e,a)}else void 0===(a=r.get(e))&&(a=new Set,r.set(e,a));a.has(n)||(a.add(n),t=Cc.bind(null,t,e,n),e.then(t,t))}function bi(t){do{var e;if((e=13===t.tag)&&(e=null===(e=t.memoizedState)||null!==e.dehydrated),e)return t;t=t.return}while(null!==t);return null}function yi(t,e,n,r,a){return 0===(1&t.mode)?(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((e=Ds(-1,1)).tag=2,Os(n,e,1))),n.lanes|=1),t):(t.flags|=65536,t.lanes=a,t)}var vi=w.ReactCurrentOwner,wi=!1;function xi(t,e,n,r){e.child=null===t?Zs(e,null,n,r):Ys(e,t.child,n,r)}function ki(t,e,n,r,a){n=n.render;var s=e.ref;return Is(e,a),r=Io(t,e,n,r,s,a),n=No(),null===t||wi?(as&&n&&ts(e),e.flags|=1,xi(t,e,r,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Si(t,e,n,r,a){if(null===t){var s=n.type;return"function"!==typeof s||Dc(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((t=zc(n.type,null,r,e,e.mode,a)).ref=e.ref,t.return=e,e.child=t):(e.tag=15,e.type=s,Ii(t,e,s,r,a))}if(s=t.child,0===(t.lanes&a)){var o=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(o,r)&&t.ref===e.ref)return Hi(t,e,a)}return e.flags|=1,(t=Oc(s,r)).ref=e.ref,t.return=e,e.child=t}function Ii(t,e,n,r,a){if(null!==t){var s=t.memoizedProps;if(lr(s,r)&&t.ref===e.ref){if(wi=!1,e.pendingProps=r=s,0===(t.lanes&a))return e.lanes=t.lanes,Hi(t,e,a);0!==(131072&t.flags)&&(wi=!0)}}return Ei(t,e,n,r,a)}function Ni(t,e,n){var r=e.pendingProps,a=r.children,s=null!==t?t.memoizedState:null;if("hidden"===r.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ca(Ol,Dl),Dl|=n;else{if(0===(1073741824&n))return t=null!==s?s.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Ca(Ol,Dl),Dl|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Ca(Ol,Dl),Dl|=r}else null!==s?(r=s.baseLanes|n,e.memoizedState=null):r=n,Ca(Ol,Dl),Dl|=r;return xi(t,e,a,n),e.child}function Ci(t,e){var n=e.ref;(null===t&&null!==n||null!==t&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function Ei(t,e,n,r,a){var s=_a(n)?Ra:Ta.current;return s=Fa(e,s),Is(e,a),n=Io(t,e,n,r,s,a),r=No(),null===t||wi?(as&&r&&ts(e),e.flags|=1,xi(t,e,n,a),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~a,Hi(t,e,a))}function Ti(t,e,n,r,a){if(_a(n)){var s=!0;La(e)}else s=!1;if(Is(e,a),null===e.stateNode)Gi(t,e),js(e,n,r),Hs(e,n,r,a),r=!0;else if(null===t){var o=e.stateNode,i=e.memoizedProps;o.props=i;var l=o.context,c=n.contextType;"object"===typeof c&&null!==c?c=Ns(c):c=Fa(e,c=_a(n)?Ra:Ta.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof o.getSnapshotBeforeUpdate;h||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==r||l!==c)&&Gs(e,o,r,c),Rs=!1;var d=e.memoizedState;o.state=d,Ms(e,r,o,a),l=e.memoizedState,i!==r||d!==l||Aa.current||Rs?("function"===typeof u&&(Ws(e,n,u,r),l=e.memoizedState),(i=Rs||Vs(e,n,i,r,d,l,c))?(h||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(e.flags|=4194308)):("function"===typeof o.componentDidMount&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),o.props=r,o.state=l,o.context=c,r=i):("function"===typeof o.componentDidMount&&(e.flags|=4194308),r=!1)}else{o=e.stateNode,_s(t,e),i=e.memoizedProps,c=e.type===e.elementType?i:ms(e.type,i),o.props=c,h=e.pendingProps,d=o.context,"object"===typeof(l=n.contextType)&&null!==l?l=Ns(l):l=Fa(e,l=_a(n)?Ra:Ta.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==l)&&Gs(e,o,r,l),Rs=!1,d=e.memoizedState,o.state=d,Ms(e,r,o,a);var f=e.memoizedState;i!==h||d!==f||Aa.current||Rs?("function"===typeof p&&(Ws(e,n,p,r),f=e.memoizedState),(c=Rs||Vs(e,n,c,r,d,f,l)||!1)?(u||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(r,f,l),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof o.componentDidUpdate&&(e.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=f),o.props=r,o.state=f,o.context=l,r=c):("function"!==typeof o.componentDidUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),r=!1)}return Ai(t,e,n,r,s,a)}function Ai(t,e,n,r,a,s){Ci(t,e);var o=0!==(128&e.flags);if(!r&&!o)return a&&Ma(e,n,!1),Hi(t,e,s);r=e.stateNode,vi.current=e;var i=o&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==t&&o?(e.child=Ys(e,t.child,null,s),e.child=Ys(e,null,i,s)):xi(t,e,i,s),e.memoizedState=r.state,a&&Ma(e,n,!0),e.child}function Ri(t){var e=t.stateNode;e.pendingContext?Oa(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Oa(0,e.context,!1),ro(t,e.containerInfo)}function Fi(t,e,n,r,a){return ps(),fs(a),e.flags|=256,xi(t,e,n,r),e.child}var _i,Di,Oi,zi,Li={dehydrated:null,treeContext:null,retryLane:0};function Mi(t){return{baseLanes:t,cachePool:null,transitions:null}}function Pi(t,e,n){var r,a=e.pendingProps,o=io.current,i=!1,l=0!==(128&e.flags);if((r=l)||(r=(null===t||null!==t.memoizedState)&&0!==(2&o)),r?(i=!0,e.flags&=-129):null!==t&&null===t.memoizedState||(o|=1),Ca(io,1&o),null===t)return cs(e),null!==(t=e.memoizedState)&&null!==(t=t.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===t.data?e.lanes=8:e.lanes=1073741824,null):(l=a.children,t=a.fallback,i?(a=e.mode,i=e.child,l={mode:"hidden",children:l},0===(1&a)&&null!==i?(i.childLanes=0,i.pendingProps=l):i=Mc(l,a,0,null),t=Lc(t,a,n,null),i.return=e,t.return=e,i.sibling=t,e.child=i,e.child.memoizedState=Mi(n),e.memoizedState=Li,t):Bi(e,l));if(null!==(o=t.memoizedState)&&null!==(r=o.dehydrated))return function(t,e,n,r,a,o,i){if(n)return 256&e.flags?(e.flags&=-257,Wi(t,e,i,r=hi(Error(s(422))))):null!==e.memoizedState?(e.child=t.child,e.flags|=128,null):(o=r.fallback,a=e.mode,r=Mc({mode:"visible",children:r.children},a,0,null),(o=Lc(o,a,i,null)).flags|=2,r.return=e,o.return=e,r.sibling=o,e.child=r,0!==(1&e.mode)&&Ys(e,t.child,null,i),e.child.memoizedState=Mi(i),e.memoizedState=Li,o);if(0===(1&e.mode))return Wi(t,e,i,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,Wi(t,e,i,r=hi(o=Error(s(419)),r,void 0))}if(l=0!==(i&t.childLanes),wi||l){if(null!==(r=Rl)){switch(i&-i){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|i))?0:a)&&a!==o.retryLane&&(o.retryLane=a,As(t,a),rc(r,t,a,-1))}return mc(),Wi(t,e,i,r=hi(Error(s(421))))}return"$?"===a.data?(e.flags|=128,e.child=t.child,e=Tc.bind(null,t),a._reactRetry=e,null):(t=o.treeContext,rs=ca(a.nextSibling),ns=e,as=!0,ss=null,null!==t&&(qa[Xa++]=Ya,qa[Xa++]=Za,qa[Xa++]=Ja,Ya=t.id,Za=t.overflow,Ja=e),e=Bi(e,r.children),e.flags|=4096,e)}(t,e,l,a,r,o,n);if(i){i=a.fallback,l=e.mode,r=(o=t.child).sibling;var c={mode:"hidden",children:a.children};return 0===(1&l)&&e.child!==o?((a=e.child).childLanes=0,a.pendingProps=c,e.deletions=null):(a=Oc(o,c)).subtreeFlags=14680064&o.subtreeFlags,null!==r?i=Oc(r,i):(i=Lc(i,l,n,null)).flags|=2,i.return=e,a.return=e,a.sibling=i,e.child=a,a=i,i=e.child,l=null===(l=t.child.memoizedState)?Mi(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},i.memoizedState=l,i.childLanes=t.childLanes&~n,e.memoizedState=Li,a}return t=(i=t.child).sibling,a=Oc(i,{mode:"visible",children:a.children}),0===(1&e.mode)&&(a.lanes=n),a.return=e,a.sibling=null,null!==t&&(null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=a,e.memoizedState=null,a}function Bi(t,e){return(e=Mc({mode:"visible",children:e},t.mode,0,null)).return=t,t.child=e}function Wi(t,e,n,r){return null!==r&&fs(r),Ys(e,t.child,null,n),(t=Bi(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,t}function Ui(t,e,n){t.lanes|=e;var r=t.alternate;null!==r&&(r.lanes|=e),Ss(t.return,e,n)}function Vi(t,e,n,r,a){var s=t.memoizedState;null===s?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function ji(t,e,n){var r=e.pendingProps,a=r.revealOrder,s=r.tail;if(xi(t,e,r.children,n),0!==(2&(r=io.current)))r=1&r|2,e.flags|=128;else{if(null!==t&&0!==(128&t.flags))t:for(t=e.child;null!==t;){if(13===t.tag)null!==t.memoizedState&&Ui(t,n,e);else if(19===t.tag)Ui(t,n,e);else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break t;for(;null===t.sibling;){if(null===t.return||t.return===e)break t;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(Ca(io,r),0===(1&e.mode))e.memoizedState=null;else switch(a){case"forwards":for(n=e.child,a=null;null!==n;)null!==(t=n.alternate)&&null===lo(t)&&(a=n),n=n.sibling;null===(n=a)?(a=e.child,e.child=null):(a=n.sibling,n.sibling=null),Vi(e,!1,a,n,s);break;case"backwards":for(n=null,a=e.child,e.child=null;null!==a;){if(null!==(t=a.alternate)&&null===lo(t)){e.child=a;break}t=a.sibling,a.sibling=n,n=a,a=t}Vi(e,!0,n,null,s);break;case"together":Vi(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function Gi(t,e){0===(1&e.mode)&&null!==t&&(t.alternate=null,e.alternate=null,e.flags|=2)}function Hi(t,e,n){if(null!==t&&(e.dependencies=t.dependencies),Ml|=e.lanes,0===(n&e.childLanes))return null;if(null!==t&&e.child!==t.child)throw Error(s(153));if(null!==e.child){for(n=Oc(t=e.child,t.pendingProps),e.child=n,n.return=e;null!==t.sibling;)t=t.sibling,(n=n.sibling=Oc(t,t.pendingProps)).return=e;n.sibling=null}return e.child}function Ki(t,e){if(!as)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;null!==e;)null!==e.alternate&&(n=e),e=e.sibling;null===n?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?e||null===t.tail?t.tail=null:t.tail.sibling=null:r.sibling=null}}function qi(t){var e=null!==t.alternate&&t.alternate.child===t.child,n=0,r=0;if(e)for(var a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=t,a=a.sibling;else for(a=t.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=t,a=a.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function Xi(t,e,n){var r=e.pendingProps;switch(es(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qi(e),null;case 1:case 17:return _a(e.type)&&Da(),qi(e),null;case 3:return r=e.stateNode,ao(),Na(Aa),Na(Ta),uo(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==t&&null!==t.child||(hs(e)?e.flags|=4:null===t||t.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ss&&(ic(ss),ss=null))),Di(t,e),qi(e),null;case 5:oo(e);var a=no(eo.current);if(n=e.type,null!==t&&null!=e.stateNode)Oi(t,e,n,r,a),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(null===e.stateNode)throw Error(s(166));return qi(e),null}if(t=no($s.current),hs(e)){r=e.stateNode,n=e.type;var o=e.memoizedProps;switch(r[da]=e,r[pa]=o,t=0!==(1&e.mode),n){case"dialog":Br("cancel",r),Br("close",r);break;case"iframe":case"object":case"embed":Br("load",r);break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],r);break;case"source":Br("error",r);break;case"img":case"image":case"link":Br("error",r),Br("load",r);break;case"details":Br("toggle",r);break;case"input":Y(r,o),Br("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},Br("invalid",r);break;case"textarea":at(r,o),Br("invalid",r)}for(var l in yt(n,o),a=null,o)if(o.hasOwnProperty(l)){var c=o[l];"children"===l?"string"===typeof c?r.textContent!==c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",c]):"number"===typeof c&&r.textContent!==""+c&&(!0!==o.suppressHydrationWarning&&Qr(r.textContent,c,t),a=["children",""+c]):i.hasOwnProperty(l)&&null!=c&&"onScroll"===l&&Br("scroll",r)}switch(n){case"input":K(r),$(r,o,!0);break;case"textarea":K(r),ot(r);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(r.onclick=$r)}r=a,e.updateQueue=r,null!==r&&(e.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===t&&(t=it(n)),"http://www.w3.org/1999/xhtml"===t?"script"===n?((t=l.createElement("div")).innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):"string"===typeof r.is?t=l.createElement(n,{is:r.is}):(t=l.createElement(n),"select"===n&&(l=t,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):t=l.createElementNS(t,n),t[da]=e,t[pa]=r,_i(t,e,!1,!1),e.stateNode=t;t:{switch(l=vt(n,r),n){case"dialog":Br("cancel",t),Br("close",t),a=r;break;case"iframe":case"object":case"embed":Br("load",t),a=r;break;case"video":case"audio":for(a=0;a<zr.length;a++)Br(zr[a],t);a=r;break;case"source":Br("error",t),a=r;break;case"img":case"image":case"link":Br("error",t),Br("load",t),a=r;break;case"details":Br("toggle",t),a=r;break;case"input":Y(t,r),a=J(t,r),Br("invalid",t);break;case"option":default:a=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},a=M({},r,{value:void 0}),Br("invalid",t);break;case"textarea":at(t,r),a=rt(t,r),Br("invalid",t)}for(o in yt(n,a),c=a)if(c.hasOwnProperty(o)){var u=c[o];"style"===o?mt(t,u):"dangerouslySetInnerHTML"===o?null!=(u=u?u.__html:void 0)&&ht(t,u):"children"===o?"string"===typeof u?("textarea"!==n||""!==u)&&dt(t,u):"number"===typeof u&&dt(t,""+u):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(i.hasOwnProperty(o)?null!=u&&"onScroll"===o&&Br("scroll",t):null!=u&&v(t,o,u,l))}switch(n){case"input":K(t),$(t,r,!1);break;case"textarea":K(t),ot(t);break;case"option":null!=r.value&&t.setAttribute("value",""+G(r.value));break;case"select":t.multiple=!!r.multiple,null!=(o=r.value)?nt(t,!!r.multiple,o,!1):null!=r.defaultValue&&nt(t,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(t.onclick=$r)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break t;case"img":r=!0;break t;default:r=!1}}r&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return qi(e),null;case 6:if(t&&null!=e.stateNode)zi(t,e,t.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(s(166));if(n=no(eo.current),no($s.current),hs(e)){if(r=e.stateNode,n=e.memoizedProps,r[da]=e,(o=r.nodeValue!==n)&&null!==(t=ns))switch(t.tag){case 3:Qr(r.nodeValue,n,0!==(1&t.mode));break;case 5:!0!==t.memoizedProps.suppressHydrationWarning&&Qr(r.nodeValue,n,0!==(1&t.mode))}o&&(e.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[da]=e,e.stateNode=r}return qi(e),null;case 13:if(Na(io),r=e.memoizedState,null===t||null!==t.memoizedState&&null!==t.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&e.mode)&&0===(128&e.flags))ds(),ps(),e.flags|=98560,o=!1;else if(o=hs(e),null!==r&&null!==r.dehydrated){if(null===t){if(!o)throw Error(s(318));if(!(o=null!==(o=e.memoizedState)?o.dehydrated:null))throw Error(s(317));o[da]=e}else ps(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;qi(e),o=!1}else null!==ss&&(ic(ss),ss=null),o=!0;if(!o)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=n,e):((r=null!==r)!==(null!==t&&null!==t.memoizedState)&&r&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===t||0!==(1&io.current)?0===zl&&(zl=3):mc())),null!==e.updateQueue&&(e.flags|=4),qi(e),null);case 4:return ao(),Di(t,e),null===t&&Vr(e.stateNode.containerInfo),qi(e),null;case 10:return ks(e.type._context),qi(e),null;case 19:if(Na(io),null===(o=e.memoizedState))return qi(e),null;if(r=0!==(128&e.flags),null===(l=o.rendering))if(r)Ki(o,!1);else{if(0!==zl||null!==t&&0!==(128&t.flags))for(t=e.child;null!==t;){if(null!==(l=lo(t))){for(e.flags|=128,Ki(o,!1),null!==(r=l.updateQueue)&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;null!==n;)t=r,(o=n).flags&=14680066,null===(l=o.alternate)?(o.childLanes=0,o.lanes=t,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=l.childLanes,o.lanes=l.lanes,o.child=l.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=l.memoizedProps,o.memoizedState=l.memoizedState,o.updateQueue=l.updateQueue,o.type=l.type,t=l.dependencies,o.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Ca(io,1&io.current|2),e.child}t=t.sibling}null!==o.tail&&Zt()>jl&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304)}else{if(!r)if(null!==(t=lo(l))){if(e.flags|=128,r=!0,null!==(n=t.updateQueue)&&(e.updateQueue=n,e.flags|=4),Ki(o,!0),null===o.tail&&"hidden"===o.tailMode&&!l.alternate&&!as)return qi(e),null}else 2*Zt()-o.renderingStartTime>jl&&1073741824!==n&&(e.flags|=128,r=!0,Ki(o,!1),e.lanes=4194304);o.isBackwards?(l.sibling=e.child,e.child=l):(null!==(n=o.last)?n.sibling=l:e.child=l,o.last=l)}return null!==o.tail?(e=o.tail,o.rendering=e,o.tail=e.sibling,o.renderingStartTime=Zt(),e.sibling=null,n=io.current,Ca(io,r?1&n|2:1&n),e):(qi(e),null);case 22:case 23:return dc(),r=null!==e.memoizedState,null!==t&&null!==t.memoizedState!==r&&(e.flags|=8192),r&&0!==(1&e.mode)?0!==(1073741824&Dl)&&(qi(e),6&e.subtreeFlags&&(e.flags|=8192)):qi(e),null;case 24:case 25:return null}throw Error(s(156,e.tag))}function Ji(t,e){switch(es(e),e.tag){case 1:return _a(e.type)&&Da(),65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 3:return ao(),Na(Aa),Na(Ta),uo(),0!==(65536&(t=e.flags))&&0===(128&t)?(e.flags=-65537&t|128,e):null;case 5:return oo(e),null;case 13:if(Na(io),null!==(t=e.memoizedState)&&null!==t.dehydrated){if(null===e.alternate)throw Error(s(340));ps()}return 65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 19:return Na(io),null;case 4:return ao(),null;case 10:return ks(e.type._context),null;case 22:case 23:return dc(),null;default:return null}}_i=function(t,e){for(var n=e.child;null!==n;){if(5===n.tag||6===n.tag)t.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Di=function(){},Oi=function(t,e,n,r){var a=t.memoizedProps;if(a!==r){t=e.stateNode,no($s.current);var s,o=null;switch(n){case"input":a=J(t,a),r=J(t,r),o=[];break;case"select":a=M({},a,{value:void 0}),r=M({},r,{value:void 0}),o=[];break;case"textarea":a=rt(t,a),r=rt(t,r),o=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(t.onclick=$r)}for(u in yt(n,r),n=null,a)if(!r.hasOwnProperty(u)&&a.hasOwnProperty(u)&&null!=a[u])if("style"===u){var l=a[u];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in r){var c=r[u];if(l=null!=a?a[u]:void 0,r.hasOwnProperty(u)&&c!==l&&(null!=c||null!=l))if("style"===u)if(l){for(s in l)!l.hasOwnProperty(s)||c&&c.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in c)c.hasOwnProperty(s)&&l[s]!==c[s]&&(n||(n={}),n[s]=c[s])}else n||(o||(o=[]),o.push(u,n)),n=c;else"dangerouslySetInnerHTML"===u?(c=c?c.__html:void 0,l=l?l.__html:void 0,null!=c&&l!==c&&(o=o||[]).push(u,c)):"children"===u?"string"!==typeof c&&"number"!==typeof c||(o=o||[]).push(u,""+c):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=c&&"onScroll"===u&&Br("scroll",t),o||l===c||(o=[])):(o=o||[]).push(u,c))}n&&(o=o||[]).push("style",n);var u=o;(e.updateQueue=u)&&(e.flags|=4)}},zi=function(t,e,n,r){n!==r&&(e.flags|=4)};var Yi=!1,Zi=!1,Qi="function"===typeof WeakSet?WeakSet:Set,$i=null;function tl(t,e){var n=t.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Nc(t,e,r)}else n.current=null}function el(t,e,n){try{n()}catch(r){Nc(t,e,r)}}var nl=!1;function rl(t,e,n){var r=e.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&t)===t){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(e,n,s)}a=a.next}while(a!==r)}}function al(t,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function sl(t){var e=t.ref;if(null!==e){var n=t.stateNode;t.tag,t=n,"function"===typeof e?e(t):e.current=t}}function ol(t){var e=t.alternate;null!==e&&(t.alternate=null,ol(e)),t.child=null,t.deletions=null,t.sibling=null,5===t.tag&&(null!==(e=t.stateNode)&&(delete e[da],delete e[pa],delete e[ga],delete e[ma],delete e[ba])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function il(t){return 5===t.tag||3===t.tag||4===t.tag}function ll(t){t:for(;;){for(;null===t.sibling;){if(null===t.return||il(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue t;if(null===t.child||4===t.tag)continue t;t.child.return=t,t=t.child}if(!(2&t.flags))return t.stateNode}}function cl(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?8===n.nodeType?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(8===n.nodeType?(e=n.parentNode).insertBefore(t,n):(e=n).appendChild(t),null!==(n=n._reactRootContainer)&&void 0!==n||null!==e.onclick||(e.onclick=$r));else if(4!==r&&null!==(t=t.child))for(cl(t,e,n),t=t.sibling;null!==t;)cl(t,e,n),t=t.sibling}function ul(t,e,n){var r=t.tag;if(5===r||6===r)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(4!==r&&null!==(t=t.child))for(ul(t,e,n),t=t.sibling;null!==t;)ul(t,e,n),t=t.sibling}var hl=null,dl=!1;function pl(t,e,n){for(n=n.child;null!==n;)fl(t,e,n),n=n.sibling}function fl(t,e,n){if(se&&"function"===typeof se.onCommitFiberUnmount)try{se.onCommitFiberUnmount(ae,n)}catch(i){}switch(n.tag){case 5:Zi||tl(n,e);case 6:var r=hl,a=dl;hl=null,pl(t,e,n),dl=a,null!==(hl=r)&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?t.parentNode.removeChild(n):t.removeChild(n)):hl.removeChild(n.stateNode));break;case 18:null!==hl&&(dl?(t=hl,n=n.stateNode,8===t.nodeType?la(t.parentNode,n):1===t.nodeType&&la(t,n),Ve(t)):la(hl,n.stateNode));break;case 4:r=hl,a=dl,hl=n.stateNode.containerInfo,dl=!0,pl(t,e,n),hl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Zi&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,o=s.destroy;s=s.tag,void 0!==o&&(0!==(2&s)||0!==(4&s))&&el(n,e,o),a=a.next}while(a!==r)}pl(t,e,n);break;case 1:if(!Zi&&(tl(n,e),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(i){Nc(n,e,i)}pl(t,e,n);break;case 21:pl(t,e,n);break;case 22:1&n.mode?(Zi=(r=Zi)||null!==n.memoizedState,pl(t,e,n),Zi=r):pl(t,e,n);break;default:pl(t,e,n)}}function gl(t){var e=t.updateQueue;if(null!==e){t.updateQueue=null;var n=t.stateNode;null===n&&(n=t.stateNode=new Qi),e.forEach((function(e){var r=Ac.bind(null,t,e);n.has(e)||(n.add(e),e.then(r,r))}))}}function ml(t,e){var n=e.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var o=t,i=e,l=i;t:for(;null!==l;){switch(l.tag){case 5:hl=l.stateNode,dl=!1;break t;case 3:case 4:hl=l.stateNode.containerInfo,dl=!0;break t}l=l.return}if(null===hl)throw Error(s(160));fl(o,i,a),hl=null,dl=!1;var c=a.alternate;null!==c&&(c.return=null),a.return=null}catch(u){Nc(a,e,u)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)bl(e,t),e=e.sibling}function bl(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(ml(e,t),yl(t),4&r){try{rl(3,t,t.return),al(3,t)}catch(m){Nc(t,t.return,m)}try{rl(5,t,t.return)}catch(m){Nc(t,t.return,m)}}break;case 1:ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return);break;case 5:if(ml(e,t),yl(t),512&r&&null!==n&&tl(n,n.return),32&t.flags){var a=t.stateNode;try{dt(a,"")}catch(m){Nc(t,t.return,m)}}if(4&r&&null!=(a=t.stateNode)){var o=t.memoizedProps,i=null!==n?n.memoizedProps:o,l=t.type,c=t.updateQueue;if(t.updateQueue=null,null!==c)try{"input"===l&&"radio"===o.type&&null!=o.name&&Z(a,o),vt(l,i);var u=vt(l,o);for(i=0;i<c.length;i+=2){var h=c[i],d=c[i+1];"style"===h?mt(a,d):"dangerouslySetInnerHTML"===h?ht(a,d):"children"===h?dt(a,d):v(a,h,d,u)}switch(l){case"input":Q(a,o);break;case"textarea":st(a,o);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!o.multiple;var f=o.value;null!=f?nt(a,!!o.multiple,f,!1):p!==!!o.multiple&&(null!=o.defaultValue?nt(a,!!o.multiple,o.defaultValue,!0):nt(a,!!o.multiple,o.multiple?[]:"",!1))}a[pa]=o}catch(m){Nc(t,t.return,m)}}break;case 6:if(ml(e,t),yl(t),4&r){if(null===t.stateNode)throw Error(s(162));a=t.stateNode,o=t.memoizedProps;try{a.nodeValue=o}catch(m){Nc(t,t.return,m)}}break;case 3:if(ml(e,t),yl(t),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ve(e.containerInfo)}catch(m){Nc(t,t.return,m)}break;case 4:default:ml(e,t),yl(t);break;case 13:ml(e,t),yl(t),8192&(a=t.child).flags&&(o=null!==a.memoizedState,a.stateNode.isHidden=o,!o||null!==a.alternate&&null!==a.alternate.memoizedState||(Vl=Zt())),4&r&&gl(t);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&t.mode?(Zi=(u=Zi)||h,ml(e,t),Zi=u):ml(e,t),yl(t),8192&r){if(u=null!==t.memoizedState,(t.stateNode.isHidden=u)&&!h&&0!==(1&t.mode))for($i=t,h=t.child;null!==h;){for(d=$i=h;null!==$i;){switch(f=(p=$i).child,p.tag){case 0:case 11:case 14:case 15:rl(4,p,p.return);break;case 1:tl(p,p.return);var g=p.stateNode;if("function"===typeof g.componentWillUnmount){r=p,n=p.return;try{e=r,g.props=e.memoizedProps,g.state=e.memoizedState,g.componentWillUnmount()}catch(m){Nc(r,n,m)}}break;case 5:tl(p,p.return);break;case 22:if(null!==p.memoizedState){kl(d);continue}}null!==f?(f.return=p,$i=f):kl(d)}h=h.sibling}t:for(h=null,d=t;;){if(5===d.tag){if(null===h){h=d;try{a=d.stateNode,u?"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none":(l=d.stateNode,i=void 0!==(c=d.memoizedProps.style)&&null!==c&&c.hasOwnProperty("display")?c.display:null,l.style.display=gt("display",i))}catch(m){Nc(t,t.return,m)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(m){Nc(t,t.return,m)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===t)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===t)break t;for(;null===d.sibling;){if(null===d.return||d.return===t)break t;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:ml(e,t),yl(t),4&r&&gl(t);case 21:}}function yl(t){var e=t.flags;if(2&e){try{t:{for(var n=t.return;null!==n;){if(il(n)){var r=n;break t}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(dt(a,""),r.flags&=-33),ul(t,ll(t),a);break;case 3:case 4:var o=r.stateNode.containerInfo;cl(t,ll(t),o);break;default:throw Error(s(161))}}catch(i){Nc(t,t.return,i)}t.flags&=-3}4096&e&&(t.flags&=-4097)}function vl(t,e,n){$i=t,wl(t,e,n)}function wl(t,e,n){for(var r=0!==(1&t.mode);null!==$i;){var a=$i,s=a.child;if(22===a.tag&&r){var o=null!==a.memoizedState||Yi;if(!o){var i=a.alternate,l=null!==i&&null!==i.memoizedState||Zi;i=Yi;var c=Zi;if(Yi=o,(Zi=l)&&!c)for($i=a;null!==$i;)l=(o=$i).child,22===o.tag&&null!==o.memoizedState?Sl(a):null!==l?(l.return=o,$i=l):Sl(a);for(;null!==s;)$i=s,wl(s,e,n),s=s.sibling;$i=a,Yi=i,Zi=c}xl(t)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,$i=s):xl(t)}}function xl(t){for(;null!==$i;){var e=$i;if(0!==(8772&e.flags)){var n=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Zi||al(5,e);break;case 1:var r=e.stateNode;if(4&e.flags&&!Zi)if(null===n)r.componentDidMount();else{var a=e.elementType===e.type?n.memoizedProps:ms(e.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var o=e.updateQueue;null!==o&&Ps(e,o,r);break;case 3:var i=e.updateQueue;if(null!==i){if(n=null,null!==e.child)switch(e.child.tag){case 5:case 1:n=e.child.stateNode}Ps(e,i,n)}break;case 5:var l=e.stateNode;if(null===n&&4&e.flags){n=l;var c=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var u=e.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Ve(d)}}}break;default:throw Error(s(163))}Zi||512&e.flags&&sl(e)}catch(p){Nc(e,e.return,p)}}if(e===t){$i=null;break}if(null!==(n=e.sibling)){n.return=e.return,$i=n;break}$i=e.return}}function kl(t){for(;null!==$i;){var e=$i;if(e===t){$i=null;break}var n=e.sibling;if(null!==n){n.return=e.return,$i=n;break}$i=e.return}}function Sl(t){for(;null!==$i;){var e=$i;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{al(4,e)}catch(l){Nc(e,n,l)}break;case 1:var r=e.stateNode;if("function"===typeof r.componentDidMount){var a=e.return;try{r.componentDidMount()}catch(l){Nc(e,a,l)}}var s=e.return;try{sl(e)}catch(l){Nc(e,s,l)}break;case 5:var o=e.return;try{sl(e)}catch(l){Nc(e,o,l)}}}catch(l){Nc(e,e.return,l)}if(e===t){$i=null;break}var i=e.sibling;if(null!==i){i.return=e.return,$i=i;break}$i=e.return}}var Il,Nl=Math.ceil,Cl=w.ReactCurrentDispatcher,El=w.ReactCurrentOwner,Tl=w.ReactCurrentBatchConfig,Al=0,Rl=null,Fl=null,_l=0,Dl=0,Ol=Ia(0),zl=0,Ll=null,Ml=0,Pl=0,Bl=0,Wl=null,Ul=null,Vl=0,jl=1/0,Gl=null,Hl=!1,Kl=null,ql=null,Xl=!1,Jl=null,Yl=0,Zl=0,Ql=null,$l=-1,tc=0;function ec(){return 0!==(6&Al)?Zt():-1!==$l?$l:$l=Zt()}function nc(t){return 0===(1&t.mode)?1:0!==(2&Al)&&0!==_l?_l&-_l:null!==gs.transition?(0===tc&&(tc=ge()),tc):0!==(t=ve)?t:t=void 0===(t=window.event)?16:Ye(t.type)}function rc(t,e,n,r){if(50<Zl)throw Zl=0,Ql=null,Error(s(185));be(t,n,r),0!==(2&Al)&&t===Rl||(t===Rl&&(0===(2&Al)&&(Pl|=n),4===zl&&lc(t,_l)),ac(t,r),1===n&&0===Al&&0===(1&e.mode)&&(jl=Zt()+500,Ba&&Va()))}function ac(t,e){var n=t.callbackNode;!function(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,a=t.expirationTimes,s=t.pendingLanes;0<s;){var o=31-oe(s),i=1<<o,l=a[o];-1===l?0!==(i&n)&&0===(i&r)||(a[o]=pe(i,e)):l<=e&&(t.expiredLanes|=i),s&=~i}}(t,e);var r=de(t,t===Rl?_l:0);if(0===r)null!==n&&Xt(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(null!=n&&Xt(n),1===e)0===t.tag?function(t){Ba=!0,Ua(t)}(cc.bind(null,t)):Ua(cc.bind(null,t)),oa((function(){0===(6&Al)&&Va()})),n=null;else{switch(we(r)){case 1:n=$t;break;case 4:n=te;break;case 16:default:n=ee;break;case 536870912:n=re}n=Rc(n,sc.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function sc(t,e){if($l=-1,tc=0,0!==(6&Al))throw Error(s(327));var n=t.callbackNode;if(Sc()&&t.callbackNode!==n)return null;var r=de(t,t===Rl?_l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&t.expiredLanes)||e)e=bc(t,r);else{e=r;var a=Al;Al|=2;var o=gc();for(Rl===t&&_l===e||(Gl=null,jl=Zt()+500,pc(t,e));;)try{vc();break}catch(l){fc(t,l)}xs(),Cl.current=o,Al=a,null!==Fl?e=0:(Rl=null,_l=0,e=zl)}if(0!==e){if(2===e&&(0!==(a=fe(t))&&(r=a,e=oc(t,a))),1===e)throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;if(6===e)lc(t,r);else{if(a=t.current.alternate,0===(30&r)&&!function(t){for(var e=t;;){if(16384&e.flags){var n=e.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!ir(s(),a))return!1}catch(i){return!1}}}if(n=e.child,16384&e.subtreeFlags&&null!==n)n.return=e,e=n;else{if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(a)&&(2===(e=bc(t,r))&&(0!==(o=fe(t))&&(r=o,e=oc(t,o))),1===e))throw n=Ll,pc(t,0),lc(t,r),ac(t,Zt()),n;switch(t.finishedWork=a,t.finishedLanes=r,e){case 0:case 1:throw Error(s(345));case 2:case 5:kc(t,Ul,Gl);break;case 3:if(lc(t,r),(130023424&r)===r&&10<(e=Vl+500-Zt())){if(0!==de(t,0))break;if(((a=t.suspendedLanes)&r)!==r){ec(),t.pingedLanes|=t.suspendedLanes&a;break}t.timeoutHandle=ra(kc.bind(null,t,Ul,Gl),e);break}kc(t,Ul,Gl);break;case 4:if(lc(t,r),(4194240&r)===r)break;for(e=t.eventTimes,a=-1;0<r;){var i=31-oe(r);o=1<<i,(i=e[i])>a&&(a=i),r&=~o}if(r=a,10<(r=(120>(r=Zt()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Nl(r/1960))-r)){t.timeoutHandle=ra(kc.bind(null,t,Ul,Gl),r);break}kc(t,Ul,Gl);break;default:throw Error(s(329))}}}return ac(t,Zt()),t.callbackNode===n?sc.bind(null,t):null}function oc(t,e){var n=Wl;return t.current.memoizedState.isDehydrated&&(pc(t,e).flags|=256),2!==(t=bc(t,e))&&(e=Ul,Ul=n,null!==e&&ic(e)),t}function ic(t){null===Ul?Ul=t:Ul.push.apply(Ul,t)}function lc(t,e){for(e&=~Bl,e&=~Pl,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-oe(e),r=1<<n;t[n]=-1,e&=~r}}function cc(t){if(0!==(6&Al))throw Error(s(327));Sc();var e=de(t,0);if(0===(1&e))return ac(t,Zt()),null;var n=bc(t,e);if(0!==t.tag&&2===n){var r=fe(t);0!==r&&(e=r,n=oc(t,r))}if(1===n)throw n=Ll,pc(t,0),lc(t,e),ac(t,Zt()),n;if(6===n)throw Error(s(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,kc(t,Ul,Gl),ac(t,Zt()),null}function uc(t,e){var n=Al;Al|=1;try{return t(e)}finally{0===(Al=n)&&(jl=Zt()+500,Ba&&Va())}}function hc(t){null!==Jl&&0===Jl.tag&&0===(6&Al)&&Sc();var e=Al;Al|=1;var n=Tl.transition,r=ve;try{if(Tl.transition=null,ve=1,t)return t()}finally{ve=r,Tl.transition=n,0===(6&(Al=e))&&Va()}}function dc(){Dl=Ol.current,Na(Ol)}function pc(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(-1!==n&&(t.timeoutHandle=-1,aa(n)),null!==Fl)for(n=Fl.return;null!==n;){var r=n;switch(es(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:ao(),Na(Aa),Na(Ta),uo();break;case 5:oo(r);break;case 4:ao();break;case 13:case 19:Na(io);break;case 10:ks(r.type._context);break;case 22:case 23:dc()}n=n.return}if(Rl=t,Fl=t=Oc(t.current,null),_l=Dl=e,zl=0,Ll=null,Bl=Pl=Ml=0,Ul=Wl=null,null!==Cs){for(e=0;e<Cs.length;e++)if(null!==(r=(n=Cs[e]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var o=s.next;s.next=a,r.next=o}n.pending=r}Cs=null}return t}function fc(t,e){for(;;){var n=Fl;try{if(xs(),ho.current=oi,yo){for(var r=go.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}yo=!1}if(fo=0,bo=mo=go=null,vo=!1,wo=0,El.current=null,null===n||null===n.return){zl=1,Ll=e,Fl=null;break}t:{var o=t,i=n.return,l=n,c=e;if(e=_l,l.flags|=32768,null!==c&&"object"===typeof c&&"function"===typeof c.then){var u=c,h=l,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=bi(i);if(null!==f){f.flags&=-257,yi(f,i,l,0,e),1&f.mode&&mi(o,u,e),c=u;var g=(e=f).updateQueue;if(null===g){var m=new Set;m.add(c),e.updateQueue=m}else g.add(c);break t}if(0===(1&e)){mi(o,u,e),mc();break t}c=Error(s(426))}else if(as&&1&l.mode){var b=bi(i);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),yi(b,i,l,0,e),fs(ui(c,l));break t}}o=c=ui(c,l),4!==zl&&(zl=2),null===Wl?Wl=[o]:Wl.push(o),o=i;do{switch(o.tag){case 3:o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,fi(0,c,e));break t;case 1:l=c;var y=o.type,v=o.stateNode;if(0===(128&o.flags)&&("function"===typeof y.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===ql||!ql.has(v)))){o.flags|=65536,e&=-e,o.lanes|=e,Ls(o,gi(o,l,e));break t}}o=o.return}while(null!==o)}xc(n)}catch(w){e=w,Fl===n&&null!==n&&(Fl=n=n.return);continue}break}}function gc(){var t=Cl.current;return Cl.current=oi,null===t?oi:t}function mc(){0!==zl&&3!==zl&&2!==zl||(zl=4),null===Rl||0===(268435455&Ml)&&0===(268435455&Pl)||lc(Rl,_l)}function bc(t,e){var n=Al;Al|=2;var r=gc();for(Rl===t&&_l===e||(Gl=null,pc(t,e));;)try{yc();break}catch(a){fc(t,a)}if(xs(),Al=n,Cl.current=r,null!==Fl)throw Error(s(261));return Rl=null,_l=0,zl}function yc(){for(;null!==Fl;)wc(Fl)}function vc(){for(;null!==Fl&&!Jt();)wc(Fl)}function wc(t){var e=Il(t.alternate,t,Dl);t.memoizedProps=t.pendingProps,null===e?xc(t):Fl=e,El.current=null}function xc(t){var e=t;do{var n=e.alternate;if(t=e.return,0===(32768&e.flags)){if(null!==(n=Xi(n,e,Dl)))return void(Fl=n)}else{if(null!==(n=Ji(n,e)))return n.flags&=32767,void(Fl=n);if(null===t)return zl=6,void(Fl=null);t.flags|=32768,t.subtreeFlags=0,t.deletions=null}if(null!==(e=e.sibling))return void(Fl=e);Fl=e=t}while(null!==e);0===zl&&(zl=5)}function kc(t,e,n){var r=ve,a=Tl.transition;try{Tl.transition=null,ve=1,function(t,e,n,r){do{Sc()}while(null!==Jl);if(0!==(6&Al))throw Error(s(327));n=t.finishedWork;var a=t.finishedLanes;if(null===n)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(s(177));t.callbackNode=null,t.callbackPriority=0;var o=n.lanes|n.childLanes;if(function(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var a=31-oe(n),s=1<<a;e[a]=0,r[a]=-1,t[a]=-1,n&=~s}}(t,o),t===Rl&&(Fl=Rl=null,_l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||Xl||(Xl=!0,Rc(ee,(function(){return Sc(),null}))),o=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||o){o=Tl.transition,Tl.transition=null;var i=ve;ve=1;var l=Al;Al|=4,El.current=null,function(t,e){if(ta=Ge,pr(t=dr())){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else t:{var r=(n=(n=t.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch(x){n=null;break t}var i=0,l=-1,c=-1,u=0,h=0,d=t,p=null;e:for(;;){for(var f;d!==n||0!==a&&3!==d.nodeType||(l=i+a),d!==o||0!==r&&3!==d.nodeType||(c=i+r),3===d.nodeType&&(i+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===t)break e;if(p===n&&++u===a&&(l=i),p===o&&++h===r&&(c=i),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===c?null:{start:l,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(ea={focusedElem:t,selectionRange:n},Ge=!1,$i=e;null!==$i;)if(t=(e=$i).child,0!==(1028&e.subtreeFlags)&&null!==t)t.return=e,$i=t;else for(;null!==$i;){e=$i;try{var g=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==g){var m=g.memoizedProps,b=g.memoizedState,y=e.stateNode,v=y.getSnapshotBeforeUpdate(e.elementType===e.type?m:ms(e.type,m),b);y.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var w=e.stateNode.containerInfo;1===w.nodeType?w.textContent="":9===w.nodeType&&w.documentElement&&w.removeChild(w.documentElement);break;default:throw Error(s(163))}}catch(x){Nc(e,e.return,x)}if(null!==(t=e.sibling)){t.return=e.return,$i=t;break}$i=e.return}g=nl,nl=!1}(t,n),bl(n,t),fr(ea),Ge=!!ta,ea=ta=null,t.current=n,vl(n,t,a),Yt(),Al=l,ve=i,Tl.transition=o}else t.current=n;if(Xl&&(Xl=!1,Jl=t,Yl=a),o=t.pendingLanes,0===o&&(ql=null),function(t){if(se&&"function"===typeof se.onCommitFiberRoot)try{se.onCommitFiberRoot(ae,t,void 0,128===(128&t.current.flags))}catch(e){}}(n.stateNode),ac(t,Zt()),null!==e)for(r=t.onRecoverableError,n=0;n<e.length;n++)a=e[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(Hl)throw Hl=!1,t=Kl,Kl=null,t;0!==(1&Yl)&&0!==t.tag&&Sc(),o=t.pendingLanes,0!==(1&o)?t===Ql?Zl++:(Zl=0,Ql=t):Zl=0,Va()}(t,e,n,r)}finally{Tl.transition=a,ve=r}return null}function Sc(){if(null!==Jl){var t=we(Yl),e=Tl.transition,n=ve;try{if(Tl.transition=null,ve=16>t?16:t,null===Jl)var r=!1;else{if(t=Jl,Jl=null,Yl=0,0!==(6&Al))throw Error(s(331));var a=Al;for(Al|=4,$i=t.current;null!==$i;){var o=$i,i=o.child;if(0!==(16&$i.flags)){var l=o.deletions;if(null!==l){for(var c=0;c<l.length;c++){var u=l[c];for($i=u;null!==$i;){var h=$i;switch(h.tag){case 0:case 11:case 15:rl(8,h,o)}var d=h.child;if(null!==d)d.return=h,$i=d;else for(;null!==$i;){var p=(h=$i).sibling,f=h.return;if(ol(h),h===u){$i=null;break}if(null!==p){p.return=f,$i=p;break}$i=f}}}var g=o.alternate;if(null!==g){var m=g.child;if(null!==m){g.child=null;do{var b=m.sibling;m.sibling=null,m=b}while(null!==m)}}$i=o}}if(0!==(2064&o.subtreeFlags)&&null!==i)i.return=o,$i=i;else t:for(;null!==$i;){if(0!==(2048&(o=$i).flags))switch(o.tag){case 0:case 11:case 15:rl(9,o,o.return)}var y=o.sibling;if(null!==y){y.return=o.return,$i=y;break t}$i=o.return}}var v=t.current;for($i=v;null!==$i;){var w=(i=$i).child;if(0!==(2064&i.subtreeFlags)&&null!==w)w.return=i,$i=w;else t:for(i=v;null!==$i;){if(0!==(2048&(l=$i).flags))try{switch(l.tag){case 0:case 11:case 15:al(9,l)}}catch(k){Nc(l,l.return,k)}if(l===i){$i=null;break t}var x=l.sibling;if(null!==x){x.return=l.return,$i=x;break t}$i=l.return}}if(Al=a,Va(),se&&"function"===typeof se.onPostCommitFiberRoot)try{se.onPostCommitFiberRoot(ae,t)}catch(k){}r=!0}return r}finally{ve=n,Tl.transition=e}}return!1}function Ic(t,e,n){t=Os(t,e=fi(0,e=ui(n,e),1),1),e=ec(),null!==t&&(be(t,1,e),ac(t,e))}function Nc(t,e,n){if(3===t.tag)Ic(t,t,n);else for(;null!==e;){if(3===e.tag){Ic(e,t,n);break}if(1===e.tag){var r=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===ql||!ql.has(r))){e=Os(e,t=gi(e,t=ui(n,t),1),1),t=ec(),null!==e&&(be(e,1,t),ac(e,t));break}}e=e.return}}function Cc(t,e,n){var r=t.pingCache;null!==r&&r.delete(e),e=ec(),t.pingedLanes|=t.suspendedLanes&n,Rl===t&&(_l&n)===n&&(4===zl||3===zl&&(130023424&_l)===_l&&500>Zt()-Vl?pc(t,0):Bl|=n),ac(t,e)}function Ec(t,e){0===e&&(0===(1&t.mode)?e=1:(e=ue,0===(130023424&(ue<<=1))&&(ue=4194304)));var n=ec();null!==(t=As(t,e))&&(be(t,e,n),ac(t,n))}function Tc(t){var e=t.memoizedState,n=0;null!==e&&(n=e.retryLane),Ec(t,n)}function Ac(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,a=t.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(e),Ec(t,n)}function Rc(t,e){return qt(t,e)}function Fc(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _c(t,e,n,r){return new Fc(t,e,n,r)}function Dc(t){return!(!(t=t.prototype)||!t.isReactComponent)}function Oc(t,e){var n=t.alternate;return null===n?((n=_c(t.tag,e,t.key,t.mode)).elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&t.flags,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function zc(t,e,n,r,a,o){var i=2;if(r=t,"function"===typeof t)Dc(t)&&(i=1);else if("string"===typeof t)i=5;else t:switch(t){case S:return Lc(n.children,a,o,e);case I:i=8,a|=8;break;case N:return(t=_c(12,n,e,2|a)).elementType=N,t.lanes=o,t;case A:return(t=_c(13,n,e,a)).elementType=A,t.lanes=o,t;case R:return(t=_c(19,n,e,a)).elementType=R,t.lanes=o,t;case D:return Mc(n,a,o,e);default:if("object"===typeof t&&null!==t)switch(t.$$typeof){case C:i=10;break t;case E:i=9;break t;case T:i=11;break t;case F:i=14;break t;case _:i=16,r=null;break t}throw Error(s(130,null==t?t:typeof t,""))}return(e=_c(i,n,e,a)).elementType=t,e.type=r,e.lanes=o,e}function Lc(t,e,n,r){return(t=_c(7,t,r,e)).lanes=n,t}function Mc(t,e,n,r){return(t=_c(22,t,r,e)).elementType=D,t.lanes=n,t.stateNode={isHidden:!1},t}function Pc(t,e,n){return(t=_c(6,t,null,e)).lanes=n,t}function Bc(t,e,n){return(e=_c(4,null!==t.children?t.children:[],t.key,e)).lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function Wc(t,e,n,r,a){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=me(0),this.expirationTimes=me(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=me(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Uc(t,e,n,r,a,s,o,i,l){return t=new Wc(t,e,n,i,l),1===e?(e=1,!0===s&&(e|=8)):e=0,s=_c(3,null,null,e),t.current=s,s.stateNode=t,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Fs(s),t}function Vc(t){if(!t)return Ea;t:{if(Vt(t=t._reactInternals)!==t||1!==t.tag)throw Error(s(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break t;case 1:if(_a(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break t}}e=e.return}while(null!==e);throw Error(s(171))}if(1===t.tag){var n=t.type;if(_a(n))return za(t,n,e)}return e}function jc(t,e,n,r,a,s,o,i,l){return(t=Uc(n,r,!0,t,0,s,0,i,l)).context=Vc(null),n=t.current,(s=Ds(r=ec(),a=nc(n))).callback=void 0!==e&&null!==e?e:null,Os(n,s,a),t.current.lanes=a,be(t,a,r),ac(t,r),t}function Gc(t,e,n,r){var a=e.current,s=ec(),o=nc(a);return n=Vc(n),null===e.context?e.context=n:e.pendingContext=n,(e=Ds(s,o)).payload={element:t},null!==(r=void 0===r?null:r)&&(e.callback=r),null!==(t=Os(a,e,o))&&(rc(t,a,o,s),zs(t,a,o)),o}function Hc(t){return(t=t.current).child?(t.child.tag,t.child.stateNode):null}function Kc(t,e){if(null!==(t=t.memoizedState)&&null!==t.dehydrated){var n=t.retryLane;t.retryLane=0!==n&&n<e?n:e}}function qc(t,e){Kc(t,e),(t=t.alternate)&&Kc(t,e)}Il=function(t,e,n){if(null!==t)if(t.memoizedProps!==e.pendingProps||Aa.current)wi=!0;else{if(0===(t.lanes&n)&&0===(128&e.flags))return wi=!1,function(t,e,n){switch(e.tag){case 3:Ri(e),ps();break;case 5:so(e);break;case 1:_a(e.type)&&La(e);break;case 4:ro(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,a=e.memoizedProps.value;Ca(bs,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=e.memoizedState))return null!==r.dehydrated?(Ca(io,1&io.current),e.flags|=128,null):0!==(n&e.child.childLanes)?Pi(t,e,n):(Ca(io,1&io.current),null!==(t=Hi(t,e,n))?t.sibling:null);Ca(io,1&io.current);break;case 19:if(r=0!==(n&e.childLanes),0!==(128&t.flags)){if(r)return ji(t,e,n);e.flags|=128}if(null!==(a=e.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ca(io,io.current),r)break;return null;case 22:case 23:return e.lanes=0,Ni(t,e,n)}return Hi(t,e,n)}(t,e,n);wi=0!==(131072&t.flags)}else wi=!1,as&&0!==(1048576&e.flags)&&$a(e,Ka,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;Gi(t,e),t=e.pendingProps;var a=Fa(e,Ta.current);Is(e,n),a=Io(null,e,r,t,a,n);var o=No();return e.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,_a(r)?(o=!0,La(e)):o=!1,e.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Fs(e),a.updater=Us,e.stateNode=a,a._reactInternals=e,Hs(e,r,t,n),e=Ai(null,e,r,!0,o,n)):(e.tag=0,as&&o&&ts(e),xi(null,e,a,n),e=e.child),e;case 16:r=e.elementType;t:{switch(Gi(t,e),t=e.pendingProps,r=(a=r._init)(r._payload),e.type=r,a=e.tag=function(t){if("function"===typeof t)return Dc(t)?1:0;if(void 0!==t&&null!==t){if((t=t.$$typeof)===T)return 11;if(t===F)return 14}return 2}(r),t=ms(r,t),a){case 0:e=Ei(null,e,r,t,n);break t;case 1:e=Ti(null,e,r,t,n);break t;case 11:e=ki(null,e,r,t,n);break t;case 14:e=Si(null,e,r,ms(r.type,t),n);break t}throw Error(s(306,r,""))}return e;case 0:return r=e.type,a=e.pendingProps,Ei(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 1:return r=e.type,a=e.pendingProps,Ti(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 3:t:{if(Ri(e),null===t)throw Error(s(387));r=e.pendingProps,a=(o=e.memoizedState).element,_s(t,e),Ms(e,r,null,n);var i=e.memoizedState;if(r=i.element,o.isDehydrated){if(o={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},e.updateQueue.baseState=o,e.memoizedState=o,256&e.flags){e=Fi(t,e,r,n,a=ui(Error(s(423)),e));break t}if(r!==a){e=Fi(t,e,r,n,a=ui(Error(s(424)),e));break t}for(rs=ca(e.stateNode.containerInfo.firstChild),ns=e,as=!0,ss=null,n=Zs(e,null,r,n),e.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){e=Hi(t,e,n);break t}xi(t,e,r,n)}e=e.child}return e;case 5:return so(e),null===t&&cs(e),r=e.type,a=e.pendingProps,o=null!==t?t.memoizedProps:null,i=a.children,na(r,a)?i=null:null!==o&&na(r,o)&&(e.flags|=32),Ci(t,e),xi(t,e,i,n),e.child;case 6:return null===t&&cs(e),null;case 13:return Pi(t,e,n);case 4:return ro(e,e.stateNode.containerInfo),r=e.pendingProps,null===t?e.child=Ys(e,null,r,n):xi(t,e,r,n),e.child;case 11:return r=e.type,a=e.pendingProps,ki(t,e,r,a=e.elementType===r?a:ms(r,a),n);case 7:return xi(t,e,e.pendingProps,n),e.child;case 8:case 12:return xi(t,e,e.pendingProps.children,n),e.child;case 10:t:{if(r=e.type._context,a=e.pendingProps,o=e.memoizedProps,i=a.value,Ca(bs,r._currentValue),r._currentValue=i,null!==o)if(ir(o.value,i)){if(o.children===a.children&&!Aa.current){e=Hi(t,e,n);break t}}else for(null!==(o=e.child)&&(o.return=e);null!==o;){var l=o.dependencies;if(null!==l){i=o.child;for(var c=l.firstContext;null!==c;){if(c.context===r){if(1===o.tag){(c=Ds(-1,n&-n)).tag=2;var u=o.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?c.next=c:(c.next=h.next,h.next=c),u.pending=c}}o.lanes|=n,null!==(c=o.alternate)&&(c.lanes|=n),Ss(o.return,n,e),l.lanes|=n;break}c=c.next}}else if(10===o.tag)i=o.type===e.type?null:o.child;else if(18===o.tag){if(null===(i=o.return))throw Error(s(341));i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Ss(i,n,e),i=o.sibling}else i=o.child;if(null!==i)i.return=o;else for(i=o;null!==i;){if(i===e){i=null;break}if(null!==(o=i.sibling)){o.return=i.return,i=o;break}i=i.return}o=i}xi(t,e,a.children,n),e=e.child}return e;case 9:return a=e.type,r=e.pendingProps.children,Is(e,n),r=r(a=Ns(a)),e.flags|=1,xi(t,e,r,n),e.child;case 14:return a=ms(r=e.type,e.pendingProps),Si(t,e,r,a=ms(r.type,a),n);case 15:return Ii(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,a=e.pendingProps,a=e.elementType===r?a:ms(r,a),Gi(t,e),e.tag=1,_a(r)?(t=!0,La(e)):t=!1,Is(e,n),js(e,r,a),Hs(e,r,a,n),Ai(null,e,r,!0,t,n);case 19:return ji(t,e,n);case 22:return Ni(t,e,n)}throw Error(s(156,e.tag))};var Xc="function"===typeof reportError?reportError:function(t){console.error(t)};function Jc(t){this._internalRoot=t}function Yc(t){this._internalRoot=t}function Zc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)}function Qc(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType&&(8!==t.nodeType||" react-mount-point-unstable "!==t.nodeValue))}function $c(){}function tu(t,e,n,r,a){var s=n._reactRootContainer;if(s){var o=s;if("function"===typeof a){var i=a;a=function(){var t=Hc(o);i.call(t)}}Gc(e,o,t,a)}else o=function(t,e,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var t=Hc(o);s.call(t)}}var o=jc(e,r,t,0,null,!1,0,"",$c);return t._reactRootContainer=o,t[fa]=o.current,Vr(8===t.nodeType?t.parentNode:t),hc(),o}for(;a=t.lastChild;)t.removeChild(a);if("function"===typeof r){var i=r;r=function(){var t=Hc(l);i.call(t)}}var l=Uc(t,0,!1,null,0,!1,0,"",$c);return t._reactRootContainer=l,t[fa]=l.current,Vr(8===t.nodeType?t.parentNode:t),hc((function(){Gc(e,l,n,r)})),l}(n,e,t,a,r);return Hc(o)}Yc.prototype.render=Jc.prototype.render=function(t){var e=this._internalRoot;if(null===e)throw Error(s(409));Gc(t,e,null,null)},Yc.prototype.unmount=Jc.prototype.unmount=function(){var t=this._internalRoot;if(null!==t){this._internalRoot=null;var e=t.containerInfo;hc((function(){Gc(null,t,null,null)})),e[fa]=null}},Yc.prototype.unstable_scheduleHydration=function(t){if(t){var e=Ie();t={blockedOn:null,target:t,priority:e};for(var n=0;n<De.length&&0!==e&&e<De[n].priority;n++);De.splice(n,0,t),0===n&&Me(t)}},xe=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=he(e.pendingLanes);0!==n&&(ye(e,1|n),ac(e,Zt()),0===(6&Al)&&(jl=Zt()+500,Va()))}break;case 13:hc((function(){var e=As(t,1);if(null!==e){var n=ec();rc(e,t,1,n)}})),qc(t,1)}},ke=function(t){if(13===t.tag){var e=As(t,134217728);if(null!==e)rc(e,t,134217728,ec());qc(t,134217728)}},Se=function(t){if(13===t.tag){var e=nc(t),n=As(t,e);if(null!==n)rc(n,t,e,ec());qc(t,e)}},Ie=function(){return ve},Ne=function(t,e){var n=ve;try{return ve=t,e()}finally{ve=n}},kt=function(t,e,n){switch(e){case"input":if(Q(t,n),e=n.name,"radio"===n.type&&null!=e){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var a=xa(r);if(!a)throw Error(s(90));q(r),Q(r,a)}}}break;case"textarea":st(t,n);break;case"select":null!=(e=n.value)&&nt(t,!!n.multiple,e,!1)}},Tt=uc,At=hc;var eu={usingClientEntryPoint:!1,Events:[va,wa,xa,Ct,Et,uc]},nu={findFiberByHostInstance:ya,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},ru={bundleType:nu.bundleType,version:nu.version,rendererPackageName:nu.rendererPackageName,rendererConfig:nu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:w.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return null===(t=Ht(t))?null:t.stateNode},findFiberByHostInstance:nu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{ae=au.inject(ru),se=au}catch(ut){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,e.createPortal=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Zc(e))throw Error(s(200));return function(t,e,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:t,containerInfo:e,implementation:n}}(t,e,null,n)},e.createRoot=function(t,e){if(!Zc(t))throw Error(s(299));var n=!1,r="",a=Xc;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(n=!0),void 0!==e.identifierPrefix&&(r=e.identifierPrefix),void 0!==e.onRecoverableError&&(a=e.onRecoverableError)),e=Uc(t,1,!1,null,0,n,0,r,a),t[fa]=e.current,Vr(8===t.nodeType?t.parentNode:t),new Jc(e)},e.findDOMNode=function(t){if(null==t)return null;if(1===t.nodeType)return t;var e=t._reactInternals;if(void 0===e){if("function"===typeof t.render)throw Error(s(188));throw t=Object.keys(t).join(","),Error(s(268,t))}return t=null===(t=Ht(e))?null:t.stateNode},e.flushSync=function(t){return hc(t)},e.hydrate=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!0,n)},e.hydrateRoot=function(t,e,n){if(!Zc(t))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,o="",i=Xc;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(o=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),e=jc(e,null,t,1,null!=n?n:null,a,0,o,i),t[fa]=e.current,Vr(t),r)for(t=0;t<r.length;t++)a=(a=(n=r[t])._getVersion)(n._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[n,a]:e.mutableSourceEagerHydrationData.push(n,a);return new Yc(e)},e.render=function(t,e,n){if(!Qc(e))throw Error(s(200));return tu(null,t,e,!1,n)},e.unmountComponentAtNode=function(t){if(!Qc(t))throw Error(s(40));return!!t._reactRootContainer&&(hc((function(){tu(null,null,t,!1,(function(){t._reactRootContainer=null,t[fa]=null}))})),!0)},e.unstable_batchedUpdates=uc,e.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!Qc(n))throw Error(s(200));if(null==t||void 0===t._reactInternals)throw Error(s(38));return tu(t,e,n,!1,r)},e.version="18.2.0-next-9e3b772b8-20220608"},4391:(t,e,n)=>{"use strict";var r=n(7950);e.createRoot=r.createRoot,e.hydrateRoot=r.hydrateRoot},7950:(t,e,n)=>{"use strict";!function t(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}(),t.exports=n(2730)},1153:(t,e,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,i=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(t,e,n){var r,s={},c=null,u=null;for(r in void 0!==n&&(c=""+n),void 0!==e.key&&(c=""+e.key),void 0!==e.ref&&(u=e.ref),e)o.call(e,r)&&!l.hasOwnProperty(r)&&(s[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps)void 0===s[r]&&(s[r]=e[r]);return{$$typeof:a,type:t,key:c,ref:u,props:s,_owner:i.current}}e.Fragment=s,e.jsx=c,e.jsxs=c},4202:(t,e)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),l=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}function y(){}function v(t,e,n){this.props=t,this.context=e,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(t,e){if("object"!==typeof t&&"function"!==typeof t&&null!=t)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},b.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")},y.prototype=b.prototype;var w=v.prototype=new y;w.constructor=v,g(w,b.prototype),w.isPureReactComponent=!0;var x=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(t,e,r){var a,s={},o=null,i=null;if(null!=e)for(a in void 0!==e.ref&&(i=e.ref),void 0!==e.key&&(o=""+e.key),e)k.call(e,a)&&!I.hasOwnProperty(a)&&(s[a]=e[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var c=Array(l),u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}if(t&&t.defaultProps)for(a in l=t.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:t,key:o,ref:i,props:s,_owner:S.current}}function C(t){return"object"===typeof t&&null!==t&&t.$$typeof===n}var E=/\/+/g;function T(t,e){return"object"===typeof t&&null!==t&&null!=t.key?function(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,(function(t){return e[t]}))}(""+t.key):e.toString(36)}function A(t,e,a,s,o){var i=typeof t;"undefined"!==i&&"boolean"!==i||(t=null);var l=!1;if(null===t)l=!0;else switch(i){case"string":case"number":l=!0;break;case"object":switch(t.$$typeof){case n:case r:l=!0}}if(l)return o=o(l=t),t=""===s?"."+T(l,0):s,x(o)?(a="",null!=t&&(a=t.replace(E,"$&/")+"/"),A(o,e,a,"",(function(t){return t}))):null!=o&&(C(o)&&(o=function(t,e){return{$$typeof:n,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}(o,a+(!o.key||l&&l.key===o.key?"":(""+o.key).replace(E,"$&/")+"/")+t)),e.push(o)),1;if(l=0,s=""===s?".":s+":",x(t))for(var c=0;c<t.length;c++){var u=s+T(i=t[c],c);l+=A(i,e,a,u,o)}else if(u=function(t){return null===t||"object"!==typeof t?null:"function"===typeof(t=p&&t[p]||t["@@iterator"])?t:null}(t),"function"===typeof u)for(t=u.call(t),c=0;!(i=t.next()).done;)l+=A(i=i.value,e,a,u=s+T(i,c++),o);else if("object"===i)throw e=String(t),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return l}function R(t,e,n){if(null==t)return t;var r=[],a=0;return A(t,r,"","",(function(t){return e.call(n,t,a++)})),r}function F(t){if(-1===t._status){var e=t._result;(e=e()).then((function(e){0!==t._status&&-1!==t._status||(t._status=1,t._result=e)}),(function(e){0!==t._status&&-1!==t._status||(t._status=2,t._result=e)})),-1===t._status&&(t._status=0,t._result=e)}if(1===t._status)return t._result.default;throw t._result}var _={current:null},D={transition:null},O={ReactCurrentDispatcher:_,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};e.Children={map:R,forEach:function(t,e,n){R(t,(function(){e.apply(this,arguments)}),n)},count:function(t){var e=0;return R(t,(function(){e++})),e},toArray:function(t){return R(t,(function(t){return t}))||[]},only:function(t){if(!C(t))throw Error("React.Children.only expected to receive a single React element child.");return t}},e.Component=b,e.Fragment=a,e.Profiler=o,e.PureComponent=v,e.StrictMode=s,e.Suspense=u,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,e.cloneElement=function(t,e,r){if(null===t||void 0===t)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var a=g({},t.props),s=t.key,o=t.ref,i=t._owner;if(null!=e){if(void 0!==e.ref&&(o=e.ref,i=S.current),void 0!==e.key&&(s=""+e.key),t.type&&t.type.defaultProps)var l=t.type.defaultProps;for(c in e)k.call(e,c)&&!I.hasOwnProperty(c)&&(a[c]=void 0===e[c]&&void 0!==l?l[c]:e[c])}var c=arguments.length-2;if(1===c)a.children=r;else if(1<c){l=Array(c);for(var u=0;u<c;u++)l[u]=arguments[u+2];a.children=l}return{$$typeof:n,type:t.type,key:s,ref:o,props:a,_owner:i}},e.createContext=function(t){return(t={$$typeof:l,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:t},t.Consumer=t},e.createElement=N,e.createFactory=function(t){var e=N.bind(null,t);return e.type=t,e},e.createRef=function(){return{current:null}},e.forwardRef=function(t){return{$$typeof:c,render:t}},e.isValidElement=C,e.lazy=function(t){return{$$typeof:d,_payload:{_status:-1,_result:t},_init:F}},e.memo=function(t,e){return{$$typeof:h,type:t,compare:void 0===e?null:e}},e.startTransition=function(t){var e=D.transition;D.transition={};try{t()}finally{D.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(t,e){return _.current.useCallback(t,e)},e.useContext=function(t){return _.current.useContext(t)},e.useDebugValue=function(){},e.useDeferredValue=function(t){return _.current.useDeferredValue(t)},e.useEffect=function(t,e){return _.current.useEffect(t,e)},e.useId=function(){return _.current.useId()},e.useImperativeHandle=function(t,e,n){return _.current.useImperativeHandle(t,e,n)},e.useInsertionEffect=function(t,e){return _.current.useInsertionEffect(t,e)},e.useLayoutEffect=function(t,e){return _.current.useLayoutEffect(t,e)},e.useMemo=function(t,e){return _.current.useMemo(t,e)},e.useReducer=function(t,e,n){return _.current.useReducer(t,e,n)},e.useRef=function(t){return _.current.useRef(t)},e.useState=function(t){return _.current.useState(t)},e.useSyncExternalStore=function(t,e,n){return _.current.useSyncExternalStore(t,e,n)},e.useTransition=function(){return _.current.useTransition()},e.version="18.2.0"},5043:(t,e,n)=>{"use strict";t.exports=n(4202)},579:(t,e,n)=>{"use strict";t.exports=n(1153)},7234:(t,e)=>{"use strict";function n(t,e){var n=t.length;t.push(e);t:for(;0<n;){var r=n-1>>>1,a=t[r];if(!(0<s(a,e)))break t;t[r]=e,t[n]=a,n=r}}function r(t){return 0===t.length?null:t[0]}function a(t){if(0===t.length)return null;var e=t[0],n=t.pop();if(n!==e){t[0]=n;t:for(var r=0,a=t.length,o=a>>>1;r<o;){var i=2*(r+1)-1,l=t[i],c=i+1,u=t[c];if(0>s(l,n))c<a&&0>s(u,l)?(t[r]=u,t[c]=n,r=c):(t[r]=l,t[i]=n,r=i);else{if(!(c<a&&0>s(u,n)))break t;t[r]=u,t[c]=n,r=c}}}return e}function s(t,e){var n=t.sortIndex-e.sortIndex;return 0!==n?n:t.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var o=performance;e.unstable_now=function(){return o.now()}}else{var i=Date,l=i.now();e.unstable_now=function(){return i.now()-l}}var c=[],u=[],h=1,d=null,p=3,f=!1,g=!1,m=!1,b="function"===typeof setTimeout?setTimeout:null,y="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function w(t){for(var e=r(u);null!==e;){if(null===e.callback)a(u);else{if(!(e.startTime<=t))break;a(u),e.sortIndex=e.expirationTime,n(c,e)}e=r(u)}}function x(t){if(m=!1,w(t),!g)if(null!==r(c))g=!0,D(k);else{var e=r(u);null!==e&&O(x,e.startTime-t)}}function k(t,n){g=!1,m&&(m=!1,y(C),C=-1),f=!0;var s=p;try{for(w(n),d=r(c);null!==d&&(!(d.expirationTime>n)||t&&!A());){var o=d.callback;if("function"===typeof o){d.callback=null,p=d.priorityLevel;var i=o(d.expirationTime<=n);n=e.unstable_now(),"function"===typeof i?d.callback=i:d===r(c)&&a(c),w(n)}else a(c);d=r(c)}if(null!==d)var l=!0;else{var h=r(u);null!==h&&O(x,h.startTime-n),l=!1}return l}finally{d=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,C=-1,E=5,T=-1;function A(){return!(e.unstable_now()-T<E)}function R(){if(null!==N){var t=e.unstable_now();T=t;var n=!0;try{n=N(!0,t)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"===typeof v)S=function(){v(R)};else if("undefined"!==typeof MessageChannel){var F=new MessageChannel,_=F.port2;F.port1.onmessage=R,S=function(){_.postMessage(null)}}else S=function(){b(R,0)};function D(t){N=t,I||(I=!0,S())}function O(t,n){C=b((function(){t(e.unstable_now())}),n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(t){t.callback=null},e.unstable_continueExecution=function(){g||f||(g=!0,D(k))},e.unstable_forceFrameRate=function(t){0>t||125<t?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<t?Math.floor(1e3/t):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(c)},e.unstable_next=function(t){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var n=p;p=e;try{return t()}finally{p=n}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(t,e){switch(t){case 1:case 2:case 3:case 4:case 5:break;default:t=3}var n=p;p=t;try{return e()}finally{p=n}},e.unstable_scheduleCallback=function(t,a,s){var o=e.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?o+s:o:s=o,t){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return t={id:h++,callback:a,priorityLevel:t,startTime:s,expirationTime:i=s+i,sortIndex:-1},s>o?(t.sortIndex=s,n(u,t),null===r(c)&&t===r(u)&&(m?(y(C),C=-1):m=!0,O(x,s-o))):(t.sortIndex=i,n(c,t),g||f||(g=!0,D(k))),t},e.unstable_shouldYield=A,e.unstable_wrapCallback=function(t){var e=p;return function(){var n=p;p=e;try{return t.apply(this,arguments)}finally{p=n}}}},8853:(t,e,n)=>{"use strict";t.exports=n(7234)},4334:(t,e,n)=>{var r=n(7359),a=n(7066),s=n(9016),o=n(9538),i=n(6288),l=n(5262),c=n(2430);c.alea=r,c.xor128=a,c.xorwow=s,c.xorshift7=o,c.xor4096=i,c.tychei=l,t.exports=c},7359:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n=function(){var t=4022871197,e=function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)};return e}();e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=n(" "),e.s1=n(" "),e.s2=n(" "),e.s0-=n(t),e.s0<0&&(e.s0+=1),e.s1-=n(t),e.s1<0&&(e.s1+=1),e.s2-=n(t),e.s2<0&&(e.s2+=1),n=null}function i(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},5262:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,a=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^a,e.a=a-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},7066:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},6288:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.w,a=e.X,s=e.i;return e.w=r=r+1640531527|0,n=a[s+34&127],t=a[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=a[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,a,s,o,i=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),a=0,s=-32;s<l;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(n=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(e&&e.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;t.w=o,t.X=i,t.i=a}(e,t)}function i(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},9538:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this;e.next=function(){var t,n,r=e.x,a=e.i;return t=r[a],n=(t^=t>>>7)^t<<24,n^=(t=r[a+1&7])^t>>>10,n^=(t=r[a+3&7])^t>>>3,n^=(t=r[a+4&7])^t<<7,t=r[a+7&7],n^=(t^=t<<13)^t<<9,r[a]=n,e.i=a+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function i(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},9016:function(t,e,n){var r;!function(t,a,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,a))||(a.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},2430:function(t,e,n){var r;!function(a,s,o){var i,l=256,c=o.pow(l,6),u=o.pow(2,52),h=2*u,d=l-1;function p(t,e,n){var r=[],d=b(m((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return i&&(t=i.randomBytes)?t=t(l):(t=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(t)),y(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=c,n=0;t<u;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&g(r,p),t.state=function(){return g(p,{})}),n?(o.random=t,e):t})(v,d,"global"in e?e.global:this==o,e.state)}function f(t){var e,n=t.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);a<l;)o[a]=a++;for(a=0;a<l;a++)o[a]=o[s=d&s+t[a%n]+(e=o[a])],o[s]=e;(r.g=function(t){for(var e,n=0,a=r.i,s=r.j,o=r.S;t--;)e=o[a=d&a+1],n=n*l+o[d&(o[a]=o[s=d&s+e])+(o[s]=e)];return r.i=a,r.j=s,n})(l)}function g(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function m(t,e){var n,r=[],a=typeof t;if(e&&"object"==a)for(n in t)try{r.push(m(t[n],e-1))}catch(s){}return r.length?r:"string"==a?t:t+"\0"}function b(t,e){for(var n,r=t+"",a=0;a<r.length;)e[d&a]=d&(n^=19*e[d&a])+r.charCodeAt(a++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(b(o.random(),s),t.exports){t.exports=p;try{i=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}("undefined"!==typeof self?self:this,[],Math)},5438:(t,e,n)=>{"use strict";var r=n(2),a=n(4992),s=n(2101)(),o=n(5558),i=n(4902),l=r("%Math.floor%");t.exports=function(t,e){if("function"!==typeof t)throw new i("`fn` is not a function");if("number"!==typeof e||e<0||e>4294967295||l(e)!==e)throw new i("`length` must be a positive 32-bit integer");var n=arguments.length>2&&!!arguments[2],r=!0,c=!0;if("length"in t&&o){var u=o(t,"length");u&&!u.configurable&&(r=!1),u&&!u.writable&&(c=!1)}return(r||c||!n)&&(s?a(t,"length",e,!0,!0):a(t,"length",e)),t}},5446:t=>{t.exports=function(t){return t&&"object"===typeof t&&"function"===typeof t.copy&&"function"===typeof t.fill&&"function"===typeof t.readUInt8}},9321:(t,e,n)=>{"use strict";var r=n(8317),a=n(1583),s=n(8004),o=n(9849);function i(t){return t.call.bind(t)}var l="undefined"!==typeof BigInt,c="undefined"!==typeof Symbol,u=i(Object.prototype.toString),h=i(Number.prototype.valueOf),d=i(String.prototype.valueOf),p=i(Boolean.prototype.valueOf);if(l)var f=i(BigInt.prototype.valueOf);if(c)var g=i(Symbol.prototype.valueOf);function m(t,e){if("object"!==typeof t)return!1;try{return e(t),!0}catch(n){return!1}}function b(t){return"[object Map]"===u(t)}function y(t){return"[object Set]"===u(t)}function v(t){return"[object WeakMap]"===u(t)}function w(t){return"[object WeakSet]"===u(t)}function x(t){return"[object ArrayBuffer]"===u(t)}function k(t){return"undefined"!==typeof ArrayBuffer&&(x.working?x(t):t instanceof ArrayBuffer)}function S(t){return"[object DataView]"===u(t)}function I(t){return"undefined"!==typeof DataView&&(S.working?S(t):t instanceof DataView)}e.isArgumentsObject=r,e.isGeneratorFunction=a,e.isTypedArray=o,e.isPromise=function(t){return"undefined"!==typeof Promise&&t instanceof Promise||null!==t&&"object"===typeof t&&"function"===typeof t.then&&"function"===typeof t.catch},e.isArrayBufferView=function(t){return"undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):o(t)||I(t)},e.isUint8Array=function(t){return"Uint8Array"===s(t)},e.isUint8ClampedArray=function(t){return"Uint8ClampedArray"===s(t)},e.isUint16Array=function(t){return"Uint16Array"===s(t)},e.isUint32Array=function(t){return"Uint32Array"===s(t)},e.isInt8Array=function(t){return"Int8Array"===s(t)},e.isInt16Array=function(t){return"Int16Array"===s(t)},e.isInt32Array=function(t){return"Int32Array"===s(t)},e.isFloat32Array=function(t){return"Float32Array"===s(t)},e.isFloat64Array=function(t){return"Float64Array"===s(t)},e.isBigInt64Array=function(t){return"BigInt64Array"===s(t)},e.isBigUint64Array=function(t){return"BigUint64Array"===s(t)},b.working="undefined"!==typeof Map&&b(new Map),e.isMap=function(t){return"undefined"!==typeof Map&&(b.working?b(t):t instanceof Map)},y.working="undefined"!==typeof Set&&y(new Set),e.isSet=function(t){return"undefined"!==typeof Set&&(y.working?y(t):t instanceof Set)},v.working="undefined"!==typeof WeakMap&&v(new WeakMap),e.isWeakMap=function(t){return"undefined"!==typeof WeakMap&&(v.working?v(t):t instanceof WeakMap)},w.working="undefined"!==typeof WeakSet&&w(new WeakSet),e.isWeakSet=function(t){return w(t)},x.working="undefined"!==typeof ArrayBuffer&&x(new ArrayBuffer),e.isArrayBuffer=k,S.working="undefined"!==typeof ArrayBuffer&&"undefined"!==typeof DataView&&S(new DataView(new ArrayBuffer(1),0,1)),e.isDataView=I;var N="undefined"!==typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function C(t){return"[object SharedArrayBuffer]"===u(t)}function E(t){return"undefined"!==typeof N&&("undefined"===typeof C.working&&(C.working=C(new N)),C.working?C(t):t instanceof N)}function T(t){return m(t,h)}function A(t){return m(t,d)}function R(t){return m(t,p)}function F(t){return l&&m(t,f)}function _(t){return c&&m(t,g)}e.isSharedArrayBuffer=E,e.isAsyncFunction=function(t){return"[object AsyncFunction]"===u(t)},e.isMapIterator=function(t){return"[object Map Iterator]"===u(t)},e.isSetIterator=function(t){return"[object Set Iterator]"===u(t)},e.isGeneratorObject=function(t){return"[object Generator]"===u(t)},e.isWebAssemblyCompiledModule=function(t){return"[object WebAssembly.Module]"===u(t)},e.isNumberObject=T,e.isStringObject=A,e.isBooleanObject=R,e.isBigIntObject=F,e.isSymbolObject=_,e.isBoxedPrimitive=function(t){return T(t)||A(t)||R(t)||F(t)||_(t)},e.isAnyArrayBuffer=function(t){return"undefined"!==typeof Uint8Array&&(k(t)||E(t))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(t){Object.defineProperty(e,t,{enumerable:!1,value:function(){throw new Error(t+" is not supported in userland")}})}))},6494:(t,e,n)=>{var r=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),n={},r=0;r<e.length;r++)n[e[r]]=Object.getOwnPropertyDescriptor(t,e[r]);return n},a=/%[sdj%]/g;e.format=function(t){if(!y(t)){for(var e=[],n=0;n<arguments.length;n++)e.push(l(arguments[n]));return e.join(" ")}n=1;for(var r=arguments,s=r.length,o=String(t).replace(a,(function(t){if("%%"===t)return"%";if(n>=s)return t;switch(t){case"%s":return String(r[n++]);case"%d":return Number(r[n++]);case"%j":try{return JSON.stringify(r[n++])}catch(e){return"[Circular]"}default:return t}})),i=r[n];n<s;i=r[++n])m(i)||!x(i)?o+=" "+i:o+=" "+l(i);return o},e.deprecate=function(t,n){if("undefined"!==typeof process&&!0===process.noDeprecation)return t;if("undefined"===typeof process)return function(){return e.deprecate(t,n).apply(this,arguments)};var r=!1;return function(){if(!r){if(process.throwDeprecation)throw new Error(n);process.traceDeprecation?console.trace(n):console.error(n),r=!0}return t.apply(this,arguments)}};var s={},o=/^$/;if({NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG){var i={NODE_ENV:"production",PUBLIC_URL:"/supercircle",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.NODE_DEBUG;i=i.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),o=new RegExp("^"+i+"$","i")}function l(t,n){var r={seen:[],stylize:u};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),g(n)?r.showHidden=n:n&&e._extend(r,n),v(r.showHidden)&&(r.showHidden=!1),v(r.depth)&&(r.depth=2),v(r.colors)&&(r.colors=!1),v(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=c),h(r,t,r.depth)}function c(t,e){var n=l.styles[e];return n?"\x1b["+l.colors[n][0]+"m"+t+"\x1b["+l.colors[n][1]+"m":t}function u(t,e){return t}function h(t,n,r){if(t.customInspect&&n&&I(n.inspect)&&n.inspect!==e.inspect&&(!n.constructor||n.constructor.prototype!==n)){var a=n.inspect(r,t);return y(a)||(a=h(t,a,r)),a}var s=function(t,e){if(v(e))return t.stylize("undefined","undefined");if(y(e)){var n="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(n,"string")}if(b(e))return t.stylize(""+e,"number");if(g(e))return t.stylize(""+e,"boolean");if(m(e))return t.stylize("null","null")}(t,n);if(s)return s;var o=Object.keys(n),i=function(t){var e={};return t.forEach((function(t,n){e[t]=!0})),e}(o);if(t.showHidden&&(o=Object.getOwnPropertyNames(n)),S(n)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return d(n);if(0===o.length){if(I(n)){var l=n.name?": "+n.name:"";return t.stylize("[Function"+l+"]","special")}if(w(n))return t.stylize(RegExp.prototype.toString.call(n),"regexp");if(k(n))return t.stylize(Date.prototype.toString.call(n),"date");if(S(n))return d(n)}var c,u="",x=!1,N=["{","}"];(f(n)&&(x=!0,N=["[","]"]),I(n))&&(u=" [Function"+(n.name?": "+n.name:"")+"]");return w(n)&&(u=" "+RegExp.prototype.toString.call(n)),k(n)&&(u=" "+Date.prototype.toUTCString.call(n)),S(n)&&(u=" "+d(n)),0!==o.length||x&&0!=n.length?r<0?w(n)?t.stylize(RegExp.prototype.toString.call(n),"regexp"):t.stylize("[Object]","special"):(t.seen.push(n),c=x?function(t,e,n,r,a){for(var s=[],o=0,i=e.length;o<i;++o)T(e,String(o))?s.push(p(t,e,n,r,String(o),!0)):s.push("");return a.forEach((function(a){a.match(/^\d+$/)||s.push(p(t,e,n,r,a,!0))})),s}(t,n,r,i,o):o.map((function(e){return p(t,n,r,i,e,x)})),t.seen.pop(),function(t,e,n){var r=t.reduce((function(t,e){return e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0);if(r>60)return n[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+n[1];return n[0]+e+" "+t.join(", ")+" "+n[1]}(c,u,N)):N[0]+u+N[1]}function d(t){return"["+Error.prototype.toString.call(t)+"]"}function p(t,e,n,r,a,s){var o,i,l;if((l=Object.getOwnPropertyDescriptor(e,a)||{value:e[a]}).get?i=l.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):l.set&&(i=t.stylize("[Setter]","special")),T(r,a)||(o="["+a+"]"),i||(t.seen.indexOf(l.value)<0?(i=m(n)?h(t,l.value,null):h(t,l.value,n-1)).indexOf("\n")>-1&&(i=s?i.split("\n").map((function(t){return"  "+t})).join("\n").slice(2):"\n"+i.split("\n").map((function(t){return"   "+t})).join("\n")):i=t.stylize("[Circular]","special")),v(o)){if(s&&a.match(/^\d+$/))return i;(o=JSON.stringify(""+a)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.slice(1,-1),o=t.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=t.stylize(o,"string"))}return o+": "+i}function f(t){return Array.isArray(t)}function g(t){return"boolean"===typeof t}function m(t){return null===t}function b(t){return"number"===typeof t}function y(t){return"string"===typeof t}function v(t){return void 0===t}function w(t){return x(t)&&"[object RegExp]"===N(t)}function x(t){return"object"===typeof t&&null!==t}function k(t){return x(t)&&"[object Date]"===N(t)}function S(t){return x(t)&&("[object Error]"===N(t)||t instanceof Error)}function I(t){return"function"===typeof t}function N(t){return Object.prototype.toString.call(t)}function C(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(t){if(t=t.toUpperCase(),!s[t])if(o.test(t)){var n=process.pid;s[t]=function(){var r=e.format.apply(e,arguments);console.error("%s %d: %s",t,n,r)}}else s[t]=function(){};return s[t]},e.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.types=n(9321),e.isArray=f,e.isBoolean=g,e.isNull=m,e.isNullOrUndefined=function(t){return null==t},e.isNumber=b,e.isString=y,e.isSymbol=function(t){return"symbol"===typeof t},e.isUndefined=v,e.isRegExp=w,e.types.isRegExp=w,e.isObject=x,e.isDate=k,e.types.isDate=k,e.isError=S,e.types.isNativeError=S,e.isFunction=I,e.isPrimitive=function(t){return null===t||"boolean"===typeof t||"number"===typeof t||"string"===typeof t||"symbol"===typeof t||"undefined"===typeof t},e.isBuffer=n(5446);var E=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function T(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){console.log("%s - %s",function(){var t=new Date,e=[C(t.getHours()),C(t.getMinutes()),C(t.getSeconds())].join(":");return[t.getDate(),E[t.getMonth()],e].join(" ")}(),e.format.apply(e,arguments))},e.inherits=n(6329),e._extend=function(t,e){if(!e||!x(e))return t;for(var n=Object.keys(e),r=n.length;r--;)t[n[r]]=e[n[r]];return t};var A="undefined"!==typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(t,e){if(!t){var n=new Error("Promise was rejected with a falsy value");n.reason=t,t=n}return e(t)}e.promisify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');if(A&&t[A]){var e;if("function"!==typeof(e=t[A]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,n,r=new Promise((function(t,r){e=t,n=r})),a=[],s=0;s<arguments.length;s++)a.push(arguments[s]);a.push((function(t,r){t?n(t):e(r)}));try{t.apply(this,a)}catch(o){n(o)}return r}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),A&&Object.defineProperty(e,A,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,r(t))},e.promisify.custom=A,e.callbackify=function(t){if("function"!==typeof t)throw new TypeError('The "original" argument must be of type Function');function e(){for(var e=[],n=0;n<arguments.length;n++)e.push(arguments[n]);var r=e.pop();if("function"!==typeof r)throw new TypeError("The last argument must be of type Function");var a=this,s=function(){return r.apply(a,arguments)};t.apply(this,e).then((function(t){process.nextTick(s.bind(null,null,t))}),(function(t){process.nextTick(R.bind(null,t,s))}))}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),Object.defineProperties(e,r(t)),e}},8004:(t,e,n)=>{"use strict";var r=n(1903),a=n(2936),s=n(1712),o=n(2028),i=n(5558),l=o("Object.prototype.toString"),c=n(4635)(),u="undefined"===typeof globalThis?n.g:globalThis,h=a(),d=o("String.prototype.slice"),p=Object.getPrototypeOf,f=o("Array.prototype.indexOf",!0)||function(t,e){for(var n=0;n<t.length;n+=1)if(t[n]===e)return n;return-1},g={__proto__:null};r(h,c&&i&&p?function(t){var e=new u[t];if(Symbol.toStringTag in e){var n=p(e),r=i(n,Symbol.toStringTag);if(!r){var a=p(n);r=i(a,Symbol.toStringTag)}g["$"+t]=s(r.get)}}:function(t){var e=new u[t],n=e.slice||e.set;n&&(g["$"+t]=s(n))});t.exports=function(t){if(!t||"object"!==typeof t)return!1;if(!c){var e=d(l(t),8,-1);return f(h,e)>-1?e:"Object"===e&&function(t){var e=!1;return r(g,(function(n,r){if(!e)try{n(t),e=d(r,1)}catch(a){}})),e}(t)}return i?function(t){var e=!1;return r(g,(function(n,r){if(!e)try{"$"+n(t)===r&&(e=d(r,1))}catch(a){}})),e}(t):null}},7571:()=>{},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},7078:()=>{},6905:()=>{},4637:()=>{},279:()=>{},4222:()=>{},1234:()=>{},2936:(t,e,n)=>{"use strict";var r=n(7163),a="undefined"===typeof globalThis?n.g:globalThis;t.exports=function(){for(var t=[],e=0;e<r.length;e++)"function"===typeof a[r[e]]&&(t[t.length]=r[e]);return t}}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var s=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},(()=>{var t,e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var o={};t=t||[null,e({}),e([]),e(e)];for(var i=2&a&&r;"object"==typeof i&&!~t.indexOf(i);i=e(i))Object.getOwnPropertyNames(i).forEach((t=>o[t]=()=>r[t]));return o.default=()=>r,n.d(s,o),s}})(),n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"===typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),n.p="/supercircle/",(()=>{"use strict";var t={};n.r(t),n.d(t,{assertParamsValid:()=>aN,computeFlatOffset:()=>bN,computeOutShape:()=>oN,getNormalizedAxes:()=>uN,isSliceContinous:()=>mN,maskToAxes:()=>sN,parseSliceParams:()=>yN,sliceInfo:()=>vN,startForAxis:()=>fN,startIndicesWithElidedDims:()=>hN,stopForAxis:()=>gN,stopIndicesWithElidedDims:()=>dN,stridesForAxis:()=>pN,stridesWithElidedDims:()=>iN});var e={};n.r(e),n.d(e,{collectGatherOpShapeInfo:()=>zA,computeOutShape:()=>OA,segOpComputeOptimalWindowSize:()=>DA});var r={};n.r(r),n.d(r,{ERF_A1:()=>ZT,ERF_A2:()=>QT,ERF_A3:()=>$T,ERF_A4:()=>tA,ERF_A5:()=>eA,ERF_P:()=>YT,PARALLELIZE_THRESHOLD:()=>LT,RowPartitionType:()=>FT,SELU_SCALE:()=>JT,SELU_SCALEALPHA:()=>XT,applyActivation:()=>OE,assertAndGetBroadcastShape:()=>UI,assertAxesAreInnerMostDims:()=>TC,assertParamsConsistent:()=>AT,assignToTypedArray:()=>iA,axesAreInnerMostDims:()=>IC,calculateShapes:()=>qT,checkEinsumDimSizes:()=>mA,checkPadOnDimRoundingMode:()=>PN,combineLocations:()=>NC,combineRaggedTensorToTensorShapes:()=>_T,complexWithEvenIndex:()=>aA,complexWithOddIndex:()=>sA,computeConv2DInfo:()=>EN,computeConv3DInfo:()=>TN,computeDefaultPad:()=>AN,computeDilation2DInfo:()=>IN,computeOptimalWindowSize:()=>MT,computeOutAndReduceShapes:()=>CC,computeOutShape:()=>RT,computePool2DInfo:()=>NN,computePool3DInfo:()=>CN,convertConv2DDataFormat:()=>MN,decodeEinsumEquation:()=>fA,eitherStridesOrDilationsAreOne:()=>zN,expandShapeToKeepDim:()=>EC,exponent:()=>cA,exponents:()=>lA,fromStringArrayToUint8:()=>MA,fromUint8ToStringArray:()=>LA,getAxesPermutation:()=>AC,getBroadcastDims:()=>BI,getComplexWithIndex:()=>oA,getEinsumComputePath:()=>bA,getEinsumPermutation:()=>gA,getFusedBiasGradient:()=>DE,getFusedDyActivation:()=>_E,getImageCenter:()=>PT,getInnerMostAxes:()=>FC,getPermuted:()=>WT,getRaggedRank:()=>OT,getReductionAxes:()=>WI,getReshaped:()=>BT,getReshapedPermuted:()=>UT,getRowPartitionTypesHelper:()=>DT,getSliceBeginCoords:()=>VT,getSliceSize:()=>jT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>xA,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>kA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>SA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>CA,getSparseReshapeInputOutputMismatchErrorMessage:()=>TA,getSparseReshapeInputOutputMultipleErrorMessage:()=>EA,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>IA,getSparseReshapeNegativeOutputDimErrorMessage:()=>NA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>_A,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>AA,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>RA,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>FA,getUndoAxesPermutation:()=>RC,isIdentityPermutation:()=>yA,log:()=>Kx,mergeRealAndImagArrays:()=>nA,prepareAndValidate:()=>GT,prepareSplitSize:()=>wA,segment_util:()=>e,shouldFuse:()=>zE,slice_util:()=>t,splitRealAndImagArrays:()=>rA,stridesOrDilationsArePositive:()=>LN,tupleValuesAreOne:()=>ON,upcastType:()=>Kk,validateDefaultValueShape:()=>zT,validateInput:()=>KT,validateUpdateShape:()=>HT,warn:()=>Hx});var a={};n.r(a),n.d(a,{addImpl:()=>NB,bincountImpl:()=>bW,bincountReduceImpl:()=>yW,bitwiseAndImpl:()=>wW,castImpl:()=>wB,ceilImpl:()=>SW,concatImpl:()=>AW,equalImpl:()=>pU,expImpl:()=>IU,expm1Impl:()=>AU,floorImpl:()=>KU,gatherNdImpl:()=>tV,gatherV2Impl:()=>nV,greaterEqualImpl:()=>iV,greaterImpl:()=>aV,lessEqualImpl:()=>wV,lessImpl:()=>bV,linSpaceImpl:()=>SV,logImpl:()=>NV,maxImpl:()=>WV,maximumImpl:()=>jV,minimumImpl:()=>$V,multiplyImpl:()=>sU,negImpl:()=>cj,notEqualImpl:()=>bj,prodImpl:()=>Rj,raggedGatherImpl:()=>zj,raggedRangeImpl:()=>Pj,raggedTensorToTensorImpl:()=>Gj,rangeImpl:()=>Kj,rsqrtImpl:()=>aG,scatterImpl:()=>iG,sigmoidImpl:()=>hB,simpleAbsImpl:()=>OB,sliceImpl:()=>pW,sparseFillEmptyRowsImpl:()=>EG,sparseReshapeImpl:()=>AG,sparseSegmentReductionImpl:()=>FG,sqrtImpl:()=>LG,staticRegexReplaceImpl:()=>jG,stridedSliceImpl:()=>XG,stringNGramsImpl:()=>ZG,stringSplitImpl:()=>tH,stringToHashBucketFastImpl:()=>nH,subImpl:()=>zU,tileImpl:()=>lH,topKImpl:()=>dH,transposeImpl:()=>UB,uniqueImpl:()=>vH});var s,o=n(5043),i=n.t(o,2),l=n(4391),c=n(7950),u=n.t(c,2);function h(){return h=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},h.apply(this,arguments)}!function(t){t.Pop="POP",t.Push="PUSH",t.Replace="REPLACE"}(s||(s={}));const d="popstate";function p(t,e){if(!1===t||null===t||"undefined"===typeof t)throw new Error(e)}function f(t,e){if(!t){"undefined"!==typeof console&&console.warn(e);try{throw new Error(e)}catch(n){}}}function g(t,e){return{usr:t.state,key:t.key,idx:e}}function m(t,e,n,r){return void 0===n&&(n=null),h({pathname:"string"===typeof t?t:t.pathname,search:"",hash:""},"string"===typeof e?y(e):e,{state:n,key:e&&e.key||r||Math.random().toString(36).substr(2,8)})}function b(t){let{pathname:e="/",search:n="",hash:r=""}=t;return n&&"?"!==n&&(e+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(e+="#"===r.charAt(0)?r:"#"+r),e}function y(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let r=t.indexOf("?");r>=0&&(e.search=t.substr(r),t=t.substr(0,r)),t&&(e.pathname=t)}return e}function v(t,e,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:o=!1}=r,i=a.history,l=s.Pop,c=null,u=f();function f(){return(i.state||{idx:null}).idx}function y(){l=s.Pop;let t=f(),e=null==t?null:t-u;u=t,c&&c({action:l,location:w.location,delta:e})}function v(t){let e="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof t?t:b(t);return n=n.replace(/ $/,"%20"),p(e,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,e)}null==u&&(u=0,i.replaceState(h({},i.state,{idx:u}),""));let w={get action(){return l},get location(){return t(a,i)},listen(t){if(c)throw new Error("A history only accepts one active listener");return a.addEventListener(d,y),c=t,()=>{a.removeEventListener(d,y),c=null}},createHref:t=>e(a,t),createURL:v,encodeLocation(t){let e=v(t);return{pathname:e.pathname,search:e.search,hash:e.hash}},push:function(t,e){l=s.Push;let r=m(w.location,t,e);n&&n(r,t),u=f()+1;let h=g(r,u),d=w.createHref(r);try{i.pushState(h,"",d)}catch(p){if(p instanceof DOMException&&"DataCloneError"===p.name)throw p;a.location.assign(d)}o&&c&&c({action:l,location:w.location,delta:1})},replace:function(t,e){l=s.Replace;let r=m(w.location,t,e);n&&n(r,t),u=f();let a=g(r,u),h=w.createHref(r);i.replaceState(a,"",h),o&&c&&c({action:l,location:w.location,delta:0})},go:t=>i.go(t)};return w}var w;!function(t){t.data="data",t.deferred="deferred",t.redirect="redirect",t.error="error"}(w||(w={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function x(t,e,n){void 0===n&&(n="/");let r=z(("string"===typeof e?y(e):e).pathname||"/",n);if(null==r)return null;let a=k(t);!function(t){t.sort(((t,e)=>t.score!==e.score?e.score-t.score:function(t,e){let n=t.length===e.length&&t.slice(0,-1).every(((t,n)=>t===e[n]));return n?t[t.length-1]-e[e.length-1]:0}(t.routesMeta.map((t=>t.childrenIndex)),e.routesMeta.map((t=>t.childrenIndex)))))}(a);let s=null;for(let o=0;null==s&&o<a.length;++o){let t=O(r);s=_(a[o],t)}return s}function k(t,e,n,r){void 0===e&&(e=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(t,a,s)=>{let o={relativePath:void 0===s?t.path||"":s,caseSensitive:!0===t.caseSensitive,childrenIndex:a,route:t};o.relativePath.startsWith("/")&&(p(o.relativePath.startsWith(r),'Absolute route path "'+o.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),o.relativePath=o.relativePath.slice(r.length));let i=W([r,o.relativePath]),l=n.concat(o);t.children&&t.children.length>0&&(p(!0!==t.index,'Index routes must not have child routes. Please remove all child routes from route path "'+i+'".'),k(t.children,e,l,i)),(null!=t.path||t.index)&&e.push({path:i,score:F(i,t.index),routesMeta:l})};return t.forEach(((t,e)=>{var n;if(""!==t.path&&null!=(n=t.path)&&n.includes("?"))for(let r of S(t.path))a(t,e,r);else a(t,e)})),e}function S(t){let e=t.split("/");if(0===e.length)return[];let[n,...r]=e,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let o=S(r.join("/")),i=[];return i.push(...o.map((t=>""===t?s:[s,t].join("/")))),a&&i.push(...o),i.map((e=>t.startsWith("/")&&""===e?"/":e))}const I=/^:[\w-]+$/,N=3,C=2,E=1,T=10,A=-2,R=t=>"*"===t;function F(t,e){let n=t.split("/"),r=n.length;return n.some(R)&&(r+=A),e&&(r+=C),n.filter((t=>!R(t))).reduce(((t,e)=>t+(I.test(e)?N:""===e?E:T)),r)}function _(t,e){let{routesMeta:n}=t,r={},a="/",s=[];for(let o=0;o<n.length;++o){let t=n[o],i=o===n.length-1,l="/"===a?e:e.slice(a.length)||"/",c=D({path:t.relativePath,caseSensitive:t.caseSensitive,end:i},l);if(!c)return null;Object.assign(r,c.params);let u=t.route;s.push({params:r,pathname:W([a,c.pathname]),pathnameBase:U(W([a,c.pathnameBase])),route:u}),"/"!==c.pathnameBase&&(a=W([a,c.pathnameBase]))}return s}function D(t,e){"string"===typeof t&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=function(t,e,n){void 0===e&&(e=!1);void 0===n&&(n=!0);f("*"===t||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were "'+t.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+t.replace(/\*$/,"/*")+'".');let r=[],a="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((t,e,n)=>(r.push({paramName:e,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));t.endsWith("*")?(r.push({paramName:"*"}),a+="*"===t||"/*"===t?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==t&&"/"!==t&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,e?void 0:"i");return[s,r]}(t.path,t.caseSensitive,t.end),a=e.match(n);if(!a)return null;let s=a[0],o=s.replace(/(.)\/+$/,"$1"),i=a.slice(1);return{params:r.reduce(((t,e,n)=>{let{paramName:r,isOptional:a}=e;if("*"===r){let t=i[n]||"";o=s.slice(0,s.length-t.length).replace(/(.)\/+$/,"$1")}const l=i[n];return t[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),t}),{}),pathname:s,pathnameBase:o,pattern:t}}function O(t){try{return t.split("/").map((t=>decodeURIComponent(t).replace(/\//g,"%2F"))).join("/")}catch(e){return f(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+e+")."),t}}function z(t,e){if("/"===e)return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,r=t.charAt(n);return r&&"/"!==r?null:t.slice(n)||"/"}function L(t,e,n,r){return"Cannot include a '"+t+"' character in a manually specified `to."+e+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function M(t){return t.filter(((t,e)=>0===e||t.route.path&&t.route.path.length>0))}function P(t,e){let n=M(t);return e?n.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase)):n.map((t=>t.pathnameBase))}function B(t,e,n,r){let a;void 0===r&&(r=!1),"string"===typeof t?a=y(t):(a=h({},t),p(!a.pathname||!a.pathname.includes("?"),L("?","pathname","search",a)),p(!a.pathname||!a.pathname.includes("#"),L("#","pathname","hash",a)),p(!a.search||!a.search.includes("#"),L("#","search","hash",a)));let s,o=""===t||""===a.pathname,i=o?"/":a.pathname;if(null==i)s=n;else{let t=e.length-1;if(!r&&i.startsWith("..")){let e=i.split("/");for(;".."===e[0];)e.shift(),t-=1;a.pathname=e.join("/")}s=t>=0?e[t]:"/"}let l=function(t,e){void 0===e&&(e="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof t?y(t):t,s=n?n.startsWith("/")?n:function(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach((t=>{".."===t?n.length>1&&n.pop():"."!==t&&n.push(t)})),n.length>1?n.join("/"):"/"}(n,e):e;return{pathname:s,search:V(r),hash:j(a)}}(a,s),c=i&&"/"!==i&&i.endsWith("/"),u=(o||"."===i)&&n.endsWith("/");return l.pathname.endsWith("/")||!c&&!u||(l.pathname+="/"),l}const W=t=>t.join("/").replace(/\/\/+/g,"/"),U=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),V=t=>t&&"?"!==t?t.startsWith("?")?t:"?"+t:"",j=t=>t&&"#"!==t?t.startsWith("#")?t:"#"+t:"";Error;function G(t){return null!=t&&"number"===typeof t.status&&"string"===typeof t.statusText&&"boolean"===typeof t.internal&&"data"in t}const H=["post","put","patch","delete"],K=(new Set(H),["get",...H]);new Set(K),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function q(){return q=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},q.apply(this,arguments)}const X=o.createContext(null);const J=o.createContext(null);const Y=o.createContext(null);const Z=o.createContext(null);const Q=o.createContext({outlet:null,matches:[],isDataRoute:!1});const $=o.createContext(null);function tt(){return null!=o.useContext(Z)}function et(){return tt()||p(!1),o.useContext(Z).location}function nt(t){o.useContext(Y).static||o.useLayoutEffect(t)}function rt(){let{isDataRoute:t}=o.useContext(Q);return t?function(){let{router:t}=pt(ht.UseNavigateStable),e=gt(dt.UseNavigateStable),n=o.useRef(!1);return nt((()=>{n.current=!0})),o.useCallback((function(r,a){void 0===a&&(a={}),n.current&&("number"===typeof r?t.navigate(r):t.navigate(r,q({fromRouteId:e},a)))}),[t,e])}():function(){tt()||p(!1);let t=o.useContext(X),{basename:e,future:n,navigator:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,n.v7_relativeSplatPath)),l=o.useRef(!1);nt((()=>{l.current=!0}));let c=o.useCallback((function(n,a){if(void 0===a&&(a={}),!l.current)return;if("number"===typeof n)return void r.go(n);let o=B(n,JSON.parse(i),s,"path"===a.relative);null==t&&"/"!==e&&(o.pathname="/"===o.pathname?e:W([e,o.pathname])),(a.replace?r.replace:r.push)(o,a.state,a)}),[e,r,i,s,t]);return c}()}function at(t,e){let{relative:n}=void 0===e?{}:e,{future:r}=o.useContext(Y),{matches:a}=o.useContext(Q),{pathname:s}=et(),i=JSON.stringify(P(a,r.v7_relativeSplatPath));return o.useMemo((()=>B(t,JSON.parse(i),s,"path"===n)),[t,i,s,n])}function st(t,e,n,r){tt()||p(!1);let{navigator:a}=o.useContext(Y),{matches:i}=o.useContext(Q),l=i[i.length-1],c=l?l.params:{},u=(l&&l.pathname,l?l.pathnameBase:"/");l&&l.route;let h,d=et();if(e){var f;let t="string"===typeof e?y(e):e;"/"===u||(null==(f=t.pathname)?void 0:f.startsWith(u))||p(!1),h=t}else h=d;let g=h.pathname||"/",m=g;if("/"!==u){let t=u.replace(/^\//,"").split("/");m="/"+g.replace(/^\//,"").split("/").slice(t.length).join("/")}let b=x(t,{pathname:m});let v=ut(b&&b.map((t=>Object.assign({},t,{params:Object.assign({},c,t.params),pathname:W([u,a.encodeLocation?a.encodeLocation(t.pathname).pathname:t.pathname]),pathnameBase:"/"===t.pathnameBase?u:W([u,a.encodeLocation?a.encodeLocation(t.pathnameBase).pathname:t.pathnameBase])}))),i,n,r);return e&&v?o.createElement(Z.Provider,{value:{location:q({pathname:"/",search:"",hash:"",state:null,key:"default"},h),navigationType:s.Pop}},v):v}function ot(){let t=function(){var t;let e=o.useContext($),n=ft(dt.UseRouteError),r=gt(dt.UseRouteError);if(void 0!==e)return e;return null==(t=n.errors)?void 0:t[r]}(),e=G(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return o.createElement(o.Fragment,null,o.createElement("h2",null,"Unexpected Application Error!"),o.createElement("h3",{style:{fontStyle:"italic"}},e),n?o.createElement("pre",{style:a},n):null,null)}const it=o.createElement(ot,null);class lt extends o.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,e){return e.location!==t.location||"idle"!==e.revalidation&&"idle"===t.revalidation?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:void 0!==t.error?t.error:e.error,location:e.location,revalidation:t.revalidation||e.revalidation}}componentDidCatch(t,e){console.error("React Router caught the following error during render",t,e)}render(){return void 0!==this.state.error?o.createElement(Q.Provider,{value:this.props.routeContext},o.createElement($.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function ct(t){let{routeContext:e,match:n,children:r}=t,a=o.useContext(X);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),o.createElement(Q.Provider,{value:e},r)}function ut(t,e,n,r){var a;if(void 0===e&&(e=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==t){var s;if(null==(s=n)||!s.errors)return null;t=n.matches}let i=t,l=null==(a=n)?void 0:a.errors;if(null!=l){let t=i.findIndex((t=>t.route.id&&(null==l?void 0:l[t.route.id])));t>=0||p(!1),i=i.slice(0,Math.min(i.length,t+1))}let c=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let o=0;o<i.length;o++){let t=i[o];if((t.route.HydrateFallback||t.route.hydrateFallbackElement)&&(u=o),t.route.id){let{loaderData:e,errors:r}=n,a=t.route.loader&&void 0===e[t.route.id]&&(!r||void 0===r[t.route.id]);if(t.route.lazy||a){c=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((t,r,a)=>{let s,h=!1,d=null,p=null;var f;n&&(s=l&&r.route.id?l[r.route.id]:void 0,d=r.route.errorElement||it,c&&(u<0&&0===a?(f="route-fallback",!1||mt[f]||(mt[f]=!0),h=!0,p=null):u===a&&(h=!0,p=r.route.hydrateFallbackElement||null)));let g=e.concat(i.slice(0,a+1)),m=()=>{let e;return e=s?d:h?p:r.route.Component?o.createElement(r.route.Component,null):r.route.element?r.route.element:t,o.createElement(ct,{match:r,routeContext:{outlet:t,matches:g,isDataRoute:null!=n},children:e})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?o.createElement(lt,{location:n.location,revalidation:n.revalidation,component:d,error:s,children:m(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):m()}),null)}var ht=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(ht||{}),dt=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(dt||{});function pt(t){let e=o.useContext(X);return e||p(!1),e}function ft(t){let e=o.useContext(J);return e||p(!1),e}function gt(t){let e=function(t){let e=o.useContext(Q);return e||p(!1),e}(),n=e.matches[e.matches.length-1];return n.route.id||p(!1),n.route.id}const mt={};i.startTransition;function bt(t){p(!1)}function yt(t){let{basename:e="/",children:n=null,location:r,navigationType:a=s.Pop,navigator:i,static:l=!1,future:c}=t;tt()&&p(!1);let u=e.replace(/^\/*/,"/"),h=o.useMemo((()=>({basename:u,navigator:i,static:l,future:q({v7_relativeSplatPath:!1},c)})),[u,c,i,l]);"string"===typeof r&&(r=y(r));let{pathname:d="/",search:f="",hash:g="",state:m=null,key:b="default"}=r,v=o.useMemo((()=>{let t=z(d,u);return null==t?null:{location:{pathname:t,search:f,hash:g,state:m,key:b},navigationType:a}}),[u,d,f,g,m,b,a]);return null==v?null:o.createElement(Y.Provider,{value:h},o.createElement(Z.Provider,{children:n,value:v}))}function vt(t){let{children:e,location:n}=t;return st(wt(e),n)}new Promise((()=>{}));o.Component;function wt(t,e){void 0===e&&(e=[]);let n=[];return o.Children.forEach(t,((t,r)=>{if(!o.isValidElement(t))return;let a=[...e,r];if(t.type===o.Fragment)return void n.push.apply(n,wt(t.props.children,a));t.type!==bt&&p(!1),t.props.index&&t.props.children&&p(!1);let s={id:t.props.id||a.join("-"),caseSensitive:t.props.caseSensitive,element:t.props.element,Component:t.props.Component,index:t.props.index,path:t.props.path,loader:t.props.loader,action:t.props.action,errorElement:t.props.errorElement,ErrorBoundary:t.props.ErrorBoundary,hasErrorBoundary:null!=t.props.ErrorBoundary||null!=t.props.errorElement,shouldRevalidate:t.props.shouldRevalidate,handle:t.props.handle,lazy:t.props.lazy};t.props.children&&(s.children=wt(t.props.children,a)),n.push(s)})),n}function xt(){return xt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},xt.apply(this,arguments)}function kt(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const St=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"];try{window.__reactRouterVersion="6"}catch(v1){}new Map;const It=i.startTransition;u.flushSync,i.useId;function Nt(t){let{basename:e,children:n,future:r,window:a}=t,s=o.useRef();var i;null==s.current&&(s.current=(void 0===(i={window:a,v5Compat:!0})&&(i={}),v((function(t,e){let{pathname:n,search:r,hash:a}=t.location;return m("",{pathname:n,search:r,hash:a},e.state&&e.state.usr||null,e.state&&e.state.key||"default")}),(function(t,e){return"string"===typeof e?e:b(e)}),null,i)));let l=s.current,[c,u]=o.useState({action:l.action,location:l.location}),{v7_startTransition:h}=r||{},d=o.useCallback((t=>{h&&It?It((()=>u(t))):u(t)}),[u,h]);return o.useLayoutEffect((()=>l.listen(d)),[l,d]),o.createElement(yt,{basename:e,children:n,location:c.location,navigationType:c.action,navigator:l,future:r})}const Ct="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Et=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Tt=o.forwardRef((function(t,e){let n,{onClick:r,relative:a,reloadDocument:s,replace:i,state:l,target:c,to:u,preventScrollReset:h,unstable_viewTransition:d}=t,f=kt(t,St),{basename:g}=o.useContext(Y),m=!1;if("string"===typeof u&&Et.test(u)&&(n=u,Ct))try{let t=new URL(window.location.href),e=u.startsWith("//")?new URL(t.protocol+u):new URL(u),n=z(e.pathname,g);e.origin===t.origin&&null!=n?u=n+e.search+e.hash:m=!0}catch(v1){}let y=function(t,e){let{relative:n}=void 0===e?{}:e;tt()||p(!1);let{basename:r,navigator:a}=o.useContext(Y),{hash:s,pathname:i,search:l}=at(t,{relative:n}),c=i;return"/"!==r&&(c="/"===i?r:W([r,i])),a.createHref({pathname:c,search:l,hash:s})}(u,{relative:a}),v=function(t,e){let{target:n,replace:r,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l}=void 0===e?{}:e,c=rt(),u=et(),h=at(t,{relative:i});return o.useCallback((e=>{if(function(t,e){return 0===t.button&&(!e||"_self"===e)&&!function(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}(t)}(e,n)){e.preventDefault();let n=void 0!==r?r:b(u)===b(h);c(t,{replace:n,state:a,preventScrollReset:s,relative:i,unstable_viewTransition:l})}}),[u,c,h,r,a,n,t,s,i,l])}(u,{replace:i,state:l,target:c,preventScrollReset:h,relative:a,unstable_viewTransition:d});return o.createElement("a",xt({},f,{href:n||y,onClick:m||s?r:function(t){r&&r(t),t.defaultPrevented||v(t)},ref:e,target:c}))}));var At,Rt;(function(t){t.UseScrollRestoration="useScrollRestoration",t.UseSubmit="useSubmit",t.UseSubmitFetcher="useSubmitFetcher",t.UseFetcher="useFetcher",t.useViewTransitionState="useViewTransitionState"})(At||(At={})),function(t){t.UseFetcher="useFetcher",t.UseFetchers="useFetchers",t.UseScrollRestoration="useScrollRestoration"}(Rt||(Rt={}));var Ft={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},_t=o.createContext&&o.createContext(Ft),Dt=["attr","size","title"];function Ot(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}function zt(){return zt=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},zt.apply(this,arguments)}function Lt(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function Mt(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?Lt(Object(n),!0).forEach((function(e){Pt(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):Lt(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function Pt(t,e,n){return e=function(t){var e=function(t,e){if("object"!==typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!==typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"===typeof e?e:String(e)}(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function Bt(t){return t&&t.map(((t,e)=>o.createElement(t.tag,Mt({key:e},t.attr),Bt(t.child))))}function Wt(t){return e=>o.createElement(Ut,zt({attr:Mt({},t.attr)},e),Bt(t.child))}function Ut(t){var e=e=>{var n,{attr:r,size:a,title:s}=t,i=Ot(t,Dt),l=a||e.size||"1em";return e.className&&(n=e.className),t.className&&(n=(n?n+" ":"")+t.className),o.createElement("svg",zt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},e.attr,r,i,{className:n,style:Mt(Mt({color:t.color||e.color},e.style),t.style),height:l,width:l,xmlns:"http://www.w3.org/2000/svg"}),s&&o.createElement("title",null,s),t.children)};return void 0!==_t?o.createElement(_t.Consumer,null,(t=>e(t))):e(Ft)}function Vt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"21",y1:"10",x2:"3",y2:"10"},child:[]},{tag:"line",attr:{x1:"21",y1:"6",x2:"3",y2:"6"},child:[]},{tag:"line",attr:{x1:"21",y1:"14",x2:"3",y2:"14"},child:[]},{tag:"line",attr:{x1:"21",y1:"18",x2:"3",y2:"18"},child:[]}]})(t)}function jt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"path",attr:{d:"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"},child:[]},{tag:"polyline",attr:{points:"3.27 6.96 12 12.01 20.73 6.96"},child:[]},{tag:"line",attr:{x1:"12",y1:"22.08",x2:"12",y2:"12"},child:[]}]})(t)}function Gt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"line",attr:{x1:"18",y1:"6",x2:"6",y2:"18"},child:[]},{tag:"line",attr:{x1:"6",y1:"6",x2:"18",y2:"18"},child:[]}]})(t)}var Ht=n(579);const Kt=function(){const[t,e]=(0,o.useState)(!1),[n,r]=(0,o.useState)(!1),a=()=>e(!1);return window.addEventListener("resize",(()=>{window.innerWidth<=960?r(!1):r(!0)})),(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)("nav",{className:"navbar",children:(0,Ht.jsxs)("div",{className:"navbar-container",children:[(0,Ht.jsxs)(Tt,{to:"/",className:"navbar-logo",onClick:a,children:["CIRCLE ",(0,Ht.jsx)(jt,{className:"name-icon"})]}),(0,Ht.jsx)("div",{className:"menu-icon",onClick:()=>e(!t),children:t?(0,Ht.jsx)(Gt,{className:"close-icon"}):(0,Ht.jsx)(Vt,{className:"open-icon"})}),(0,Ht.jsxs)("ul",{className:t?"nav-menu active":"nav-menu",children:[(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/",className:"nav-links",onClick:a,children:"Home"})}),(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/projects",className:"nav-links",onClick:a,children:"Projects"})})," ",(0,Ht.jsx)("li",{className:"nav-item",children:(0,Ht.jsx)(Tt,{to:"/contact",className:"nav-links",onClick:a,children:"Contact Info"})})]})]})})})};function qt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"},child:[]}]})(t)}function Xt(t){return Wt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M913.9 552.2L805 181.4v-.1c-7.6-22.9-25.7-36.5-48.3-36.5-23.4 0-42.5 13.5-49.7 35.2l-71.4 213H388.8l-71.4-213c-7.2-21.7-26.3-35.2-49.7-35.2-23.1 0-42.5 14.8-48.4 36.6L110.5 552.2c-4.4 14.7 1.2 31.4 13.5 40.7l368.5 276.4c2.6 3.6 6.2 6.3 10.4 7.8l8.6 6.4 8.5-6.4c4.9-1.7 9-4.7 11.9-8.9l368.4-275.4c12.4-9.2 18-25.9 13.6-40.6zM751.7 193.4c1-1.8 2.9-1.9 3.5-1.9 1.1 0 2.5.3 3.4 3L818 394.3H684.5l67.2-200.9zm-487.4 1c.9-2.6 2.3-2.9 3.4-2.9 2.7 0 2.9.1 3.4 1.7l67.3 201.2H206.5l57.8-200zM158.8 558.7l28.2-97.3 202.4 270.2-230.6-172.9zm73.9-116.4h122.1l90.8 284.3-212.9-284.3zM512.9 776L405.7 442.3H620L512.9 776zm157.9-333.7h119.5L580 723.1l90.8-280.8zm-40.7 293.9l207.3-276.7 29.5 99.2-236.8 177.5z"},child:[]}]})(t)}const Jt=function(){return(0,Ht.jsx)("div",{className:"contact-page",children:(0,Ht.jsx)("a",{href:"https://www.linkedin.com/in/wiramonth/",children:(0,Ht.jsx)(qt,{className:"sns-icon"})})})};const Yt=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Jt,{})})},Zt=n.p+"static/media/video3.438dba662d3f94358903.mp4";const Qt=function(){return(0,Ht.jsx)("div",{className:"hero-container",children:(0,Ht.jsx)("video",{src:Zt,autoPlay:!0,loop:!0,muted:!0})})};const $t=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(Qt,{})})};class te{refCount(t){return ee("refCount")}incRef(t){return ee("incRef")}timerAvailable(){return!0}time(t){return ee("time")}read(t){return ee("read")}readSync(t){return ee("readSync")}readToGPU(t,e){return ee("readToGPU")}numDataIds(){return ee("numDataIds")}disposeData(t,e){return ee("disposeData")}write(t,e,n){return ee("write")}move(t,e,n,r,a){return ee("move")}memory(){return ee("memory")}floatPrecision(){return ee("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return ee("dispose")}}function ee(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function ne(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,re(t,e,n)}function re(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function ae(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function se(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";ae(ce(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function oe(t){ae(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function ie(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),Array.isArray(t)||pe(t)&&!n)for(let r=0;r<t.length;++r)ie(t[r],e,n);else e.push(t);return e}function le(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function ce(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ue(t){return t%1===0}function he(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function de(t,e){const n=e.length;return ae((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),ae(t.every((t=>ue(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function pe(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function fe(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function ge(t){return"string"===typeof t||t instanceof String}function me(t){return"number"===typeof t}function be(t){return Array.isArray(t)?be(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":me(t)?"float32":ge(t)?"string":"boolean"===typeof t?"bool":"float32"}function ye(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ve(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function we(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=we(t+e*i,o,n,r)}return a}function xe(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return we(0,t,e,n)}function ke(t,e){const n=Se(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Se(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function Ie(t){t.forEach((e=>{ae(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function Ne(t){return t&&t.then&&"function"===typeof t.then}const Ce="tfjsflags";class Ee{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Te,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ne(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Ce in t){t[Ce].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if("".concat(+e)===e)return+e;throw new Error("Could not parse value flag value ".concat(e," for flag ").concat(t,"."))}(e,n)}))}}}function Te(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Ae(){return Fe}let Re,Fe=null;function _e(){if(null==Re){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Re=t}return Re}function De(t,e){const n=function(){const t=_e();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Oe="Add",ze="ArgMax",Le="AvgPool",Me="AvgPool3D",Pe="BatchMatMul",Be="BatchToSpaceND",We="Cast",Ue="ClipByValue",Ve="ComplexAbs",je="Concat",Ge="Conv2D",He="Conv2DBackpropInput",Ke="Conv3D",qe="Cosh",Xe="Cumsum",Je="DepthwiseConv2dNative",Ye="RealDiv",Ze="ExpandDims",Qe="Fill",$e="Floor",tn="FloorDiv",en="FusedBatchNorm",nn="GatherV2",rn="GreaterEqual",an="Identity",sn="LeakyRelu",on="Log1p",ln="Maximum",cn="MaxPool",un="MaxPool3D",hn="Mean",dn="Minimum",pn="Multiply",fn="OnesLike",gn="OneHot",mn="Pack",bn="PadV2",yn="Prelu",vn="Range",wn="Relu",xn="Reshape",kn="ResizeNearestNeighbor",Sn="ResizeBilinear",In="Relu6",Nn="Reverse",Cn="Round",En="Rsqrt",Tn="Select",An="Selu",Rn="Slice",Fn="Sinh",_n="Sigmoid",Dn="Softplus",On="Sqrt",zn="SpaceToBatchND",Ln="SplitV",Mn="Softmax",Pn="SquaredDifference",Bn="Tanh",Wn="Tile",Un="Transpose",Vn="Unpack",jn="UnsortedSegmentSum",Gn="ZerosLike",Hn="Step",Kn="FromPixels",qn="_FusedMatMul",Xn="FusedConv2D",Jn="FusedDepthwiseConv2D";function Yn(){Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn(...arguments)}const Zn=De("kernelRegistry",(()=>new Map)),Qn=De("gradRegistry",(()=>new Map));function $n(t,e){const n=rr(t,e);return Zn.get(n)}function tr(t){return Qn.get(t)}function er(t){const e=Zn.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function nr(t){const{kernelName:e}=t;Qn.has(e)&&Ae().getBool("DEBUG")&&Yn("Overriding the gradient for '".concat(e,"'")),Qn.set(e,t)}function rr(t,e){return"".concat(e,"_").concat(t)}var ar=n(7353),sr=n.n(ar);const or=sr()||ar;function ir(t){return or.fromString(t,!0,16)}ir("c3a5c85c97cb3127"),ir("b492b66fbe98f273"),ir("9ae16a3b2f90404f");function lr(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=ie(t)),Ae().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function cr(){return Ae().platform.now()}function ur(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ae().platform.encode(t,e)}function hr(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ae().platform.decode(t,e)}class dr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new fr)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=cr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:cr()-o})}if(Ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{pr(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function pr(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class fr{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?he("".concat(r,"ms"),9):r.error,i=he(t,25),l=e.rank,c=e.size,u=he(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const gr=20,mr=3,br=7;function yr(t,e,n,r){const a=ve(e),s=function(t,e,n,r){const a=le(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?kr(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],vr(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=xr(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function vr(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(br))," + ")+"".concat(parseFloat(t[1].toFixed(br)),"j"):ge(t)?"'".concat(t,"'"):"bool"===n?wr(t):parseFloat(t.toFixed(br)).toString(),he(r,e)}function wr(t){return 0===t?"false":"true"}function xr(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[vr(kr(t)[0],0,n)]}return"bool"===n?[wr(t[0])]:[t[0].toString()]}if(1===l){if(i>gr){const e=mr*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-mr)*o,i*o));return"complex64"===n&&(r=kr(r),s=kr(s)),["["+r.map(((t,e)=>vr(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>vr(t,a[i-mr+e],n))).join(", ")+"]"]}return["["+("complex64"===n?kr(t):Array.from(t)).map(((t,e)=>vr(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>gr){for(let e=0;e<mr;e++){const r=e*h,s=r+h;d.push(...xr(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-mr;e<i;e++){const r=e*h,s=r+h;d.push(...xr(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...xr(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function kr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Sr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=le(t),null!=n){const t=n.length;ae(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||function(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}(e,this.size),this.strides=ve(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),ae(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ir().makeTensor(this.values,this.shape,this.dtype)}}let Ir=null,Nr=null,Cr=null;class Er{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=le(t),this.strides=ve(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Nr.buffer(this.shape,this.dtype,t)}bufferSync(){return Nr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return xe(this.shape,t,"complex64"===this.dtype)}arraySync(){return xe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Ir().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>hr(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ir().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ir().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>hr(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ir().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ir().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Nr.print(this,t)}clone(){return this.throwIfDisposed(),Nr.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return yr(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Nr.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Ir().makeVariable(this,t,e,n)}}Object.defineProperty(Er,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),De("Tensor",(()=>Er));class Tr extends Er{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!ce(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Ir().disposeTensor(this),this.dataId=t.dataId,Ir().incRef(this,null)}dispose(){Ir().disposeVariable(this),this.isDisposedInternal=!0}}var Ar,Rr,Fr,_r,Dr;Object.defineProperty(Tr,Symbol.hasInstance,{value:t=>t instanceof Er&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Ar||(Ar={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Rr||(Rr={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Fr||(Fr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(_r||(_r={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Dr||(Dr={}));const Or={float32:_r,int32:Rr,bool:Fr,complex64:Dr};function zr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return Or[t][e]}function Lr(t,e){if(t.dtype===e.dtype)return[t,e];const n=zr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Mr(t,e){return e.some((e=>e.id===t.id))}function Pr(t){const e=[];return Br(t,e,new Set),e}function Br(t,e,n){if(null==t)return;if(t instanceof Er)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),Br(t,e,n))}}function Wr(t){return null!=t.kernelName}class Ur{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Vr{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ur}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(Yn("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new dr(this.backendInstance),!0}setupRegisteredKernels(){er(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){er(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof te||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Yn("Initialization of backend ".concat(t," failed")),Yn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return Yn("Initialization of backend ".concat(t," failed")),Yn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return Vr.nextTensorId++}nextVariableId(){return Vr.nextVariableId++}clone(t){const e=Gr.runKernel(an,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return Gr.runKernel(We,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=$n(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Wr(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Wr(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=$n(e,this.backendName);ae(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=Wr(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=tr(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(ae(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&ge(t[0])&&(a=t.map((t=>ur(t))));const s=r.write(a,e,n),o=new Er(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Er(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Tr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*fe(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Tr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*fe(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=tr(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=Se(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Pr(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(ae(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));ae(a instanceof Er,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=ke(le(t),"float32");return Gr.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!ce(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),Hr);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return ae(ye(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;ae(r.every((t=>t instanceof Er)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),ae(s.value instanceof Er,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),ae(ye(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];ae(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),ae(a.every((t=>t instanceof Er)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=cr(),n=await this.backend.time(t);return n.wallMs=cr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ur;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function jr(){const t=_e();if(null==t._tfengine){const e=new Ee(t);t._tfengine=new Vr(e)}var e;return e=t._tfengine.ENV,Fe=e,Ir=()=>t._tfengine,t._tfengine}Vr.nextTensorId=0,Vr.nextVariableId=0;const Gr=jr();function Hr(t,e){const n={a:t,b:e};return Gr.runKernel(Oe,n)}const Kr=Ae();function qr(t,e){let n=t;if(pe(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||pe(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Xr(t,r,[]),r}function Xr(t,e,n){if(n=n||[],!Array.isArray(t)&&!pe(t))return void ae(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));ae(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),ae(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)Xr(t[a],r,n.concat(a))}function Jr(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function Yr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Er)return Jr(r,t.dtype,e,n),t;let a=be(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Jr(r,a,e,n),null==t||!pe(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=qr(t,a);pe(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?lr(t,a):ie(t,[],!0);return Gr.makeTensor(o,s,a)}function Zr(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>Yr(t,"".concat(e,"[").concat(a,"]"),n,r)))}Kr.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Kr.registerFlag("IS_BROWSER",(()=>"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope)),Kr.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Kr.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Kr.registerFlag("PROD",(()=>!1)),Kr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Kr.getBool("DEBUG"))),Kr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Kr.registerFlag("IS_TEST",(()=>!1)),Kr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Kr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Kr.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),Kr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Kr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Qr(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Gr.startScope(n);try{const t=r(...arguments);return Ne(t)&&console.error("Cannot return a Promise inside of tidy."),Gr.endScope(t),t}catch(t){throw Gr.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const $r=Qr({complex_:function(t,e){const n=Yr(t,"real","complex"),r=Yr(e,"imag","complex");se(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return Gr.runKernel("Complex",a)}});function ta(t,e,n,r){if(null==r&&(r=be(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!pe(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Ie(e);const t=le(e),r=le(n);ae(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==le(e.slice(a));ae(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return pe(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?lr(t,r):ie(t,[],!0),Gr.makeTensor(t,e,r)}function ea(t,e,n){return ta(t,e,qr(t,n),n)}const na={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ra=4;async function aa(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+ra*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=ra,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:oa(await Promise.all(r)),specs:n}}function sa(t,e){const n={};let r,a=0;for(const s of e){const e=s.name,o=s.dtype,i=s.shape,l=le(i);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(s.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(s.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==o)throw new Error("Weight ".concat(s.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(o,"."))}const i=na[n.dtype],u=t.slice(a,a+l*i),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===r&&(r=pa()),c=r(h)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");c=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=Math.round(e*n.scale+n.min)}}a+=l*i}else if("string"===o){const e=le(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(a,a+ra))[0];a+=ra;const n=new Uint8Array(t.slice(a,a+e));c.push(n),a+=e}}else{const r=na[o],s=t.slice(a,a+l*r);if("float32"===o)c=new Float32Array(s);else if("int32"===o)c=new Int32Array(s);else if("bool"===o)c=new Uint8Array(s);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(e,"': ").concat(o));{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const a=ea(t,i,"float32"),o=ea(r,i,"float32");n[e]=$r(a,o),a.dispose(),o.dispose()}}a+=l*r}"complex64"!==o&&(n[e]=ea(c,i,o))}return n}function oa(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const ia="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function la(t){return ia?Buffer.byteLength(t):new Blob([t]).size}function ca(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function ua(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function ha(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),r}(t,n,r)}function da(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:la(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:la(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function pa(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0===(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const a=r[o],i=t[n[a>>10]+(1023&a)]+e[a>>10];s[o]=i}return new Float32Array(a)}}class fa{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==fa.instance&&(fa.instance=new fa),fa.instance}static registerSaveRouter(t){fa.getInstance().saveRouters.push(t)}static registerLoadRouter(t){fa.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return fa.getHandlers(t,"save")}static getLoadHandlers(t,e){return fa.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?fa.getInstance().loadRouters:fa.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const ga=(t,e)=>fa.getLoadHandlers(t,e),ma="tensorflowjs",ba="models_store",ya="model_info_store";function va(){if(!Ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function wa(t){const e=t.result;e.createObjectStore(ba,{keyPath:"modelPath"}),e.createObjectStore(ya,{keyPath:"modelPath"})}class xa{constructor(t){if(this.indexedDB=va(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(ma,1);r.onupgradeneeded=()=>wa(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(ba,"readonly"),r=e.objectStore(ba).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{const r=da(e),s=a.transaction(ya,"readwrite");let o=s.objectStore(ya);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;i.onsuccess=()=>{l=a.transaction(ba,"readwrite");const i=l.objectStore(ba).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});i.onsuccess=()=>t({modelArtifactsInfo:r}),i.onerror=t=>{o=s.objectStore(ya);const e=o.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(i.error)),e.onerror=t=>(a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}xa.URL_SCHEME="indexeddb://";const ka=t=>{return Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(xa.URL_SCHEME)?(e=t.slice(xa.URL_SCHEME.length),new xa(e)):null;var e};fa.registerSaveRouter(ka),fa.registerLoadRouter(ka);class Sa{constructor(){this.indexedDB=va()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(ma,1);n.onupgradeneeded=()=>wa(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(ya,"readonly"),s=a.objectStore(ya).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(xa.URL_SCHEME)?e.slice(xa.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(ma,1);r.onupgradeneeded=()=>wa(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(ya,"readwrite"),o=s.objectStore(ya),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(ba,"readwrite");const r=l.objectStore(ba).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const Ia="/",Na="tensorflowjs_models",Ca="info",Ea="model_topology",Ta="weight_specs",Aa="weight_data",Ra="model_metadata";function Fa(t){return{info:[Na,t,Ca].join(Ia),topology:[Na,t,Ea].join(Ia),weightSpecs:[Na,t,Ta].join(Ia),weightData:[Na,t,Aa].join(Ia),modelMetadata:[Na,t,Ra].join(Ia)}}function _a(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Da(t){const e=t.split(Ia);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(Ia)}class Oa{constructor(t){if(!Ae().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Fa(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),a=da(t);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(t){if(ia)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData));const e={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(e)),{modelArtifactsInfo:a}}catch(e){throw _a(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(ia){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}Oa.URL_SCHEME="localstorage://";const za=t=>{return Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Oa.URL_SCHEME)?(e=t.slice(Oa.URL_SCHEME.length),new Oa(e)):null;var e};fa.registerSaveRouter(za),fa.registerLoadRouter(za);class La{constructor(){ae(Ae().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),ae("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Na+Ia,n=Ia+Ca;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[Da(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=Fa(t=(e=t).startsWith(Oa.URL_SCHEME)?e.slice(Oa.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return _a(n),r}}const Ma="://";class Pa{constructor(){this.managers={}}static getInstance(){return null==Pa.instance&&(Pa.instance=new Pa),Pa.instance}static registerManager(t,e){ae(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(Ma)&&(t=t.slice(0,t.indexOf(Ma))),ae(t.length>0,(()=>"scheme must not be an empty string."));const n=Pa.getInstance();ae(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=Pa.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(Pa.getInstance().managers)}}class Ba{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){window&&Ae().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}}if(Ae().get("IS_BROWSER")){Ae().setPlatform("browser",new Ba);try{Pa.registerManager(Oa.URL_SCHEME,new La)}catch(w1){}try{Pa.registerManager(xa.URL_SCHEME,new Sa)}catch(w1){}}const Wa=()=>n(5817);let Ua;class Va{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ae().global.fetch?Ae().global.fetch(t,e):(null==Ua&&(Ua=Wa()),Ua(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}function ja(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",Ie(t),new Sr(t,e,n)}Ae().get("IS_NODE")&&!Ae().get("IS_BROWSER")&&Ae().setPlatform("node",new Va);const Ga=Qr({cast_:function(t,e){const n=Yr(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return Gr.runKernel(We,r,a)}});const Ha=Qr({clone_:function(t){const e={x:Yr(t,"x","clone","string_or_numeric")};return Gr.runKernel(an,e)}});jr();Nr={buffer:ja,cast:Ga,clone:Ha,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}};function Ka(t){return new Promise((t=>setTimeout(t))).then(t)}class qa{constructor(t){if(!Ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(qa.URL_SCHEME)&&(t=t.slice(qa.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=ua(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Ka((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Ka((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:da(t)}}}}qa.URL_SCHEME="downloads://";function Xa(t,e,n,r){!function(t){ae(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){ae(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),ae(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),ae(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function Ja(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ae().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await Xa(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await Xa(a,e.onProgress,.5,1)}fa.registerSaveRouter((t=>Ae().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(qa.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new qa(t)}(t.slice(qa.URL_SCHEME.length)):null));class Ya{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(ae("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Ae().platform.fetch,ae(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&ae(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=ua(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:da(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(v1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return ha(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=function(t){const e=[];for(const n of t)e.push(...n.weights);return e}(t),o=[],i=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):o.push(a+t+r);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,ca(await Ja(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Za(t){return null!=t.match(Ya.URL_SCHEME_REGEX)}Ya.URL_SCHEME_REGEX=/^https?:\/\//;const Qa=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Za(t))):Za(t),n)return $a(t,e)}return null};function $a(t,e){return new Ya(t,e)}fa.registerSaveRouter(Qa),fa.registerLoadRouter(Qa);class ts{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class es{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function ns(t,e,n,r){return new es(function(t,e,n,r){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new ts(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ts({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ts({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r})}(...arguments))}function rs(t,e,n){if(oe(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=qr(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ta(t,e,r,n)}let as;function ss(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&t instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(t.constructor.name));i=!0}if(null!=$n(Kn,Gr.backendName)){const n={pixels:t},r={numChannels:e};return Gr.runKernel(Kn,n,r)}const[l,c]=a?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,h;if(o)u=t.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)u=t.data;else if(s||a||i){if(null==as)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");as=new OffscreenCanvas(1,1).getContext("2d")}else as=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});as.canvas.width=l,as.canvas.height=c,as.drawImage(t,0,0,l,c),u=as.getImageData(0,0,l,c).data}if(4===e)h=new Int32Array(u);else{const t=l*c;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=u[4*n+t]}return rs(h,[c,l,e],"int32")}Qr({fromPixels_:ss});class os{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class is{constructor(){this.classNameMap={}}static getMap(){return null==is.instance&&(is.instance=new is),is.instance}static register(t){is.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ls(t){ae(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),ae("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),ae(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),is.register(t)}function cs(){return Gr.memory()}function us(t,e){return Gr.tidy(t,e)}function hs(t){Pr(t).forEach((t=>t.dispose()))}function ds(t){return Gr.keep(t)}function ps(){return Gr.backend}function fs(t){return Gr.customGrad(t)}function gs(t,e){if((pe(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&pe(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ta(t,[],[],e)}Cr=function(t){Ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class ms extends os{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return hs(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){ae(ye(t),(()=>"The f passed in variableGrads(f) must be a function")),ae(null==e||Array.isArray(e)&&e.every((t=>t instanceof Tr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in Gr.registeredVariables)e.push(Gr.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),ae(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=Gr.gradients(t,e,null,!0);ae(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),ae(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&hs(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:gs(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ms,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const bs=Qr({abs_:function(t){const e=Yr(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return Gr.runKernel(Ve,t)}{const t={x:e};return Gr.runKernel("Abs",t)}}});const ys=Qr({add_:function(t,e){let n=Yr(t,"a","add"),r=Yr(e,"b","add");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(Oe,a)}});const vs=Qr({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","all","bool")},a={axis:e,keepDims:n};return Gr.runKernel("All",r,a)}});const ws=Qr({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","any","bool")},a={axis:e,keepDims:n};return Gr.runKernel("Any",r,a)}});const xs=Qr({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Yr(t,"x","argMax")},r={axis:e};return Gr.runKernel(ze,n,r)}});function ks(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=Is(n),[b,y]=Is(r),v=Ns(d,b),w=Ns(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=Ss(t,e,n));const s=t[0],o=t[1],i=Cs((s-e+2*r)/n+1,a),l=Cs((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=Cs((e-s+d+p)/r+1,i),h=Cs((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function Ss(t,e,n){const r=Ns(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function Is(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Ns(t,e){return e<=1?t:t+(t-1)*(e-1)}function Cs(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function Es(t){const[e,n,r]=Is(t);return 1===e&&1===n&&1===r}function Ts(t,e){return Es(t)||Es(e)}function As(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)ae(ue(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{ae(ue(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const Rs=Qr({reshape_:function(t,e){const n={x:Yr(t,"x","reshape","string_or_numeric")},r={shape:e};return Gr.runKernel(xn,n,r)}});const Fs=Qr({avgPool_:function(t,e,n,r,a){const s=Yr(t,"x","avgPool","float32");ae(Ts(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),As("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=Gr.runKernel(Le,l,c);return u=Ga(u,s.dtype),i?Rs(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const _s=Qr({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Yr(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),ae("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),As("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=Gr.runKernel(Me,c,u);return h=Ga(h,i.dtype),l?Rs(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Ds=Qr({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ae(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ae(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?Rs(t,[1,1,1,t.size]):2===t.rank?Rs(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=Gr.runKernel(en,h,d);return Rs(p,o.shape)}});const Os=Qr({batchNorm2d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),ae(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});const zs=Qr({batchNorm3d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),ae(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});const Ls=Qr({batchNorm4d_:function(t,e,n,r,a,s){const o=Yr(t,"x","batchNorm"),i=Yr(e,"mean","batchNorm"),l=Yr(n,"variance","batchNorm");let c,u;return null!=a&&(c=Yr(a,"scale","batchNorm")),null!=r&&(u=Yr(r,"offset","batchNorm")),ae(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),ae(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),ae(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&ae(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&ae(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),Ds(o,i,l,u,c,s)}});function Ms(t,e,n){const r={shape:t,value:e,dtype:n};return Gr.runKernel(Qe,{},r)}const Ps=Qr({clipByValue_:function(t,e,n){const r=Yr(t,"x","clipByValue");if(ae(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return Ms(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return Gr.runKernel(Ue,a,s)}});const Bs=Qr({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;ae(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Zr(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return Ha(n[0]);const r=n,a={axis:e};return Gr.runKernel(je,r,a)}});const Ws=Qr({concat1d_:function(t){return Bs(t,0)}});const Us=Qr({concat2d_:function(t,e){return Bs(t,e)}});const Vs=Qr({concat3d_:function(t,e){return Bs(t,e)}});const js=Qr({concat4d_:function(t,e){return Bs(t,e)}});const Gs=Qr({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","conv2d","float32"),l=Yr(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),ae(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),As("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];ae(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),ae(Ts(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Ge,d,p);return u?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Hs=Qr({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","conv1d"),l=Yr(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1]])),ae(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),ae(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),As("conv1d",r,o),ae(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),ae(Ts(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),ae("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=Rs(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Rs(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Gs(d,h,[1,n],r,"NHWC",[1,s],o);return Rs(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Ks=Qr({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;ae(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),ae(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),ae(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),ae(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];ae(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),ae(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),As("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Gr.runKernel(He,d,p);return c?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const qs=Qr({conv2dTranspose_:function(t,e,n,r,a,s){const o=Yr(t,"x","conv2dTranspose"),i=Yr(e,"filter","conv2dTranspose");return Ks(n,o,i,r,a,"NHWC",s)}});const Xs=Qr({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=Yr(t,"x","conv3d"),i=Yr(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),ae(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),ae(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),ae(Ts(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),ae("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported.")));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=Gr.runKernel(Ke,u,h);return c?Rs(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Js=Qr({conv3DBackpropInput_:function(t,e,n,r,a){ae(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];ae(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),ae(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),ae(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),ae(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),ae(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=Gr.runKernel("Conv3DBackpropInputV2",u,h);return i?Rs(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ys=Qr({conv3dTranspose_:function(t,e,n,r,a){const s=Yr(t,"x","conv3dTranspose"),o=Yr(e,"filter","conv3dTranspose");return Js(n,s,o,r,a)}});const Zs=Qr({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=Yr(t,"x","depthwiseConv2d","float32"),l=Yr(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),ae(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];ae(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),As("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Gr.runKernel(Je,d,p);return u?Rs(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Qs=Qr({floorDiv_:function(t,e){let n=Yr(t,"a","floorDiv"),r=Yr(e,"b","floorDiv");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(tn,a)}});const $s=Qr({div_:function(t,e){let n=Yr(t,"a","div"),r=Yr(e,"b","div");if([n,r]=Lr(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Qs(n,r);const a={a:n,b:r};return Gr.runKernel(Ye,a,{})}});const to=Qr({elu_:function(t){const e={x:Yr(t,"x","elu","float32")};return Gr.runKernel("Elu",e)}});function eo(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function no(t,e){const n=[],r=Math.max(t.length,e.length);for(let a=0;a<r;a++){let r=t[t.length-a-1];null==r&&(r=1);let s=e[e.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}n.unshift(r)}}return n}const ro=Qr({equal_:function(t,e){let n=Yr(t,"a","equal","string_or_numeric"),r=Yr(e,"b","equal","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Equal",a)}});const ao=Qr({exp_:function(t){const e={x:Yr(t,"x","exp")};return Gr.runKernel("Exp",e)}});const so=Qr({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Yr(t,"x","expandDims","string_or_numeric");ae(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return Gr.runKernel(Ze,r,a)}});const oo=Qr({tile_:function(t,e){const n=Yr(t,"x","tile","string_or_numeric");ae(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return Gr.runKernel(Wn,r,a)}});const io=Qr({eye_:function(t,e,n){null==e&&(e=t);const r=ja([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=Rs(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return oo(so(s,0),[n[0],1,1]);if(2===n.length)return oo(so(so(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return oo(so(so(so(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const lo=Qr({floor_:function(t){const e={x:Yr(t,"x","floor","float32")};return Gr.runKernel($e,e)}});const co=Qr({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:Yr(t,"x","gather"),indices:Yr(e,"indices","gather","int32")},s={axis:n,batchDims:r};return Gr.runKernel(nn,a,s)}});const uo=Qr({greater_:function(t,e){let n=Yr(t,"a","greater","string_or_numeric"),r=Yr(e,"b","greater","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Greater",a)}});const ho=Qr({greaterEqual_:function(t,e){let n=Yr(t,"a","greaterEqual","string_or_numeric"),r=Yr(e,"b","greaterEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(rn,a)}});const po=Qr({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Yr(t,"x","leakyRelu")},r={alpha:e};return Gr.runKernel(sn,n,r)}});const fo=Qr({log_:function(t){const e={x:Yr(t,"x","log","float32")};return Gr.runKernel("Log",e)}});const go=Qr({log1p_:function(t){const e={x:Yr(t,"x","log1p")};return Gr.runKernel(on,e)}});const mo=Qr({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","max")},a={reductionIndices:e,keepDims:n};return Gr.runKernel("Max",r,a)}});const bo=Qr({mul_:function(t,e){let n=Yr(t,"a","mul"),r=Yr(e,"b","mul");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel(pn,a)}});const yo=Qr({sub_:function(t,e){let n=Yr(t,"a","sub"),r=Yr(e,"b","sub");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel("Sub",a)}});const vo=Qr({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Yr(t,"x","sum");"bool"===r.dtype&&(r=Ga(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return Gr.runKernel("Sum",a,s)}});const wo=Qr({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Yr(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=fs(((t,n)=>{const r=mo(t,e,!0),a=yo(t,r),s=yo(Ga(a,"float32"),fo(vo(ao(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=ao(r);return yo(t,bo(vo(t,e,!0),a))}}}));return r(n)}});const xo=Qr({logicalAnd_:function(t,e){const n=Yr(t,"a","logicalAnd","bool"),r=Yr(e,"b","logicalAnd","bool");no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LogicalAnd",a)}});const ko=Qr({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=Yr(t,"a","matMul"),s=Yr(e,"b","matMul");[a,s]=Lr(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return Gr.runKernel(Pe,o,i)}});const So=Qr({maxPool_:function(t,e,n,r,a){const s=Yr(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),ae(Ts(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),As("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=Gr.runKernel(cn,l,c);return i?Rs(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Io=Qr({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=Yr(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),ae("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),As("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=Gr.runKernel(un,c,u);return l?Rs(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const No=Qr({maximum_:function(t,e){let n=Yr(t,"a","maximum"),r=Yr(e,"b","maximum");[n,r]=Lr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(ln,a)}});const Co=Qr({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","mean")},a={axis:e,keepDims:n};return Gr.runKernel(hn,r,a)}});const Eo=Qr({minimum_:function(t,e){let n=Yr(t,"a","minimum"),r=Yr(e,"b","minimum");[n,r]=Lr(n,r),"bool"===n.dtype&&(n=Ga(n,"int32"),r=Ga(r,"int32")),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(dn,a)}});function To(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Ao(t,e){return function(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}(t,e.map((t=>1)),e)}function Ro(t,e){if(To(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Fo(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}const _o=Qr({square_:function(t){const e=Yr(t,"x","square");return Gr.runKernel("Square",{x:e},{})}});const Do=Qr({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=de(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=Yr(t,"x","moments")).shape),r=Co(t,n,e);let a=r.shape;e||(a=Ao(r.shape,n));const s=_o(yo(Ga(t,"float32"),Rs(r,a)));return{mean:r,variance:Co(s,n,e)}}});const Oo=Qr({neg_:function(t){const e={x:Yr(t,"x","neg")};return Gr.runKernel("Neg",e)}});const zo=Qr({notEqual_:function(t,e){let n=Yr(t,"a","notEqual","string_or_numeric"),r=Yr(e,"b","notEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("NotEqual",a)}});const Lo=Qr({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:Yr(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return Gr.runKernel(gn,s,o)}});function Mo(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Mo(t,"float32"),n=Mo(t,"float32");return $r(e,n)}const n=Se(le(t),e);return Gr.makeTensor(n,t,e)}function Po(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===e){const e=Po(t,"float32"),n=Mo(t,"float32");return $r(e,n)}const n=ke(le(t),e);return Gr.makeTensor(n,t,e)}const Bo=Qr({onesLike_:function(t){const e={x:Yr(t,"x","onesLike")};return Gr.runKernel(fn,e)}});const Wo=Qr({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=Yr(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return Gr.runKernel(bn,s,a)}});const Uo=Qr({prelu_:function(t,e){const n={x:Yr(t,"x","prelu"),alpha:Yr(e,"alpha","prelu")};return Gr.runKernel(yn,n)}});var Vo=n(4334);class jo{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Vo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Go{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Vo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ho=Qr({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new jo(e,n,r,!1,a),o=ja(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const Ko=Qr({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>4?arguments[4]:void 0;const a=ja(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=new Go(e,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}});const qo=Qr({relu_:function(t){const e={x:Yr(t,"x","relu")};return Gr.runKernel(wn,e)}});const Xo=Qr({reverse_:function(t,e){const n={x:Yr(t,"x","reverse")},r={dims:e};return Gr.runKernel(Nn,n,r)}});const Jo=Qr({selu_:function(t){const e={x:Yr(t,"x","selu")};return Gr.runKernel(An,e)}});const Yo=Qr({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=Yr(t,"x","separableConv2d"),l=Yr(e,"depthwiseFilter","separableConv2d"),c=Yr(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ae(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),ae(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),ae(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),ae(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),ae(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];ae(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=Zs(u,l,r,a,o,s),g=Gs(f,c,1,"valid",o);return h?Rs(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const Zo=Qr({sigmoid_:function(t){const e={x:Yr(t,"x","sigmoid","float32")};return Gr.runKernel(_n,e)}});const Qo=Qr({slice_:function(t,e,n){const r=Yr(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return Gr.runKernel(Rn,a,s)}});const $o=Qr({slice1d_:function(t,e,n){const r=Yr(t,"x","slice1d");return ae(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,[e],[n])}});const ti=Qr({slice2d_:function(t,e,n){const r=Yr(t,"x","slice2d");return ae(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ei=Qr({slice3d_:function(t,e,n){const r=Yr(t,"x","slice3d");return ae(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ni=Qr({slice4d_:function(t,e,n){const r=Yr(t,"x","slice4d");return ae(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),Qo(r,e,n)}});const ri=Qr({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Yr(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return Gr.runKernel(Mn,r,a)}});const ai=Qr({softplus_:function(t){const e={x:Yr(t,"x","softplus")};return Gr.runKernel(Dn,e)}});const si=Qr({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:Yr(t,"x","split")},a={numOrSizeSplits:e,axis:n};return Gr.runKernel(Ln,r,a)}});const oi=Qr({sqrt_:function(t){const e={x:Yr(t,"x","sqrt","float32")};return Gr.runKernel(On,e)}});const ii=Qr({squeeze_:function(t,e){const n=Yr(t,"x","squeeze","string_or_numeric");return Rs(n,function(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:de(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}(n.shape,e).newShape)}});const li=Qr({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Zr(t,"tensors","stack","string_or_numeric");ae(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&ae(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return Gr.runKernel(mn,r,a)}});const ci=Qr({tanh_:function(t){const e={x:Yr(t,"x","tanh","float32")};return Gr.runKernel(Bn,e)}});function ui(t,e){oe(t);const n=qr(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ta(t,null,n,e)}function hi(t,e,n){if(oe(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=qr(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ta(t,e,r,n)}const di=Qr({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new jo(e,n,r,!0,a),o=ja(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const pi=Qr({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Yr(t,"x","unstack","string_or_numeric");ae(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return Gr.runKernel(Vn,r,a)}});const fi=Qr({broadcastTo_:function(t,e){let n=Yr(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!==0)))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(e,"]."));if(e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Rs(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Ha(n);const o={x:n},i={reps:s};return Gr.runKernel(Wn,o,i)}});const gi=Qr({where_:function(t,e,n){const r=Yr(e,"a","where"),a=Yr(n,"b","where"),s=Yr(t,"condition","where","bool"),o=no(no(s.shape,r.shape),a.shape),i={condition:fi(s,o),t:fi(r,o),e:fi(a,o)};return Gr.runKernel(Tn,i)}});const mi=Qr({zerosLike_:function(t){const e={x:Yr(t,"x","zerosLike")};return Gr.runKernel(Gn,e)}});const bi=Qr({imag_:function(t){const e={input:Yr(t,"input","imag")};return Gr.runKernel("Imag",e)}});const yi=Qr({real_:function(t){const e={input:Yr(t,"input","real")};return Gr.runKernel("Real",e)}});const vi=Qr({transpose_:function(t,e,n){const r=Yr(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),ae(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{ae(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?us((()=>{let t=yi(r),e=bi(r);return t=Gr.runKernel(Un,{x:t},s),e=Gr.runKernel(Un,{x:e},s),n&&(e=Oo(e)),$r(t,e)})):Gr.runKernel(Un,a,s)}});const wi=Qr({dropout_:function(t,e,n,r){const a=Yr(t,"x","dropout");if(ae("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),ae(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Er?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if(ce(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=$s(lo(ys(Ko(s,0,1,"float32",r),o)),o);return bo(a,i)}});const xi=Qr({fft_:function(t){ae("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("FFT",e)}});const ki=Qr({rfft_:function(t,e){ae("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=Qo(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=Bs([t,Mo(r)],t.shape.length-1),n=e}else a=t;const s=mi(a),o=Rs($r(a,s),[r,n]),i=xi(o),l=Math.floor(n/2)+1,c=yi(i),u=bi(i),h=si(c,[l,n-l],c.shape.length-1),d=si(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,Rs($r(h[0],d[0]),p)}});const Si=Qr({ifft_:function(t){ae("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return Gr.runKernel("IFFT",e)}});Qr({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=Rs(t,[n,e]);r=Si(a)}else{const a=[n,2*(e-1)],s=Rs(yi(t),[n,e]),o=Rs(bi(t),[n,e]),i=Xo(Qo(s,[0,1],[n,e-2]),1),l=bo(Xo(Qo(o,[0,1],[n,e-2]),1),gs(-1)),c=Bs([s,i],1),u=Bs([o,l],1),h=Rs($r(c,u),[a[0],a[1]]);r=Si(h)}if(r=yi(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=Rs(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const Ii=Qr({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ae(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),ae(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),ae(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];ae(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),ae(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),As("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return Gr.runKernel("Conv2DBackpropFilter",h,d)}});const Ni=Qr({relu6_:function(t){const e={x:Yr(t,"x","relu6")};return Gr.runKernel(In,e)}});const Ci=Qr({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Yr(t,"x","step")},r={alpha:e};return Gr.runKernel(Hn,n,r)}});function Ei(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return bo(t,Ci(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function Ti(t,e){let n=e;const r=eo(t.shape,e.shape);return r.length>0&&(n=vo(n,r)),Rs(n,t.shape)}function Ai(t,e,n,r){if("linear"===e)return t;if("relu"===e)return qo(t);if("elu"===e)return to(t);if("relu6"===e)return Ni(t);if("prelu"===e)return Uo(t,n);if("leakyrelu"===e)return po(t,r);if("sigmoid"===e)return Zo(t);throw new Error("Unknown fused activation ".concat(e,"."))}const Ri=(t,e)=>!(t>0)||"linear"===e;const Fi=Qr({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===Ri(Gr.state.gradientDepth,c)){ae("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=Gs(e,n,r,a,s,o,i);return null!=l&&(t=ys(t,l)),Ai(t,c,u,h)}const d=Yr(e,"x","conv2d","float32"),p=Yr(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Rs(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),ae(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),As("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];ae(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),ae(Ts(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=ks(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=Yr(l,"bias","fused conv2d"),[y]=Lr(y,d),"NHWC"===s?no(b.outShape,y.shape):(ae(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),ae(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(ae(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)ae(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{no(t,b.outShape)}catch(v1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=Yr(u,"prelu weights","fused conv2d")}const w=(t,e)=>{ae("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=Ei(t,l,c);ae(Es(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[Ks(i.shape,h,n,r,a),Ii(i,h,n.shape,r,a)];if(null!=u){const t=Ti(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=fs(((t,e,n)=>{let r=Gr.runKernel(Xn,x,k);return n([e,t,r]),g&&(r=Rs(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=fs(((t,e,n,r)=>{let a=Gr.runKernel(Xn,x,k);return r([e,t,a,n]),g&&(a=Rs(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const _i=Qr({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return Gr.runKernel("DepthwiseConv2dNativeBackpropFilter",c,u)}});const Di=Qr({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=Gr.runKernel("DepthwiseConv2dNativeBackpropInput",c,u);return l?Rs(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Qr({fusedDepthwiseConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(!1===Ri(Gr.state.gradientDepth,c)){let t=Zs(e,n,r,a,s,o,i);return null!=l&&(t=ys(t,l)),Ai(t,c,u,h)}const d=Yr(e,"x","depthwiseConv2d","float32"),p=Yr(n,"filter","depthwiseConv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Rs(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),ae(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),ae(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==o&&(o=[1,1]),ae(Ts(r,o),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(r," and dilations '").concat(o,"'"))),As("fused depthwiseConv2d",a,i);const m=ks(f.shape,p.shape,r,o,a,i,!0);let b,y;null!=l&&(b=Yr(l,"bias","fused conv2d"),[b]=Lr(b,d),no(m.outShape,b.shape)),null!=u&&(y=Yr(u,"prelu weights","fused depthwiseConv2d"));const v=(t,e)=>{ae(Es(o),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'")));const[n,s,l,u]=e,h=Ei(t,l,c),d=Di(s.shape,h,n,r,a,o,i),p=_i(s,h,n.shape,r,a,o,i);if(null!=u){return[d,p,Ti(b,h)]}return[d,p]},w={x:f,filter:p,bias:b,preluActivationWeights:y},x={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=fs(((t,e,n)=>{let r=Gr.runKernel(Jn,w,x);return n([e,t,r]),g&&(r=Rs(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(f,p)}{const t=fs(((t,e,n,r)=>{let a=Gr.runKernel(Jn,w,x);return r([e,t,a,n]),g&&(a=Rs(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return t(f,p,b)}}});const Oi=Qr({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===Ri(Gr.state.gradientDepth,o)){let t=ko(e,n,r,a);return null!=s&&(t=ys(t,s)),Ai(t,o,i,l)}let c=Yr(e,"a","fused matMul"),u=Yr(n,"b","fused matMul");[c,u]=Lr(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=le(g),y=le(m);ae(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=no(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=Rs(c,r?[b,h,p]:[b,p,h]),x=Rs(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=Yr(s,"bias","fused matMul"),[k]=Lr(k,c),no(v,k.shape)),null!=i&&(S=Yr(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=Ei(Rs(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=ko(u,i,!1,!1),d=ko(u,n,!0,!1)):r&&!a?(h=ko(i,u,!1,!0),d=ko(n,u,!1,!1)):(h=ko(i,u,!0,!0),d=ko(u,n,!0,!0)):(h=ko(u,i,!1,!0),d=ko(n,u,!0,!1)),null!=s){return[h,d,Ti(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},C={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=fs(((t,e,n)=>{const r=Gr.runKernel(qn,N,C);return n([t,e,r]),{value:Rs(r,v),gradFunc:I}}));return t(w,x)}{const t=fs(((t,e,n,r)=>{const a=Gr.runKernel(qn,N,C);return r([t,e,a,n]),{value:Rs(a,v),gradFunc:I}}));return t(w,x,k)}}});function zi(t,e,n){const r=1-t%2,a=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);a[s]=e-n*Math.cos(o)}return ui(a,"float32")}Qr({hammingWindow_:function(t){return zi(t,.54,.46)}});const Li=Qr({hannWindow_:function(t){return zi(t,.5,.5)}});const Mi=Qr({frame_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const o=[];for(;s+e<=t.size;)o.push(Qo(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,i=Bs([Qo(t,s,e-r),Ms([r],a)]);o.push(i),s+=n}return 0===o.length?hi([],[0,e]):Rs(Bs(o),[o.length,e])}});Qr({stft_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Li;var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=Mi(t,e,n),i=bo(o,a(e));return ki(i,r)}});const Pi=Qr({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"image","cropAndResize"),i=Yr(e,"boxes","cropAndResize","float32"),l=Yr(n,"boxInd","cropAndResize","int32"),c=i.shape[0];ae(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),ae(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),ae(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),ae(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),ae(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),ae("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return Gr.runKernel("CropAndResize",u,h)}});const Bi=Qr({flipLeftRight_:function(t){const e=Yr(t,"image","flipLeftRight","float32");ae(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return Gr.runKernel("FlipLeftRight",n,{})}});const Wi=Qr({grayscaleToRGB_:function(t){const e=Yr(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];ae(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),ae(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,oo(e,a)}});const Ui=Qr({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Yr(t,"image","rotateWithOffset","float32");ae(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return Gr.runKernel("RotateWithOffset",s,o)}});function Vi(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),ae(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),ae(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),ae(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),ae(1===e.rank,(()=>"scores must be a 1D tensor")),ae(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),ae(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const ji=Qr({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Yr(t,"boxes","nonMaxSuppression","float32"),o=Yr(e,"scores","nonMaxSuppression","float32"),i=Vi(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Gr.runKernel("NonMaxSuppressionV3",{boxes:s,scores:o},l)}});function Gi(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||Hi)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function Hi(t,e){return t>e?1:t<e?-1:0}function Ki(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(Ji);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=qi(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*Xi(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&Gi(c,e,Ji))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function qi(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function Xi(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Ji(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const Yi=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Yr(t,"boxes","nonMaxSuppressionAsync"),o=Yr(e,"scores","nonMaxSuppressionAsync"),i=Vi(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=function(t,e,n,r,a){return Ki(t,e,n,r,a,0)}(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),ui(h,"int32")};const Zi=Qr({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"boxes","nonMaxSuppression"),i=Yr(e,"scores","nonMaxSuppression"),l=Vi(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=Gr.runKernel("NonMaxSuppressionV5",c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const Qi=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=Yr(t,"boxes","nonMaxSuppressionAsync"),i=Yr(e,"scores","nonMaxSuppressionAsync"),l=Vi(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=function(t,e,n,r,a,s){return Ki(t,e,n,r,a,s,!0)}(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ui(d,"int32"),selectedScores:ui(p)}};const $i=Qr({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Yr(t,"boxes","nonMaxSuppression"),i=Yr(e,"scores","nonMaxSuppression"),l=Vi(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=Gr.runKernel("NonMaxSuppressionV4",c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const tl=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Yr(t,"boxes","nonMaxSuppressionAsync"),i=Yr(e,"scores","nonMaxSuppressionAsync"),l=Vi(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=function(t,e,n,r,a,s){return Ki(t,e,n,r,a,0,!1,s,!0)}(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:ui(f,"int32"),validOutputs:gs(g,"int32")}};const el=Qr({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Yr(t,"images","resizeBilinear");ae(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),ae(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),ae(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Rs(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(Sn,i,l);return o?Rs(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const nl=Qr({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=Yr(t,"images","resizeNearestNeighbor");ae(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),ae(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),ae("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),ae(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=Rs(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=Gr.runKernel(kn,i,l);return o?Rs(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const rl=Qr({bincount_:function(t,e,n){const r=Yr(t,"x","bincount"),a=Yr(e,"weights","bincount");ae("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),ae(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),ae(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return Gr.runKernel("Bincount",s,o)}});const al=Qr({lessEqual_:function(t,e){let n=Yr(t,"a","lessEqual","string_or_numeric"),r=Yr(e,"b","lessEqual","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("LessEqual",a)}});const sl=Qr({round_:function(t){const e={x:Yr(t,"x","round")};return Gr.runKernel(Cn,e)}});function ol(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return Gr.runKernel(vn,{},a)}const il=Qr({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=Yr(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=bo(ui([r]),255);if(ae(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),ae(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),ae("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),ae("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=si(a,[1,1,1],-1);const t=bo(o,.2989),e=bo(i,.587),n=bo(l,.114);c=ys(ys(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=ui([-1]),c=ui([0]),u=ui([0]);for(let h=0;h<t.size-1;h++){n=Qo(t,0,h+1),r=Qo(t,h+1),o=$s(vo(n),e),i=$s(vo(r),e);const d=vo(bo(n,ol(0,n.size)));a=$s(d,vo(n));const p=Ms(r.shape,n.size),f=ys(ol(0,r.size),p),g=bo(r,f);s=$s(vo(g),vo(r));const m=yo(a,s),b=yo(a,s),y=bo(o,i);u=bo(bo(y,m),b);const v=uo(u,c);c=gi(v,u,c),l=gi(v,ui([h]),l)}return l}(rl(Ga(sl(c),"int32"),ea([]),256),s)}const h=n?al(c,u):uo(c,u);return Ga(bo(h,255),"int32")}});const ll=Qr({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=Yr(t,"image","transform","float32"),i=Yr(e,"transforms","transform","float32");ae(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),ae(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),ae(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Gr.runKernel("Transform",l,c)}});const cl=Qr({bandPart_:function(t,e,n){ae(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),ae(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")));const r=Yr(t,"a","bandPart");ae(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);if(!(e<=s))throw new Error("bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=o))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."));e<0&&(e=s),n<0&&(n=o);const i=Rs(ol(0,s,1,"int32"),[-1,1]),l=ol(0,o,1,"int32"),c=yo(i,l),u=xo(al(c,gs(+e,"int32")),ho(c,gs(-n,"int32"))),h=Mo([s,o],r.dtype);return Rs(li(pi(Rs(r,[-1,s,o])).map((t=>gi(u,t,h)))),a)}});const ul=Qr({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Yr(t,"x","min")},a={axis:e,keepDims:n};return Gr.runKernel("Min",r,a)}});const hl=Qr({pow_:function(t,e){let n=Yr(t,"base","pow"),r=Yr(e,"exp","pow");[n,r]=Lr(n,r);const a={a:n,b:r};return Gr.runKernel("Pow",a)}});function dl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return bs(t);if(1!==t.rank&&null===n)return dl(Rs(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return vo(bs(t),n);if(e===1/0)return mo(bs(t),n);if(e===-1/0)return ul(bs(t),n);if("euclidean"===e||2===e)return oi(vo(hl(bs(t),gs(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return mo(vo(bs(t),n[0]),n[1]-1);if(e===1/0)return mo(vo(bs(t),n[1]),n[0]);if(e===-1/0)return ul(vo(bs(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return oi(vo(_o(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const pl=Qr({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=dl(t=Yr(t,"x","norm"),e,n);let s=a.shape;if(r){const e=de(n,t.shape);s=Ao(a.shape,e)}return Rs(a,s)}});const fl=Qr({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,ae(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)ae(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=si(t,t.shape[0],0).map((t=>ii(t,[0])));ae(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(Gr.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=bo(vo(bo(n[e],t)),n[e]);t=yo(t,r)}return $s(t,pl(t,"euclidean"))})));return e?li(n,0):n}});function gl(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Gr.tidy((()=>{ae(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=io(n),s=Ha(t);const o=hi([[1]],[1,1]);let i=Ha(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=Gr.tidy((()=>{const e=Qo(s,[t,t],[n-t,1]),l=pl(e),c=Qo(s,[t,t],[1,1]),u=gi(uo(c,0),hi([[-1]]),hi([[1]])),h=yo(c,bo(u,l)),d=$s(e,h);i=1===d.shape[0]?Ha(o):Bs([o,Qo(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Oo($s(ko(u,h),l)),f=Qo(s,[t,0],[n-t,r]),g=bo(p,i),m=vi(i);if(0===t)s=yo(f,ko(g,ko(m,f)));else{const e=yo(f,ko(g,ko(m,f)));s=Bs([Qo(s,[0,0],[t,r]),e],0)}const b=vi(g),y=Qo(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=yo(y,ko(ko(y,i),b));else{const e=yo(y,ko(ko(y,i),b));a=Bs([Qo(a,[0,0],[n,t]),e],1)}return[i,s,a]})),hs([e,l,c])}return!e&&n>r&&(a=Qo(a,[0,0],[n,r]),s=Qo(s,[0,0],[r,r])),[a,s]}))}const ml=Qr({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(ae(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return gl(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=pi(Rs(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=gl(t,e);a.push(n),s.push(r)}));return[Rs(li(a,0),t.shape),Rs(li(s,0),t.shape)]}}});var bl;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(bl||(bl={}));const yl=Qr({computeWeightedLoss_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bl.SUM_BY_NONZERO_WEIGHTS;const r=Yr(t,"losses","computeWeightedLoss");let a=null;null!=e&&(a=Yr(e,"weights","computeWeightedLoss"));const s=null==a?r:bo(r,a);if(n===bl.NONE)return s;if(n===bl.SUM)return vo(s);if(n===bl.MEAN){if(null==a)return Co(s);{const t=r.size/a.size,e=$s(vo(s),vo(a));return t>1?$s(e,gs(t)):e}}if(n===bl.SUM_BY_NONZERO_WEIGHTS){if(null==a)return $s(vo(s),gs(r.size));{const t=bo(a,Po(r.shape)),e=Ga(vo(zo(t,gs(0))),"float32");return $s(vo(s),e)}}throw Error("Unknown reduction: ".concat(n))}});Qr({absoluteDifference_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS;const a=Yr(t,"labels","absoluteDifference"),s=Yr(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=Yr(n,"weights","absoluteDifference")),se(a.shape,s.shape,"Error in absoluteDifference: ");const i=bs(yo(a,s));return yl(i,o,r)}});Qr({cosineDistance_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","cosineDistance"),o=Yr(e,"predictions","cosineDistance");let i=null;null!=r&&(i=Yr(r,"weights","cosineDistance")),se(s.shape,o.shape,"Error in cosineDistance: ");const l=gs(1),c=yo(l,vo(bo(s,o),n,!0));return yl(c,i,a)}});Qr({hingeLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS,a=Yr(t,"labels","hingeLoss");const s=Yr(e,"predictions","hingeLoss");let o=null;null!=n&&(o=Yr(n,"weights","hingeLoss")),se(a.shape,s.shape,"Error in hingeLoss: ");const i=gs(1);a=yo(bo(gs(2),a),i);const l=qo(yo(i,bo(a,s)));return yl(l,o,r)}});Qr({huberLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","huberLoss"),o=Yr(e,"predictions","huberLoss");let i=null;null!=n&&(i=Yr(n,"weights","huberLoss")),se(s.shape,o.shape,"Error in huberLoss: ");const l=gs(r),c=bs(yo(o,s)),u=Eo(c,l),h=yo(c,u),d=ys(bo(gs(.5),_o(u)),bo(l,h));return yl(d,i,a)}});Qr({logLoss_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS;const s=Yr(t,"labels","logLoss"),o=Yr(e,"predictions","logLoss");let i=null;null!=n&&(i=Yr(n,"weights","logLoss")),se(s.shape,o.shape,"Error in logLoss: ");const l=gs(1),c=gs(r),u=Oo(bo(s,fo(ys(o,c)))),h=bo(yo(l,s),fo(ys(yo(l,o),c))),d=yo(u,h);return yl(d,i,a)}});const vl=Qr({squaredDifference_:function(t,e){let n=Yr(t,"a","squaredDifference"),r=Yr(e,"b","squaredDifference");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel(Pn,a,{})}});Qr({meanSquaredError_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:bl.SUM_BY_NONZERO_WEIGHTS;const a=Yr(t,"labels","meanSquaredError"),s=Yr(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=Yr(n,"weights","meanSquaredError")),se(a.shape,s.shape,"Error in meanSquaredError: ");const i=vl(a,s);return yl(i,o,r)}});Qr({sigmoidCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS,s=Yr(t,"multiClassLabels","sigmoidCrossEntropy");const o=Yr(e,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Yr(n,"weights","sigmoidCrossEntropy")),se(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=gs(r),e=gs(1),n=gs(.5);s=ys(bo(s,yo(e,t)),bo(n,t))}const l=function(t,e){const n=Yr(t,"labels","sigmoidCrossEntropyWithLogits"),r=Yr(e,"logits","sigmoidCrossEntropyWithLogits");se(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=qo(r),s=bo(r,n),o=go(ao(Oo(bs(r))));return ys(yo(a,s),o)}(s,o);return yl(l,i,a)}});const wl=Qr({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=Yr(t,"x","logSumExp"),a=de(e,r.shape),s=mo(r,a,!0),o=yo(r,s),i=ao(o),l=vo(i,a),c=fo(l),u=ys(Rs(s,c.shape),c);if(n){const t=Ao(u.shape,a);return Rs(u,t)}return u}});Qr({softmaxCrossEntropy_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:bl.SUM_BY_NONZERO_WEIGHTS,s=Yr(t,"onehotLabels","softmaxCrossEntropy");const o=Yr(e,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Yr(n,"weights","softmaxCrossEntropy")),se(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=gs(r),e=gs(1),n=gs(s.shape[1]);s=ys(bo(s,yo(e,t)),$s(t,n))}const l=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(e.rank," ")+"and dim was ".concat(n));const r=fs(((t,e,r)=>{const a=wl(e,[n],!0),s=yo(Ga(e,"float32"),a);r([t,s]);const o=Oo(bo(s,t));return{value:vo(o,[n]),gradFunc:(t,e)=>{const[r,a]=e,s=Ao(t.shape,[n]);return[bo(Rs(t,s),yo(Ga(r,"float32"),ao(a))),bo(Rs(t,s),yo(ao(a),Ga(r,"float32")))]}}}));return r(t,e)}(s,o);return yl(l,i,a)}});Qr({sparseFillEmptyRows_:function(t,e,n,r){const a=Yr(t,"indices","sparseFillEmptyRows","int32"),s=Yr(e,"values","sparseFillEmptyRows"),o=Yr(n,"denseShape","sparseFillEmptyRows","int32"),i=Yr(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const l={indices:a,values:s,denseShape:o,defaultValue:i},c=Gr.runKernel("SparseFillEmptyRows",l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}});Qr({sparseReshape_:function(t,e,n){const r=Yr(t,"inputIndices","sparseReshape","int32"),a=Yr(e,"inputShape","sparseReshape","int32"),s=Yr(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==a.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(a.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const o={inputIndices:r,inputShape:a,newShape:s},i=Gr.runKernel("SparseReshape",o);return{outputIndices:i[0],outputShape:i[1]}}});Qr({sparseSegmentMean_:function(t,e,n){const r=Yr(t,"data","sparseSegmentMean"),a=Yr(e,"indices","sparseSegmentMean","int32"),s=Yr(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentMean",o)}});Qr({sparseSegmentSum_:function(t,e,n){const r=Yr(t,"data","sparseSegmentSum"),a=Yr(e,"indices","sparseSegmentSum","int32"),s=Yr(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(a.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const o={data:r,indices:a,segmentIds:s};return Gr.runKernel("SparseSegmentSum",o)}});Qr({stringNGrams_:function(t,e,n,r,a,s,o,i){const l=Yr(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error("Data must be a vector, saw: ".concat(l.shape));const c=Yr(e,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},h={data:l,dataSplits:c},d=Gr.runKernel("StringNGrams",h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});Qr({stringSplit_:function(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Yr(t,"input","stringSplit","string"),a=Yr(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error("Input should be Tensor1D but received shape ".concat(r.shape));if(0!==a.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(a.shape));const s={skipEmpty:n},o={input:r,delimiter:a},i=Gr.runKernel("StringSplit",o,s);return{indices:i[0],values:i[1],shape:i[2]}}});Qr({stringToHashBucketFast_:function(t,e){const n=Yr(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return Gr.runKernel("StringToHashBucketFast",a,r)}});const xl={flipLeftRight:Bi,grayscaleToRGB:Wi,resizeNearestNeighbor:nl,resizeBilinear:el,rotateWithOffset:Ui,cropAndResize:Pi,nonMaxSuppression:ji,nonMaxSuppressionAsync:Yi,nonMaxSuppressionWithScore:Zi,nonMaxSuppressionWithScoreAsync:Qi,nonMaxSuppressionPadded:$i,nonMaxSuppressionPaddedAsync:tl,threshold:il,transform:ll},kl={bandPart:cl,gramSchmidt:fl,qr:ml};class Sl extends ms{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:us((()=>mi(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:us((()=>mi(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;us((()=>{const t=ys(bo(s,this.rho),bo(_o(a),1-this.rho)),e=bo($s(oi(ys(o,this.epsilon)),oi(ys(s,this.epsilon))),a),n=ys(bo(o,this.rho),bo(_o(e),1-this.rho));s.assign(t),o.assign(n);const i=ys(bo(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(hs(this.accumulatedGrads.map((t=>t.variable))),hs(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}Sl.className="Adadelta",ls(Sl);class Il extends ms{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:us((()=>Ms(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;us((()=>{const t=ys(s,_o(a));s.assign(t);const e=ys(bo($s(a,oi(ys(t,Gr.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&hs(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}Il.className="Adagrad",ls(Il);class Nl extends ms{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],us((()=>{this.accBeta1=gs(e).variable(),this.accBeta2=gs(n).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);us((()=>{const n=yo(1,this.accBeta1),r=yo(1,this.accBeta2);e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:us((()=>mi(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:us((()=>mi(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=ys(bo(i,this.beta1),bo(o,1-this.beta1)),u=ys(bo(l,this.beta2),bo(_o(o),1-this.beta2)),h=$s(c,n),d=$s(u,r);i.assign(c),l.assign(u);const p=ys(bo($s(h,ys(oi(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(bo(this.accBeta1,this.beta1)),this.accBeta2.assign(bo(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&hs(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&hs(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),us((()=>{this.accBeta1.assign(hl(this.beta1,this.iterations_+1)),this.accBeta2.assign(hl(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Nl.className="Adam",ls(Nl);class Cl extends ms{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],us((()=>{this.iteration=gs(0).variable(),this.accBeta1=gs(e).variable()})),null==r&&(this.epsilon=Gr.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);us((()=>{const n=yo(1,this.accBeta1),r=$s(-this.learningRate,ys(bo(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=Gr.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:mi(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:mi(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=ys(bo(i,this.beta1),bo(o,1-this.beta1)),u=bo(l,this.beta2),h=bs(o),d=No(u,h);i.assign(c),l.assign(d);const p=ys(bo($s(r,n),$s(c,ys(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(ys(this.iteration,1)),this.accBeta1.assign(bo(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&hs(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&hs(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Cl.className="Adamax",ls(Cl);class El extends ms{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=Gr.registeredVariables[e];us((()=>{const t=ys(bo(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=ds(gs(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}El.className="SGD",ls(El);class Tl extends El{constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=gs(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:us((()=>mi(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&us((()=>{let t;const e=ys(bo(this.m,a),s);t=this.useNesterov?ys(bo(this.c,ys(s,bo(e,this.m))),r):ys(bo(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&hs(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Tl.className="Momentum",ls(Tl);class Al extends ms{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Gr.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Gr.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:us((()=>mi(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:us((()=>mi(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:us((()=>mi(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;us((()=>{const t=ys(bo(o,this.decay),bo(_o(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=ys(bo(e,this.decay),bo(s,1-this.decay)),l=$s(bo(s,this.learningRate),oi(yo(t,ys(_o(a),this.epsilon)))),c=ys(bo(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=yo(r,c);r.assign(u)}else{const t=ys(bo(o,this.decay),bo(_o(s),1-this.decay)),e=ys(bo(i,this.momentum),$s(bo(s,this.learningRate),oi(ys(t,this.epsilon))));o.assign(t),i.assign(e);const n=yo(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&hs(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&hs(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&hs(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Al.className="RMSProp",ls(Al);class Rl{static sgd(t){return new El(t)}static momentum(t,e){return new Tl(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new Al(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Nl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Sl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Cl(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new Il(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Fl={sgd:Rl.sgd,momentum:Rl.momentum,adadelta:Rl.adadelta,adagrad:Rl.adagrad,rmsprop:Rl.rmsprop,adamax:Rl.adamax,adam:Rl.adam},_l="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function Dl(){return new Promise((t=>_l((()=>t()))))}var Ol,zl=n(6494);function Ll(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(Ul(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=Ll(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function Ml(t){return Pl(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:Bl)}function Pl(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(Ul(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=Pl(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function Bl(t){return null===t?null:Ul(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function Wl(t,e){const n=new Map;Ll(t,e,n);for(const r of Array.from(n.keys())){const t=n.get(r);if(Ne(t)){const e=await t;n.set(r,e)}}return Ll(t,e,n)}function Ul(t){let e=!1;if(Ae().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(551);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Er)&&!(t instanceof Promise)&&!e)}function Vl(t){return function(t,e){return Ll(t,e)}(t,jl)}function jl(t){return t instanceof Er?{value:t.clone(),recurse:!1}:Ul(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class Gl{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class Hl extends Gl{constructor(){super(Hl.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function Kl(t){return new Yl(t)}function ql(t){return new Zl(t)}function Xl(t,e){return new lc(t,e)}Hl.INITIAL_CAPACITY=32;class Jl{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new ac(this,t)}filter(t){return new nc(this,t)}map(t){return new rc(this,t)}mapAsync(t){return new sc(this,t)}serialMapAsync(t){return new sc(this,t).serial()}flatmap(t){return new ic(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new ec(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bl;return this.rowMajorBatch(t,e).map((t=>Ml(t,n)))}concatenate(t,e){return new lc(Kl([this,t]),e)}take(t){return t<0||null==t?this:new tc(this,t)}skip(t){return t<0||null==t?this:new $l(this,t)}prefetch(t){return new uc(this,t)}shuffle(t,e){return new hc(this,t,e)}serial(){return new Ql(this)}}class Yl extends Jl{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:Vl(t),done:!1}}}class Zl extends Jl{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(v1){throw v1.message="Error thrown while iterating through a dataset: ".concat(v1.message),v1}}}class Ql extends Jl{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class $l extends Jl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;hs(t.value)}return this.upstream.next()}}class tc extends Jl{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class ec extends Jl{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class nc extends Jl{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;hs(t.value)}}}class rc extends Jl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Pr(t.value),n=this.transform(t.value),r=Pr(n);for(const a of e)Mr(a,r)||a.dispose();return{value:n,done:!1}}}class ac extends Jl{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(v1){if(!this.handler(v1))return{value:null,done:!0}}}}class sc extends Jl{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Pr(t.value),n=await this.transform(t.value),r=Pr(n);for(const a of e)Mr(a,r)||a.dispose();return{value:n,done:!1}}}class oc extends Jl{constructor(){super(),this.outputQueue=new Hl,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ic extends oc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Pr(t.value),n=this.transform(t.value),r=Pr(n);this.outputQueue.pushAll(n);for(const a of e)Mr(a,r)||a.dispose();return!0}}class lc extends Jl{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(Ol||(Ol={}));class cc extends Jl{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ol.FAIL;super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{".concat("TODO: fill in upstream of zip summaries","} -> Zip")}async nextState(t){await t;let e=0,n=0;const r=await Wl(this.iterators,(function(t){if(t instanceof Jl){return{value:t.next().then((t=>(e++,t.done&&n++,t.value))),recurse:!1}}return{value:null,recurse:!0}}));if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Ol.FAIL:throw new Error("Zipped streams should have the same length. "+"Mismatched at element ".concat(this.count,"."));case Ol.SHORTEST:return{value:null,done:!0};case Ol.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class uc extends Jl{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new Gl(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class hc extends uc{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Vo.alea(n||cr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class dc{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return ae(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),pc((async()=>(await n.iterator()).columnMajorBatch(t,e,mc)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,pc((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,pc((async()=>(await e.iterator()).filter((e=>us((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return pc((async()=>(await e.iterator()).map((e=>us((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return pc((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return pc((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,pc((async()=>Xl(ql((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,pc((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Vo.alea(e||cr().toString());return pc((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,pc((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function pc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends dc{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function fc(t){return pc((async()=>Kl(t)),t.length)}function gc(t){if(!Ul(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=null==e?t[n].size:Math.min(e,t[n].size);return pc((async()=>function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ol.FAIL;return new cc(t,e)}(await Wl(t,(t=>{if(t instanceof dc)return{value:t.iterator(),recurse:!1};if(Ul(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),Ol.SHORTEST)),e)}function mc(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Er||pe(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Er?li(t):ea(t)}(t),recurse:!1}}return{value:null,recurse:!0}}dc.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");class bc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bc.prototype)}}class yc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,yc.prototype)}}class vc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vc.prototype)}}class wc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,wc.prototype)}}class xc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xc.prototype)}}Error;class kc{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function Sc(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function Ic(t,e){if(!t)throw new xc(e)}function Nc(t,e){let n=0;for(const r of t)r===e&&n++;return n}function Cc(t){return 1===t.length?t[0]:t}function Ec(t){return Array.isArray(t)?t:[t]}function Tc(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Ac(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let Rc={};function Fc(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function _c(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>_c(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?_c(e):t[n]=e.value)}}}function Dc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in Rc)s=Rc[a];else if(s=e[a],null==s)throw new vc("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new vc("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in Rc?[i,l]=Rc.className:o in e&&([i,l]=e[o]),null==i)throw new vc("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(Rc))t[n]=Rc[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},Rc);for(const a of Object.keys(n))Rc[a]=n[a];_c(s.config);const r=l(i,s.config,n,a);return Rc=Object.assign({},e),r}{const t=Object.assign({},Rc);for(const r of Object.keys(n))Rc[r]=n[r];const e=new i(s.config);return Rc=Object.assign({},t),e}}}function Oc(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function zc(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function Lc(t){if(null==t)throw new vc("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Mc(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new vc("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function Pc(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Ic(n>=0),Ic(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function Bc(t,e){Array.isArray(t)?(ae(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>Bc(t,"element ".concat(n+1," of ").concat(e))))):ae(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(Wc(t),".")))}function Wc(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>Wc(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function Uc(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let Vc=0;function jc(){return Vc++}const Gc={};function Hc(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in Gc||(Gc[t]=0),Gc[t]+=1,t+Gc[t].toString()}const Kc=["channelsFirst","channelsLast"],qc=["nearest","bilinear"],Xc=["valid","same","causal"],Jc=["max","avg"],Yc=["sum","mul","concat","ave"],Zc=new Map;function Qc(t){Mc(Kc,"DataFormat",t)}function $c(t){Mc(Xc,"PaddingMode",t)}function tu(t){Mc(Jc,"PoolMode",t)}const eu=[],nu="/";function ru(t,e){eu.push(t);try{const t=e();return eu.pop(),t}catch(v1){throw eu.pop(),v1}}function au(t){if(!iu(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===eu.length?"":eu.join(nu)+nu)+t}function su(t){if(!iu(t))throw new Error("Not a valid tensor name: '"+t+"'");Zc.has(t)||Zc.set(t,0);const e=Zc.get(t);if(Zc.set(t,Zc.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return Zc.set(n,1),n}return t}const ou=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function iu(t){return!!t.match(ou)}function lu(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function cu(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function uu(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function hu(t,e){if(e<t)throw new vc("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let du;function pu(){return null==du&&(du=ps().epsilon()),du}function fu(t,e){return Ga(t,e)}function gu(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),Rs(t,n)}function mu(t,e,n){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:return ti(t,[e,0],[n,t.shape[1]]);case 3:return ei(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return ni(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Qo(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Qo(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new vc("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function bu(t,e,n){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:return ti(t,[0,e],[t.shape[0],n]);case 3:return ei(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return ni(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new vc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function yu(t,e,n,r){return us((()=>{switch(t.rank){case 1:return $o(t,e,n);case 2:switch(r){case 1:return mu(t,e,n);case 2:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return mu(t,e,n);case 2:return ei(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return mu(t,e,n);case 2:return ni(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return ni(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return bu(t,e,n);default:throw new vc("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new vc("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function vu(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Bs(t,n)}function wu(t,e){switch(t.rank){case 1:return Ws([t,e]);case 2:return Us([t,e],0);case 3:return Vs([t,e],0);case 4:return js([t,e],0);default:throw new vc("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function xu(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new vc("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return oo(t,e)}function ku(t){return Ho(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Su(t,e,n,r){if(t.rank<2||e.rank<2)throw new wc("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new wc("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return Oi({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Cu(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=Rs(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=Rs(vi(e,u),[l,-1]);const h=[...a,...c];return Rs(Oi({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?Cu(t.rank,r,"channelsLast"):null,activation:n}),h)}}function Iu(t,e,n){return us((()=>(e=Array.isArray(e)?ui(e,"int32"):Ga(e,"int32"),co(t,e,n))))}function Nu(t){return bo(t,t)}function Cu(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new vc("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1,1,1]):Rs(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,1,1,r[0]]):Rs(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1,1]):Rs(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,1,r[0]]):Rs(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?Rs(e,[1,r[0],1]):Rs(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Rs(e,[1,1,r[0]]):Rs(e,[1].concat(r))}else if(t<3)return e;throw new vc("Unsupported input rank by biasAdd: ".concat(e.rank))}function Eu(t,e,n){return us((()=>(null==n&&(n="channelsLast"),Qc(n),ys(t,Cu(t.rank,e,n)))))}function Tu(t,e,n,r){return us((()=>wi(t,e,n,r)))}function Au(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const Ru=["fanIn","fanOut","fanAvg"],Fu=["normal","uniform","truncatedNormal"];class _u extends os{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Du extends _u{apply(t,e){return Mo(t,e)}}Du.className="Zeros",ls(Du);class Ou extends _u{apply(t,e){return Po(t,e)}}Ou.className="Ones",ls(Ou);class zu extends _u{constructor(t){if(super(),"object"!==typeof t)throw new vc("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new vc("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return us((()=>bo(gs(this.value),Po(t,e))))}getConfig(){return{value:this.value}}}zu.className="Constant",ls(zu);class Lu extends _u{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Ko(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Lu.className="RandomUniform",ls(Lu);class Mu extends _u{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("randomNormal does not support dType ".concat(e,"."));return ku(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Mu.className="RandomNormal",ls(Mu);class Pu extends _u{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("truncatedNormal does not support dType ".concat(e,"."));return di(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Pu.className="TruncatedNormal",ls(Pu);class Bu extends _u{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return us((()=>{if(2!==t.length||t[0]!==t[1])throw new vc("Identity matrix initializer can only be used for 2D square matrices.");return bo(this.gain,io(t[0]))}))}getConfig(){return{gain:this.gain}}}Bu.className="Identity",ls(Bu);class Wu extends _u{constructor(t){if(super(),t.scale<0)throw new vc("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,Mc(Ru,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){Mc(Fu,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Qc(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=lu(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=lu(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=lu(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new wc("".concat(this.getClassName()," does not support dType ").concat(e,"."));return di(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return Ko(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Wu.className="VarianceScaling",ls(Wu);class Uu extends Wu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Uu.className="GlorotUniform",ls(Uu);class Vu extends Wu{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Vu.className="GlorotNormal",ls(Vu);class ju extends Wu{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}ju.className="HeNormal",ls(ju);class Gu extends Wu{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Gu.className="HeUniform",ls(Gu);class Hu extends Wu{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Hu.className="LeCunNormal",ls(Hu);class Ku extends Wu{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Wu.className}}Ku.className="LeCunNormal",ls(Ku);class qu extends _u{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new wc("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return us((()=>{if(t.length<2)throw new wc("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than 2000 (".concat(t[0]*t[1],") elements: ")+"Slowness may result.");const e=ku(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=kl.gramSchmidt(e);return t[0]>t[1]&&(n=vi(n)),bo(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}qu.className="Orthogonal",ls(qu);const Xu={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ju(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"initializer")}function Yu(t){return Fc(t)}function Zu(t){if("string"===typeof t){const e=t in Xu?Xu[t]:t;if("GlorotNormal"===e)return new Vu;if("GlorotUniform"===e)return new Uu;if("HeNormal"===e)return new ju;if("HeUniform"===e)return new Gu;if("LeCunNormal"===e)return new Hu;if("LeCunUniform"===e)return new Ku;{const t={};return t.className=e,t.config={},Ju(t)}}return t instanceof _u?t:Ju(t)}function Qu(t){return Array.isArray(t)&&Array.isArray(t[0])}function $u(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function th(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new vc("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function eh(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new vc("Expected exactly 1 Shape; got ".concat(t.length))}return t}function nh(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const rh="Variable";class ah{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rh,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=jc(),n=null==n?rh:n,this.originalName=au(n),this.name=su(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Gr.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function sh(t){return t.map((t=>t.read()))}function oh(t){t.forEach((t=>{t[0].write(t[1])}))}class ih{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class lh{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=jc(),null!=s&&(this.originalName=au(s),this.name=su(this.originalName)),this.rank=e.length}}let ch=0;class uh{constructor(t,e){this.callArgs=e,this.id=ch++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hh=0;class dh extends os{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hh++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=Tc(t)+"_"+Hc(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new yc("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new vc("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return Cc(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Cc(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new bc("Layer ".concat(this.name)+" is not connected, no input to return.");return Cc(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bc("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new bc("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Cc(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Ec(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=Ec(this.inputSpec);if(t.length!==e.length)throw new vc("Layer ".concat(this.name," expects ").concat(e.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(t));for(let n=0;n<t.length;n++){const r=t[n],a=e[n];if(null==a)continue;const s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&r.dtype!==a.dtype)throw new vc("Input ".concat(n," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(r.dtype,"."));if(a.axes){const t=r.shape;for(const e in a.axes){const r=Number(e),s=a.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(o))throw new vc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(r," of input shape to ")+"have value ".concat(s," but got shape ").concat(t,"."))}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const e=a.shape[t],s=r.shape[t];if(null!=e&&null!=s&&e!==s)throw new vc("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(r.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=Ec(t);let r=!0;for(const s of n)if(!(s instanceof lh)){r=!1;break}let a=!0;for(const s of n)if(s instanceof lh){a=!1;break}if(r===a)throw new vc("Arguments to apply() must be all SymbolicTensors or all Tensors");return ru(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of Ec(t))e.push(n.shape);this.build(Cc(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);const a=Ec(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=Cc(s),null!=this.activityRegularizer)throw new wc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=Ec(t);const e=[];for(const n of t)e.push(n.shape);return Cc(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new lh(s,n,this,Ec(t),e,this.name,r))):new lh(s,r,this,Ec(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new wc("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bc("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new bc("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new yc("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return nh(this.weights)}build(t){this.built=!0}getWeights(){return sh(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){us((()=>{const e=this.weights;if(e.length!==t.length)throw new vc('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=sh(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!ce(s.shape,i.shape))throw new vc("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}oh(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new vc("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():Zu("zeros"));const l=r.apply(e,n),c=new ah(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Ec(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=Ec(t);e=Ec(e),n=Ec(n),r=Ec(r),a=$u(a),s=$u(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new uh({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function ph(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=ph(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class fh extends dh{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:Hc("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new vc("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new vc("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new vc("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new lh(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new vc("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function gh(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new vc("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;null==n&&(n="float32");return new fh({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}fh.className="InputLayer",ls(fh);class mh{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof mh)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new vc("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Ga(e,t.dtype)}catch(w1){throw new vc("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof lh){if(null==this.id2Value[t.id])throw new vc("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new vc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof lh){if(null==this.id2Value[t.id])throw new vc("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new vc("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&hs(this.id2Mask)}}const bh=new kc,yh=new kc;function vh(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=bh.get(u);if(null==d){const t=function(t,e){ae(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=xh(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=xh(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:wh(r)}}(o,e);d=t.sorted,h=t.recipientCounts,bh.put(u,d),yh.put(u,h)}h={},a||Object.assign(h,yh.get(u));const p=new mh(e);for(let f=0;f<d.length;++f){if(null!=r){const t=cs().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof fh)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=Ec(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=kh(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||hs(u)}return p.disposeMasks(),s?l:l[0]}function wh(t){const e={};for(const n in t)e[n]=t[n].size;return e}function xh(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function kh(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}Ae().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=bh&&bh.setMaxEntries(t),null!=yh&&yh.setMaxEntries(t)}));const Sh={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Ci(Ga(n,"float32"),-1))}}},Ih={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=_o(Ga(n,"float32")),r=oi(yo(gs(1),e));return Oo($s(t,r))}}}},Nh={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oi(yo(_o(Ga(n,"float32")),1));return $s(t,e)}}}},Ch={kernelName:Oe,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{let e=t;const r=eo(n.shape,a);return r.length>0&&(e=vo(e,r)),Rs(e,n.shape)},b:()=>{let e=t;const n=eo(r.shape,a);return n.length>0&&(e=vo(e,n)),Rs(e,r.shape)}}}},Eh={kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},Th={kernelName:ze,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mi(n)}}},Ah={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mi(n)}}},Rh={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,oi(yo(gs(1),_o(Ga(n,"float32")))))}}},Fh={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=oi(ys(gs(1),_o(Ga(n,"float32"))));return $s(t,e)}}}},_h={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=ys(_o(n),_o(r));let s=bo(t,$s(r,e));const o=eo(n.shape,a);return o.length>0&&(s=vo(s,o)),Rs(s,n.shape)},b:()=>{const e=ys(_o(n),_o(r));let s=Oo(bo(t,$s(n,e)));const o=eo(r.shape,a);return o.length>0&&(s=vo(s,o)),Rs(s,r.shape)}}}},Dh={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,ys(_o(Ga(n,"float32")),1))}}},Oh={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,yo(gs(1),_o(Ga(n,"float32"))))}}};const zh=Qr({avgPool3dGrad_:function(t,e,n,r,a,s){const o=Yr(t,"dy","avgPool3dGrad"),i=Yr(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),ae(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),As("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Gr.runKernel("AvgPool3DGrad",h,d);return u?Rs(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Lh={kernelName:Me,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>zh(t,r,a,s,o,i)}}};const Mh=Qr({avgPoolGrad_:function(t,e,n,r,a){const s=Yr(t,"dy","avgPoolGrad"),o=Yr(e,"input","avgPoolGrad");ae(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=Rs(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Rs(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),ae(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=Gr.runKernel("AvgPoolGrad",u,h);return c?Rs(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ph={kernelName:Le,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Mh(t,r,a,s,o)}}},Bh={kernelName:Pe,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>ko(t,a,!1,!1),b:()=>ko(t,r,!0,!1)}:s&&!o?{a:()=>ko(a,t,!1,!0),b:()=>ko(r,t,!1,!1)}:{a:()=>ko(a,t,!0,!0),b:()=>ko(t,r,!0,!0)}:{a:()=>ko(t,a,!1,!0),b:()=>ko(r,t,!0,!1)}}};const Wh=Qr({spaceToBatchND_:function(t,e,n){const r=Yr(t,"x","spaceToBatchND");ae(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),ae(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),ae(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return Gr.runKernel(zn,a,s)}}),Uh={kernelName:Be,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Wh(t,r,a)}}},Vh={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>vo(t,i,!0)}}},jh={kernelName:We,gradFunc:t=>({x:()=>t.clone()})},Gh={kernelName:"Ceil",gradFunc:t=>({x:()=>mi(t)})},Hh={kernelName:Ue,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>gi(xo(ho(r,a),al(r,s)),t,mi(t))}}},Kh={kernelName:Ve,inputsToSave:["x"],gradFunc:Sh.gradFunc},qh={kernelName:je,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=de(a,e[0].shape)[0],o=r.map((t=>t[s]));return si(t,o,s).map((t=>()=>t))}},Xh={kernelName:Ge,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return ae(Es(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>Ks(r.shape,t,a,o,i,l),filter:()=>Ii(r,t,a.shape,o,i,l)}}},Jh={kernelName:He,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Gs(t,a,s,o,i,1,l),filter:()=>Ii(t,r,a.shape,s,o,i,l)}}};const Yh=Qr({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=Rs(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=Rs(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ae(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),ae(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),ae(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),ae(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),ae(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return Gr.runKernel("Conv3DBackpropFilterV2",i,l)}}),Zh={kernelName:Ke,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;ae(Es(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>Js(o.shape,t,i,a,s),filter:()=>Yh(o,t,i.shape,a,s)}}};const Qh=Qr({sin_:function(t){const e={x:Yr(t,"x","sin","float32")};return Gr.runKernel("Sin",e)}}),$h={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(Oo(Qh(Ga(n,"float32"))),t)}}};const td=Qr({sinh_:function(t){const e={x:Yr(t,"x","sinh")};return Gr.runKernel(Fn,e)}}),ed={kernelName:qe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(td(Ga(n,"float32")),t)}}};const nd=Qr({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Yr(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel(Xe,a,s)}}),rd={kernelName:Xe,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=Ro([a],r.rank);let n=nd(t,a,s,!o);return null!=e&&(n=vi(n,e)),n}}}},ad={kernelName:Je,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;ae(Es(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return ae(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),ae(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),ae(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),ae(Ts(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),As("depthwiseConv2d",s,o),{x:()=>Di(l.shape,t,c,a,s,i,o),filter:()=>_i(l,t,c.shape,a,s,i,o)}}},sd={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>Gr.runKernel("Dilation2DBackpropInput",s,n),filter:()=>Gr.runKernel("Dilation2DBackpropFilter",o,n)}}},od={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Gr.runKernel("EluGrad",r)}}},id={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bo(ao(Oo(_o(n))),2/Math.sqrt(Math.PI));return{x:()=>bo(t,r)}}},ld={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,n)}}},cd={kernelName:Ze,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>Rs(t,n.shape)}}},ud={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,ao(n))}}},hd={kernelName:$e,gradFunc:t=>({x:()=>mi(t)})},dd={kernelName:tn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=$s(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{let e=bo(t,Ga(n,"float32"));const s=eo(r.shape,a);s.length>0&&(e=Rs(vo(e,s),r.shape));const o=_o(r);return Oo($s(e,Ga(o,"float32")))}}}};const pd=Qr({rsqrt_:function(t){const e={x:Yr(t,"x","rsqrt","float32")};return Gr.runKernel(En,e)}}),fd={kernelName:en,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?gs(1):i,c=eo(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=yo(a,s),d=bo(t,l),p=pd(ys(o,gs(r))),f=bo(bo(bo(p,p),p),gs(-.5));return{x:()=>1===s.rank?Rs(bo(bo(t,oo(Rs(p,[1,1,1,s.shape[0]]),u)),l),a.shape):Rs(bo(bo(t,p),l),a.shape),mean:()=>{let t=bo(bo(p,gs(-1)),d);return 1===s.rank&&(t=vo(t,c)),Rs(t,s.shape)},variance:()=>{let t=bo(bo(f,h),d);return 1===s.rank&&(t=vo(t,c)),Rs(t,s.shape)},scale:()=>{const e=bo(h,p);let n=bo(t,e);return 1===s.rank&&(n=vo(n,c)),Rs(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=vo(e,c)),Rs(e,s.shape)}}}};const gd=Qr({unsortedSegmentSum_:function(t,e,n){const r=Yr(t,"x","unsortedSegmentSum"),a=Yr(e,"segmentIds","unsortedSegmentSum","int32");ae(ue(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return Gr.runKernel(jn,s,o)}}),md={kernelName:nn,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s}=n,o=de(s,r.shape)[0];return{x:()=>{const e=r.shape,n=a.size,i=e.slice(0,o),l=i.length,c=e.slice(s,e.length).slice(1),u=c.length,h=bd(0,l),d=bd(l+1,l+1+u),p=yd([i,[n],c]),f=Rs(t,p),g=Rs(a,[n]),m=yd([[l],h,d]),b=vi(f,m);let y=gd(b,g,r.shape[o]);const v=Fo(m);return y=vi(y,v),y},indices:()=>a}}};function bd(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function yd(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const vd={kernelName:rn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>mi(n),b:()=>mi(r)}}},wd={kernelName:an,gradFunc:t=>({x:()=>Ga(t,"float32")})},xd={kernelName:"IsFinite",gradFunc:t=>({x:()=>mi(t)})},kd={kernelName:"IsInf",gradFunc:t=>({x:()=>mi(t)})},Sd={kernelName:"IsNan",gradFunc:t=>({x:()=>mi(t)})},Id={kernelName:sn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=uo(r,0);return{x:()=>gi(s,t,bo(t,a))}}},Nd={kernelName:on,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,ys(n,1))}}},Cd={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,Ga(n,"float32"))}}},Ed={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=ao(r);return yo(t,bo(vo(t,a,!0),e))}}}};const Td=Qr({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Gr.runKernel("LRNGrad",r,a)}}),Ad={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>Td(r,a,t,s,o,i,l)}}};function Rd(t,e,n,r){return e.rank<n.rank&&(e=Rs(e,Ao(e.shape,r))),t.rank<n.rank&&(t=Rs(t,Ao(t.shape,r))),{x:()=>bo(t,Ga(ro(n,e),t.dtype))}}const Fd={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=Rd(t,e[1],s,de(a,s.shape));return{x:()=>o.x()}}};const _d=Qr({less_:function(t,e){let n=Yr(t,"a","less","string_or_numeric"),r=Yr(e,"b","less","string_or_numeric");[n,r]=Lr(n,r),no(n.shape,r.shape);const a={a:n,b:r};return Gr.runKernel("Less",a)}}),Dd={kernelName:ln,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bo(t,Ga(ho(n,r),"float32")),b:()=>bo(t,Ga(_d(n,r),"float32"))}}};const Od=Qr({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=Yr(t,"dy","maxPool3dGrad"),l=Yr(e,"input","maxPool3dGrad"),c=Yr(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=Rs(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=Rs(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Rs(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ae(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),ae(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),ae(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),As("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=Gr.runKernel("MaxPool3DGrad",f,g);return p?Rs(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),zd={kernelName:un,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>Od(t,r,a,s,o,i,l)}}};const Ld=Qr({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=Yr(t,"dy","maxPoolGrad"),l=Yr(e,"input","maxPoolGrad"),c=Yr(n,"output","maxPoolGrad");ae(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),ae(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),ae(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),As("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return Gr.runKernel("MaxPoolGrad",u,h)}}),Md={kernelName:cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>Ld(t,r,a,s,o,i)}}},Pd={kernelName:hn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=de(a,r.shape),o=function(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}(r.shape,s),i=le(o[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=Rs(t,e);return $s(bo(n,Po(r.shape,"float32")),i)}}}},Bd={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=Rd(t,o,s,de(a,s.shape));return{x:()=>i.x()}}},Wd={kernelName:dn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bo(t,Ga(al(n,r),"float32")),b:()=>bo(t,Ga(uo(n,r),"float32"))}}},Ud={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Qo(t,s,r.shape)}}},Vd={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=eo(n.shape,a);return e.length>0?Rs(vo(t,e),n.shape):t},b:()=>{const e=bo(t,Oo(lo($s(n,r)))),s=eo(r.shape,a);return s.length>0?Rs(vo(e,s),r.shape):e}}}},jd={kernelName:pn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=bo(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{const e=bo(t,Ga(n,"float32")),s=eo(r.shape,a);return s.length>0?Rs(vo(e,s),r.shape):e}}}},Gd={kernelName:"Neg",gradFunc:t=>({x:()=>Oo(t)})},Hd={kernelName:gn,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Mo(n.shape,"float32")}}},Kd={kernelName:fn,gradFunc:t=>({x:()=>mi(t)})},qd={kernelName:mn,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return pi(t,r).map((t=>()=>t))}},Xd={kernelName:bn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>Qo(t,s,r.shape)}}},Jd={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=no(s.shape,o.shape);return{a:()=>{const e=Ga(o,"float32");let n=bo(t,bo(e,hl(s,yo(e,gs(1)))));const r=eo(s.shape,i);return r.length>0&&(n=vo(n,r)),Rs(n,s.shape)},b:()=>{const e=uo(s,0),n=gi(e,fo(s),mi(s));let r=bo(t,bo(a,n));const l=eo(o.shape,i);return l.length>0&&(r=vo(r,l)),Rs(r,o.shape)}}}},Yd={kernelName:yn,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=uo(n,0);return{x:()=>gi(a,t,bo(t,r)),alpha:()=>{let e=gi(a,mi(t),bo(t,n));const s=eo(r.shape,t.shape);return s.length>0&&(e=vo(e,s)),Rs(e,r.shape)}}}};const Zd=Qr({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:Yr(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return Gr.runKernel("Cumprod",a,s)}});function Qd(t,e,n){const r=t.shape.length,a=r-n.length,s=Ro(n,r);let o=t;null!=s&&(o=vi(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=Rs(e,r),s=Zd(t,n,!0,!1),o=Zd(t,n,!0,!0),i=bo(s,o);return bo(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=Fo(s);c=vi(c,t)}return c}const $d={kernelName:"Prod",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>Qd(r,t,s)}}},tp={kernelName:Ye,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{const e=$s(t,Ga(r,"float32")),s=eo(n.shape,a);return s.length>0?Rs(vo(e,s),n.shape):e},b:()=>{let e=bo(t,Ga(n,"float32"));const s=eo(r.shape,a);s.length>0&&(e=Rs(vo(e,s),r.shape));const o=_o(r);return Oo($s(e,Ga(o,"float32")))}}}},ep={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,Oo(_o(n)))}}},np={kernelName:In,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bo(al(n,6),Ci(n));return{x:()=>bo(t,Ga(r,"float32"))}}},rp={kernelName:wn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Ga(Ci(n),"float32"))}}},ap={kernelName:xn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Rs(t,n.shape)}}},sp={kernelName:Sn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeBilinearGrad",a,n)}}},op={kernelName:kn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>Gr.runKernel("ResizeNearestNeighborGrad",a,n)}}},ip={kernelName:Nn,gradFunc:(t,e,n)=>{const{dims:r}=n,a=de(r,t.shape);return{x:()=>Xo(t,a)}}},lp={kernelName:Cn,gradFunc:t=>({x:()=>mi(t)})},cp={kernelName:En,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Oo($s(t,bo(hl(n,1.5),2)))}}};const up=Qr({logicalNot_:function(t){const e={x:Yr(t,"x","logicalNot","bool")};return Gr.runKernel("LogicalNot",e)}}),hp={kernelName:Tn,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Ga(mi(n),"float32"),t:()=>bo(t,Ga(n,t.dtype)),e:()=>bo(t,Ga(up(n),t.dtype))}}},dp={kernelName:An,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=uo(n,gs(0)),r=gs(1.7580993408473768),a=gs(1.0507009873554805),s=bo(t,a),o=bo(bo(t,r),ao(Ga(n,"float32")));return gi(e,s,o)}}}},pp={kernelName:_n,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,bo(n,yo(gs(1),n)))}}},fp={kernelName:"Sign",gradFunc:t=>({x:()=>mi(t)})};const gp=Qr({cos_:function(t){const e={x:Yr(t,"x","cos","float32")};return Gr.runKernel("Cos",e)}}),mp={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(gp(Ga(n,"float32")),t)}}};const bp=Qr({cosh_:function(t){const e={x:Yr(t,"x","cosh","float32")};return Gr.runKernel(qe,e)}}),yp={kernelName:Fn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(bp(Ga(n,"float32")),t)}}};const vp={kernelName:Rn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=function(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{ae(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(ae(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>Wo(t,c)}}},wp={kernelName:Mn,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=bo(t,r);return{logits:()=>yo(s,bo(vo(s,[a],true),r))}}},xp={kernelName:Dn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,Zo(n))}}};const kp=Qr({batchToSpaceND_:function(t,e,n){const r=Yr(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));ae(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),ae(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),ae(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return Gr.runKernel(Be,s,o)}}),Sp={kernelName:zn,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>kp(t,r,a)}}},Ip={kernelName:Ln,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Bs(t,r)}}};const Np=[Sh,Ih,Nh,Ch,Eh,Th,Ah,Rh,Fh,_h,Dh,Oh,Lh,Ph,Bh,Uh,Vh,jh,Gh,Hh,Kh,qh,Jh,Xh,Zh,$h,ed,rd,ad,sd,tp,od,id,ld,cd,ud,dd,hd,fd,md,vd,wd,xd,kd,Sd,Id,Nd,Cd,Ed,Ad,Fd,Fd,Dd,zd,Md,Pd,Bd,Wd,Ud,Vd,jd,Gd,Hd,Kd,qd,Xd,Xd,Jd,Yd,$d,ep,np,rp,ap,sp,op,ip,lp,cp,hp,dp,pp,fp,mp,yp,vp,wp,xp,Sp,Sp,Ip,Ip,{kernelName:On,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,bo(oi(Ga(n,"float32")),2))}}},{kernelName:Pn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=gs(2);return{a:()=>bo(t,bo(a,yo(n,r))),b:()=>bo(t,bo(a,yo(r,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(t,bo(Ga(n,"float32"),2))}}},{kernelName:Hn,gradFunc:t=>({x:()=>mi(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=no(n.shape,r.shape);return{a:()=>{let e=t;const r=eo(n.shape,a);return r.length>0&&(e=vo(e,r)),Rs(e,n.shape)},b:()=>{let e=t;const n=eo(r.shape,a);return n.length>0&&(e=vo(e,n)),Rs(Oo(e),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;de(s,r.shape).forEach((t=>{a[t]=1}));const o=Rs(t,a),i=bo(o,Po(r.shape,"float32"));return{x:()=>i}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$s(t,_o(gp(n)))}}},{kernelName:Bn,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bo(yo(gs(1),_o(n)),t)}}},{kernelName:Wn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=mi(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=ys(e,Qo(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=ys(e,Qo(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Un,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=Fo(a);return{x:()=>vi(t,s)}}},{kernelName:Vn,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>li(t,a)}}},{kernelName:jn,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=No(e,mi(e)),r=co(t,n);let a=ho(e,gs(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=so(a,i+1);a=xo(a,Po(r.shape,"bool"));const o=mi(r);return gi(a,r,o)}(t,n)}}},{kernelName:Gn,gradFunc:t=>({x:()=>mi(t)})}];for(const n of Np)nr(n);function Cp(t,e){return us((()=>oi(vo(bo(t,t),e,!0))))}class Ep extends os{getConfig(){return{}}}class Tp extends Ep{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>{const e=Cp(t,this.axis),n=Ps(e,0,this.maxValue);return bo(t,$s(n,ys(pu(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Tp.className="MaxNorm",ls(Tp);class Ap extends Ep{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>$s(t,ys(pu(),Cp(t,this.axis)))))}getConfig(){return{axis:this.axis}}}Ap.className="UnitNorm",ls(Ap);class Rp extends Ep{apply(t){return qo(t)}}Rp.className="NonNeg",ls(Rp);class Fp extends Ep{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return us((()=>{const e=Cp(t,this.axis),n=ys(bo(this.rate,Ps(e,this.minValue,this.maxValue)),bo(1-this.rate,e));return bo(t,$s(n,ys(pu(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Fp.className="MinMaxNorm",ls(Fp);const _p={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Dp(t){return Fc(t)}function Op(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"constraint")}function zp(t){if(null==t)return null;if("string"===typeof t){return Op({className:t in _p?_p[t]:t,config:{}})}return t instanceof Ep?t:Op(t)}async function Lp(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];hs(r)}}function Mp(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var Pp;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(Pp||(Pp={}));class Bp{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Wp{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class Up extends Bp{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=us((()=>ys(this.totals[r],bo(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:us((()=>{const t=bo($s(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),ds(e[n])})))}}class Vp extends Bp{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class jp extends Bp{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Dl,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");me(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():cr();return function(){const s=null!=n?n():cr();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await Lp(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await Lp(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await Lp(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await Lp(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await Lp(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):me(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await Lp(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await Lp(t),await this.trainEnd(t))}}function Gp(t,e){if(null==t&&(t={}),t instanceof Bp)return[t];if(Array.isArray(t)&&t[0]instanceof Bp)return t;return Ec(t).map((t=>new jp(t,e)))}class Hp{constructor(){}static registerCallbackConstructor(t,e){ae(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),Hp.checkForDuplicate(e),null==Hp.constructors[t]&&(Hp.constructors[t]=[]),Hp.constructors[t].push(e)}static checkForDuplicate(t){for(const e in Hp.constructors){Hp.constructors[+e].forEach((e=>{if(e===t)throw new vc("Duplicate callback constructor.")}))}}static clear(){Hp.constructors={}}static createCallbacks(t){const e=[];for(const n in Hp.constructors){const r=+n;t>=r&&e.push(...Hp.constructors[r])}return e.map((t=>new t))}}function Kp(t,e,n,r,a,s,o,i,l){const c=new Vp,u=[new Up,...Hp.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new Wp(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function qp(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Dc(t,is.getMap().classNameMap,e,"layer",n)}function Xp(t,e){return us((()=>{"float32"!==t.dtype&&(t=Ga(t,"float32"));const n=vo(Nu(t),e,!0),r=Ms(n.shape,pu()),a=oi(No(n,r));return $s(t,a)}))}function Jp(t,e){return us((()=>Co(Nu(yo(e,t)),-1)))}function Yp(t,e){return us((()=>Co(bs(yo(e,t)),-1)))}function Zp(t,e){return us((()=>{const n=yo(t,e),r=Ps(bs(t),pu(),Number.MAX_VALUE),a=bs($s(n,r));return bo(100,Co(a,-1))}))}function Qp(t,e){return us((()=>{const n=Ps(e,pu(),Number.MAX_VALUE),r=fo(ys(1,n)),a=Ps(t,pu(),Number.MAX_VALUE),s=fo(ys(1,a));return Co(Nu(yo(r,s)),-1)}))}function $p(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{if(n)e=ri(e);else{const t=vo(e,e.shape.length-1,!0);e=$s(e,t)}return e=Ps(e,pu(),1-pu()),Oo(vo(bo(Ga(t,"float32"),fo(e)),e.shape.length-1))}))}function tf(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{const r=Ga(lo(function(t){const e=[lu(t.shape)];return Rs(t,e)}(t)),"int32"),a=(e=Ps(e,pu(),1-pu())).shape;return $p(Rs(Lo(r,a[a.length-1]),a),e,n)}))}function ef(t,e){return us((()=>{let n;return n=Ps(e,pu(),1-pu()),n=fo($s(n,yo(1,n))),Co(function(t,e){if(!ce(t.shape,e.shape))throw new vc("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return us((()=>{const n=qo(e),r=Oo(bs(e));return ys(yo(n,bo(e,t)),go(ao(r)))}))}(t,n),-1)}))}function nf(t,e){return us((()=>{const n=Ps(t,pu(),1),r=Ps(e,pu(),1);return vo(bo(t,fo($s(n,r))),-1)}))}function rf(t,e){return us((()=>{const n=Xp(t,-1),r=Xp(e,-1),a=bo(n,r);return Oo(vo(a,-1))}))}Hp.constructors={};const af={meanSquaredError:Jp,meanAbsoluteError:Yp,meanAbsolutePercentageError:Zp,meanSquaredLogarithmicError:Qp,squaredHinge:function(t,e){return us((()=>{const n=No(0,yo(1,bo(t,e)));return Co(Nu(n),-1)}))},hinge:function(t,e){return us((()=>{const n=No(0,yo(1,bo(t,e)));return Co(n,-1)}))},categoricalHinge:function(t,e){return us((()=>{const n=vo(bo(t,e),-1),r=mo(bo(yo(1,t),e),-1);return No(0,ys(1,yo(r,n)))}))},logcosh:function(t,e){return us((()=>{const n=Math.log(2),r=yo(e,t),a=yo(ys(r,ai(bo(-2,r))),n);return Co(a,-1)}))},categoricalCrossentropy:$p,sparseCategoricalCrossentropy:tf,binaryCrossentropy:ef,kullbackLeiblerDivergence:nf,poisson:function(t,e){return us((()=>{const n=fo(ys(pu(),e));return Co(yo(e,bo(t,n)),-1)}))},cosineProximity:rf};function sf(t){if("string"===typeof t){if(t in af)return af[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new vc(e)}return t}function of(t,e){return us((()=>{const n=bo(.5,Bo(e)),r=fu(uo(e,n),t.dtype);return Co(ro(t,r),-1)}))}function lf(t,e){return us((()=>fu(ro(xs(t,-1),xs(e,-1)),"float32")))}function cf(t,e){return us((()=>Ga(vo(xo(ro(t,1),ro(e,1))),"float32")))}function uf(t,e){return ef(t,e)}function hf(t,e){return t.rank===e.rank&&(t=ii(t,[t.rank-1])),(e=xs(e,-1)).dtype!==t.dtype&&(e=Ga(e,t.dtype)),Ga(ro(t,e),"float32")}const df=$p,pf=tf,ff={binaryAccuracy:of,categoricalAccuracy:lf,precision:function(t,e){return us((()=>{const n=cf(t,e),r=function(t,e){return us((()=>Ga(vo(xo(ro(t,0),ro(e,1))),"float32")))}(t,e),a=ys(n,r);return Ga(gi(uo(a,0),$s(n,a),0),"float32")}))},categoricalCrossentropy:df,sparseCategoricalCrossentropy:pf,mse:Jp,MSE:Jp,mae:Yp,MAE:Yp,mape:Zp,MAPE:Zp,cosine:rf};function gf(t){if("string"===typeof t&&t in ff)return ff[t];if("string"!==typeof t&&null!=t)return t;throw new vc("Unknown metric ".concat(t))}function mf(t){if(Ic(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys(af))if(af[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(ff))if(ff[n]===t){e=n;break}return void 0!==e?e:t.name}}const bf=1048576;function yf(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!vf(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>bf&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(bf,"."))}}function vf(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!vf(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!vf(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function wf(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),xf(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?kf(i[u],n,r):Sf(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?nh(t.collectedTrainableWeights):nh(t.trainableWeights);return e}(t),c=nh(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function xf(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function kf(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(w1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(w1){r="multiple"}const s=t.name,o=t.getClassName();xf(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function Sf(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(w1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(w1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];xf(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)xf(["","","","",o[u]],e,r)}function If(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function Nf(t,e){if(null===t)return null;if("string"===typeof t)return Ac(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];If(e,a,r)?n.push(r):n.push(Nf(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=Ac(n);e[t]=Nf(r,t)}}return e}}function Cf(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return Tc(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];If(e,a,r)?n.push(r):n.push(Cf(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=Tc(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?Cf(r,n):r}return e}}const Ef="3.21.0";class Tf extends dh{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=Hc(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],zc(this.inputs).length!==this.inputs.length)throw new vc("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));zc(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;Ic(0===e,"input layer has >1 nodes"),Ic(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof fh))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new yc("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(Tf.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(Oc);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Tf&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(Oc);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new yc("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new yc('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new vc("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;for(const s of this.layers)for(const t of s.weights){if(null!=n[t.originalName])throw new vc("Duplicate weight name: ".concat(t.originalName));n[t.originalName]=t,r++}const a=[];for(const s in t){let r=s;if(null==n[s]){const t=s.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])a.push([n[r],t[s]]);else if(e)throw new vc("Provided weight data has no target variable: ".concat(s));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new vc("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}oh(a)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(Ef),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Cf(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return us((()=>{t=Ec(t);const n=new mh;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return vh(this.outputs,n,e)}))}computeMask(t,e){return us((()=>{let n;return t=Ec(t),n=null==e?Sc(null,t.length):Ec(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=$u(t);if(e.length!==this.inputLayers.length)throw new vc("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Oc);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=$u(t.computeOutputShape(Cc(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];Ic(t in n),a.push(n[t])}return Cc(a)}runInternalGraph(t,e){null==e&&(e=Sc(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(Oc);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=Ec(t.call(e,c)),l=Ec(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=Ec(t.call(r,c)),l=Ec(t.computeMask(r,o));if(t.activityRegularizer)throw new wc("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){Ic(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof Tf?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=Tf.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new vc("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}if(null==t)throw new vc("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new vc("No such layer: ".concat(t))}calculateLosses(){return us((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=Tf.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=Tf.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(w1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[Tf.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=Tf.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=Tf.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(Cc(n),a)}function i(t){const a=t.name,o=qp(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new vc("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!Lc(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];Ic(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];Ic(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new vc("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){us((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function Af(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Rf(t,e){return Af(t,e,"classWeight")}async function Ff(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=us((()=>{if(1===t.shape.length)return Ha(t);if(2===t.shape.length){if(t.shape[1]>1){return xs(t,1)}if(1===t.shape[1])return Rs(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());hs(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),ui(a,"float32")}return null}function _f(t,e){return bo(t,e)}function Df(t,e){let n,r;const a=e;n=a.xs,r=a.ys,ae(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=Of("input",t.inputNames,n),o=Of("output",t.outputNames,r),i=s[0].shape[0];ae(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),ae(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)ae(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)ae(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function Of(t,e,n){if(n instanceof Er)return[n];if(Array.isArray(n))return ae(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new vc("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function zf(t,e,n){const r=null!=n.batchesPerEpoch;if(ae(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),ae(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),ae(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),ae(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),ae(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(Lf(n.validationData))ae(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new wc("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=Gp(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Kp(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=Df(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Rf(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Ff(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);hs(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,ds(n)}await d.onBatchEnd(h,s),Mp(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=Lf(n.validationData)?Ec(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):Ec(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Lf(t){return"function"===typeof t.iterator}function Mf(t){ae(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function Pf(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>mu(t,e,n-e))):mu(t,e,n-e)}function Bf(t,e){return us((()=>null==t?null:Array.isArray(t)?t.map((t=>Bf(t,e))):Iu(t,"int32"===e.dtype?e:Ga(e,"int32"))))}function Wf(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}async function Uf(t,e,n){let r,a,s,o,i,l,c,u,h,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const p=null==d.batchSize?32:d.batchSize;Mf(p);const f=!1,g=await t.standardizeUserData(e,n,d.sampleWeight,d.classWeight,f,p);r=g[0],a=g[1],h=g[2];let m,b=!1;if(null!=d.validationData&&d.validationData.length>0){if(b=!0,2!==d.validationData.length)throw 3===d.validationData.length?new wc("validationData including sample weights is not supported yet."):new vc("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));i=d.validationData[0],l=d.validationData[1];const e=!0,n=await t.standardizeUserData(i,l,null,null,e,p);c=n[0],u=n[1],m=c.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){b=!0;const t=Math.floor(r[0].shape[0]*(1-d.validationSplit)),e=r[0].shape[0];c=Pf(r,t,e),s=r,r=Pf(r,0,t),u=Pf(a,t,e),o=a,a=Pf(a,0,t),m=c.concat(u)}else null!=d.validationSteps&&(b=!0);const y=r.concat(a).concat(h);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),w=t.getDedupedMetricsNames();let x,k;b?(t.makeTestFunction(),x=t.testFunction,k=w.slice().concat(w.map((t=>"val_"+t)))):(x=null,m=[],k=w.slice());const S=Gp(d.callbacks,d.yieldEvery),I=await async function(t,e,n,r,a,s,o,i,l,c,u,h,d,p,f){null==a&&(a=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let g=!1;if(null!=l&&null!=c&&(g=!0),null!=f&&(g=!0,null==p))throw new vc("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=t.checkNumSamples(n,a,p,"steps_per_epoch");let b;null!=m&&(b=hu(0,m)),null==o&&(o=1);const{callbackList:y,history:v}=Kp(i,o,s,d,m,p,a,g,h);y.setModel(t),t.history=v,await y.onTrainBegin(),t.stopTraining_=!1;for(let w=d;w<s;++w){await y.onEpochBegin(w);const s={};if(null!=p)throw new wc("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new wc("batch shuffling is not implemneted yet");u&&ne(b);const o=ui(b),i=Wf(m,a);for(let u=0;u<i.length;++u){const h={};if(await y.onBatchBegin(u,h),us((()=>{const d=i[u][0],p=i[u][1],f=mu(o,d,p-d);h.batch=u,h.size=p-d;const m=Bf(n,f),b=e(m);for(let t=0;t<r.length;++t){const e=r[t],n=b[t];h[e]=n,ds(n)}if(u===i.length-1&&g){const e=t.testLoop(l,c,a);for(let t=0;t<r.length;++t){const n=r[t],a=e[t];ds(a),s["val_"+n]=a}}})),await y.onBatchEnd(u,h),Mp(h),t.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(w,s),t.stopTraining_)break}return await y.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,w,p,d.epochs,d.verbose,S,x,m,d.shuffle,k,d.initialEpoch,null,null);return I}finally{t.isTraining=!1,jf(r,e),jf(a,n),jf(s,e),jf(o,n),jf(c,i),jf(u,l),null!=h&&hs(h)}}function Vf(t){const e=[];t instanceof Er&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(gu(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function jf(t,e){if(null==t)return;const n=[];if(e instanceof Er)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Er)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Gf(t){return Array.isArray(t)}function Hf(t){return!function(t){return t instanceof Er}(t)&&!Gf(t)}function Kf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Gf(t)&&t.length>0)e=!0;else if(Hf(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new vc("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(Hf(t)){r=[];for(const n of e){if(null==t[n])throw new vc('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Gf(t)){if(t.length!==e.length)throw new vc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new vc("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=Vf(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new vc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new vc("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function qf(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new vc("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new vc("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new vc("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new vc("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class Xf extends Tf{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new vc("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");wf(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>Fl.adagrad(.01),Adadelta:()=>Fl.adadelta(1,.95,pu()),Adam:()=>Fl.adam(.001,.9,.999,pu()),Adamax:()=>Fl.adamax(.002,.9,.999,pu(),0),RMSProp:()=>Fl.rmsprop(.001,.9,0,pu()),SGD:()=>Fl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new vc("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ms))throw new vc("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new vc("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>sf(t)))}else{const n=sf(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new vc('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push(sf(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ru("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};ru("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===ef?-1!==["accuracy","acc"].indexOf(o)?r=of:-1!==["crossentropy","ce"].indexOf(o)&&(r=uf):this.lossFunctions[t]===tf?-1!==["accuracy","acc"].indexOf(o)?r=hf:-1!==["crossentropy","ce"].indexOf(o)&&(r=pf):-1!==["accuracy","acc"].indexOf(o)?r=lf:-1!==["crossentropy","ce"].indexOf(o)&&(r=df),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=gf(o);s=t,n=""+mf(o)}let e;ru(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Mf(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return Cc(this.testLoop(e,t,r,n.verbose,n.steps))}finally{jf(a[0],t),jf(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new wc("Verbose mode is not implemented yet.");ae(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=us((()=>{if(e.value){const{xs:n,ys:r}=Df(t,e.value),o=n.concat(r),c=us((()=>a(o)));if(hs(o),0===l)for(let t=0;t<c.length;++t)s.push(gs(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=us((()=>ys(s[t],bo(u,e)))),l>0&&hs(n)}hs(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=$s(s[c],i),hs(t)}return Cc(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new vc("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new vc("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new vc("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new mh;if(t instanceof Er&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new vc("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new vc("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=vh(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=Sc(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new vc("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return us((()=>{const r=this.checkNumSamples(t);if(n)throw new wc("Verbose predictLoop() is not implemented yet.");const a=Wf(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){us((()=>{const n=a[e][0],r=a[e][1],s=Pf(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new mh(o);return vh(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return Cc(s.map((t=>Bs(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Vf(t);qf(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return Mf(t),this.predictLoop(n,t)}finally{jf(n,t)}}predictOnBatch(t){qf(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new yc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===tf?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=zc(t.map((t=>t.shape[0])));r.sort();const a=zc(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new vc("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new vc("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!ce(r,a))throw new vc("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=Kf(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Kf(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[Jp,ef,$p];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===$p&&1===s.shape[s.shape.length-1])throw new vc("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new vc("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new vc("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Rf(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Ff(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return us((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new wc("Verbose mode is not implemented yet.");if(null!=a)throw new wc("steps mode in testLoop() is not implemented yet");{const r=Wf(s,n),a=ui(hu(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=mu(a,s,i-s),c=Bf(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(gs(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=ys(o[t],bo(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=$s(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(Nc(t,r)>1){const e=Nc(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new mh(t),i=vh(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=_f(t,a[n]));const s=Co(t);e.push(s),l=0===n?t:ys(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=Co(e(r[a],i[a]))}ds(t),s.push(t)}return l=Co(l),this.calculateLosses().forEach((t=>{l=ys(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>us((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new mh(s),i=vh(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=Co(r(a[t],i[t]));n=0===t?s:ys(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=Co(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){return Uf(this,t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}async fitDataset(t,e){return zf(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return hs(s),jf(n[0],t),jf(n[1],e),Cc(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=cs().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-cs().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=Tc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>Tc(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=Tc(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Tc(mf(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>Tc(mf(t))));{const t={};for(const e in this.metrics)t[e]=Tc(mf(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=qp(Nf(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=Ac(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>Ac(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=Ac(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>Ac(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=Ac(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,fa.getSaveHandlers(n));if(0===e.length)throw new vc("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new vc("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new vc("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await aa(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Ef),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await aa(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=ca([r.data,e])}if(null!=this.userDefinedMetadata){const t=!0;yf(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){yf(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Xf.className="Model",ls(Xf);class Jf extends Xf{}async function Yf(t,e){if(null==e&&(e={}),"string"===typeof t){const n=ga(t,e);if(0===n.length)n.push($a(t,e));else if(n.length>1)throw new vc("Found more than one (".concat(n.length,") load handlers for ")+"URL '".concat(t,"'"));t=n[0]}return async function(t,e,n){null==n&&(n={});if(null==t.load)throw new vc("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let a=r.modelTopology;null!=a.model_config&&(a=a.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,i=qp(Nf(a),e,o),l=r.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=r.userDefinedMetadata&&i.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new vc("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=sa(t,e),r={},a=[];return e.forEach((t=>{"optimizer"===t.group?a.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);i.loadWeights(t,s),null!=i.optimizer&&e.length>0&&await i.optimizer.setWeights(e),hs(t),hs(e.map((t=>t.tensor)))}return i}(t,void 0,e)}Jf.className="Functional",ls(Jf);class Zf extends Xf{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:Hc("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new vc("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof Zf||t instanceof Xf;let n;if(e){if(n=t,1!==n.outputs.length)throw new vc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new vc("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new vc("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=gh({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new vc("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new vc("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=ph(this.outputs[0])}this.inboundNodes=[],new uh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Sc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(eh(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Xf({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new yc("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new vc("Legacy serialization format not supported yet.");n=e}else ae(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof Zf))throw new wc("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=qp(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new vc("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new vc("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}function Qf(t){return new Xf(t)}function $f(t,e){return null==e&&(e={}),Yf(t,e)}Zf.className="Sequential",ls(Zf);class tg extends os{getConfig(){return{}}}class eg extends tg{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new wc("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return to(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}eg.className="elu",ls(eg);class ng extends tg{apply(t){return Jo(t)}}ng.className="selu",ls(ng);class rg extends tg{apply(t){return qo(t)}}rg.className="relu",ls(rg);class ag extends tg{apply(t){return us((()=>Eo(6,qo(t))))}}ag.className="relu6",ls(ag);class sg extends tg{apply(t){return t}}sg.className="linear",ls(sg);class og extends tg{apply(t){return Zo(t)}}og.className="sigmoid",ls(og);class ig extends tg{apply(t){return function(t){return us((()=>{const e=ys(.5,bo(.2,t));return Ps(e,0,1)}))}(t)}}ig.className="hardSigmoid",ls(ig);class lg extends tg{apply(t){return ai(t)}}lg.className="softplus",ls(lg);class cg extends tg{apply(t){return function(t){return us((()=>$s(t,ys(bs(t),1))))}(t)}}cg.className="softsign",ls(cg);class ug extends tg{apply(t){return ci(t)}}ug.className="tanh",ls(ug);class hg extends tg{apply(t){return ri(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}hg.className="softmax",ls(hg);class dg extends tg{apply(t){return wo(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}dg.className="logSoftmax",ls(dg);class pg extends tg{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return us((()=>bo(Zo(bo(t,e)),t)))}}pg.className="swish",ls(pg);class fg extends tg{apply(t){return us((()=>bo(t,ci(ai(t)))))}}function gg(t){return t.getClassName()}function mg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"activation")}function bg(t){if(null==t){const t={className:"linear",config:{}};return mg(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},mg(e)}return t instanceof tg?t:mg(t)}function yg(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}fg.className="mish",ls(fg);class vg extends os{}class wg extends vg{constructor(t){super(),yg(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return us((()=>{let e=Mo([1]);return this.hasL1&&(e=ys(e,vo(bo(this.l1,bs(t))))),this.hasL2&&(e=ys(e,vo(bo(this.l2,Nu(t))))),Rs(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}wg.className="L1L2",ls(wg);const xg={l1l2:"L1L2"};function kg(t){return Fc(t)}function Sg(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Dc(t,is.getMap().classNameMap,e,"regularizer")}function Ig(t){if(null==t)return null;if("string"===typeof t){return Sg({className:t in xg?xg[t]:t,config:{}})}return t instanceof vg?t:Sg(t)}class Ng extends dh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=th(t);let n=qo(t);return null!=this.maxValue&&(n=Ps(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}Ng.className="ReLU",ls(Ng);class Cg extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=th(t);return po(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Cg.className="LeakyReLU",ls(Cg);class Eg extends dh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Zu(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ig(t.alphaRegularizer),this.alphaConstraint=zp(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new vc("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=eh(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new ih({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=th(t),Uo(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Yu(this.alphaInitializer),alphaRegularizer:kg(this.alphaRegularizer),alphaConstraint:Dp(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}Eg.className="PReLU",ls(Eg);class Tg extends dh{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new wc("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=th(t);return to(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Tg.className="ELU",ls(Tg);class Ag extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=th(t);return bo(n,Ga(uo(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}Ag.className="ThresholdedReLU",ls(Ag);class Rg extends dh{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new hg).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=th(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Fg(t,e,n){if("number"===typeof t)return Sc(t,e);if(t.length!==e)throw new vc("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new vc("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function _g(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function Dg(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+uu([n-e,0]);else{if("same"!==r)throw new vc("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function Og(t,e){return us((()=>(Qc(e),"channelsFirst"===e?vi(t,[0,2,3,1]):t)))}function zg(t,e){return us((()=>(Qc(e),"channelsFirst"===e?vi(t,[0,2,3,4,1]):t)))}function Lg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),3!==t.shape.length)throw new vc("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new vc("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new vc("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=vi(t,[0,2,1])),"causal"===a)throw new wc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Hs(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=Eu(i,n)),i}))}function Mg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),3!==t.rank&&4!==t.rank)throw new vc("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new vc("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=Og(t,s);if("causal"===a)throw new wc("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Fi({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=vi(l,[0,3,1,2])),l}))}function Pg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return us((()=>{if(null==s&&(s="channelsLast"),Qc(s),4!==t.rank&&5!==t.rank)throw new vc("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new vc("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=zg(t,s);if("causal"===a)throw new wc("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=Xs(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=Eu(i,n)),"channelsFirst"===s&&(i=vi(i,[0,4,1,2,3])),i}))}Rg.className="Softmax",ls(Rg);class Bg extends dh{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Bg.verifyArgs(e),this.rank=t,Bc(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new wc("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=Fg(e.kernelSize,t,"kernelSize"),this.strides=Fg(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,$c(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Qc(this.dataFormat),this.activation=bg(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Zu(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=zp(e.biasConstraint),this.biasRegularizer=Ig(e.biasRegularizer),this.activityRegularizer=Ig(e.activityRegularizer),this.dilationRate=Fg(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new vc("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new vc("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new vc("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(Ic("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,3))throw new vc("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:gg(this.activation),useBias:this.useBias,biasInitializer:Yu(this.biasInitializer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),biasConstraint:Dp(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Wg extends Bg{constructor(t,e){super(t,e),this.kernel=null,Wg.verifyArgs(e),this.filters=e.filters,Bc(this.filters,"filters"),this.kernelInitializer=Zu(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=zp(e.kernelConstraint),this.kernelRegularizer=Ig(e.kernelRegularizer)}build(t){t=eh(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return us((()=>{let e;t=th(t);const n=null==this.bias?null:this.bias.read(),r=Uc(this.activation.getClassName());if(null!=r&&2===this.rank)e=Mg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=Lg(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=Mg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new wc("convolutions greater than 3D are not implemented yet.");e=Pg(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=eh(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=_g(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Yu(this.kernelInitializer),kernelRegularizer:kg(this.kernelRegularizer),kernelConstraint:Dp(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new vc("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class Ug extends Wg{constructor(t){super(2,t),Ug.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,2))throw new vc("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}Ug.className="Conv2D",ls(Ug);class Vg extends Wg{constructor(t){super(3,t),Vg.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new vc("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}Vg.className="Conv3D",ls(Vg);class jg extends Ug{constructor(t){if(super(t),this.inputSpec=[new ih({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new vc("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=eh(t)).length)throw new vc("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ih({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e=th(t);if(4!==e.shape.length)throw new vc("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,Dg(o,u,l,this.padding),Dg(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vi(e,[0,2,3,1]));let p=qs(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=vi(p,[0,3,1,2])),null!=this.bias&&(p=Eu(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=eh(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=Dg(e[r],i,s,this.padding),e[a]=Dg(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}jg.className="Conv2DTranspose",ls(jg);class Gg extends Vg{constructor(t){if(super(t),this.inputSpec=[new ih({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new vc("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=eh(t)).length)throw new vc("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new vc("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ih({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e=th(t);if(5!==e.shape.length)throw new vc("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,Dg(i,p,u,this.padding),Dg(l,f,h,this.padding),Dg(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=vi(e,[0,2,3,4,1]));let b=Ys(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=vi(b,[0,4,1,2,3])),null!==this.bias&&(b=Eu(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=eh(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=Dg(e[r],c,o,this.padding),e[a]=Dg(e[a],u,i,this.padding),e[s]=Dg(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Gg.className="Conv3DTranspose",ls(Gg);class Hg extends Wg{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new vc("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new vc("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new vc("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Zu(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ig(e.depthwiseRegularizer),this.depthwiseConstraint=zp(e.depthwiseConstraint),this.pointwiseInitializer=Zu(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ig(e.pointwiseRegularizer),this.pointwiseConstraint=zp(e.pointwiseConstraint)}build(t){if((t=eh(t)).length<this.rank+2)throw new vc("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new vc("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new ih({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return us((()=>{let e;if(t=th(t),1===this.rank)throw new wc("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=vi(t,[0,2,3,1])),e=Yo(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=Eu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=vi(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Yu(this.depthwiseInitializer),t.pointwiseInitializer=Yu(this.pointwiseInitializer),t.depthwiseRegularizer=kg(this.depthwiseRegularizer),t.pointwiseRegularizer=kg(this.pointwiseRegularizer),t.depthwiseConstraint=Dp(this.depthwiseConstraint),t.pointwiseConstraint=Dp(this.pointwiseConstraint),t}}Hg.className="SeparableConv";class Kg extends Hg{constructor(t){super(2,t)}}Kg.className="SeparableConv2D",ls(Kg);class qg extends Wg{constructor(t){super(1,t),qg.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!Pc(t.kernelSize,"number",1,1))throw new vc("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}qg.className="Conv1D",ls(qg);class Xg extends dh{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return us((()=>{if(t=th(t),"channelsLast"===this.dataFormat){const e=yu(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yu(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=yu(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yu(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Xg.className="Cropping2D",ls(Xg);class Jg extends dh{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,Mc(qc,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return us((()=>{let e=th(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=vi(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?xl.resizeNearestNeighbor(e,[t,r]):xl.resizeBilinear(e,[t,r]);return vi(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?xl.resizeNearestNeighbor(e,[t,r]):xl.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}Jg.className="UpSampling2D",ls(Jg);class Yg extends Bg{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Zu(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=zp(t.depthwiseConstraint),this.depthwiseRegularizer=Ig(t.depthwiseRegularizer)}build(t){if((t=eh(t)).length<4)throw new vc("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new vc("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return us((()=>{null==a&&(a="channelsLast"),Qc(a);let o=Og(t,a);if(4!==t.rank)throw new vc("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new vc("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=Zs(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=vi(o,[0,3,1,2])),o}))}(t=th(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=Eu(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=eh(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=_g(e,this.kernelSize[0],this.padding,this.strides[0]),s=_g(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Yu(this.depthwiseInitializer),t.depthwiseRegularizer=kg(this.depthwiseRegularizer),t.depthwiseConstraint=Dp(this.depthwiseRegularizer),t}}function Zg(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new vc("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function Qg(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return us((()=>{const l=e.shape.length;if(l<3)throw new vc("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(hu(2,l));if(e=vi(e,c),null!=s)throw new wc("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=Ga(Ga(a,"bool"),"float32"),a.rank===l-1&&(a=so(a,-1)),a=vi(a,c)),r&&(e=Xo(e,0),null!=a&&(a=Xo(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=pi(e);let g,m;null!=a&&(g=pi(a));for(let e=0;e<p;++e){const n=f[e],r=us((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=us((()=>{const t=g[e],n=yo(Bo(t),t);return{output:ys(bo(r[0],t),bo(d[0],n)),newStates:d.map(((e,a)=>ys(bo(r[1][a],t),bo(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=li(u,1)}return[h,m,d]}))}Yg.className="DepthwiseConv2D",ls(Yg);class $g extends dh{constructor(t){let e;if(super(t),null==t.cell)throw new vc("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new im({cells:t.cell}):t.cell,null==e.stateSize)throw new vc("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new ih({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return hu(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Qu(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return us((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new wc("Constants support is not implemented in RNN yet.");Qu(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new ih({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ce(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new vc("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new ih({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];us((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new vc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Mo([n,t]))):this.states_=[Mo([n,this.cell.stateSize])];else if(null==t)hs(this.states_),null!=this.keptStates&&(hs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>Mo([n,t]))):this.states_[0]=Mo([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new vc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):hs(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!ce(r.shape,s))throw new vc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>ds(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Zg(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new ih({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof lh){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return us((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=th(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new vc("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=Qg(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return us((()=>{let e=Mo(t.shape);return e=vo(e,[1,2]),e=gu(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?xu(e,[1,t]):e)):this.cell.stateSize>1?[xu(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===$g.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=qp(e.cell,n);return new t(Object.assign(e,{cell:r}))}}$g.className="RNN",ls($g);class tm extends dh{}class em extends tm{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Bc(this.units,"units"),this.activation=bg(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=eh(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{if(2!==t.length)throw new vc("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=Su(null!=s?bo(t,s):t,this.kernel.read()),null!=this.bias&&(a=Eu(a,this.bias.read())),null!=o&&(n=bo(n,o));let i=ys(a,Su(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}em.className="SimpleRNNCell",ls(em);class nm extends $g{constructor(t){t.cell=new em(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}nm.className="SimpleRNN",ls(nm);class rm extends tm{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new vc("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Bc(this.units,"units"),this.activation=bg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=bg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=eh(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return us((()=>{if(2!==t.length)throw new vc("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=bo(t,a[0]));let c=Su(t,this.kernel.read());this.useBias&&(c=Eu(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bo(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=si(u,[2*this.units,this.units],u.rank-1),p=Su(r,h),[f,g,m]=si(c,3,c.rank-1),[b,y]=si(p,2,p.rank-1);o=this.recurrentActivation.apply(ys(f,b)),i=this.recurrentActivation.apply(ys(g,y));const v=Su(bo(i,r),d);l=this.activation.apply(ys(m,v));const w=ys(bo(o,r),bo(ys(1,Oo(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),recurrentActivation:gg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}rm.className="GRUCell",ls(rm);class am extends $g{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new rm(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}am.className="GRU",ls(am);class sm extends tm{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Bc(this.units,"units"),this.activation=bg(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=bg(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zu(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ig(t.kernelRegularizer),this.recurrentRegularizer=Ig(t.recurrentRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.kernelConstraint=zp(t.kernelConstraint),this.recurrentConstraint=zp(t.recurrentConstraint),this.biasConstraint=zp(t.biasConstraint),this.dropout=cu([1,uu([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=cu([1,uu([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=eh(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends _u{apply(e,r){const a=t.apply([n]),s=(new Ou).apply([n]),o=t.apply([2*n]);return wu(wu(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return us((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new vc("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=bo(t,s[0]));let h=Su(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bo(r,o[0])),h=ys(h,Su(r,this.recurrentKernel.read())),this.useBias&&(h=Eu(h,this.bias.read()));const[d,p,f,g]=si(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=ys(bo(l,a),bo(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=bo(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gg(this.activation),recurrentActivation:gg(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),recurrentInitializer:Yu(this.recurrentInitializer),biasInitializer:Yu(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:kg(this.kernelRegularizer),recurrentRegularizer:kg(this.recurrentRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),recurrentConstraint:Dp(this.recurrentConstraint),biasConstraint:Dp(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}sm.className="LSTMCell",ls(sm);class om extends $g{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new sm(t),super(t)}call(t,e){return us((()=>{null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}om.className="LSTM",ls(om);class im extends tm{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return us((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;Qu(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{ru("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign({},t,e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(qp(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return sh(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}oh(e)}}function lm(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):Tu(e(),n),i=()=>Au(o,e,r);if(!a||a<=1)return ds(i().clone());return Array(a).fill(void 0).map(i).map((t=>ds(t.clone())))}im.className="StackedRNNCells",ls(im);var cm=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class um extends $g{constructor(t){if(t.unroll)throw new wc("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new wc("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ih({ndim:5})]}call(t,e){return us((()=>{if(null!=this.cell.dropoutMask&&(hs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new vc("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return us((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=Mo([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];us((()=>{if(!this.stateful)throw new bc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new vc("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mo(a))):this.states_=[Mo(a)];else if(null==t)hs(this.states_),null!=this.keptStates&&(hs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mo(a))):this.states_[0]=Mo(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new vc("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):hs(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!ce(n.shape,r))throw new vc("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>ds(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=_g(l,r[0],a,s[0],o[0]),h=_g(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}um.className="ConvRNN2D";class hm extends sm{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign({},t,{units:e})),this.filters=e,Bc(this.filters,"filters"),this.kernelSize=Fg(n,2,"kernelSize"),this.kernelSize.forEach((t=>Bc(t,"kernelSize"))),this.strides=Fg(r||1,2,"strides"),this.strides.forEach((t=>Bc(t,"strides"))),this.padding=a||"valid",$c(this.padding),this.dataFormat=s||"channelsLast",Qc(this.dataFormat),this.dilationRate=Fg(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>Bc(t,"dilationRate")))}build(t){var e;t=eh(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new vc("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends _u{apply(t,e){return vu([n.apply([r]),Po([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return us((()=>{if(3!==t.length)throw new vc("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lm({ones:()=>Bo(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?bo(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lm({ones:()=>Bo(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=si(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?si(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,C,E,T]=si(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),g=this.recurrentConv(g,E),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(ys(l,p)),R=this.recurrentActivation.apply(ys(c,f)),F=ys(bo(R,s),bo(A,this.activation.apply(ys(u,g)))),_=bo(this.recurrentActivation.apply(ys(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=cm(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(t,e,n,r){const a=Gs(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Eu(a,n,this.dataFormat):a}recurrentConv(t,e){return Gs(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}hm.className="ConvLSTM2DCell",ls(hm);class dm extends um{constructor(t){const e=new hm(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}dm.className="ConvLSTM2D",ls(dm);class pm extends dh{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return Au((()=>Tu(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}pm.className="Dropout",ls(pm);class fm extends pm{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}fm.className="SpatialDropout1D",ls(fm);class gm extends dh{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Bc(this.units,"units"),this.activation=bg(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=Zu(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Zu(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=zp(t.kernelConstraint),this.biasConstraint=zp(t.biasConstraint),this.kernelRegularizer=Ig(t.kernelRegularizer),this.biasRegularizer=Ig(t.biasRegularizer),this.activityRegularizer=Ig(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=eh(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=eh(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=Uc(this.activation.getClassName());let a;return null!=r?a=Su(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Su(n,this.kernel.read()),null!=this.bias&&(a=Eu(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:gg(this.activation),useBias:this.useBias,kernelInitializer:Yu(this.kernelInitializer),biasInitializer:Yu(this.biasInitializer),kernelRegularizer:kg(this.kernelRegularizer),biasRegularizer:kg(this.biasRegularizer),activityRegularizer:kg(this.activityRegularizer),kernelConstraint:Dp(this.kernelConstraint),biasConstraint:Dp(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}gm.className="Dense",ls(gm);class mm extends dh{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=eh(t);for(const e of t.slice(1))if(null==e)throw new vc('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],lu(t,1)]}call(t,e){return us((()=>{this.invokeCallHook(t,e);let n=th(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=vi(n,t)}return function(t){if(t.rank<=1)throw new vc("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],lu(t.shape,1)];return Rs(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}mm.className="Flatten",ls(mm);class bm extends dh{constructor(t){super(t),this.supportsMasking=!0,this.activation=bg(t.activation)}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);return this.activation.apply(n)}))}getConfig(){const t={activation:gg(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}bm.className="Activation",ls(bm);class ym extends dh{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return us((()=>{return t=th(t),e=t,n=this.n,us((()=>{if(2!==e.shape.length)throw new vc("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return xu(gu(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}ym.className="RepeatVector",ls(ym);class vm extends dh{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new vc("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=lu(t);if(null!==s){if(0===a||o%a!==0)throw new vc(n);r[s]=o/a}else if(o!==a)throw new vc(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Rs(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}vm.className="Reshape",ls(vm);class wm extends dh{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=hu(1,t.dims.length+1);if(!ce(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ih({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=eh(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return vi(th(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}wm.className="Permute",ls(wm);class xm extends dh{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=th(t);return ws(zo(n,this.maskValue),-1)}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t),r=ws(zo(n,this.maskValue),-1,!0);return bo(n,Ga(r,n.dtype))}))}}xm.className="Masking",ls(xm);class km extends dh{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Ec(t.inputLength))}this.inputDim=t.inputDim,Bc(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Bc(this.outputDim,"outputDim"),this.embeddingsInitializer=Zu(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ig(t.embeddingsRegularizer),this.activityRegularizer=Ig(t.activityRegularizer),this.embeddingsConstraint=zp(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return us((()=>this.maskZero?(t=th(t),zo(t,mi(t))):null))}computeOutputShape(t){if(t=eh(t),null==this.inputLength)return[...t,this.outputDim];const e=Ec(this.inputLength);if(e.length!==t.length-1)throw new vc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new vc('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return us((()=>{this.invokeCallHook(t,e);let n=th(t);"int32"!==n.dtype&&(n=fu(n,"int32"));const r=Iu(this.embeddings.read(),Rs(n,[n.size]));return Rs(r,eh(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yu(this.embeddingsInitializer),embeddingsRegularizer:kg(this.embeddingsRegularizer),activityRegularizer:kg(this.activityRegularizer),embeddingsConstraint:Dp(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}km.className="Embedding",ls(km);class Sm extends dh{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new wc}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new vc("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[eh(t)]),t.length<2)throw new vc("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=zc(e),e.length>1)throw new vc("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===zc(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return us((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=uu(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=gu(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=Rs(s,[r].concat(lu(t.slice(1))));o=vi(o,[1,0]),o=Rs(o,a),e.push(o),n=!0}else if(t>1){const r=hu(1,t).concat([0]);e.push(vi(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=Rs(vi(Rs(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(hu(0,a-1));r=vi(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=zc(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return us((()=>{if(null==e)return null;if(!Array.isArray(e))throw new vc("`mask` should be an Array");if(!Array.isArray(t))throw new vc("`inputs` should be an Array");if(e.length!==t.length)throw new vc("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:so(t,0))))[0];for(let t=1;t<e.length-1;++t)n=xo(n,e[t]);return n}))}}class Im extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ys(e,t[n]);return e}))}}Im.className="Add",ls(Im);class Nm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bo(e,t[n]);return e}))}}Nm.className="Multiply",ls(Nm);class Cm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ys(e,t[n]);return bo(1/t.length,e)}))}}Cm.className="Average",ls(Cm);class Em extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=No(e,t[n]);return e}))}}Em.className="Maximum",ls(Em);class Tm extends Sm{constructor(t){super(t)}mergeFunction(t){return us((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Eo(e,t[n]);return e}))}}Tm.className="Minimum",ls(Tm);class Am extends Sm{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new vc("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if(ce(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new vc("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return us((()=>vu(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new vc("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new vc("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new vc("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new vc("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return us((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(Ga(Bo(t[s]),"bool")):e[s].rank<t[s].rank?r.push(so(e[s],-1)):r.push(e[s]);const a=Bs(r,this.axis);return vs(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function Rm(t,e){for(;t<0;)t+=e;return t}Am.className="Concatenate",ls(Am);class Fm extends Sm{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){ae(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new wc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new vc("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new vc("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>Rm(e,t[n].shape.length))):[Rm(this.axes,n.shape.length),Rm(this.axes,r.shape.length)],this.normalize&&(n=Xp(n,e[0]),r=Xp(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new wc("batchDot is not implemented for tensors of 4D or higher rank yet");if(ae(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),ae(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new wc("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return us((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Rs(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Rs(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?vo(bo(t,e),s[0]):vo(bo(vi(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=ko(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=ii(o,e)}return 1===o.shape.length&&(o=so(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[Rm(this.axes,t.length),Rm(this.axes,e.length)],n}computeOutputShape(t){ae(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new wc("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Fm.className="Dot",ls(Fm);class _m extends dh{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);return Au((()=>ys(ku(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}_m.className="GaussianNoise",ls(_m);class Dm extends dh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return us((()=>{this.invokeCallHook(t,e);const n=th(t);if(this.rate>0&&this.rate<1){return Au((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return bo(n,ku(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}Dm.className="GaussianDropout",ls(Dm);class Om extends dh{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||th(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return us((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=th(t),r=-1.7580993408473766;let a=ho(Ko(n),this.rate);a=fu(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=ys(bo(e,a),bo(ys(a,-1),r));return ys(bo(i,s),o)};return Au(r,(()=>th(t)),e.training||!1)}return t}))}}function zm(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=Os(t,e,n,r,a,o);else if(3===t.rank)s=zs(t,e,n,r,a,o);else{if(4!==t.rank)throw new wc("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=Ls(t,e,n,r,a,o)}return s}function Lm(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ce(r.slice().sort(),hu(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return us((()=>{const s=Do(t,r),o=s.mean,i=s.variance;return[zm(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return us((()=>{const s=Do(t,r),o=s.mean,i=s.variance,l=[];for(const e of hu(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=Rs(o,l),u=Rs(i,l),h=null==e?null:Rs(e,l),d=null==n?null:Rs(n,l);return[zm(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}Om.className="AlphaDropout",ls(Om);class Mm extends dh{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Zu(t.betaInitializer||"zeros"),this.gammaInitializer=Zu(t.gammaInitializer||"ones"),this.movingMeanInitializer=Zu(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Zu(t.movingVarianceInitializer||"ones"),this.betaConstraint=zp(t.betaConstraint),this.gammaConstraint=zp(t.gammaConstraint),this.betaRegularizer=Ig(t.betaRegularizer),this.gammaRegularizer=Ig(t.gammaRegularizer)}build(t){t=eh(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new vc("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new ih({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return us((()=>{const n=null!=e.training&&e.training,r=th(t),a=r.shape,s=a.length,o=hu(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=Sc(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!ce(c,hu(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=Rs(this.movingMean.read(),l),e=Rs(this.movingVariance.read(),l),n=this.center?Rs(this.beta.read(),l):null,a=this.scale?Rs(this.gamma.read(),l):null;return zm(r,t,e,n,a,this.epsilon)}return zm(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=Lm(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{us((()=>{const r=1-n,a=t.read(),s=bo(yo(a,e),r);t.write(yo(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yu(this.betaInitializer),gammaInitializer:Yu(this.gammaInitializer),movingMeanInitializer:Yu(this.movingMeanInitializer),movingVarianceInitializer:Yu(this.movingVarianceInitializer),betaRegularizer:kg(this.betaRegularizer),gammaRegularizer:kg(this.gammaRegularizer),betaConstraint:Dp(this.betaConstraint),gammaConstraint:Dp(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Mm.className="BatchNormalization",ls(Mm);class Pm extends dh{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=Zu(t.betaInitializer||"zeros"),this.gammaInitializer=Zu(t.gammaInitializer||"ones"),this.betaRegularizer=Ig(t.betaRegularizer),this.gammaRegularizer=Ig(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=eh(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==zc(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=th(t),r=n.shape,a=r.length;return us((()=>{let{mean:t,variance:e}=Do(n,this.axis,!0);const s=Sc(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?Rs(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=oo(t,c),e=oo(e,c),null!=i&&(i=oo(i,u)),null!=l&&(l=oo(l,u)),zm(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yu(this.betaInitializer),gammaInitializer:Yu(this.gammaInitializer),betaRegularizer:kg(this.betaRegularizer),gammaRegularizer:kg(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Pm.className="LayerNormalization",ls(Pm);class Bm extends dh{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new vc("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new vc("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new vc("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){let e,n;return t=eh(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return us((()=>{return e=th(t),n=this.padding,r=this.dataFormat,us((()=>{if(4!==e.rank)throw new vc("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new vc("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new vc("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Wo(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function Wm(t,e,n,r,a,s){return us((()=>{let o;Qc(a),tu(s),$c(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=Og(t,a);const i="same"===r?"same":"valid";return o="max"===s?So(t,e,n,i):Fs(t,e,n,i),"channelsFirst"===a&&(o=vi(o,[0,3,1,2])),o}))}function Um(t,e,n,r,a,s){return us((()=>{let o;Qc(a),tu(s),$c(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=zg(t,a);const i="same"===r?"same":"valid";return o="max"===s?Io(t,e,n,i):_s(t,e,n,i),"channelsFirst"===a&&(o=vi(o,[0,4,1,2,3])),o}))}Bm.className="ZeroPadding2D",ls(Bm);class Vm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new vc("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(Bc(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new vc("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,$c(this.padding),this.inputSpec=[new ih({ndim:3})]}computeOutputShape(t){const e=_g((t=eh(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return us((()=>{this.invokeCallHook(t,e),t=gu(th(t),2);const n=this.poolingFunction(th(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ii(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class jm extends Vm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"max")}}jm.className="MaxPooling1D",ls(jm);class Gm extends Vm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"avg")}}Gm.className="AveragePooling1D",ls(Gm);class Hm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new vc("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];Bc(this.poolSize,"poolSize"),Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),$c(this.padding),this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){t=eh(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=_g(e,this.poolSize[0],this.padding,this.strides[0]),n=_g(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return us((()=>(this.invokeCallHook(t,e),this.poolingFunction(th(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Km extends Hm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"max")}}Km.className="MaxPooling2D",ls(Km);class qm extends Hm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Wm(t,e,n,r,a,"avg")}}qm.className="AveragePooling2D",ls(qm);class Xm extends dh{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new vc("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Bc(this.poolSize,"poolSize"),Bc(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),$c(this.padding),this.inputSpec=[new ih({ndim:5})]}computeOutputShape(t){t=eh(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=_g(e,this.poolSize[0],this.padding,this.strides[0]),n=_g(n,this.poolSize[1],this.padding,this.strides[1]),r=_g(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return us((()=>(this.invokeCallHook(t,e),this.poolingFunction(th(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Jm extends Xm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Um(t,e,n,r,a,"max")}}Jm.className="MaxPooling3D",ls(Jm);class Ym extends Xm{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return Qc(a),$c(r),Um(t,e,n,r,a,"avg")}}Ym.className="AveragePooling3D",ls(Ym);class Zm extends dh{constructor(t){super(t),this.inputSpec=[new ih({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new wc}}class Qm extends Zm{constructor(t){super(t||{})}call(t,e){return us((()=>{const e=th(t);return Co(e,1)}))}}Qm.className="GlobalAveragePooling1D",ls(Qm);class $m extends Zm{constructor(t){super(t||{})}call(t,e){return us((()=>{const e=th(t);return mo(e,1)}))}}$m.className="GlobalMaxPooling1D",ls($m);class tb extends dh{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Qc(this.dataFormat),this.inputSpec=[new ih({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new wc}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class eb extends tb{call(t,e){return us((()=>{const e=th(t);return"channelsLast"===this.dataFormat?Co(e,[1,2]):Co(e,[2,3])}))}}eb.className="GlobalAveragePooling2D",ls(eb);class nb extends tb{call(t,e){return us((()=>{const e=th(t);return"channelsLast"===this.dataFormat?mo(e,[1,2]):mo(e,[2,3])}))}}nb.className="GlobalMaxPooling2D",ls(nb);class rb extends dh{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=qp(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class ab extends rb{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=eh(t)).length<3)throw new vc("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=eh(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return us((()=>Qg(((t,n)=>[th(this.layer.call(t,e)),[]]),t=th(t),[],!1,null,null,!1,!0)[1]))}}ab.className="TimeDistributed",ls(ab);class sb extends rb{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=qp(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=qp(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,Mc(Yc,"BidirectionalMergeMode",a),t.weights)throw new wc("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):Cc(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=Zg(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new vc("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new ih({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new wc("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof lh;for(const l of s)if(l instanceof lh!==i)throw new vc("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return us((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Xo(a,1)),"concat"===this.mergeMode?o=vu([r,a]):"sum"===this.mergeMode?o=ys(r,a):"ave"===this.mergeMode?o=bo(.5,ys(r,a)):"mul"===this.mergeMode?o=bo(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){ru(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),ru(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=qp(e.layer);if(delete e.layer,null!=e.numConstants)throw new wc("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}sb.className="Bidirectional",ls(sb);class ob extends dh{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return us((()=>("float32"!==(t=th(t)).dtype&&(t=fu(t,"float32")),ys(bo(t,this.scale),this.offset))))}}ob.className="Rescaling",ls(ob);var ib=function(t,e){return(ib=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};var lb=function(){return(lb=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var a in e=arguments[n])Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t}).apply(this,arguments)};function cb(t,e,n,r){return new(n||(n=Promise))((function(a,s){function o(t){try{l(r.next(t))}catch(t){s(t)}}function i(t){try{l(r.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?a(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,i)}l((r=r.apply(t,e||[])).next())}))}function ub(t,e){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}function hb(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],r=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function db(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var r,a,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(r=s.next()).done;)o.push(r.value)}catch(t){a={error:t}}finally{try{r&&!r.done&&(n=s.return)&&n.call(s)}finally{if(a)throw a.error}}return o}function pb(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(db(arguments[e]));return t}function fb(t){return cb(this,void 0,void 0,(function(){var e,r,a,s,o;return ub(this,(function(i){switch(i.label){case 0:return"http://","https://",e="file://",0!==t.indexOf("http://")&&0!==t.indexOf("https://")?[3,3]:[4,fetch(t)];case 1:return[4,i.sent().json()];case 2:return[2,i.sent()];case 3:return 0!==t.indexOf(e)?[3,5]:(r=n(7571),a=(0,zl.promisify)(r.readFile),o=(s=JSON).parse,[4,a(t.slice(e.length),{encoding:"utf-8"})]);case 4:return[2,o.apply(s,[i.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+t+". Supported schemes are: http://, https://, and (node.js-only) file://")}}))}))}var gb=null;function mb(t){return null==gb&&(gb=ps().epsilon()),us((function(){var e=Do(t),n=e.mean,r=e.variance;return $s(yo(t,n),ys(oi(r),gb))}))}function bb(t){if(t.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return null==gb&&(gb=ps().epsilon()),us((function(){var e=Do(ui(t)),n=e.mean,r=e.variance,a=n.arraySync(),s=Math.sqrt(r.arraySync()),o=Array.from(t).map((function(t){return(t-a)/(s+gb)}));return new Float32Array(o)}))}function yb(t){return cb(this,void 0,void 0,(function(){return ub(this,(function(e){return[2,navigator.mediaDevices.getUserMedia({audio:null==t||t,video:!1})]}))}))}var vb=function(){function t(t){var e=this;if(null==t)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(null==t.spectrogramCallback)throw new Error("spectrogramCallback cannot be null or undefined");if(!(t.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+t.numFramesPerSpectrogram);if(t.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+t.suppressionTimeMillis);if(this.suppressionTimeMillis=t.suppressionTimeMillis,this.spectrogramCallback=t.spectrogramCallback,this.numFrames=t.numFramesPerSpectrogram,this.sampleRateHz=t.sampleRateHz||44100,this.fftSize=t.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.overlapFactor=t.overlapFactor,this.includeRawAudio=t.includeRawAudio,ae(this.overlapFactor>=0&&this.overlapFactor<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+e.overlapFactor})),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=window.AudioContext||window.webkitAudioContext}return t.prototype.start=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){switch(a.label){case 0:if(null!=this.frameIntervalTask)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return e=this,[4,yb(t)];case 1:return e.stream=a.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),n=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,n.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),r=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new kb(r,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}}))}))},t.prototype.onAudioFrame=function(){return cb(this,void 0,void 0,(function(){var t,e,n,r;return ub(this,(function(a){switch(a.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(t=wb(this.freqDataQueue),e=xb(t,[1,this.numFrames,this.columnTruncateLength,1]),n=void 0,this.includeRawAudio&&(r=wb(this.timeDataQueue),n=xb(r,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(e,n)]):[3,2]);case 1:a.sent()&&this.tracker.suppress(),hs([e,n]),a.label=2;case 2:return[2]}}))}))},t.prototype.stop=function(){return cb(this,void 0,void 0,(function(){return ub(this,(function(t){if(null==this.frameIntervalTask)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]}))}))},t.prototype.setConfig=function(t){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},t.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},t}();function wb(t){var e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((function(t,r){return n.set(t,r*e)})),n}function xb(t,e){var n=new Float32Array(le(e));return n.set(t,n.length-t.length),ea(n,e)}var kb=function(){function t(t,e){var n=this;this.period=t,this.suppressionTime=null==e?0:e,this.counter=0,ae(this.period>0,(function(){return"Expected period to be positive, but got "+n.period}))}return t.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(null==this.suppressionOnset||this.counter-this.suppressionOnset>this.suppressionTime)},t.prototype.suppress=function(){this.suppressionOnset=this.counter},t}();function Sb(t){var e=0;t.forEach((function(t){e+=t.byteLength}));var n=new Uint8Array(e),r=0;return t.forEach((function(t){n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Ib(t){var e=0;t.forEach((function(t){return e+=t.length}));var n=new Float32Array(e),r=0;return t.forEach((function(t){n.set(t,r),r+=t.length})),n}function Nb(t){if(null==t)throw new Error("Received null or undefind string");for(var e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n.buffer}function Cb(t){if(null==t)throw new Error("Received null or undefind buffer");var e=new Uint8Array(t);return decodeURIComponent(escape(String.fromCharCode.apply(String,pb(e))))}var Eb="TFJSSCDS",Tb="_background_noise_",Ab=function(){function t(t){if(this.examples={},this.label2Ids={},null!=t)for(var e=function(t){ae(null!=t,(function(){return"Received null or undefined buffer"}));var e=0,n=Cb(t.slice(e,8));ae(n===Eb,(function(){return"Deserialization error: Invalid descriptor"})),e+=8,e+=4;var r=new Uint32Array(t,e,1),a=e+=4;e=a+r[0];var s=Cb(t.slice(a,e));return{manifest:JSON.parse(s),data:t.slice(e)}}(t),n=0,r=0;r<e.manifest.length;++r){var a=e.manifest[r],s=a.spectrogramNumFrames*a.spectrogramFrameSize;null!=a.rawAudioNumSamples&&(s+=a.rawAudioNumSamples),s*=4,this.addExample(Fb({spec:a,data:e.data.slice(n,n+s)})),n+=s}}return t.prototype.addExample=function(t){ae(null!=t,(function(){return"Got null or undefined example"})),ae(null!=t.label&&t.label.length>0,(function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(t.label)}));var e=function(){function t(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return t()+t()+"-"+t()+"-"+t()+"-"+t()+"-"+t()+t()+t()}();return this.examples[e]=t,t.label in this.label2Ids||(this.label2Ids[t.label]=[]),this.label2Ids[t.label].push(e),e},t.prototype.merge=function(t){var e,n,r,a;ae(t!==this,(function(){return"Cannot merge a dataset into itself"}));var s=t.getVocabulary();try{for(var o=hb(s),i=o.next();!i.done;i=o.next()){var l=i.value,c=t.getExamples(l);try{for(var u=(r=void 0,hb(c)),h=u.next();!h.done;h=u.next()){var d=h.value;this.addExample(d.example)}}catch(t){r={error:t}}finally{try{h&&!h.done&&(a=u.return)&&a.call(u)}finally{if(r)throw r.error}}}}catch(t){e={error:t}}finally{try{i&&!i.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}},t.prototype.getExampleCounts=function(){var t={};for(var e in this.examples){var n=this.examples[e];n.label in t||(t[n.label]=0),t[n.label]++}return t},t.prototype.getExamples=function(t){var e=this;ae(null!=t,(function(){return"Expected label to be a string, but got "+JSON.stringify(t)})),ae(t in this.label2Ids,(function(){return'No example of label "'+t+'" exists in dataset'}));var n=[];return this.label2Ids[t].forEach((function(t){n.push({uid:t,example:e.examples[t]})})),n},t.prototype.getData=function(t,e){var n=this;ae(this.size()>0,(function(){return"Cannot get spectrograms as tensors because the dataset is empty"}));var r=this.getVocabulary();null!=t?ae(-1!==r.indexOf(t),(function(){return"Label "+t+" is not in the vocabulary ("+JSON.stringify(r)+")"})):ae(r.length>1,(function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+r.length+" word."})),null==e&&(e={});var a,s,o=this.getSortedUniqueNumFrames();1===o.length?(a=null==e.numFrames?o[0]:e.numFrames,s=null==e.hopFrames?1:e.hopFrames):(ae(null!=(a=e.numFrames)&&Number.isInteger(a)&&a>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."})),ae(a<=o[0],(function(){return"numFrames ("+a+") exceeds the minimum numFrames ("+o[0]+") among the examples of the Dataset."})),ae(null!=(s=e.hopFrames)&&Number.isInteger(s)&&s>0,(function(){return"There are "+o.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."})));var i=null==e.normalize||e.normalize;return us((function(){for(var o,l,c,u=[],h=[],d=[],p=0;p<r.length;++p){var f=r[p];if(null==t||f===t){var g=n.label2Ids[f],m=function(r){var o,l,g=n.examples[r].spectrogram,m=g.frameSize;null==c?c=m:ae(m===c,(function(){return"Mismatch in frameSize  ("+m+" vs "+c+")"}));var b=g.data.length/m,y=null;f!==Tb&&(y=null==g.keyFrameIndex?Db(g).dataSync()[0]:g.keyFrameIndex);var v=rs(g.data,[b,m,1]),w=_b(b,y,a,s),x=function(n){var r=us((function(){var t=Qo(v,[n[0],0,0],[n[1]-n[0],-1,-1]);return i?mb(t):t}));e.getDataset?h.push(r.dataSync()):u.push(r),null==t&&d.push(p)};try{for(var k=(o=void 0,hb(w)),S=k.next();!S.done;S=k.next())x(S.value)}catch(t){o={error:t}}finally{try{S&&!S.done&&(l=k.return)&&l.call(k)}finally{if(o)throw o.error}}hs(v)};try{for(var b=(o=void 0,hb(g)),y=b.next();!y.done;y=b.next())m(y.value)}catch(t){o={error:t}}finally{try{y&&!y.done&&(l=b.return)&&l.call(b)}finally{if(o)throw o.error}}}}null!=e.augmentByMixingNoiseRatio&&n.augmentByMixingNoise(e.getDataset?h:u,d,e.augmentByMixingNoiseRatio);var v=null==e.shuffle||e.shuffle;if(e.getDataset){var w=null==e.datasetBatchSize?32:e.datasetBatchSize,x=null==e.datasetValidationSplit?.15:e.datasetValidationSplit;ae(x>0&&x<1,(function(){return"Invalid dataset validation split: "+x}));var k=h.map((function(t,e){return[t,d[e]]}));ne(k),h=k.map((function(t){return t[0]}));var S=k.map((function(t){return t[1]})),I=function(t,e,n){var r,a,s,o,i,l,c,u;ae(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n}));for(var h=!Array.isArray(t[0]),d=e,p=[],f=0;f<d.length;++f){var g=d[f];null==p[g]&&(p[g]=[]),p[g].push(f)}var m=p.length,b=[],y=[];for(p.map((function(t){return ne(t)})),f=0;f<m;++f)for(var v=p[f],w=Math.round(v.length*(1-n)),x=0;x<v.length;++x)x<w?b.push(v[x]):y.push(v[x]);if(h){var k=[],S=[],I=[],N=[];try{for(var C=hb(b),E=C.next();!E.done;E=C.next()){var T=E.value;k.push(t[T]),S.push(e[T])}}catch(t){r={error:t}}finally{try{E&&!E.done&&(a=C.return)&&a.call(C)}finally{if(r)throw r.error}}try{for(var A=hb(y),R=A.next();!R.done;R=A.next())T=R.value,I.push(t[T]),N.push(e[T])}catch(t){s={error:t}}finally{try{R&&!R.done&&(o=A.return)&&o.call(A)}finally{if(s)throw s.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}k=[],S=[],I=[],N=[];try{for(var F=hb(b),_=F.next();!_.done;_=F.next())T=_.value,k.push(t[T]),S.push(e[T])}catch(t){i={error:t}}finally{try{_&&!_.done&&(l=F.return)&&l.call(F)}finally{if(i)throw i.error}}try{for(var D=hb(y),O=D.next();!O.done;O=D.next())T=O.value,I.push(t[T]),N.push(e[T])}catch(t){c={error:t}}finally{try{O&&!O.done&&(u=D.return)&&u.call(D)}finally{if(c)throw c.error}}return{trainXs:k,trainYs:S,valXs:I,valYs:N}}(h,S,x),N=I.trainXs,C=I.trainYs,E=I.valXs,T=I.valYs,A=fc(N).map((function(t){return rs(t,[a,c,1])})),R=fc(C).map((function(t){return ii(Lo([t],r.length),[0])})),F=gc({xs:A,ys:R});v&&(F=F.shuffle(h.length)),F=F.batch(w).prefetch(4);var _=fc(E).map((function(t){return rs(t,[a,c,1])})),D=fc(T).map((function(t){return ii(Lo([t],r.length),[0])})),O=gc({xs:_,ys:D});return[F,O=O.batch(w).prefetch(4)]}if(v){var z=[];u.forEach((function(t,e){z.push({x:t,y:d[e]})})),ne(z),u=z.map((function(t){return t.x})),d=z.map((function(t){return t.y}))}var L=null==t?Ga(Lo(ui(d,"int32"),r.length),"float32"):void 0;return{xs:li(u),ys:L}}))},t.prototype.augmentByMixingNoise=function(t,e,n){var r,a;if(null==t||0===t.length)throw new Error("Cannot perform augmentation because data is null or empty");for(var s=t[0]instanceof Float32Array,o=this.getVocabulary(),i=[],l=[],c=0;c<e.length;++c)o[e[c]]===Tb?i.push(c):l.push(c);if(0===i.length)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+Tb);var u=[],h=[],d=function(r){var a=i[function(t,e){return Math.floor((e-t)*Math.random())+t}(0,i.length)],o=s?ui(t[r]):t[r],l=s?ui(t[a]):t[a],c=us((function(){return mb(ys(o,bo(l,n)))}));s?u.push(c.dataSync()):u.push(c),h.push(e[r])};try{for(var p=hb(l),f=p.next();!f.done;f=p.next())d(f.value)}catch(t){r={error:t}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(r)throw r.error}}console.log("Data augmentation: mixing noise: added "+u.length+" examples"),u.forEach((function(e){return t.push(e)})),e.push.apply(e,pb(h))},t.prototype.getSortedUniqueNumFrames=function(){for(var t,e,n=new Set,r=this.getVocabulary(),a=0;a<r.length;++a){var s=r[a],o=this.label2Ids[s];try{for(var i=(t=void 0,hb(o)),l=i.next();!l.done;l=i.next()){var c=l.value,u=this.examples[c].spectrogram,h=u.data.length/u.frameSize;n.add(h)}}catch(e){t={error:e}}finally{try{l&&!l.done&&(e=i.return)&&e.call(i)}finally{if(t)throw t.error}}}var d=pb(n);return d.sort(),d},t.prototype.removeExample=function(t){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var e=this.examples[t].label;delete this.examples[t];var n=this.label2Ids[e].indexOf(t);this.label2Ids[e].splice(n,1),0===this.label2Ids[e].length&&delete this.label2Ids[e]},t.prototype.setExampleKeyFrameIndex=function(t,e){if(!(t in this.examples))throw new Error("Nonexistent example UID: "+t);var n=this.examples[t].spectrogram,r=n.data.length/n.frameSize;ae(e>=0&&e<r&&Number.isInteger(e),(function(){return"Invalid keyFrameIndex: "+e+". Must be >= 0, < "+r+", and an integer."})),n.keyFrameIndex=e},t.prototype.size=function(){return Object.keys(this.examples).length},t.prototype.durationMillis=function(){var t=0;for(var e in this.examples){var n=this.examples[e].spectrogram,r=23.22|n.frameDurationMillis;t+=n.data.length/n.frameSize*r}return t},t.prototype.empty=function(){return 0===this.size()},t.prototype.clear=function(){this.examples={}},t.prototype.getVocabulary=function(){var t=new Set;for(var e in this.examples){var n=this.examples[e];t.add(n.label)}var r=pb(t);return r.sort(),r},t.prototype.serialize=function(t){var e,n,r,a,s=this.getVocabulary();ae(!this.empty(),(function(){return"Cannot serialize empty Dataset"})),null!=t&&(Array.isArray(t)||(t=[t]),t.forEach((function(t){if(-1===s.indexOf(t))throw new Error('Word label "'+t+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(s)+".")})));var o=[],i=[];try{for(var l=hb(s),c=l.next();!c.done;c=l.next()){var u=c.value;if(null==t||-1!==t.indexOf(u)){var h=this.label2Ids[u];try{for(var d=(r=void 0,hb(h)),p=d.next();!p.done;p=d.next()){var f=p.value,g=Rb(this.examples[f]);o.push(g.spec),i.push(g.data)}}catch(t){r={error:t}}finally{try{p&&!p.done&&(a=d.return)&&a.call(d)}finally{if(r)throw r.error}}}}}catch(t){e={error:t}}finally{try{c&&!c.done&&(n=l.return)&&n.call(l)}finally{if(e)throw e.error}}return function(t){var e=Nb(JSON.stringify(t.manifest)),n=Nb(Eb),r=new Uint32Array([1]),a=new Uint32Array([e.byteLength]);return Sb([Sb([n,r.buffer,a.buffer]),e,t.data])}({manifest:o,data:Sb(i)})},t}();function Rb(t){var e=null!=t.rawAudio,n={label:t.label,spectrogramNumFrames:t.spectrogram.data.length/t.spectrogram.frameSize,spectrogramFrameSize:t.spectrogram.frameSize};null!=t.spectrogram.keyFrameIndex&&(n.spectrogramKeyFrameIndex=t.spectrogram.keyFrameIndex);var r=t.spectrogram.data.buffer.slice(0);return e&&(n.rawAudioNumSamples=t.rawAudio.data.length,n.rawAudioSampleRateHz=t.rawAudio.sampleRateHz,r=Sb([r,t.rawAudio.data.buffer])),{spec:n,data:r}}function Fb(t){var e={frameSize:t.spec.spectrogramFrameSize,data:new Float32Array(t.data.slice(0,4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))};null!=t.spec.spectrogramKeyFrameIndex&&(e.keyFrameIndex=t.spec.spectrogramKeyFrameIndex);var n={label:t.spec.label,spectrogram:e};return null!=t.spec.rawAudioNumSamples&&(n.rawAudio={sampleRateHz:t.spec.rawAudioSampleRateHz,data:new Float32Array(t.data.slice(4*t.spec.spectrogramFrameSize*t.spec.spectrogramNumFrames))}),n}function _b(t,e,n,r){if(ae(Number.isInteger(t)&&t>0,(function(){return"snippetLength must be a positive integer, but got "+t})),null!=e&&ae(Number.isInteger(e)&&e>=0,(function(){return"focusIndex must be a non-negative integer, but got "+e})),ae(Number.isInteger(n)&&n>0,(function(){return"windowLength must be a positive integer, but got "+n})),ae(Number.isInteger(r)&&r>0,(function(){return"windowHop must be a positive integer, but got "+r})),ae(n<=t,(function(){return"windowLength ("+n+") exceeds snippetLength ("+t+")"})),ae(e<t,(function(){return"focusIndex ("+e+") equals or exceeds snippetLength ("+t+")"})),n===t)return[[0,t]];var a=[];if(null==e){for(var s=0;s+n<=t;)a.push([s,s+n]),s+=r;return a}var o=Math.floor(n/2),i=e-o;for(i<0?i=0:i+n>t&&(i=t-n);!(i-r<0||e>=i-r+n);)i-=r;for(;i+n<=t&&!(e<i);)a.push([i,i+n]),i+=r;return a}function Db(t){return us((function(){return xs(function(t){return us((function(){var e=t.data.length/t.frameSize,n=hi(t.data,[e,t.frameSize]);return Co(n,-1)}))}(t))}))}var Ob="0.5.4",zb="tfjs-speech-commands-saved-model-metadata",Lb="indexeddb://tfjs-speech-commands-model/",Mb={localStorage:"undefined"==typeof window?null:window.localStorage};var Pb=.25,Bb=function(){function t(e,n,r){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+function(t){return t.split(".").slice(0,2).join(".")}(Ob)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},ae(null==n&&null==r||null!=n&&null!=r,(function(){return"modelURL and metadataURL must be both provided or both not provided."})),null==n?(null==e?e=t.DEFAULT_VOCABULARY_NAME:ae(-1!==t.VALID_VOCABULARY_NAMES.indexOf(e),(function(){return"Invalid vocabulary name: '"+e+"'"})),this.vocabulary=e,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(ae(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided"})),this.modelArtifactsOrURL=n,this.metadataOrURL=r),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return t.prototype.listen=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o,i=this;return ub(this,(function(l){switch(l.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(l.sent(),null==e&&(e={}),n=null==e.probabilityThreshold?0:e.probabilityThreshold,e.includeEmbedding&&(n=0),ae(n>=0&&n<=1,(function(){return"Invalid probabilityThreshold value: "+n})),r=null!=e.invokeCallbackOnNoiseAndUnknown&&e.invokeCallbackOnNoiseAndUnknown,e.includeEmbedding&&(r=!0),e.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+e.suppressionTimeMillis);return ae((a=null==e.overlapFactor?.5:e.overlapFactor)>=0&&a<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+a})),s=function(a,s){return cb(i,void 0,void 0,(function(){var s,o,i,l,c,u,h,d,p,f,g;return ub(this,(function(m){switch(m.label){case 0:return s=mb(a),e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return m.sent(),g=db(this.modelWithEmbeddingOutput.predict(s),2),o=g[0],i=g[1],[3,3];case 2:o=this.model.predict(s),m.label=3;case 3:return[4,o.data()];case 4:return l=m.sent(),[4,(c=o.argMax(-1)).data()];case 5:return u=m.sent()[0],h=Math.max.apply(Math,pb(l)),hs([o,c,s]),h<n?[2,!1]:[3,6];case 6:return d=void 0,e.includeSpectrogram?(p={},[4,a.data()]):[3,8];case 7:p.data=m.sent(),p.frameSize=this.nonBatchInputShape[1],d=p,m.label=8;case 8:return f=!0,r||this.words[u]!==Tb&&"_unknown_"!==this.words[u]||(f=!1),f&&t({scores:l,spectrogram:d,embedding:i}),[2,f]}}))}))},o=null==e.suppressionTimeMillis?this.DEFAULT_SUPPRESSION_TIME_MILLIS:e.suppressionTimeMillis,this.audioDataExtractor=new vb({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:o,spectrogramCallback:s,overlapFactor:a}),[4,this.audioDataExtractor.start(e.audioTrackConstraints)];case 2:return l.sent(),this.streaming=!0,[2]}}))}))},t.prototype.ensureModelLoaded=function(){return cb(this,void 0,void 0,(function(){var t,e,n,r,a=this;return ub(this,(function(s){switch(s.label){case 0:return null!=this.model?[2]:[4,this.ensureMetadataLoaded()];case 1:return s.sent(),"string"!=typeof this.modelArtifactsOrURL?[3,3]:[4,$f(this.modelArtifactsOrURL)];case 2:return t=s.sent(),[3,5];case 3:return[4,$f(ns(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:t=s.sent(),s.label=5;case 5:if(1!==t.inputs.length)throw new Error("Expected model to have 1 input, but got a model with "+t.inputs.length+" inputs");if(4!==t.inputs[0].shape.length)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+t.inputs[0].shape.length);if(1!==t.inputs[0].shape[3])throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(t.inputs[0].shape[3])+"}");if(2!==(e=t.outputShape).length)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(e));if(e[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+e[1]+") and number of words ("+this.words.length+").");return this.model=t,this.freezeModel(),this.nonBatchInputShape=t.inputs[0].shape.slice(1),this.elementsPerExample=1,t.inputs[0].shape.slice(1).forEach((function(t){return a.elementsPerExample*=t})),this.warmUpModel(),n=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,r=t.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=r*n,[2]}}))}))},t.prototype.ensureModelWithEmbeddingOutputCreated=function(){return cb(this,void 0,void 0,(function(){var t,e;return ub(this,(function(n){switch(n.label){case 0:return null!=this.modelWithEmbeddingOutput?[2]:[4,this.ensureModelLoaded()];case 1:for(n.sent(),e=this.model.layers.length-2;e>=0;--e)if("Dense"===this.model.layers[e].getClassName()){t=this.model.layers[e];break}if(null==t)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=Qf({inputs:this.model.inputs,outputs:[this.model.outputs[0],t.output]}),[2]}}))}))},t.prototype.warmUpModel=function(){var t=this;us((function(){for(var e=Mo([1].concat(t.nonBatchInputShape)),n=0;n<3;++n)t.model.predict(e)}))},t.prototype.ensureMetadataLoaded=function(){return cb(this,void 0,void 0,(function(){var t,e,n;return ub(this,(function(r){switch(r.label){case 0:return null!=this.words?[2]:"string"!=typeof this.metadataOrURL?[3,2]:[4,fb(this.metadataOrURL)];case 1:return e=r.sent(),[3,3];case 2:e=this.metadataOrURL,r.label=3;case 3:if(null==(t=e).wordLabels){if(null==(n=t.words))throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=n}else this.words=t.wordLabels;return[2]}}))}))},t.prototype.stopListening=function(){return cb(this,void 0,void 0,(function(){return ub(this,(function(t){switch(t.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return t.sent(),this.streaming=!1,[2]}}))}))},t.prototype.isListening=function(){return this.streaming},t.prototype.wordLabels=function(){return this.words},t.prototype.params=function(){return this.parameters},t.prototype.modelInputShape=function(){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},t.prototype.recognize=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o,i,l,c,u,h,d,p,f;return ub(this,(function(g){switch(g.label){case 0:return null==e&&(e={}),[4,this.ensureModelLoaded()];case 1:return g.sent(),null!=t?[3,3]:[4,this.recognizeOnline()];case 2:n=g.sent(),t=n.data,g.label=3;case 3:if(t instanceof Er)this.checkInputTensorShape(t),a=t,r=t.shape[0];else{if(t.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+t.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");r=t.length/this.elementsPerExample,a=function(t,e,n){if(oe(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=qr(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ta(t,e,r,n)}(t,[r].concat(this.nonBatchInputShape))}return o={scores:null},e.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return g.sent(),i=this.modelWithEmbeddingOutput.predict(a),s=i[0],o.embedding=i[1],[3,6];case 5:s=this.model.predict(a),g.label=6;case 6:return 1!==r?[3,8]:(l=o,[4,s.data()]);case 7:return l.scores=g.sent(),[3,10];case 8:return c=pi(s),u=c.map((function(t){return t.data()})),h=o,[4,Promise.all(u)];case 9:h.scores=g.sent(),hs(c),g.label=10;case 10:return e.includeSpectrogram?(d=o,p={},t instanceof Er?[4,t.data()]:[3,12]):[3,14];case 11:return f=g.sent(),[3,13];case 12:f=t,g.label=13;case 13:d.spectrogram=(p.data=f,p.frameSize=this.nonBatchInputShape[1],p),g.label=14;case 14:return hs(s),[2,o]}}))}))},t.prototype.recognizeOnline=function(){return cb(this,void 0,void 0,(function(){var t=this;return ub(this,(function(e){return[2,new Promise((function(e,n){t.audioDataExtractor=new vb({sampleRateHz:t.parameters.sampleRateHz,numFramesPerSpectrogram:t.nonBatchInputShape[0],columnTruncateLength:t.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n){return cb(t,void 0,void 0,(function(){var t,r,a;return ub(this,(function(s){switch(s.label){case 0:return t=mb(n),[4,this.audioDataExtractor.stop()];case 1:return s.sent(),r=e,a={},[4,t.data()];case 2:return r.apply(void 0,[(a.data=s.sent(),a.frameSize=this.nonBatchInputShape[1],a)]),t.dispose(),[2,!1]}}))}))},overlapFactor:0}),t.audioDataExtractor.start()}))]}))}))},t.prototype.createTransfer=function(t){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");ae(null!=t&&"string"==typeof t&&t.length>1,(function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(t)})),ae(null==this.transferRecognizers[t],(function(){return"There is already a transfer-learning model named '"+t+"'"}));var e=new Wb(t,this.parameters,this.model);return this.transferRecognizers[t]=e,e},t.prototype.freezeModel=function(){var t,e;try{for(var n=hb(this.model.layers),r=n.next();!r.done;r=n.next())r.value.trainable=!1}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}},t.prototype.checkInputTensorShape=function(t){var e=this.model.inputs[0].shape.length;if(t.shape.length!==e)throw new Error("Expected input Tensor to have rank "+e+", but got rank "+t.shape.length+" that differs ");var n=t.shape.slice(1),r=this.model.inputs[0].shape.slice(1);if(!ce(n,r))throw new Error("Expected input to have shape [null,"+r+"], but got shape [null,"+n+"]")},t.VALID_VOCABULARY_NAMES=["18w","directional4w"],t.DEFAULT_VOCABULARY_NAME="18w",t}(),Wb=function(t){function e(e,n,r){var a=t.call(this)||this;return a.name=e,a.parameters=n,a.baseModel=r,ae(null!=e&&"string"==typeof e&&e.length>0,(function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(e)})),a.nonBatchInputShape=a.baseModel.inputs[0].shape.slice(1),a.words=null,a.dataset=new Ab,a}return function(t,e){function n(){this.constructor=t}ib(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}(e,t),e.prototype.collectExample=function(t,e){return cb(this,void 0,void 0,(function(){var n,r,a,s,o=this;return ub(this,(function(i){if(ae(!this.streaming,(function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"})),ae(null!=t&&"string"==typeof t&&t.length>0,(function(){return"Must provide a non-empty string when collecting transfer-learning example"})),null==e&&(e={}),null!=e.durationMultiplier&&null!=e.durationSec)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return null!=e.durationSec?(ae(e.durationSec>0,(function(){return"Expected durationSec to be > 0, but got "+e.durationSec})),r=this.parameters.fftSize/this.parameters.sampleRateHz,n=Math.ceil(e.durationSec/r)):null!=e.durationMultiplier?(ae(e.durationMultiplier>=1,(function(){return"Expected duration multiplier to be >= 1, but got "+e.durationMultiplier})),n=Math.round(this.nonBatchInputShape[0]*e.durationMultiplier)):n=this.nonBatchInputShape[0],null!=e.snippetDurationSec&&(ae(e.snippetDurationSec>0,(function(){return"snippetDurationSec is expected to be > 0, but got "+e.snippetDurationSec})),ae(null!=e.onSnippet,(function(){return"onSnippet must be provided if snippetDurationSec is provided."}))),null!=e.onSnippet&&ae(null!=e.snippetDurationSec,(function(){return"snippetDurationSec must be provided if onSnippet is provided."})),a=this.parameters.fftSize/this.parameters.sampleRateHz,s=a*n,this.streaming=!0,[2,new Promise((function(r){var a=null==e.snippetDurationSec?1:e.snippetDurationSec/s,i=1-a,l=Math.round(1/a),c=0,u=-1,h=[];o.audioDataExtractor=new vb({sampleRateHz:o.parameters.sampleRateHz,numFramesPerSpectrogram:n,columnTruncateLength:o.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n,a){return cb(o,void 0,void 0,(function(){var s,o,i,d,p,f,g,m,b,y,v,w,x,k,S,I,N,C,E,T;return ub(this,(function(A){switch(A.label){case 0:return null!=e.onSnippet?[3,7]:(s=mb(n),i=(o=this.dataset).addExample,d={label:t},p={},[4,s.data()]);case 1:return d.spectrogram=(p.data=A.sent(),p.frameSize=this.nonBatchInputShape[1],p),e.includeRawAudio?(g={},[4,a.data()]):[3,3];case 2:return g.data=A.sent(),g.sampleRateHz=this.audioDataExtractor.sampleRateHz,f=g,[3,4];case 3:f=void 0,A.label=4;case 4:return i.apply(o,[(d.rawAudio=f,d)]),s.dispose(),[4,this.audioDataExtractor.stop()];case 5:return A.sent(),this.streaming=!1,this.collateTransferWords(),m=r,b={},[4,n.data()];case 6:return m.apply(void 0,[(b.data=A.sent(),b.frameSize=this.nonBatchInputShape[1],b)]),[3,13];case 7:return[4,n.data()];case 8:for(y=A.sent(),-1===u&&(u=y.length),v=u-1;0!==y[v]&&v>=0;)v--;return w=u-v-1,u=v+1,x=y.slice(y.length-w,y.length),h.push(x),null!=e.onSnippet&&e.onSnippet({data:x,frameSize:this.nonBatchInputShape[1]}),c++!==l?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return A.sent(),this.streaming=!1,this.collateTransferWords(),k=bb(Ib(h)),S={data:k,frameSize:this.nonBatchInputShape[1]},N=(I=this.dataset).addExample,C={label:t,spectrogram:S},e.includeRawAudio?(T={},[4,a.data()]):[3,11];case 10:return T.data=A.sent(),T.sampleRateHz=this.audioDataExtractor.sampleRateHz,E=T,[3,12];case 11:E=void 0,A.label=12;case 12:N.apply(I,[(C.rawAudio=E,C)]),r(S),A.label=13;case 13:return[2,!1]}}))}))},overlapFactor:i,includeRawAudio:e.includeRawAudio}),o.audioDataExtractor.start(e.audioTrackConstraints)}))]}))}))},e.prototype.clearExamples=function(){var t=this;ae(null!=this.words&&this.words.length>0&&!this.dataset.empty(),(function(){return"No transfer learning examples exist for model name "+t.name})),this.dataset.clear(),this.words=null},e.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},e.prototype.getExamples=function(t){return this.dataset.getExamples(t)},e.prototype.setExampleKeyFrameIndex=function(t,e){this.dataset.setExampleKeyFrameIndex(t,e)},e.prototype.removeExample=function(t){this.dataset.removeExample(t),this.collateTransferWords()},e.prototype.isDatasetEmpty=function(){return this.dataset.empty()},e.prototype.loadExamples=function(t,e){var n,r,a,s;void 0===e&&(e=!1);var o=new Ab(t);e&&this.clearExamples();var i=o.getVocabulary();try{for(var l=hb(i),c=l.next();!c.done;c=l.next()){var u=c.value,h=o.getExamples(u);try{for(var d=(a=void 0,hb(h)),p=d.next();!p.done;p=d.next()){var f=p.value;this.dataset.addExample(f.example)}}catch(t){a={error:t}}finally{try{p&&!p.done&&(s=d.return)&&s.call(d)}finally{if(a)throw a.error}}}}catch(t){n={error:t}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}this.collateTransferWords()},e.prototype.serializeExamples=function(t){return this.dataset.serialize(t)},e.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},e.prototype.collectTransferDataAsTensors=function(t,e){var n=this.nonBatchInputShape[0];t=t||Pb;var r=Math.round(t*n),a=this.dataset.getData(null,lb({numFrames:n,hopFrames:r},e));return{xs:a.xs,ys:a.ys}},e.prototype.collectTransferDataAsTfDataset=function(t,e,n,r){void 0===e&&(e=.15),void 0===n&&(n=32);var a=this.nonBatchInputShape[0];t=t||Pb;var s=Math.round(t*a);return this.dataset.getData(null,lb({numFrames:a,hopFrames:s,getDataset:!0,datasetBatchSize:n,datasetValidationSplit:e},r))},e.prototype.train=function(t){return cb(this,void 0,void 0,(function(){var e,n=this;return ub(this,(function(r){return ae(null!=this.words&&this.words.length>0,(function(){return"Cannot train transfer-learning model '"+n.name+"' because no transfer learning example has been collected."})),ae(this.words.length>1,(function(){return"Cannot train transfer-learning model '"+n.name+"' because only 1 word label ('"+JSON.stringify(n.words)+"') has been collected for transfer learning. Requires at least 2."})),null!=t.fineTuningEpochs&&ae(t.fineTuningEpochs>=0&&Number.isInteger(t.fineTuningEpochs),(function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+t.fineTuningEpochs})),null==t&&(t={}),null==this.model&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:t.optimizer||"sgd",metrics:["acc"]}),e=null==t.fitDatasetDurationMillisThreshold?6e4:t.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>e?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+e+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(t)]):[2,this.trainOnTensors(t)]}))}))},e.prototype.trainOnDataset=function(t){return cb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c;return ub(this,(function(u){switch(u.label){case 0:return ae(t.epochs>0,(function(){return"Invalid config.epochs"})),e=null==t.batchSize?32:t.batchSize,n=t.windowHopRatio||Pb,r=db(this.collectTransferDataAsTfDataset(n,t.validationSplit,e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),2),a=r[0],s=r[1],o=cr(),[4,this.model.fitDataset(a,{epochs:t.epochs,validationData:t.validationSplit>0?s:null,callbacks:null==t.callback?null:[t.callback]})];case 1:return i=u.sent(),console.log("fitDataset() took "+(cr()-o).toFixed(2)+" ms"),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?(l=cr(),[4,this.fineTuningUsingTfDatasets(t,a,s)]):[3,3];case 2:return c=u.sent(),console.log("fitDataset() (fine-tuning) took "+(cr()-l).toFixed(2)+" ms"),[2,[i,c]];case 3:return[2,i]}}))}))},e.prototype.trainOnTensors=function(t){return cb(this,void 0,void 0,(function(){var e,n,r,a,s,o,i,l,c,u;return ub(this,(function(h){switch(h.label){case 0:e=t.windowHopRatio||Pb,n=this.collectTransferDataAsTensors(e,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),r=n.xs,a=n.ys,console.log("Training data: xs.shape = "+r.shape+", ys.shape = "+a.shape),h.label=1;case 1:return h.trys.push([1,,6,7]),null!=t.validationSplit?(l=function(t,e,n){return ae(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n})),us((function(){for(var r=xs(e,-1).dataSync(),a=[],s=0;s<r.length;++s){var o=r[s];null==a[o]&&(a[o]=[]),a[o].push(s)}var i=a.length,l=[],c=[];for(a.map((function(t){return ne(t)})),s=0;s<i;++s)for(var u=a[s],h=Math.round(u.length*(1-n)),d=0;d<u.length;++d)d<h?l.push(u[d]):c.push(u[d]);return{trainXs:co(t,l),trainYs:co(e,l),valXs:co(t,c),valYs:co(e,c)}}))}(r,a,t.validationSplit),s=l.trainXs,o=l.trainYs,i=[l.valXs,l.valYs]):(s=r,o=a),[4,this.model.fit(s,o,{epochs:null==t.epochs?20:t.epochs,validationData:i,batchSize:t.batchSize,callbacks:null==t.callback?null:[t.callback]})];case 2:return c=h.sent(),null!=t.fineTuningEpochs&&t.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(t,s,o,i)]:[3,4];case 3:return u=h.sent(),[2,[c,u]];case 4:return[2,c];case 5:return[3,7];case 6:return hs([r,a,s,o,i]),[7];case 7:return[2]}}))}))},e.prototype.fineTuningUsingTfDatasets=function(t,e,n){return cb(this,void 0,void 0,(function(){var r,a,s;return ub(this,(function(o){switch(o.label){case 0:return r=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,a=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:a,metrics:["acc"]}),[4,this.model.fitDataset(e,{epochs:t.fineTuningEpochs,validationData:n,callbacks:null==t.callback?null:[t.callback]})];case 1:return s=o.sent(),this.secondLastBaseDenseLayer.trainable=r,[2,s]}}))}))},e.prototype.fineTuningUsingTensors=function(t,e,n,r){return cb(this,void 0,void 0,(function(){var a,s,o;return ub(this,(function(i){switch(i.label){case 0:return a=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,s=null==t.fineTuningOptimizer?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:s,metrics:["acc"]}),[4,this.model.fit(e,n,{epochs:t.fineTuningEpochs,validationData:r,batchSize:t.batchSize,callbacks:null==t.fineTuningCallback?null:[t.fineTuningCallback]})];case 1:return o=i.sent(),this.secondLastBaseDenseLayer.trainable=a,[2,o]}}))}))},e.prototype.evaluate=function(t){return cb(this,void 0,void 0,(function(){var e=this;return ub(this,(function(n){return ae(null!=t.wordProbThresholds&&t.wordProbThresholds.length>0,(function(){return"Received null or empty wordProbThresholds"})),0,ae(this.words[0]===Tb,(function(){return"Cannot perform evaluation when the first tag is not "+Tb})),[2,us((function(){for(var n=[],r=0,a=e.collectTransferDataAsTensors(t.windowHopRatio),s=a.xs,o=a.ys.argMax(-1).dataSync(),i=e.model.predict(s),l=mo(Qo(i,[0,1],[i.shape[0],i.shape[1]-1]),-1),c=i.shape[0],u=0;u<t.wordProbThresholds.length;++u){for(var h=t.wordProbThresholds[u],d=l.greater(gs(h)).dataSync(),p=0,f=0,g=0,m=0,b=0;b<c;++b)0===o[b]?(p++,d[b]&&g++):(f++,d[b]&&m++);var y=g/p,v=m/f;n.push({probThreshold:h,fpr:y,tpr:v}),console.log("ROC thresh="+h+": fpr="+y.toFixed(4)+", tpr="+v.toFixed(4)),u>0&&(r+=Math.abs(n[u-1].fpr-n[u].fpr)*(n[u-1].tpr+n[u].tpr)/2)}return{rocCurve:n,auc:r}}))]}))}))},e.prototype.createTransferModelFromBaseModel=function(){var t=this;ae(null!=this.words,(function(){return"No word example is available for tranfer-learning model of name "+t.name}));for(var e=this.baseModel.layers,n=e.length-2;n>=0&&"dense"!==e[n].getClassName().toLowerCase();)n--;if(n<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=e[n];var r,a,s=this.secondLastBaseDenseLayer.output;this.transferHead=new Zf(a),this.transferHead.add((r={units:this.words.length,activation:"softmax",inputShape:s.shape.slice(1),name:"NewHeadDense"},new gm(r)));var o=this.transferHead.apply(s);this.model=Qf({inputs:this.baseModel.inputs,outputs:o})},e.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},e.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:Ob,modelName:this.name,timeStamp:(new Date).toISOString(),wordLabels:this.wordLabels()}},e.prototype.save=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){return e=null!=t,t=t||Ub(this.name),e||(n=Mb.localStorage.getItem(zb),(r=null==n?{}:JSON.parse(n))[this.name]=this.getMetadata(),Mb.localStorage.setItem(zb,JSON.stringify(r))),console.log("Saving model to "+t),[2,this.model.save(t)]}))}))},e.prototype.load=function(t){return cb(this,void 0,void 0,(function(){var e,n,r;return ub(this,(function(a){switch(a.label){case 0:if(e=null!=t,t=t||Ub(this.name),!e){if(null==(n=JSON.parse(Mb.localStorage.getItem(zb)))||null==n[this.name])throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=n[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return r=this,[4,$f(t)];case 1:return r.model=a.sent(),console.log("Loaded model from "+t+":"),this.model.summary(),[2]}}))}))},e.prototype.createTransfer=function(t){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},e}(Bb);function Ub(t){return""+Lb+t}class Vb{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class jb{refCount(t){return Gb("refCount")}incRef(t){return Gb("incRef")}timerAvailable(){return!0}time(t){return Gb("time")}read(t){return Gb("read")}readSync(t){return Gb("readSync")}readToGPU(t,e){return Gb("readToGPU")}numDataIds(){return Gb("numDataIds")}disposeData(t,e){return Gb("disposeData")}write(t,e,n){return Gb("write")}move(t,e,n,r,a){return Gb("move")}createTensorFromGPUData(t,e,n){return Gb("createTensorFromGPUData")}memory(){return Gb("memory")}floatPrecision(){return Gb("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Gb("dispose")}}function Gb(t){throw new Error("'".concat(t,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function Hb(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Xb(t,e,n)}function Kb(t,e,n){return Math.max(t,Math.min(e,n))}function qb(t){return t%2===0?t:t+1}function Xb(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Jb(t,e){if(!t)throw new Error("string"===typeof e?e:e())}function Yb(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Jb($b(t,e),(()=>n+" Shapes ".concat(t," and ").concat(e," must match")))}function Zb(t){Jb(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function Qb(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function $b(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ty(t){return t%1===0}function ey(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function ny(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function ry(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let o=0;const i=()=>{if(t())return void a();o++;const l=e(o);null!=n&&o>=n?s():null!=r?r(i,l):setTimeout(i,l)};i()}))}function ay(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(-1===t[s]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(r," and dim ").concat(s));r=s}else if(t[s]<0)throw Error("Shapes can not be < 0. Found ".concat(t[s]," at dim ").concat(s));if(-1===r){if(e>0&&e!==n)throw Error("Size(".concat(e,") must match the product of shape ").concat(t));return t}if(0===n)throw Error("Cannot infer the missing size in [".concat(t,"] when ")+"there are 0 elements");if(e%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(e," / ").concat(n));const a=t.slice();return a[r]=e/n,a}function sy(t,e){const n=e.length;return Jb((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(t))),Jb(t.every((t=>ty(t))),(()=>"All values in axis param must be integers but "+"got axis ".concat(t))),t.map((t=>t<0?n+t:t))}function oy(t,e){const n=[],r=[],a=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||a?null:sy(e,t).sort();let o=0;for(let i=0;i<t.length;++i){if(null!=s){if(s[o]===i&&1!==t[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(t[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),s[o]<=i&&o++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function iy(t,e){return ly(t,e)}function ly(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type ".concat(t));n=new Array(e)}return n}function cy(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function uy(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype ".concat(t))}function hy(t){return"string"===typeof t||t instanceof String}function dy(t){return"number"===typeof t}function py(t){return Array.isArray(t)?py(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":dy(t)?"float32":hy(t)?"string":"boolean"===typeof t?"bool":"float32"}function fy(t){return!!(t&&t.constructor&&t.call&&t.apply)}function gy(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function my(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function by(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)a[e]=n[t+e]}else{const s=e[0],o=e.slice(1),i=o.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)a[e]=by(t+e*i,o,n,r)}return a}function yy(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error("[".concat(t,"] does not match the input size ").concat(e.length).concat(n?" for a complex tensor":"","."));return by(0,t,e,n)}function vy(t,e){const n=wy(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function wy(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type ".concat(e))}function xy(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return yy(t,new Float32Array(n));if("int32"===e)return yy(t,new Int32Array(n));if("bool"===e)return yy(t,new Uint8Array(n));throw new Error("Unknown data type ".concat(e))}function ky(t){t.forEach((e=>{Jb(Number.isInteger(e)&&e>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(t,"].")))}))}function Sy(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let a=0;a<t.length-1;++a)r+=n[a]*t[a];return r}function Iy(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(t/n[a]),t-=r[a]*n[a];return r[r.length-1]=t,r}function Ny(t){return t&&t.then&&"function"===typeof t.then}const Cy="tfjsflags";class Ey{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ty,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(t,"."))),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn("Setting feature override from URL ".concat(t,": ").concat(e,".")),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ny(e))throw new Error("Flag ".concat(t," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag ".concat(t," as it has not been registered."));this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '".concat(t,"': no evaluation function found."));return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(Cy in t){t[Cy].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){const n=e.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:e}(0,n)}))}}}function Ty(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,r[0],r[1]),r.join("=")})),e}function Ay(){return Fy}let Ry,Fy=null;function _y(){if(null==Ry){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof n.g)t=n.g;else if("undefined"!==typeof process)t=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}Ry=t}return Ry}function Dy(t,e){const n=function(){const t=_y();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Oy="Abs",zy="Acos",Ly="Acosh",My="Add",Py="AddN",By="All",Wy="Any",Uy="ArgMax",Vy="ArgMin",jy="Asin",Gy="Asinh",Hy="Atan",Ky="Atanh",qy="Atan2",Xy="AvgPool",Jy="AvgPoolGrad",Yy="AvgPool3D",Zy="AvgPool3DGrad",Qy="BatchMatMul",$y="BatchToSpaceND",tv="Bincount",ev="BitwiseAnd",nv="BroadcastArgs",rv="Cast",av="Ceil",sv="ClipByValue",ov="Complex",iv="ComplexAbs",lv="Concat",cv="Conv2D",uv="Conv2DBackpropFilter",hv="Conv2DBackpropInput",dv="Conv3D",pv="Conv3DBackpropFilterV2",fv="Conv3DBackpropInputV2",gv="Cos",mv="Cosh",bv="Cumprod",yv="Cumsum",vv="CropAndResize",wv="DenseBincount",xv="DepthToSpace",kv="DepthwiseConv2dNative",Sv="DepthwiseConv2dNativeBackpropFilter",Iv="DepthwiseConv2dNativeBackpropInput",Nv="Diag",Cv="Dilation2D",Ev="Dilation2DBackpropInput",Tv="Dilation2DBackpropFilter",Av="Draw",Rv="RealDiv",Fv="Einsum",_v="Elu",Dv="EluGrad",Ov="Erf",zv="Equal",Lv="Exp",Mv="ExpandDims",Pv="Expm1",Bv="FFT",Wv="Fill",Uv="FlipLeftRight",Vv="Floor",jv="FloorDiv",Gv="FusedBatchNorm",Hv="GatherV2",Kv="GatherNd",qv="Greater",Xv="GreaterEqual",Jv="Identity",Yv="IFFT",Zv="Imag",Qv="IsFinite",$v="IsInf",tw="IsNan",ew="LeakyRelu",nw="Less",rw="LessEqual",aw="LinSpace",sw="Log",ow="Log1p",iw="LogicalAnd",lw="LogicalNot",cw="LogicalOr",uw="LRN",hw="LRNGrad",dw="Max",pw="Maximum",fw="MaxPool",gw="MaxPoolGrad",mw="MaxPool3D",bw="MaxPool3DGrad",yw="MaxPoolWithArgmax",vw="Mean",ww="Min",xw="Minimum",kw="MirrorPad",Sw="Mod",Iw="Multinomial",Nw="Multiply",Cw="Neg",Ew="NotEqual",Tw="NonMaxSuppressionV3",Aw="NonMaxSuppressionV4",Rw="NonMaxSuppressionV5",Fw="OnesLike",_w="OneHot",Dw="Pack",Ow="PadV2",zw="Pow",Lw="Prelu",Mw="Prod",Pw="RaggedGather",Bw="RaggedRange",Ww="RaggedTensorToTensor",Uw="Range",Vw="Real",jw="Reciprocal",Gw="Relu",Hw="Reshape",Kw="ResizeNearestNeighbor",qw="ResizeNearestNeighborGrad",Xw="ResizeBilinear",Jw="ResizeBilinearGrad",Yw="Relu6",Zw="Reverse",Qw="Round",$w="Rsqrt",tx="ScatterNd",ex="TensorScatterUpdate",nx="SearchSorted",rx="Select",ax="Selu",sx="Slice",ox="Sin",ix="Sinh",lx="Sign",cx="Sigmoid",ux="Softplus",hx="Sqrt",dx="Sum",px="SpaceToBatchND",fx="SplitV",gx="Softmax",mx="SparseFillEmptyRows",bx="SparseReshape",yx="SparseSegmentMean",vx="SparseSegmentSum",wx="SparseToDense",xx="SquaredDifference",kx="Square",Sx="StaticRegexReplace",Ix="StridedSlice",Nx="StringNGrams",Cx="StringSplit",Ex="StringToHashBucketFast",Tx="Sub",Ax="Tan",Rx="Tanh",Fx="Tile",_x="TopK",Dx="Transform",Ox="Transpose",zx="Unique",Lx="Unpack",Mx="UnsortedSegmentSum",Px="ZerosLike",Bx="Step",Wx="FromPixels",Ux="RotateWithOffset",Vx="_FusedMatMul",jx="FusedConv2D",Gx="FusedDepthwiseConv2D";function Hx(){Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.warn(...arguments)}function Kx(){Ay().getBool("IS_TEST")||Ay().getBool("PROD")||console.log(...arguments)}const qx=Dy("kernelRegistry",(()=>new Map)),Xx=Dy("gradRegistry",(()=>new Map));function Jx(t,e){const n=tk(t,e);return qx.get(n)}function Yx(t){return Xx.get(t)}function Zx(t){const e=qx.entries(),n=[];for(;;){const{done:r,value:a}=e.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===t&&n.push(o)}return n}function Qx(t){const{kernelName:e,backendName:n}=t,r=tk(e,n);qx.has(r)&&Hx("The kernel '".concat(e,"' for backend ")+"'".concat(n,"' is already registered")),qx.set(r,t)}function $x(t){const{kernelName:e}=t;Xx.has(e)&&Ay().getBool("DEBUG")&&Hx("Overriding the gradient for '".concat(e,"'")),Xx.set(e,t)}function tk(t,e){return"".concat(e,"_").concat(t)}function ek(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}const nk=sr()||ar;function rk(t){return nk.fromString(t,!0,16)}const ak=rk("c3a5c85c97cb3127"),sk=rk("b492b66fbe98f273"),ok=rk("9ae16a3b2f90404f");function ik(t){return t.xor(t.shru(47))}function lk(t,e,n){const r=t.slice(e,e+n);return nk.fromBytes(Array.from(r),!0,!0)}function ck(t,e){return lk(t,e,8)}function uk(t,e){return lk(t,e,4)}function hk(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function dk(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rk("9ddfea08eb382d69"),r=t.xor(e).mul(n);r=r.xor(r.shru(47));let a=e.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function pk(t,e,n,r){return function(t,e,n,r,a,s){a=a.add(t),s=hk(s.add(a).add(r),21);const o=a;return a=(a=a.add(e)).add(n),s=s.add(hk(a,44)),[a.add(r),s.add(o)]}(ck(t,e),ck(t,e+8),ck(t,e+16),ck(t,e+24),n,r)}function fk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=nk.fromNumber(81,!0);if(e<=32)return e<=16?function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;if(e>=8){const n=ok.add(2*e),r=ck(t,0).add(ok),a=ck(t,e-8);return dk(hk(a,37).mul(n).add(r),hk(r,25).add(a).mul(n),n)}if(e>=4){const n=ok.add(2*e);return dk(uk(t,0).shl(3).add(e),uk(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return ik(ok.mul(n).xor(ak.mul(r))).mul(ok)}return ok}(t,e):function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=ok.add(2*e),r=ck(t,0).mul(sk),a=ck(t,8),s=ck(t,e-8).mul(n),o=ck(t,e-16).mul(ok);return dk(hk(r.add(a),43).add(hk(s,30)).add(o),r.add(hk(a.add(ok),18)).add(s),n)}(t,e);if(e<=64)return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.length;const n=ok.add(2*e),r=ck(t,0).mul(ok),a=ck(t,8),s=ck(t,e-8).mul(n),o=ck(t,e-16).mul(ok),i=hk(r.add(a),43).add(hk(s,30)).add(o),l=dk(i,r.add(hk(a.add(ok),18)).add(s),n),c=ck(t,16).mul(n),u=ck(t,24),h=i.add(ck(t,e-32)).mul(n),d=l.add(ck(t,e-24)).mul(n);return dk(hk(c.add(u),43).add(hk(h,30)).add(d),c.add(hk(u.add(r),18)).add(h),n)}(t,e);let r=n,a=n.mul(sk).add(113),s=ik(a.mul(ok).add(113)).mul(ok),o=[nk.UZERO,nk.UZERO],i=[nk.UZERO,nk.UZERO];r=r.mul(ok).add(ck(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{r=hk(r.add(a).add(o[0]).add(ck(t,l+8)),37).mul(sk),a=hk(a.add(o[1]).add(ck(t,l+48)),42).mul(sk),r=r.xor(i[1]),a=a.add(o[0]).add(ck(t,l+40)),s=hk(s.add(i[0]),33).mul(sk),o=pk(t,l,o[1].mul(sk),r.add(i[0])),i=pk(t,l+32,s.add(i[1]),a.add(ck(t,l+16))),[s,r]=[r,s],l+=64}while(l!==c);const h=sk.add(s.and(255).shl(1));return l=u,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=hk(r.add(a).add(o[0]).add(ck(t,l+8)),37).mul(h),a=hk(a.add(o[1]).add(ck(t,l+48)),42).mul(h),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(ck(t,l+40))),s=hk(s.add(i[0]),33).mul(h),o=pk(t,l,o[1].mul(h),r.add(i[0])),i=pk(t,l+32,s.add(i[1]),a.add(ck(t,l+16))),[s,r]=[r,s],dk(dk(o[0],i[0],h).add(ik(a).mul(ak)).add(s),dk(o[1],i[1],h).add(r),h)}function gk(t,e){return"string"===e?yk(t):mk([t],e)}function mk(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=xk(t)),Ay().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(e," being uploaded contains ").concat(r,"."))}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type ".concat(e))}function bk(){return Ay().platform.now()}function yk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ay().platform.encode(t,e)}function vk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return e=e||"utf-8",Ay().platform.decode(t,e)}function wk(t){return null!=Ay().platform.isTypedArray?Ay().platform.isTypedArray(t):ek(t)}function xk(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e&&(e=[]),"boolean"===typeof t||"number"===typeof t||"string"===typeof t||Ny(t)||null==t||wk(t)&&n)e.push(t);else if(Array.isArray(t)||wk(t))for(let r=0;r<t.length;++r)xk(t[r],e,n);else{let r=-1;for(const e of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(e)&&(r=Math.max(r,Number(e)));for(let a=0;a<=r;a++)xk(t[a],e,n)}return e}class kk{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Ik)}profileKernel(t,e,n){let r;const a=()=>{r=n()};let s;const o=bk();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:bk()-o})}if(Ay().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const e=r[i];e.data().then((n=>{Sk(n,e.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:a,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],a,n[2])}))}))}}function Sk(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn("Found ".concat(e," in the result of '").concat(n,"'")),!0}return!1}class Ik{logKernelProfile(t,e,n,r,a,s){const o="number"===typeof r?ny("".concat(r,"ms"),9):r.error,i=ny(t,25),l=e.rank,c=e.size,u=ny(e.shape.toString(),14);let h="";for(const d in a){const t=a[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(l,"D ").concat(u,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Nk=20,Ck=3,Ek=7;function Tk(t,e,n,r){const a=my(e),s=function(t,e,n,r){const a=Qb(e),s=r[r.length-1],o=new Array(s).fill(0),i=e.length,l="complex64"===n?_k(t):t;if(i>1)for(let c=0;c<a/s;c++){const t=c*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Ak(l[t+e],0,n).length)}return o}(t,e,n,a),o=e.length,i=Fk(t,e,n,a,s),l=["Tensor"];return r&&(l.push("  dtype: ".concat(n)),l.push("  rank: ".concat(o)),l.push("  shape: [".concat(e,"]")),l.push("  values:")),l.push(i.map((t=>"    "+t)).join("\n")),l.join("\n")}function Ak(t,e,n){let r;return r=Array.isArray(t)?"".concat(parseFloat(t[0].toFixed(Ek))," + ")+"".concat(parseFloat(t[1].toFixed(Ek)),"j"):hy(t)?"'".concat(t,"'"):"bool"===n?Rk(t):parseFloat(t.toFixed(Ek)).toString(),ny(r,e)}function Rk(t){return 0===t?"false":"true"}function Fk(t,e,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=e[0],l=e.length;if(0===l){if("complex64"===n){return[Ak(_k(t)[0],0,n)]}return"bool"===n?[Rk(t[0])]:[t[0].toString()]}if(1===l){if(i>Nk){const e=Ck*o;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((i-Ck)*o,i*o));return"complex64"===n&&(r=_k(r),s=_k(s)),["["+r.map(((t,e)=>Ak(t,a[e],n))).join(", ")+", ..., "+s.map(((t,e)=>Ak(t,a[i-Ck+e],n))).join(", ")+"]"]}return["["+("complex64"===n?_k(t):Array.from(t)).map(((t,e)=>Ak(t,a[e],n))).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,d=[];if(i>Nk){for(let e=0;e<Ck;e++){const r=e*h,s=r+h;d.push(...Fk(t.slice(r,s),c,n,u,a,!1))}d.push("...");for(let e=i-Ck;e<i;e++){const r=e*h,s=r+h;d.push(...Fk(t.slice(r,s),c,n,u,a,e===i-1))}}else for(let g=0;g<i;g++){const e=g*h,r=e+h;d.push(...Fk(t.slice(e,r),c,n,u,a,g===i-1))}const p=2===l?",":"";d[0]="["+(i>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function _k(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Dk{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Qb(t),null!=n){const t=n.length;Jb(t===this.size,(()=>"Length of values '".concat(t,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ly(e,this.size),this.strides=my(t)}set(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Jb(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=t}get(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];0===e.length&&(e=[0]);let r=0;for(const s of e){if(s<0||s>=this.shape[r]){const t="Requested out of range element at ".concat(e,". ")+"  Buffer shape=".concat(this.shape);throw new Error(t)}r++}let a=e[e.length-1];for(let s=0;s<e.length-1;++s)a+=this.strides[s]*e[s];return this.values[a]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ok().makeTensor(this.values,this.shape,this.dtype)}}let Ok=null,zk=null,Lk=null;class Mk{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Qb(t),this.strides=my(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return zk.buffer(this.shape,this.dtype,t)}bufferSync(){return zk.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return yy(this.shape,t,"complex64"===this.dtype)}arraySync(){return yy(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Ok().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map((t=>vk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ok().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ok().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>vk(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ok().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ok().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return zk.print(this,t)}clone(){return this.throwIfDisposed(),zk.clone(this)}toString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Tk(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),zk.cast(this,t)}variable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Ok().makeVariable(this,t,e,n)}}function Pk(){return Dy("Tensor",(()=>Mk))}Object.defineProperty(Mk,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Pk();class Bk extends Mk{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(t.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!$b(t.shape,this.shape))throw new Error("shape of the new value (".concat(t.shape,") and ")+"previous value (".concat(this.shape,") must match"));Ok().disposeTensor(this),this.dataId=t.dataId,Ok().incRef(this,null)}dispose(){Ok().disposeVariable(this),this.isDisposedInternal=!0}}var Wk,Uk,Vk,jk,Gk;Object.defineProperty(Bk,Symbol.hasInstance,{value:t=>t instanceof Mk&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Wk||(Wk={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Uk||(Uk={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Vk||(Vk={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(jk||(jk={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Gk||(Gk={}));const Hk={float32:jk,int32:Uk,bool:Vk,complex64:Gk};function Kk(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast ".concat(t," with ").concat(e))}return Hk[t][e]}function qk(t){return Kk(t,"int32")}function Xk(t){return null!=t&&"object"===typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function Jk(t){return"undefined"!==typeof GPUBuffer&&null!=t&&"object"===typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function Yk(t,e){if(t.dtype===e.dtype)return[t,e];const n=Kk(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Zk(t,e){return e.some((e=>e.id===t.id))}function Qk(t){const e=[];return $k(t,e,new Set),e}function $k(t,e,n){if(null==t)return;if(t instanceof Mk)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=t;for(const s in a){const t=a[s];n.has(t)||(n.add(t),$k(t,e,n))}}function tS(t){return null!=t.kernelName}class eS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class nS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new eS}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error("The highest priority backend '".concat(t,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return t in this.registryFactory?(Hx("".concat(t," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error("Backend name '".concat(t,"' not found in registry"));if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new kk(this.backendInstance),!0}setupRegisteredKernels(){Zx(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Zx(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error("Cannot initialize backend ".concat(t,", no registration found."));try{const n=e.factory();if(!n||n instanceof jb||"function"!==typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Hx("Initialization of backend ".concat(t," failed")),Hx(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(w1){return Hx("Initialization of backend ".concat(t," failed")),Hx(w1.stack||w1.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error("".concat(t," backend not found in registry"));this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,a=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!==typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!==typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return nS.nextTensorId++}nextVariableId(){return nS.nextVariableId++}clone(t){const e=aS.runKernel(Jv,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return aS.runKernel(rv,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=Jx(t,this.backendName)))throw new Error("Kernel '".concat(t,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let a=0;n.forEach((t=>{a+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-a-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(t,"'"))}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=tS(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(tS(t)){const{kernelName:e,inputs:a,attrs:s}=t;null==this.backendName&&this.backend;const l=Jx(e,this.backendName);Jb(null!=l,(()=>"Cannot find registered kernel '".concat(e,"' for backend '").concat(this.backendName,"'"))),o=()=>{const t=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,a,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,a=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();i=this.tidy((()=>e(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:c,attrs:u}=t,h=tS(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,c,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=o()})),r&&this.addTapeNode(l,c,e,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((t=>null!=c[t]?c[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=Yx(t);if(null!=r){const t=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Jb(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>a[e]));return s.concat(o)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=t;"string"===n&&hy(t[0])&&(a=t.map((t=>yk(t))));const s=r.write(a,e,n),o=new Mk(e,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(a);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const a={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:a}=t,s=new Mk(r,a,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const a=new Bk(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*uy(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Bk||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*uy(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:a},i=Yx(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=wy(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],a,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Qk(t),n=new Set(e.map((t=>t.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const t=this.state.activeScope.track[a];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Jb(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));Jb(a instanceof Mk,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},a={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],s=n.inputs;for(const t in s){const o=s[t];let i=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach((t=>r[t.id]=!0)),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(s[e.outputs[t].id]){for(const t in n)s[n[t].id]=!0,o[e.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const e=t[l];if(a[e.id]&&o[e.id]){const t={};for(const a in e.inputs){const n=e.inputs[a];r[n.id]&&(t[a]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,i.push(n)}}return i}(this.state.activeTape,e,a);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[a.id]=null==n?function(t){const e=vy(Qb(t),"float32");return aS.makeTensor(e,t,"float32")}(a.shape):n,function(t,e,n,r){for(let a=e.length-1;a>=0;a--){const s=e[a],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const e in s.inputs){if(!(e in i))throw new Error("Cannot backprop through input ".concat(e,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const a=n((()=>i[e]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(e," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const o=s.inputs[e];if(!$b(a.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(e,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==t[o.id])t[o.id]=a;else{const e=t[o.id];t[o.id]=r(e,a),e.dispose()}}}}(t,s,(t=>this.tidy(t)),sS);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(t){var e=this;return Jb(fy(t),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Jb(r.every((t=>t instanceof Mk)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};r.forEach(((t,e)=>{o[e]=t}));return e.runKernelFunc({forwardFunc:(e,n)=>(s=t(...r,n),Jb(s.value instanceof Mk,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Jb(fy(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(t,e)=>{const n=s.gradFunc(t,e),a=Array.isArray(n)?n:[n];Jb(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Jb(a.every((t=>t instanceof Mk)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return a.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=bk(),n=await this.backend.time(t);return n.wallMs=bk()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new eS;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function rS(){const t=_y();if(null==t._tfengine){const e=new Ey(t);t._tfengine=new nS(e)}var e;return e=t._tfengine.ENV,Fy=e,function(t){Ok=t}((()=>t._tfengine)),t._tfengine}nS.nextTensorId=0,nS.nextVariableId=0;const aS=rS();function sS(t,e){const n={a:t,b:e};return aS.runKernel(My,n)}let oS;function iS(t){if(void 0!==oS)return oS;if(t||"undefined"!==typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!==typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function lS(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const cS=Ay();function uS(t,e){let n=t;if(wk(t))return"string"===e?[]:[t.length];if(Xk(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if(Jk(t))return[t.buffer.size/(null==e?4:uy(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||wk(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Ay().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hS(t,r,[]),r}function hS(t,e,n){if(n=n||[],!Array.isArray(t)&&!wk(t))return void Jb(0===e.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(e[0]," elements")));Jb(e.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements"))),Jb(t.length===e[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(e[0]," ")+"elements, but has ".concat(t.length," elements")));const r=e.slice(1);for(let a=0;a<t.length;++a)hS(t[a],r,n.concat(a))}function dS(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(t," tensor, but got ").concat(e," tensor"))}}function pS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(t instanceof Pk())return dS(r,t.dtype,e,n),t;let a=py(t);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),dS(r,a,e,n),null==t||!wk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const r=null==t?"null":t.constructor.name;throw new Error("Argument '".concat(e,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const s=uS(t,a);wk(t)||Array.isArray(t)||(t=[t]);const o="string"!==a?mk(t,a):xk(t,[],!0);return aS.makeTensor(o,s,a)}function fS(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(t))throw new Error("Argument ".concat(e," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return t.map(((t,a)=>pS(t,"".concat(e,"[").concat(a,"]"),n,r)))}cS.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),cS.registerFlag("IS_BROWSER",(()=>lS())),cS.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),cS.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),cS.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),cS.registerFlag("PROD",(()=>!1)),cS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>cS.getBool("DEBUG"))),cS.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),cS.registerFlag("IS_TEST",(()=>!1)),cS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>cS.getBool("DEBUG"))),cS.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),cS.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),cS.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function gS(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(e.length," keys."));let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){aS.startScope(n);try{const t=r(...arguments);return Ny(t)&&console.error("Cannot return a Promise inside of tidy."),aS.endScope(t),t}catch(t){throw aS.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const mS=gS({complex_:function(t,e){const n=pS(t,"real","complex"),r=pS(e,"imag","complex");Yb(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return aS.runKernel(ov,a)}});function bS(t,e,n,r){if(null==r)r=py(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Jk(t)||Xk(t)){if("float32"!==r&&"int32"!==r)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(r,"."));return aS.backend.createTensorFromGPUData(t,e||n,r)}if(!wk(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){ky(e);const t=Qb(e),r=Qb(n);Jb(t===r,(()=>"Based on the provided shape, [".concat(e,"], the tensor should have ")+"".concat(t," values but has ").concat(r)));for(let a=0;a<n.length;++a){const t=n[a],r=a!==n.length-1||t!==Qb(e.slice(a));Jb(n[a]===e[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(e,"). ")))}}return wk(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?mk(t,r):xk(t,[],!0),aS.makeTensor(t,e,r)}function yS(t,e,n){return bS(t,e,uS(t,n),n)}const vS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class wS{static join(t){return new wS(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t)return;if(t instanceof Array||(t=[t]),0===(t=t.map((t=>wk(t)?t.buffer:t))).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=e+r.byteLength;this.shards.push({buffer:r,start:e,end:a}),e=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(-1===n)throw new Error("Could not find start shard for byte ".concat(t));const r=new ArrayBuffer(e-t),a=new Uint8Array(r);let s=0;for(let o=n;o<this.shards.length;o++){const n=this.shards[o],r=t+s-n.start,i=s,l=Math.min(e,n.end)-n.start,c=new Uint8Array(n.buffer,r,l-r);if(a.set(c,i),s+=c.length,e<n.end)break}return r}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(t,e){let n=0,r=t.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=e(t[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,e);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function xS(){return aS}function kS(){return aS.memory()}function SS(t,e){return aS.tidy(t,e)}function IS(t){Qk(t).forEach((t=>t.dispose()))}function NS(t){return aS.keep(t)}function CS(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return aS.registerBackend(t,e,n)}function ES(){return aS.backend}!function(t){Lk=t}((function(t){Ay().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const TS=4;async function AS(t,e){const n=[],r=[],a=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise((async t=>{const e=await i.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+TS*e.length,r=new Uint8Array(n);let a=0;for(let s=0;s<e.length;s++){const t=e[s],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,a),a+=TS,r.set(t,a),a+=t.length}t(r)}));r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:DS(await Promise.all(r)),specs:n}}function RS(t,e){const n=new wS(t),r={};let a=0;for(const s of e){const t=FS(s,((t,e)=>n.slice(a+t,a+e)));r[s.name]=_S(s,n.slice(a,a+t)),a+=t}return r}function FS(t,e){const n=Qb(t.shape);let r;if("quantization"in t){const e=t.quantization;r=vS[e.dtype]}else{if("string"===t.dtype){let t=0;for(let r=0;r<n;r++)t+=TS+new Uint32Array(e(t,t+TS))[0];return t}r=vS[t.dtype]}return n*r}function _S(t,e){const n=t.name,r=t.dtype,a=t.shape,s=Qb(a);let o,i=0;if("quantization"in t){const a=t.quantization;if("uint8"===a.dtype||"uint16"===a.dtype){if(!("min"in a)||!("scale"in a))throw new Error("Weight ".concat(t.name," with quantization ").concat(a.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==a.dtype)throw new Error("Weight ".concat(t.name," has unknown ")+"quantization dtype ".concat(a.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==r)throw new Error("Weight ".concat(t.name," is quantized with ").concat(a.dtype," ")+"which only supports weights of type float32 not ".concat(r,"."))}const l=vS[a.dtype],c="uint8"===a.dtype?new Uint8Array(e):new Uint16Array(e);if("float32"===r)if("uint8"===a.dtype||"uint16"===a.dtype){o=new Float32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];o[t]=e*a.scale+a.min}}else{if("float16"!==a.dtype)throw new Error("Unsupported quantization type ".concat(a.dtype," ")+"for weight type float32.");{const t=function(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0===(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const a=r[o],i=t[n[a>>10]+(1023&a)]+e[a>>10];s[o]=i}return new Float32Array(a)}}();o=t(c)}}else{if("int32"!==r)throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(r));if("uint8"!==a.dtype&&"uint16"!==a.dtype)throw new Error("Unsupported quantization type ".concat(a.dtype," ")+"for weight type int32.");o=new Int32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];o[t]=Math.round(e*a.scale+a.min)}}i+=s*l}else if("string"===r){const n=Qb(t.shape);o=[];for(let t=0;t<n;t++){const t=new Uint32Array(e.slice(i,i+TS))[0];i+=TS;const n=new Uint8Array(e.slice(i,i+t));o.push(n),i+=t}}else{const t=vS[r];if("float32"===r)o=new Float32Array(e);else if("int32"===r)o=new Int32Array(e);else{if("bool"!==r){if("complex64"===r){o=new Float32Array(e);const t=new Float32Array(o.length/2),n=new Float32Array(o.length/2);for(let e=0;e<t.length;e++)t[e]=o[2*e],n[e]=o[2*e+1];const r=yS(t,a,"float32"),s=yS(n,a,"float32"),i=mS(r,s);return r.dispose(),s.dispose(),i}throw new Error("Unsupported dtype in weight '".concat(n,"': ").concat(r))}o=new Uint8Array(e)}i+=s*t}return yS(o,a,r)}function DS(t){if(null===t)throw new Error("Invalid input value: ".concat(JSON.stringify(t)));let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(t.constructor.name))}));const r=new Uint8Array(e);let a=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),a),a+=t.byteLength})),r.buffer}const OS="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function zS(t){return OS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function LS(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(n.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function MS(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}(t,n,r)}function PS(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:zS(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:zS(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:new wS(t.weightData).byteLength}}function BS(t){const e=[];for(const n of t)e.push(...n.weights);return e}class WS{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==WS.instance&&(WS.instance=new WS),WS.instance}static registerSaveRouter(t){WS.getInstance().saveRouters.push(t)}static registerLoadRouter(t){WS.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return WS.getHandlers(t,"save")}static getLoadHandlers(t,e){return WS.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?WS.getInstance().loadRouters:WS.getInstance().saveRouters).forEach((e=>{const a=e(t,n);null!==a&&r.push(a)})),r}}const US="tensorflowjs",VS="models_store",jS="model_info_store";function GS(){if(!Ay().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"===typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function HS(t){const e=t.result;e.createObjectStore(VS,{keyPath:"modelPath"}),e.createObjectStore(jS,{keyPath:"modelPath"})}class KS{constructor(t){if(this.indexedDB=GS(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(US,1);r.onupgradeneeded=()=>HS(r),r.onsuccess=()=>{const a=r.result;if(null==e){const e=a.transaction(VS,"readonly"),r=e.objectStore(VS).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));t(r.result.modelArtifacts)},r.onerror=t=>(a.close(),n(r.error)),e.oncomplete=()=>a.close()}else{e.weightData=wS.join(e.weightData);const r=PS(e),o=a.transaction(jS,"readwrite");let i,l,c=o.objectStore(jS);try{i=c.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}i.onsuccess=()=>{l=a.transaction(VS,"readwrite");const i=l.objectStore(VS);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r})}catch(s){return n(s)}u.onsuccess=()=>t({modelArtifactsInfo:r}),u.onerror=t=>{c=o.objectStore(jS);const e=c.delete(this.modelPath);e.onsuccess=()=>(a.close(),n(u.error)),e.onerror=t=>(a.close(),n(u.error))}},i.onerror=t=>(a.close(),n(i.error)),o.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=t=>n(r.error)}))}}KS.URL_SCHEME="indexeddb://";const qS=t=>{return Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(KS.URL_SCHEME)?(e=t.slice(KS.URL_SCHEME.length),new KS(e)):null;var e};WS.registerSaveRouter(qS),WS.registerLoadRouter(qS);class XS{constructor(){this.indexedDB=GS()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(US,1);n.onupgradeneeded=()=>HS(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(jS,"readonly"),s=a.objectStore(jS).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),a.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(KS.URL_SCHEME)?e.slice(KS.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(US,1);r.onupgradeneeded=()=>HS(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(jS,"readwrite"),o=s.objectStore(jS),i=o.get(t);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error("Cannot find model with path '".concat(t,"' ")+"in IndexedDB."));{const r=o.delete(t),s=()=>{l=a.transaction(VS,"readwrite");const r=l.objectStore(VS).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),a.close(),n(i.error))}},i.onerror=t=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=t=>n(r.error)}))}}const JS="/",YS="tensorflowjs_models",ZS="info",QS="model_topology",$S="weight_specs",tI="weight_data",eI="model_metadata";function nI(t){return{info:[YS,t,ZS].join(JS),topology:[YS,t,QS].join(JS),weightSpecs:[YS,t,$S].join(JS),weightData:[YS,t,tI].join(JS),modelMetadata:[YS,t,eI].join(JS)}}function rI(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function aI(t){const e=t.split(JS);if(e.length<3)throw new Error("Invalid key format: ".concat(t));return e.slice(1,e.length-1).join(JS)}class sI{constructor(t){if(!Ay().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=nI(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=PS(t),a=wS.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(OS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,a=e.length;r<a;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(a));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(w1){throw rI(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");e.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const t=JSON.parse(a);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return e.weightData=function(t){if(OS){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(s),e}}sI.URL_SCHEME="localstorage://";const oI=t=>{return Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(sI.URL_SCHEME)?(e=t.slice(sI.URL_SCHEME.length),new sI(e)):null;var e};WS.registerSaveRouter(oI),WS.registerLoadRouter(oI);class iI{constructor(){Jb(Ay().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Jb("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=YS+JS,n=JS+ZS;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(e)&&a.endsWith(n)){t[aI(a)]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){var e;const n=nI(t=(e=t).startsWith(sI.URL_SCHEME)?e.slice(sI.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(t,"'"));const r=JSON.parse(this.LS.getItem(n.info));return rI(n),r}}const lI="://";class cI{constructor(){this.managers={}}static getInstance(){return null==cI.instance&&(cI.instance=new cI),cI.instance}static registerManager(t,e){Jb(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(lI)&&(t=t.slice(0,t.indexOf(lI))),Jb(t.length>0,(()=>"scheme must not be an empty string."));const n=cI.getInstance();Jb(null==n.managers[t],(()=>"A model store manager is already registered for scheme '".concat(t,"'."))),n.managers[t]=e}static getManager(t){const e=cI.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '".concat(t,"'"));return e}static getSchemes(){return Object.keys(cI.getInstance().managers)}}class uI{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got ".concat(e));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!==typeof window&&Ay().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return ek(t)}}if(Ay().get("IS_BROWSER")){Ay().setPlatform("browser",new uI);try{cI.registerManager(sI.URL_SCHEME,new iI)}catch(w1){}try{cI.registerManager(KS.URL_SCHEME,new XS)}catch(w1){}}const hI=()=>n(7078);let dI;class pI{constructor(){this.util=n(6905),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ay().global.fetch?Ay().global.fetch(t,e):(null==dI&&(dI=hI()),dI(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(e));return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}function fI(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return e=e||"float32",ky(t),new Dk(t,e,n)}Ay().get("IS_NODE")&&!Ay().get("IS_BROWSER")&&Ay().setPlatform("node",new pI);const gI=gS({cast_:function(t,e){const n=pS(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype ".concat(e));if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:e};return aS.runKernel(rv,r,a)}});const mI=gS({clone_:function(t){const e={x:pS(t,"x","clone","string_or_numeric")};return aS.runKernel(Jv,e)}});rS();!function(t){zk=t}({buffer:fI,cast:gI,clone:mI,print:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(t.toString(e))}});const bI=gS({add_:function(t,e){let n=pS(t,"a","add"),r=pS(e,"b","add");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(My,a)}});const yI=gS({floorDiv_:function(t,e){let n=pS(t,"a","floorDiv"),r=pS(e,"b","floorDiv");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(jv,a)}});const vI=gS({div_:function(t,e){let n=pS(t,"a","div"),r=pS(e,"b","div");if([n,r]=Yk(n,r),"int32"===n.dtype&&"int32"===r.dtype)return yI(n,r);const a={a:n,b:r};return aS.runKernel(Rv,a,{})}});const wI=gS({mul_:function(t,e){let n=pS(t,"a","mul"),r=pS(e,"b","mul");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Nw,a)}});const xI=gS({sqrt_:function(t){const e={x:pS(t,"x","sqrt","float32")};return aS.runKernel(hx,e)}});const kI=gS({square_:function(t){const e=pS(t,"x","square");return aS.runKernel("Square",{x:e},{})}});const SI=gS({zerosLike_:function(t){const e={x:pS(t,"x","zerosLike")};return aS.runKernel(Px,e)}});function II(t){return aS.customGrad(t)}function NI(t,e){if((wk(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&wk(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bS(t,[],[],e)}const CI=new Map,EI=new Map;class TI{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class AI{constructor(){this.classNameMap={}}static getMap(){return null==AI.instance&&(AI.instance=new AI),AI.instance}static register(t){AI.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function RI(t,e,n){Jb(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),Jb("string"===typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),Jb(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof e&&(e="Custom"),"undefined"===typeof n&&(n=t.className);const r=e+">"+n;return AI.register(t),CI.set(r,t),EI.set(t,r),t}class FI extends TI{minimize(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:a[t.name]})));this.applyGradients(t)}else this.applyGradients(a);return IS(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){Jb(fy(t),(()=>"The f passed in variableGrads(f) must be a function")),Jb(null==e||Array.isArray(e)&&e.every((t=>t instanceof Bk)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in aS.registeredVariables)e.push(aS.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,a=e.length;e=e.filter((t=>t.trainable)),Jb(e.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:s,grads:o}=aS.gradients(t,e,null,!0);Jb(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Jb(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return e.forEach(((t,e)=>{null!=o[e]&&(i[t.name]=o[e])})),null!=r&&r.forEach((t=>i[t.name]=null)),{value:s,grads:i}}(t,e)}dispose(){null!=this.iterations_&&IS(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:NI(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(FI,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class _I extends FI{static get className(){return"Adadelta"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(e,"/accum_grad"),variable:SS((()=>SI(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(e,"/accum_var"),variable:SS((()=>SI(r).variable(false)))});const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;SS((()=>{const t=bI(wI(s,this.rho),wI(kI(a),1-this.rho)),e=wI(vI(xI(bI(o,this.epsilon)),xI(bI(s,this.epsilon))),a),n=bI(wI(o,this.rho),wI(kI(e),1-this.rho));s.assign(t),o.assign(n);const i=bI(wI(e,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(IS(this.accumulatedGrads.map((t=>t.variable))),IS(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function DI(t,e,n){ky(t);const r={shape:t,value:e,dtype:n=n||py(e)};return aS.runKernel(Wv,{},r)}class OI extends FI{static get className(){return"Adagrad"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:"".concat(e,"/accumulator"),variable:SS((()=>DI(r.shape,this.initialAccumulatorValue).variable(t)))}}const a=Array.isArray(t)?t[n].tensor:t[e];if(null==a)return;const s=this.accumulatedGrads[n].variable;SS((()=>{const t=bI(s,kI(a));s.assign(t);const e=bI(wI(vI(a,xI(bI(t,aS.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&IS(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const zI=gS({pow_:function(t,e){let n=pS(t,"base","pow"),r=pS(e,"exp","pow");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(zw,a)}});const LI=gS({sub_:function(t,e){let n=pS(t,"a","sub"),r=pS(e,"b","sub");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Tx,a)}});class MI extends FI{static get className(){return"Adam"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],SS((()=>{this.accBeta1=NI(e).variable(),this.accBeta2=NI(n).variable()})),null==r&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);SS((()=>{const n=LI(1,this.accBeta1),r=LI(1,this.accBeta2);e.forEach(((e,a)=>{const s=aS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:SS((()=>SI(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(e,"/v"),variable:SS((()=>SI(s).variable(false)))});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,c=bI(wI(i,this.beta1),wI(o,1-this.beta1)),u=bI(wI(l,this.beta2),wI(kI(o),1-this.beta2)),h=vI(c,n),d=vI(u,r);i.assign(c),l.assign(u);const p=bI(wI(vI(h,bI(xI(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(wI(this.accBeta1,this.beta1)),this.accBeta2.assign(wI(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&IS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&IS(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),SS((()=>{this.accBeta1.assign(zI(this.beta1,this.iterations_+1)),this.accBeta2.assign(zI(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const PI=gS({abs_:function(t){const e=pS(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return aS.runKernel(iv,t)}{const t={x:e};return aS.runKernel(Oy,t)}}});function BI(t,e){const n=t.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=t[s]||1;(e[e.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function WI(t,e){const n=[];for(let r=0;r<e.length;r++){const a=t[t.length-r-1],s=e.length-r-1,o=e[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function UI(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let a=0;a<n;a++){let s=t[t.length-a-1];null==s&&(s=1);let o=e[e.length-a-1];if(null==o&&(o=1),1===s)r[n-a-1]=o;else if(1===o)r[n-a-1]=s;else{if(s!==o){const n="Operands could not be broadcast together with shapes "+"".concat(t," and ").concat(e,".");throw Error(n)}r[n-a-1]=s}}return r}const VI=gS({maximum_:function(t,e){let n=pS(t,"a","maximum"),r=pS(e,"b","maximum");[n,r]=Yk(n,r),"bool"===n.dtype&&(n=gI(n,"int32"),r=gI(r,"int32")),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(pw,a)}});class jI extends FI{static get className(){return"Adamax"}constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],SS((()=>{this.iteration=NI(0).variable(),this.accBeta1=NI(e).variable()})),null==r&&(this.epsilon=aS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);SS((()=>{const n=LI(1,this.accBeta1),r=vI(-this.learningRate,bI(wI(this.iteration,this.decay),1));e.forEach(((e,a)=>{const s=aS.registeredVariables[e];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(e,"/m"),variable:SI(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(e,"/v"),variable:SI(s).variable(false)});const o=Array.isArray(t)?t[a].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,c=bI(wI(i,this.beta1),wI(o,1-this.beta1)),u=wI(l,this.beta2),h=PI(o),d=VI(u,h);i.assign(c),l.assign(d);const p=bI(wI(vI(r,n),vI(c,bI(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(bI(this.iteration,1)),this.accBeta1.assign(wI(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&IS(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&IS(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class GI extends FI{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const a=aS.registeredVariables[e];SS((()=>{const t=bI(wI(this.c,r),a);a.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=NS(NI(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class HI extends GI{static get className(){return"Momentum"}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=NI(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:"".concat(e,"/momentum"),variable:SS((()=>SI(r).variable(t)))}}const a=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&SS((()=>{let t;const e=bI(wI(this.m,a),s);t=this.useNesterov?bI(wI(this.c,bI(s,wI(e,this.m))),r):bI(wI(this.c,e),r),a.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&IS(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class KI extends FI{static get className(){return"RMSProp"}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=aS.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=aS.registeredVariables[e],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(e,"/rms"),variable:SS((()=>SI(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(e,"/momentum"),variable:SS((()=>SI(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(e,"/mg"),variable:SS((()=>SI(r).variable(a)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;SS((()=>{const t=bI(wI(o,this.decay),wI(kI(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=bI(wI(e,this.decay),wI(s,1-this.decay)),l=vI(wI(s,this.learningRate),xI(LI(t,bI(kI(a),this.epsilon)))),c=bI(wI(i,this.momentum),l);o.assign(t),e.assign(a),i.assign(c);const u=LI(r,c);r.assign(u)}else{const t=bI(wI(o,this.decay),wI(kI(s),1-this.decay)),e=bI(wI(i,this.momentum),vI(wI(s,this.learningRate),xI(bI(t,this.epsilon))));o.assign(t),i.assign(e);const n=LI(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&IS(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&IS(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&IS(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const qI=[_I,OI,MI,jI,HI,KI,GI];function XI(t){return new Promise((t=>setTimeout(t))).then(t)}class JI{constructor(t){if(!Ay().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(JI.URL_SCHEME)&&(t=t.slice(JI.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=wS.join(t.weightData),n=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const e=LS(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(e)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await XI((()=>a.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=n,await XI((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:PS(t)}}}}JI.URL_SCHEME="downloads://";function YI(t,e,n,r){!function(t){Jb(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Jb(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(t))),Jb(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(e))),Jb(e>=t,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(t," and endFraction ")+"".concat(e)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++a/t.length*(r-n);return e(o),s})),s))))}async function ZI(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ay().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),a=(null==e.onProgress?await Promise.all(r):await YI(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(a):await YI(a,e.onProgress,.5,1)}WS.registerSaveRouter((t=>Ay().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(JI.URL_SCHEME)?function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new JI(t)}(t.slice(JI.URL_SCHEME.length)):null));class QI{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Jb("function"===typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Ay().platform.fetch,Jb(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&Jb(2===t.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(t.length,")."))),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=LS(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);if(e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData){const n=wS.join(t.weightData);e.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:PS(t),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(t.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(v1){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return MS(await this.loadModelJSON(),(t=>this.loadWeights(t)))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),n=BS(t.weightsManifest);return Object.assign(Object.assign({},t),{weightSpecs:n,getWeightStream:()=>function(t,e){var n;const r=null==e.fetchFunc?Ay().platform.fetch:e.fetchFunc;let a,s=0;return null===(n=e.onProgress)||void 0===n||n.call(e,0),new ReadableStream({pull:async n=>{for(var o;s<t.length;){if(!a){const n=(await r(t[s],e.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:i,value:l}=await a.read();if(!i)return void n.enqueue(l);s++,a=void 0,null===(o=e.onProgress)||void 0===o||o.call(e,s/t.length)}n.close()}})}(e,this.loadOptions)})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),a=n>e?t.substring(n):"";return[r+"/",a]}(e),a=this.weightPathPrefix||n,s=[],o=[];for(const i of t)for(const t of i.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):s.push(a+t+r);return this.weightUrlConverter&&s.push(...await Promise.all(o)),s}async loadWeights(t){const e=await this.getWeightUrls(t);return[BS(t),await ZI(e,this.loadOptions)]}}function $I(t){return null!=t.match(QI.URL_SCHEME_REGEX)}QI.URL_SCHEME_REGEX=/^https?:\/\//;const tN=(t,e)=>{if("undefined"===typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>$I(t))):$I(t),n)return eN(t,e)}return null};function eN(t,e){return new QI(t,e)}WS.registerSaveRouter(tN),WS.registerLoadRouter(tN);const nN=-2,rN=-1;function aN(t,e,n){const r=t.shape.length;Jb(r===e.length,(()=>"Error in slice".concat(r,"D: Length of begin ").concat(e," must ")+"match the rank of the array (".concat(r,")."))),Jb(r===n.length,(()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,").")));for(let a=0;a<r;++a)Jb(e[a]+n[a]<=t.shape[a],(()=>"Error in slice".concat(r,"D: begin[").concat(a,"] + size[").concat(a,"] ")+"(".concat(e[a]+n[a],") would overflow input.shape[").concat(a,"] (").concat(t.shape[a],")")))}function sN(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function oN(t,e,n){const r=[];for(let a=0;a<t.length;a++)r[a]=Math.ceil((e[a]-t[a])/n[a]);return r}function iN(t,e,n,r){const a=[...t];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[e]=1:(a.splice(e,0,1),a.pop());return a}function lN(t,e,n){return n<=t?n:n-(e-1)}function cN(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function uN(t,e,n,r,a,s,o,i,l){const c=t.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;u=hN(o,l,c,r,t),h=dN(i,l,c,a,t),d=iN(s,l,c,t)}else for(let p=0;p<c;p++)u[p]=fN(o,r,s,t,p,l),h[p]=gN(i,a,s,t,p,l),d[p]=pN(s,p,l);return{begin:u,end:h,strides:d}}function hN(t,e,n,r,a){const s=[...a],o=cN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const a=lN(e,n,i);let o=r[a];t&1<<a&&(o=0),s[i]=o}return s}function dN(t,e,n,r,a){const s=[...a],o=cN(n,e);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const a=lN(e,n,i);let o=r[a];t&1<<a&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const t=a[i];s[i]<0&&(s[i]+=t),s[i]=Kb(0,s[i],a[i])}return s}function pN(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function fN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=Kb(0,o,l-1),o}function gN(t,e,n,r,a,s){let o=e[a];const i=n[a]||1;(t&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=i>0?Kb(0,o,l):Kb(-1,o,l-1),o}function mN(t,e,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(e[a]>0||n[a]!==t[a])return!1;return!0}function bN(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function yN(t,e,n){let r;const a=t.shape.length;let s;return r="number"===typeof e?[e,...new Array(a-1).fill(0)]:e.length<a?e.concat(new Array(a-e.length).fill(0)):e.slice(),r.forEach((t=>{Jb(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(Jb(-1===e,(()=>"Negative size values should be exactly -1 but got "+"".concat(e," for the slice() size at index ").concat(n,"."))),t.shape[n]-r[n]))),[r,s]}function vN(t,e,n,r,a,s,o,i,l){let c;if(null==r?(c=new Array(e.length),c.fill(1)):c=r,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let y=0;y<h.dims;y++)u&&0!==(1<<y&i)&&h.numAddAxisAfterEllipsis++,1<<y&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const a=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<a;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(nN),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(e.dims," dims, ").concat(e.begin.length,"."));null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(rN),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let y=0;y<t.length;++y){if(0===d.strides[y])throw Error("strides[".concat(y,"] must be non-zero"));const e=!!(d.shrinkAxisMask&1<<y),n=t[y];if(-1===n){m.push(e?1:-1);continue}const r=[d.beginMask&1<<y,d.endMask&1<<y],a=[d.strides[y]>0?0:-1,d.strides[y]>0?n:n-1];if(e&&d.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[y];const s=!!(d.beginMask&1<<y&&d.endMask&1<<y);if(d.beginValid&&d.endValid){if(e){const t=d.begin[y]<0?n+d.begin[y]:d.begin[y];if(d.begin[y]=t,d.end[y]=d.begin[y]+1,t<0||t>=n)throw Error("slice index ".concat(d.begin[y]," of dimension ").concat(y," out of bounds."))}else d.begin[y]=wN(d.begin[y],0,d.strides[y],n,r,a),d.end[y]=wN(d.end[y],1,d.strides[y],n,r,a);const t=1===d.strides[y]&&0===d.begin[y]&&d.end[y]===n;p=p&&t,f=f&&(0===y&&1===d.strides[y]||t)}else p=p&&1===d.strides[y]&&s,f=f&&(0===y&&1===d.strides[y]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[y]-d.begin[y],i=!0):e?(o=1,i=!0):s&&n>=0&&(o=d.strides[y]<0?-n:n,i=!0),i){let t;t=0===o||o<0!==d.strides[y]<0?0:Math.trunc(o/d.strides[y])+(o%d.strides[y]!==0?1:0),m.push(t)}else m.push(-1)}for(let y=0;y<d.finalShapeGatherIndices.length;++y){const t=d.finalShapeGatherIndices[y];t>=0?b.push(m[t]):t===nN&&b.push(1)}return{finalShapeSparse:b.filter(((t,e)=>d.finalShapeGatherIndices[e]!==nN)),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function wN(t,e,n,r,a,s){if(a[e])return n>0?s[e]:s[e+1&1];{const e=t<0?r+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}const xN=gS({all_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","all","bool")},a={axis:e,keepDims:n};return aS.runKernel(By,r,a)}});const kN=gS({any_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","any","bool")},a={axis:e,keepDims:n};return aS.runKernel(Wy,r,a)}});const SN=gS({argMax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","argMax")},r={axis:e};return aS.runKernel(Uy,n,r)}});function IN(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return EN(t,[...e,t[3]],n,s,r,null,null,MN(a))}function NN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,l]=RN(e);let c;if("channelsLast"===o)c=[i,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));c=[i,l,t[1],t[1]]}return EN(t,c,n,r,a,s,!1,o)}function CN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,l,c]=FN(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,l,c,t[1],t[1]]}return TN(t,u,n,r,a,!1,h,s)}function EN(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,c,u,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[l,h,c,u]=t}const[d,p,,f]=e,[g,m]=RN(n),[b,y]=RN(r),v=_N(d,b),w=_N(p,y),{padInfo:x,outHeight:k,outWidth:S}=function(t,e,n,r,a,s,o,i,l){let c,u,h;if("number"===typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,a){null==r&&(r=AN(t,e,n));const s=t[0],o=t[1],i=DN((s-e+2*r)/n+1,a),l=DN((o-e+2*r)/n+1,a);return[i,l]}([e,n],s,r,t,i);u=a[0],h=a[1]}else if("same"===t){u=Math.ceil(e/r),h=Math.ceil(n/a);const t=Math.max(0,(u-1)*r+s-e),i=Math.max(0,(h-1)*a+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);c={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((n-o+1)/a);else{if("object"!==typeof t)throw Error("Unknown padding parameter: ".concat(t));{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=DN((e-s+d+p)/r+1,i),h=DN((n-o+f+g)/a+1,i)}}return{padInfo:c,outHeight:u,outWidth:h}}(a,c,u,g,m,v,w,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[l,I,k,S]:"channelsLast"===i&&(N=[l,k,S,I]),{batchSize:l,dataFormat:i,inHeight:c,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:t,outShape:N,filterShape:e}}function TN(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[l,d,c,u,h]=t}const[p,f,g,,m]=e,[b,y,v]=FN(n),[w,x,k]=FN(r),S=_N(p,w),I=_N(f,x),N=_N(g,k),{padInfo:C,outDepth:E,outHeight:T,outWidth:A}=function(t,e,n,r,a,s,o,i,l,c,u){let h,d,p,f;"valid"===t&&(t=0);if("number"===typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const g=function(t,e,n,r,a,s){null==a&&(a=AN(t,e[0],r[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)t[i]+2*a>=e[i]&&(o[i]=DN((t[i]-e[i]+2*a)/r[i]+1,s));return o}([e,n,r,1],[i,l,c],1,[a,s,o],t,u);d=g[0],p=g[1],f=g[2]}else{if("same"!==t)throw Error("Unknown padding parameter: ".concat(t));{d=Math.ceil(e/a),p=Math.ceil(n/s),f=Math.ceil(r/o);const t=(d-1)*a+i-e,u=(p-1)*s+l-n,g=(f-1)*o+c-r,m=Math.floor(t/2),b=t-m,y=Math.floor(u/2),v=u-y,w=Math.floor(g/2);h={top:y,bottom:v,left:w,right:g-w,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(a,c,u,h,b,y,v,S,I,N,i),R=s?m*d:m;let F;return"channelsFirst"===o?F=[l,R,E,T,A]:"channelsLast"===o&&(F=[l,E,T,A,R]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:E,outHeight:T,outWidth:A,outChannels:R,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:x,dilationWidth:k,inShape:t,outShape:F,filterShape:e}}function AN(t,e,n){const r=_N(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((t[0]*(n-1)-n+r)/2)}function RN(t){return"number"===typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function FN(t){return"number"===typeof t?[t,t,t]:t}function _N(t,e){return e<=1?t:t+(t-1)*(e-1)}function DN(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode ".concat(e))}}function ON(t){const[e,n,r]=RN(t);return 1===e&&1===n&&1===r}function zN(t,e){return ON(t)||ON(e)}function LN(t){return RN(t).every((t=>t>0))}function MN(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(t))}function PN(t,e,n){if(null!=n){if("string"===typeof e)throw Error("Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,"."));if("number"===typeof e)Jb(ty(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")));else{if("object"!==typeof e)throw Error("Error in ".concat(t,": Unknown padding parameter: ").concat(e));e.forEach((e=>{e.forEach((e=>{Jb(ty(e),(()=>"Error in ".concat(t,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(e,".")))}))}))}}}const BN=gS({reshape_:function(t,e){const n={x:pS(t,"x","reshape","string_or_numeric")},r={shape:e};return aS.runKernel(Hw,n,r)}});const WN=gS({avgPool_:function(t,e,n,r,a){const s=pS(t,"x","avgPool","float32");Jb(zN(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=BN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),PN("avgPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a};let u=aS.runKernel(Xy,l,c);return u=gI(u,s.dtype),i?BN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const UN=gS({avgPool3d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=pS(t,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=BN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Jb("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Jb("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),PN("avgPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let h=aS.runKernel(Yy,c,u);return h=gI(h,i.dtype),l?BN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const VN=gS({batchNorm_:function(t,e,n,r,a,s){null==s&&(s=.001);const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?BN(t,[1,1,1,t.size]):2===t.rank?BN(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?BN(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),scale:c,offset:u,mean:i,variance:l},d={varianceEpsilon:s},p=aS.runKernel(Gv,h,d);return BN(p,o.shape)}});const jN=gS({batchNorm2d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),Jb(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),VN(o,i,l,u,c,s)}});const GN=gS({batchNorm3d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),Jb(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),VN(o,i,l,u,c,s)}});const HN=gS({batchNorm4d_:function(t,e,n,r,a,s){const o=pS(t,"x","batchNorm"),i=pS(e,"mean","batchNorm"),l=pS(n,"variance","batchNorm");let c,u;return null!=a&&(c=pS(a,"scale","batchNorm")),null!=r&&(u=pS(r,"offset","batchNorm")),Jb(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),Jb(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Jb(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=c&&Jb(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=u&&Jb(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),VN(o,i,l,u,c,s)}});const KN=gS({broadcastTo_:function(t,e){let n=pS(t,"broadcastTo","x");const r=n.shape;if(ky(e),e.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(e.length," < input.rank=").concat(n.rank,"."));if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=BN(n,t)}const a=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(a[l]===e[l])s[l]=1;else if(1!==n.shape[l])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(e,"]."));if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return mI(n);const o={x:n},i={reps:s};return aS.runKernel(Fx,o,i)}});const qN=gS({clipByValue_:function(t,e,n){const r=pS(t,"x","clipByValue");if(Jb(e<=n,(()=>"Error in clip: min (".concat(e,") must be ")+"less than or equal to max (".concat(n,")."))),e===n)return DI(r.shape,e,r.dtype);const a={x:r},s={clipValueMin:e,clipValueMax:n};return aS.runKernel(sv,a,s)}});const XN=gS({concat_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Jb(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=fS(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(t.dtype,". "))})),1===n.length)return mI(n[0]);const r=n,a={axis:e};return aS.runKernel(lv,r,a)}});const JN=gS({concat1d_:function(t){return XN(t,0)}});const YN=gS({concat2d_:function(t,e){return XN(t,e)}});const ZN=gS({concat3d_:function(t,e){return XN(t,e)}});const QN=gS({concat4d_:function(t,e){return XN(t,e)}});const $N=gS({conv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","conv2d","float32"),l=pS(e,"filter","conv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=BN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),Jb(4===l.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(l.rank,"."))),PN("conv2d",r,o);const h="NHWC"===a?c.shape[3]:c.shape[1];Jb(h===l.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(l.shape[2],"."))),Jb(zN(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Jb(LN(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Jb(LN(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=aS.runKernel(cv,d,p);return u?BN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const tC=gS({conv1d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","conv1d"),l=pS(e,"filter","conv1d");let c=i,u=!1;2===i.rank&&(u=!0,c=BN(i,[1,i.shape[0],i.shape[1]])),Jb(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),Jb(3===l.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(l.rank,"."))),PN("conv1d",r,o),Jb(c.shape[2]===l.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(l.shape[1],"."))),Jb(zN(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),Jb(LN(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Jb(LN(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Jb("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=BN(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=BN(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=$N(d,h,[1,n],r,"NHWC",[1,s],o);return BN(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const eC=gS({conv2DBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;Jb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let i=t,l=e,c=!1;3===e.rank&&(c=!0,l=BN(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),Jb(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Jb(4===l.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(l.rank))),Jb(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?l.shape[3]:l.shape[1];Jb(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Jb(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),PN("conv2dDerInput",a,o);const d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=aS.runKernel(hv,d,p);return c?BN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const nC=gS({conv2dTranspose_:function(t,e,n,r,a,s){const o=pS(t,"x","conv2dTranspose"),i=pS(e,"filter","conv2dTranspose");return eC(n,o,i,r,a,"NHWC",s)}});const rC=gS({conv3d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=pS(t,"x","conv3d"),i=pS(e,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=BN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===l.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(l.rank,"."))),Jb(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Jb(l.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(l.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Jb(zN(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Jb("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported."))),Jb(LN(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Jb(LN(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:l,filter:i},h={strides:n,pad:r,dataFormat:a,dilations:s},d=aS.runKernel(dv,u,h);return c?BN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const aC=gS({conv3DBackpropInput_:function(t,e,n,r,a){Jb(t.length===e.rank,(()=>"Length of inShape "+"(".concat(t.length,") and rank of dy (").concat(e.rank,") must match")));let s=t,o=e,i=!1;4===e.rank&&(i=!0,o=BN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];Jb(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),Jb(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),Jb(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Jb(l===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Jb(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:a,strides:r,inputShape:s},d=aS.runKernel(fv,u,h);return i?BN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const sC=gS({conv3dTranspose_:function(t,e,n,r,a){const s=pS(t,"x","conv3dTranspose"),o=pS(e,"filter","conv3dTranspose");return aC(n,s,o,r,a)}});const oC=gS({denseBincount_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"x","denseBincount"),s=pS(e,"weights","denseBincount");Jb("int32"===a.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Jb(a.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(a.rank,"."))),Jb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Jb(s.size===a.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(a.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:a,weights:s},i={size:n,binaryOutput:r};return aS.runKernel(wv,o,i)}});const iC=gS({depthwiseConv2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=pS(t,"x","depthwiseConv2d","float32"),l=pS(e,"filter","depthwiseConv2d","float32");let c=i,u=!1;3===i.rank&&(u=!0,c=BN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),Jb(4===l.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(l.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];Jb(h===l.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(l.shape[2],"."))),PN("depthwiseConv2d",r,o);const d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=aS.runKernel(kv,d,p);return u?BN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const lC=gS({elu_:function(t){const e={x:pS(t,"x","elu","float32")};return aS.runKernel(_v,e)}});const cC=gS({equal_:function(t,e){let n=pS(t,"a","equal","string_or_numeric"),r=pS(e,"b","equal","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(zv,a)}});const uC=gS({exp_:function(t){const e={x:pS(t,"x","exp")};return aS.runKernel(Lv,e)}});const hC=gS({expandDims_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","expandDims","string_or_numeric");Jb(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:e};return aS.runKernel(Mv,r,a)}});const dC=gS({tile_:function(t,e){const n=pS(t,"x","tile","string_or_numeric");Jb(n.rank===e.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(e,".")));const r={x:n},a={reps:e};return aS.runKernel(Fx,r,a)}});const pC=gS({eye_:function(t,e,n){null==e&&(e=t);const r=fI([t,e],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const s=BN(r.toTensor(),[t,e]);if(null==n)return s;if(1===n.length)return dC(hC(s,0),[n[0],1,1]);if(2===n.length)return dC(hC(hC(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return dC(hC(hC(hC(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const fC=gS({floor_:function(t){const e={x:pS(t,"x","floor","float32")};return aS.runKernel(Vv,e)}});const gC=gS({gather_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:pS(t,"x","gather"),indices:pS(e,"indices","gather","int32")},s={axis:n,batchDims:r};return aS.runKernel(Hv,a,s)}});const mC=gS({greater_:function(t,e){let n=pS(t,"a","greater","string_or_numeric"),r=pS(e,"b","greater","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(qv,a)}});const bC=gS({greaterEqual_:function(t,e){let n=pS(t,"a","greaterEqual","string_or_numeric"),r=pS(e,"b","greaterEqual","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(Xv,a)}});const yC=gS({leakyRelu_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:pS(t,"x","leakyRelu")},r={alpha:e};return aS.runKernel(ew,n,r)}});const vC=gS({log_:function(t){const e={x:pS(t,"x","log","float32")};return aS.runKernel(sw,e)}});const wC=gS({log1p_:function(t){const e={x:pS(t,"x","log1p")};return aS.runKernel(ow,e)}});const xC=gS({max_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","max")},a={reductionIndices:e,keepDims:n};return aS.runKernel(dw,r,a)}});const kC=gS({sum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=pS(t,"x","sum");"bool"===r.dtype&&(r=gI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return aS.runKernel(dx,a,s)}});const SC=gS({logSoftmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=pS(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(e));const r=II(((t,n)=>{const r=xC(t,e,!0),a=LI(t,r),s=LI(gI(a,"float32"),vC(kC(uC(a),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,a=uC(r);return LI(t,wI(kC(t,e,!0),a))}}}));return r(n)}});function IC(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function NC(t,e,n){const r=t.length+e.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(t[s++]):a.push(e[o++]);return a}function CC(t,e){const n=[],r=t.length;for(let a=0;a<r;a++)-1===e.indexOf(a)&&n.push(t[a]);return[n,e.map((e=>t[e]))]}function EC(t,e){return NC(t,e.map((t=>1)),e)}function TC(t,e,n){Jb(IC(e,n),(()=>"".concat(t," supports only inner-most axes for now. ")+"Got axes ".concat(e," and rank-").concat(n," input.")))}function AC(t,e){if(IC(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function RC(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function FC(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const _C=gS({logSumExp_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=pS(t,"x","logSumExp"),a=sy(e,r.shape),s=xC(r,a,!0),o=LI(r,s),i=uC(o),l=kC(i,a),c=vC(l),u=bI(BN(s,c.shape),c);if(n){const t=EC(u.shape,a);return BN(u,t)}return u}});const DC=gS({logicalAnd_:function(t,e){const n=pS(t,"a","logicalAnd","bool"),r=pS(e,"b","logicalAnd","bool");UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(iw,a)}});const OC=gS({matMul_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=pS(t,"a","matMul"),s=pS(e,"b","matMul");[a,s]=Yk(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return aS.runKernel(Qy,o,i)}});const zC=gS({maxPool_:function(t,e,n,r,a){const s=pS(t,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=BN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),Jb(zN(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),PN("maxPool",r,a);const l={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:a},u=aS.runKernel(fw,l,c);return i?BN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const LC=gS({maxPool3d_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=pS(t,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=BN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Jb(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Jb("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),PN("maxPool3d",r,a);const c={x:i},u={filterSize:e,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=aS.runKernel(mw,c,u);return l?BN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const MC=gS({mean_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","mean")},a={axis:e,keepDims:n};return aS.runKernel(vw,r,a)}});const PC=gS({min_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:pS(t,"x","min")},a={axis:e,keepDims:n};return aS.runKernel(ww,r,a)}});const BC=gS({minimum_:function(t,e){let n=pS(t,"a","minimum"),r=pS(e,"b","minimum");[n,r]=Yk(n,r),"bool"===n.dtype&&(n=gI(n,"int32"),r=gI(r,"int32")),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(xw,a)}});const WC=gS({moments_:function(t){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=sy(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(t=pS(t,"x","moments")).shape),r=MC(t,n,e);let a=r.shape;e||(a=EC(r.shape,n));const s=kI(LI(gI(t,"float32"),BN(r,a)));return{mean:r,variance:MC(s,n,e)}}});const UC=gS({neg_:function(t){const e={x:pS(t,"x","neg")};return aS.runKernel(Cw,e)}});const VC=gS({notEqual_:function(t,e){let n=pS(t,"a","notEqual","string_or_numeric"),r=pS(e,"b","notEqual","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(Ew,a)}});const jC=gS({oneHot_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(e));const s={indices:pS(t,"indices","oneHot","int32")},o={dtype:a,depth:e,onValue:n,offValue:r};return aS.runKernel(_w,s,o)}});function GC(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(ky(t),"complex64"===e){const e=GC(t,"float32"),n=GC(t,"float32");return mS(e,n)}const n=wy(Qb(t),e);return aS.makeTensor(n,t,e)}function HC(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(ky(t),"complex64"===e){const e=HC(t,"float32"),n=GC(t,"float32");return mS(e,n)}const n=vy(Qb(t),e);return aS.makeTensor(n,t,e)}const KC=gS({onesLike_:function(t){const e={x:pS(t,"x","onesLike")};return aS.runKernel(Fw,e)}});const qC=gS({pad_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=pS(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:e,constantValue:n},s={x:r};return aS.runKernel(Ow,s,a)}});const XC=gS({prelu_:function(t,e){const n={x:pS(t,"x","prelu"),alpha:pS(e,"alpha","prelu")};return aS.runKernel(Lw,n)}});class JC{constructor(t,e,n,r,a){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Vo.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class YC{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(t," - ").concat(e," <= 1 and dtype is not float"));this.random=Vo.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ZC=gS({randomNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(ky(t),null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const s=new JC(e,n,r,!1,a),o=fI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const QC=gS({randomUniform_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;ky(t);const s=fI(t,r),o=new YC(e,n,null,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});function $C(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:r};return aS.runKernel(Uw,{},a)}const tE=gS({relu_:function(t){const e={x:pS(t,"x","relu")};return aS.runKernel(Gw,e)}});const eE=gS({reverse_:function(t,e){const n={x:pS(t,"x","reverse")},r={dims:e};return aS.runKernel(Zw,n,r)}});const nE=gS({selu_:function(t){const e={x:pS(t,"x","selu")};return aS.runKernel(ax,e)}});const rE=gS({separableConv2d_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=pS(t,"x","separableConv2d"),l=pS(e,"depthwiseFilter","separableConv2d"),c=pS(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=BN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Jb(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Jb(4===l.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Jb(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(l.rank,"."))),Jb(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),Jb(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=l.shape[2],p=l.shape[3];Jb(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=iC(u,l,r,a,o,s),g=$N(f,c,1,"valid",o);return h?BN(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const aE=gS({sigmoid_:function(t){const e={x:pS(t,"x","sigmoid","float32")};return aS.runKernel(cx,e)}});const sE=gS({slice_:function(t,e,n){const r=pS(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:e,size:n};return aS.runKernel(sx,a,s)}});const oE=gS({slice1d_:function(t,e,n){const r=pS(t,"x","slice1d");return Jb(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),sE(r,[e],[n])}});const iE=gS({slice2d_:function(t,e,n){const r=pS(t,"x","slice2d");return Jb(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),sE(r,e,n)}});const lE=gS({slice3d_:function(t,e,n){const r=pS(t,"x","slice3d");return Jb(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),sE(r,e,n)}});const cE=gS({slice4d_:function(t,e,n){const r=pS(t,"x","slice4d");return Jb(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),sE(r,e,n)}});const uE=gS({softmax_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=pS(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(e));const r={logits:n},a={dim:e};return aS.runKernel(gx,r,a)}});const hE=gS({softplus_:function(t){const e={x:pS(t,"x","softplus")};return aS.runKernel(ux,e)}});const dE=gS({split_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:pS(t,"x","split")},a={numOrSizeSplits:e,axis:n};return aS.runKernel(fx,r,a)}});const pE=gS({squeeze_:function(t,e){const n=pS(t,"x","squeeze","string_or_numeric");return BN(n,oy(n.shape,e).newShape)}});const fE=gS({stack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=fS(t,"tensors","stack","string_or_numeric");Jb(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Jb(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:e};return aS.runKernel(Dw,r,a)}});const gE=gS({tanh_:function(t){const e={x:pS(t,"x","tanh","float32")};return aS.runKernel(Rx,e)}});function mE(t,e){Zb(t);const n=uS(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bS(t,null,n,e)}function bE(t,e,n){if(Zb(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=uS(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bS(t,e,r,n)}const yE=gS({truncatedNormal_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(ky(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new JC(e,n,r,!0,a),o=fI(t,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const vE=gS({unstack_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","unstack","string_or_numeric");Jb(e>=-n.shape.length&&e<n.shape.length,(()=>"Axis = ".concat(e," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:e};return aS.runKernel(Lx,r,a)}});const wE=gS({where_:function(t,e,n){const r=pS(e,"a","where"),a=pS(n,"b","where"),s=pS(t,"condition","where","bool"),o=UI(UI(s.shape,r.shape),a.shape),i={condition:KN(s,o),t:KN(r,o),e:KN(a,o)};return aS.runKernel(rx,i)}});const xE=gS({imag_:function(t){const e={input:pS(t,"input","imag")};return aS.runKernel(Zv,e)}});const kE=gS({real_:function(t){const e={input:pS(t,"input","real")};return aS.runKernel(Vw,e)}});const SE=gS({transpose_:function(t,e,n){const r=pS(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),Jb(r.rank===e.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(e,"."))),e.forEach((t=>{Jb(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(e)))})),r.rank<=1)return r.clone();const a={x:r},s={perm:e};return"complex64"===r.dtype?SS((()=>{let t=kE(r),e=xE(r);return t=aS.runKernel(Ox,{x:t},s),e=aS.runKernel(Ox,{x:e},s),n&&(e=UC(e)),mS(t,e)})):aS.runKernel(Ox,a,s)}});const IE=gS({dropout_:function(t,e,n,r){const a=pS(t,"x","dropout");if(Jb("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),Jb(e>=0&&e<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(e,"."))),0===e)return t instanceof Mk?a.clone():a;const s=function(t,e){if(null==e)return t.shape.slice();if($b(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(a,n),o=1-e,i=vI(fC(bI(QC(s,0,1,"float32",r),o)),o);return wI(a,i)}});const NE=gS({fft_:function(t){Jb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return aS.runKernel(Bv,e)}});const CE=gS({rfft_:function(t,e){Jb("float32"===t.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(t.dtype)));let n=t.shape[t.shape.length-1];const r=t.size/n;let a;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,a=sE(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,a=XN([t,GC(r)],t.shape.length-1),n=e}else a=t;const s=SI(a),o=BN(mS(a,s),[r,n]),i=NE(o),l=Math.floor(n/2)+1,c=kE(i),u=xE(i),h=dE(c,[l,n-l],c.shape.length-1),d=dE(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,BN(mS(h[0],d[0]),p)}});const EE=gS({ifft_:function(t){Jb("complex64"===t.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(t.dtype,".")));const e={input:t};return aS.runKernel(Yv,e)}});const TE=gS({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const a=BN(t,[n,e]);r=EE(a)}else{const a=[n,2*(e-1)],s=BN(kE(t),[n,e]),o=BN(xE(t),[n,e]),i=eE(sE(s,[0,1],[n,e-2]),1),l=wI(eE(sE(o,[0,1],[n,e-2]),1),NI(-1)),c=XN([s,i],1),u=XN([o,l],1),h=BN(mS(c,u),[a[0],a[1]]);r=EE(h)}if(r=kE(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=BN(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const AE=gS({conv2DBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=BN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=BN(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Jb(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Jb(4===l.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(l.shape,"."))),Jb(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?l.shape[3]:l.shape[1];Jb(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),Jb(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),PN("conv2dDerFilter",a,o);const h={x:i,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return aS.runKernel(uv,h,d)}});const RE=gS({relu6_:function(t){const e={x:pS(t,"x","relu6")};return aS.runKernel(Yw,e)}});const FE=gS({step_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","step")},r={alpha:e};return aS.runKernel(Bx,n,r)}});function _E(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return wI(t,FE(e));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function DE(t,e){let n=e;const r=WI(t.shape,e.shape);return r.length>0&&(n=kC(n,r)),BN(n,t.shape)}function OE(t,e,n,r){if("linear"===e)return t;if("relu"===e)return tE(t);if("elu"===e)return lC(t);if("relu6"===e)return RE(t);if("prelu"===e)return XC(t,n);if("leakyrelu"===e)return yC(t,r);if("sigmoid"===e)return aE(t);throw new Error("Unknown fused activation ".concat(e,"."))}const zE=(t,e)=>!(t>0)||"linear"===e;const LE=gS({fusedConv2d_:function(t){let{x:e,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:l,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:h}=t;if(c=c||"linear",!1===zE(aS.state.gradientDepth,c)){Jb("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let t=$N(e,n,r,a,s,o,i);return null!=l&&(t=bI(t,l)),OE(t,c,u,h)}const d=pS(e,"x","conv2d","float32"),p=pS(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=BN(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Jb(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Jb(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),PN("fused conv2d",a,i);const m="NHWC"===s?f.shape[3]:f.shape[1];Jb(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Jb(zN(r,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(o,"'")));const b=EN(f.shape,p.shape,r,o,a,i);let y,v;if(null!=l&&(y=pS(l,"bias","fused conv2d"),[y]=Yk(y,d),"NHWC"===s?UI(b.outShape,y.shape):(Jb(y.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(y.shape.length,"."))),Jb(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(y.shape,") is not ")+"compatible with the number of output channels "+"(".concat(b.outChannels,")"))))),null!=u){const t=u.shape;if(Jb(t.length<=1||3===t.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(t.length,"."))),1===t.length)Jb(1===t[0]||t[0]===b.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(t,") is not compatible with the number of output ")+"channels (".concat(b.outChannels,").")));else if(3===t.length)try{UI(t,b.outShape)}catch(v1){const n="Error in fused conv2d: PReLU activation weights (".concat(t,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(b.outShape,").");throw Error(n)}v=pS(u,"prelu weights","fused conv2d")}const w=(t,e)=>{Jb("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,l,u]=e,h=_E(t,l,c);Jb(ON(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[eC(i.shape,h,n,r,a),AE(i,h,n.shape,r,a)];if(null!=u){const t=DE(u,h);d.push(t)}return d},x={x:f,filter:p,bias:y,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:h};if(null==l){const t=II(((t,e,n)=>{let r=aS.runKernel(jx,x,k);return n([e,t,r]),g&&(r=BN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return t(f,p)}{const t=II(((t,e,n,r)=>{let a=aS.runKernel(jx,x,k);return r([e,t,a,n]),g&&(a=BN(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}));return t(f,p,y)}}});const ME=gS({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t;3===t.rank&&(i=BN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=BN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:l},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return aS.runKernel(Sv,c,u)}});const PE=gS({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e,l=!1;3===e.rank&&(l=!0,i=BN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:n},u={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:t},h=aS.runKernel(Iv,c,u);return l?BN(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const BE=gS({fusedMatMul_:function(t){let{a:e,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:l=.2}=t;if(!1===zE(aS.state.gradientDepth,o)){let t=OC(e,n,r,a);return null!=s&&(t=bI(t,s)),OE(t,o,i,l)}let c=pS(e,"a","fused matMul"),u=pS(n,"b","fused matMul");[c,u]=Yk(c,u);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=c.shape.slice(0,-2),m=u.shape.slice(0,-2),b=Qb(g),y=Qb(m);Jb(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=UI(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),w=BN(c,r?[b,h,p]:[b,p,h]),x=BN(u,a?[y,f,d]:[y,d,f]);let k,S;null!=s&&(k=pS(s,"bias","fused matMul"),[k]=Yk(k,c),UI(v,k.shape)),null!=i&&(S=pS(i,"prelu weights","fused matMul"));const I=(t,e)=>{const[n,i,l,c]=e,u=_E(BN(t,l.shape),l,o);let h,d;if(r||a?!r&&a?(h=OC(u,i,!1,!1),d=OC(u,n,!0,!1)):r&&!a?(h=OC(i,u,!1,!0),d=OC(n,u,!1,!1)):(h=OC(i,u,!0,!0),d=OC(u,n,!0,!0)):(h=OC(u,i,!1,!0),d=OC(n,u,!0,!1)),null!=s){return[h,d,DE(c,u)]}return[h,d]},N={a:w,b:x,bias:k,preluActivationWeights:S},C={transposeA:r,transposeB:a,activation:o,leakyreluAlpha:l};if(null==s){const t=II(((t,e,n)=>{const r=aS.runKernel(Vx,N,C);return n([t,e,r]),{value:BN(r,v),gradFunc:I}}));return t(w,x)}{const t=II(((t,e,n,r)=>{const a=aS.runKernel(Vx,N,C);return r([t,e,a,n]),{value:BN(a,v),gradFunc:I}}));return t(w,x,k)}}});const WE=gS({cropAndResize_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"image","cropAndResize"),i=pS(e,"boxes","cropAndResize","float32"),l=pS(n,"boxInd","cropAndResize","int32"),c=i.shape[0];Jb(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Jb(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(i.shape,"."))),Jb(1===l.rank&&l.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(i.shape,"."))),Jb(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),Jb(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),Jb("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:o,boxes:i,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return aS.runKernel(vv,u,h)}});const UE=gS({flipLeftRight_:function(t){const e=pS(t,"image","flipLeftRight","float32");Jb(4===e.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(e.rank,".")));const n={image:e};return aS.runKernel(Uv,n,{})}});const VE=gS({grayscaleToRGB_:function(t){const e=pS(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];Jb(e.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Jb(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(e.rank);return a.fill(1,0,n),a[n]=3,dC(e,a)}});const jE=gS({einsum_:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const a=n.map(((t,e)=>pS(t,"tensors".concat(e),"einsum"))),s={equation:t};return aS.runKernel(Fv,a,s)}});const GE=gS({rgbToGrayscale_:function(t){const e=pS(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];Jb(e.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(e.rank,"."))),Jb(3===r,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(r,".")));const a=e.dtype,s=gI(e,"float32"),o=mE([.2989,.587,.114]);let i;switch(e.rank){case 2:i=jE("ij,j->i",s,o);break;case 3:i=jE("ijk,k->ij",s,o);break;case 4:i=jE("ijkl,l->ijk",s,o);break;case 5:i=jE("ijklm,m->ijkl",s,o);break;case 6:i=jE("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return i=hC(i,-1),gI(i,a)}});const HE=gS({rotateWithOffset_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=pS(t,"image","rotateWithOffset","float32");Jb(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const s={image:a},o={radians:e,fillValue:n,center:r};return aS.runKernel(Ux,s,o)}});function KE(t,e,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),Jb(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),Jb(2===t.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(t.rank,"'"))),Jb(4===t.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(t.shape[1]))),Jb(1===e.rank,(()=>"scores must be a 1D tensor")),Jb(e.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(e.shape[0]))),Jb(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const qE=gS({nonMaxSuppression_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=pS(t,"boxes","nonMaxSuppression","float32"),o=pS(e,"scores","nonMaxSuppression","float32"),i=KE(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return aS.runKernel(Tw,{boxes:s,scores:o},l)}});function XE(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,a=t.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(t,e,n||JE)}(t,e,n),a=r<0?-(r+1):r;t.splice(a,0,e)}function JE(t,e){return t>e?1:t<e?-1:0}function YE(t,e,n,r,a){return $E(t,e,n,r,a,0)}function ZE(t,e,n,r,a,s){return $E(t,e,n,r,a,0,!1,s,!0)}function QE(t,e,n,r,a,s){return $E(t,e,n,r,a,s,!0)}function $E(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let m=0;m<e.length;m++)e[m]>a&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(nT);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<a)break;let i=!1;for(let l=h.length-1;l>=o;--l){const n=tT(t,s,h[l]);if(n>=r){i=!0;break}if(e.score=e.score*eT(r,u,n),e.score<=a)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(s),d.push(e.score)):e.score>a&&XE(c,e,nT))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function tT(t,e,n){const r=t.subarray(4*e,4*e+4),a=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(o,u),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function eT(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function nT(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const rT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=pS(t,"boxes","nonMaxSuppressionAsync"),o=pS(e,"scores","nonMaxSuppressionAsync"),i=KE(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=YE(c,u,n,r,a);return s!==t&&s.dispose(),o!==e&&o.dispose(),mE(h,"int32")};const aT=gS({nonMaxSuppressionWithScore_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"boxes","nonMaxSuppression"),i=pS(e,"scores","nonMaxSuppression"),l=KE(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=aS.runKernel(Rw,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const sT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=pS(t,"boxes","nonMaxSuppressionAsync"),i=pS(e,"scores","nonMaxSuppressionAsync"),l=KE(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=QE(u,h,n,r,a,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:mE(d,"int32"),selectedScores:mE(p)}};const oT=gS({nonMaxSuppressionPadded_:function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=pS(t,"boxes","nonMaxSuppression"),i=pS(e,"scores","nonMaxSuppression"),l=KE(o,i,n,r,a,null),c={boxes:o,scores:i},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=aS.runKernel(Aw,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const iT=async function(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=pS(t,"boxes","nonMaxSuppressionAsync"),i=pS(e,"scores","nonMaxSuppressionAsync"),l=KE(o,i,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=ZE(d,p,c,u,h,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:mE(f,"int32"),validOutputs:NI(g,"int32")}};const lT=gS({resizeBilinear_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"images","resizeBilinear");Jb(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Jb(2===e.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(e,"."))),Jb(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=BN(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=aS.runKernel(Xw,i,l);return o?BN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const cT=gS({resizeNearestNeighbor_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=pS(t,"images","resizeNearestNeighbor");Jb(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Jb(2===e.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(e,"."))),Jb("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Jb(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=BN(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=e,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=aS.runKernel(Kw,i,l);return o?BN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const uT=gS({bincount_:function(t,e,n){const r=pS(t,"x","bincount"),a=pS(e,"weights","bincount");Jb("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Jb(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Jb(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const s={x:r,weights:a},o={size:n};return aS.runKernel(tv,s,o)}});const hT=gS({lessEqual_:function(t,e){let n=pS(t,"a","lessEqual","string_or_numeric"),r=pS(e,"b","lessEqual","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(rw,a)}});const dT=gS({round_:function(t){const e={x:pS(t,"x","round")};return aS.runKernel(Qw,e)}});const pT=gS({threshold_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=pS(t,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,c,u=wI(mE([r]),255);if(Jb(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),Jb(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),Jb("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),Jb("otsu"===e||"binary"===e,(()=>"Method must be binary or otsu, but was ".concat(e))),3===a.shape[2]){[o,i,l]=dE(a,[1,1,1],-1);const t=wI(o,.2989),e=wI(i,.587),n=wI(l,.114);c=bI(bI(t,e),n)}else c=t;if("otsu"===e){u=function(t,e){let n,r,a,s,o,i,l=mE([-1]),c=mE([0]),u=mE([0]);for(let h=0;h<t.size-1;h++){n=sE(t,0,h+1),r=sE(t,h+1),o=vI(kC(n),e),i=vI(kC(r),e);const d=kC(wI(n,$C(0,n.size)));a=vI(d,kC(n));const p=DI(r.shape,n.size),f=bI($C(0,r.size),p),g=wI(r,f);s=vI(kC(g),kC(r));const m=LI(a,s),b=LI(a,s),y=wI(o,i);u=wI(wI(y,m),b);const v=mC(u,c);c=wE(v,u,c),l=wE(v,mE([h]),l)}return l}(uT(gI(dT(c),"int32"),yS([]),256),s)}const h=n?hT(c,u):mC(c,u);return gI(wI(h,255),"int32")}});const fT=gS({transform_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=pS(t,"image","transform","float32"),i=pS(e,"transforms","transform","float32");Jb(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Jb(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Jb(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const l={image:o,transforms:i},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return aS.runKernel(Dx,l,c)}});const gT=gS({less_:function(t,e){let n=pS(t,"a","less","string_or_numeric"),r=pS(e,"b","less","string_or_numeric");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(nw,a)}});const mT=gS({bandPart_:function(t,e,n){const r=pS(t,"a","bandPart");Jb(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[s,o]=r.shape.slice(-2);let i,l;"number"===typeof e?(Jb(e%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(e,"."))),Jb(e<=s,(()=>"bandPart(): numLower (".concat(e,")")+" must not be greater than the number of rows (".concat(s,")."))),i=pS(e<0?s:e,"numLower","bandPart")):(Jb("int32"===e.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=wE(gT(e,0),s,BC(e,s))),"number"===typeof n?(Jb(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Jb(n<=o,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."))),l=pS(n<0?o:n,"numUpper","bandPart")):(Jb("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=wE(gT(n,0),o,BC(n,o)));const c=BN($C(0,s,1,"int32"),[-1,1]),u=$C(0,o,1,"int32"),h=LI(c,u),d=DC(hT(h,i),bC(h,UC(l))),p=GC([s,o],r.dtype);return BN(fE(vE(BN(r,[-1,s,o])).map((t=>wE(d,t,p)))),a)}});function bT(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===t.rank)return PI(t);if(1!==t.rank&&null===n)return bT(BN(t,[-1]),e,n);if(1===t.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===e)return kC(PI(t),n);if(e===1/0)return xC(PI(t),n);if(e===-1/0)return PC(PI(t),n);if("euclidean"===e||2===e)return xI(kC(zI(PI(t),NI(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}if(Array.isArray(n)&&2===n.length){if(1===e)return xC(kC(PI(t),n[0]),n[1]-1);if(e===1/0)return xC(kC(PI(t),n[1]),n[0]);if(e===-1/0)return PC(kC(PI(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return xI(kC(kI(t),n));throw new Error("Error in norm: invalid ord value: ".concat(e))}throw new Error("Error in norm: invalid axis: ".concat(n))}const yT=gS({norm_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=bT(t=pS(t,"x","norm"),e,n);let s=a.shape;if(r){const e=sy(n,t.shape);s=EC(a.shape,e)}return BN(a,s)}});const vT=gS({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Jb(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Jb(t[e].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(t[e].shape[0]," vs. ").concat(n,")")))}else e=!0,t=dE(t,t.shape[0],0).map((t=>pE(t,[0])));Jb(t.length<=t[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(t.length,") exceeds ")+"number of dimensions (".concat(t[0].shape[0],").")));const n=[],r=t;for(let a=0;a<t.length;++a)n.push(aS.tidy((()=>{let t=r[a];if(a>0)for(let e=0;e<a;++e){const r=wI(kC(wI(n[e],t)),n[e]);t=LI(t,r)}return vI(t,yT(t,"euclidean"))})));return e?fE(n,0):n}});function wT(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return aS.tidy((()=>{Jb(2===t.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(t.shape.length,"D Tensor.")));const n=t.shape[0],r=t.shape[1];let a=pC(n),s=mI(t);const o=bE([[1]],[1,1]);let i=mI(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=i,c=a;[i,s,a]=aS.tidy((()=>{const e=sE(s,[t,t],[n-t,1]),l=yT(e),c=sE(s,[t,t],[1,1]),u=wE(mC(c,0),bE([[-1]]),bE([[1]])),h=LI(c,wI(u,l)),d=vI(e,h);i=1===d.shape[0]?mI(o):XN([o,sE(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=UC(vI(OC(u,h),l)),f=sE(s,[t,0],[n-t,r]),g=wI(p,i),m=SE(i);if(0===t)s=LI(f,OC(g,OC(m,f)));else{const e=LI(f,OC(g,OC(m,f)));s=XN([sE(s,[0,0],[t,r]),e],0)}const b=SE(g),y=sE(a,[0,t],[n,a.shape[1]-t]);if(0===t)a=LI(y,OC(OC(y,i),b));else{const e=LI(y,OC(OC(y,i),b));a=XN([sE(a,[0,0],[n,t]),e],1)}return[i,s,a]})),IS([e,l,c])}return!e&&n>r&&(a=sE(a,[0,0],[n,r]),s=sE(s,[0,0],[r,r])),[a,s]}))}const xT=gS({qr_:function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Jb(t.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(t.rank))),2===t.rank)return wT(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=vE(BN(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),a=[],s=[];r.forEach((t=>{const[n,r]=wT(t,e);a.push(n),s.push(r)}));return[BN(fE(a,0),t.shape),BN(fE(s,0),t.shape)]}}});var kT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(kT||(kT={}));const ST=gS({squaredDifference_:function(t,e){let n=pS(t,"a","squaredDifference"),r=pS(e,"b","squaredDifference");[n,r]=Yk(n,r),UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(xx,a,{})}});const IT={flipLeftRight:UE,grayscaleToRGB:VE,resizeNearestNeighbor:cT,resizeBilinear:lT,rgbToGrayscale:GE,rotateWithOffset:HE,cropAndResize:WE,nonMaxSuppression:qE,nonMaxSuppressionAsync:rT,nonMaxSuppressionWithScore:aT,nonMaxSuppressionWithScoreAsync:sT,nonMaxSuppressionPadded:oT,nonMaxSuppressionPaddedAsync:iT,threshold:pT,transform:fT},NT={bandPart:mT,gramSchmidt:vT,qr:xT};const CT=class{static sgd(t){return new GI(t)}static momentum(t,e){return new HI(t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(t){return new KI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new MI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new _I(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new jI(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(t){return new OI(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},ET="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:t=>t();function TT(){return new Promise((t=>ET((()=>t()))))}function AT(t,e){const n=t[0].length;t.forEach(((t,e)=>{Jb(t.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(e,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Jb(e>=0&&e<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const r=t[0];t.forEach(((t,a)=>{for(let s=0;s<n;s++)Jb(s===e||t[s]===r[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(a,"] (").concat(t,") ")+"does not match the shape of the rest (".concat(r,") ")+"along the non-concatenated axis ".concat(a,".")))}))}function RT(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var FT;function _T(t,e,n){let r=new Array;if(null==n&&null==e)return r;if(null==e)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(null==n)return r;if(t+n.length!==r.length)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.rank = ").concat(t+n.length,", but shape.rank = ").concat(r.length));for(let a=1;a<n.length;++a){const s=n[a],o=r[r.length-n.length+a],i=r[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(e," are incompatible: rt input.shape[").concat(a+t,"] = ").concat(s," but shape[").concat(a+t,"] = ").concat(i))}else r[o]=s}return r}function DT(t){const e={FIRST_DIM_SIZE:FT.FIRST_DIM_SIZE,VALUE_ROWIDS:FT.VALUE_ROWIDS,ROW_LENGTHS:FT.ROW_LENGTHS,ROW_SPLITS:FT.ROW_SPLITS,ROW_LIMITS:FT.ROW_LIMITS,ROW_STARTS:FT.ROW_STARTS},n=[];for(const r of t){if(!(r in e))break;n.push(e[r])}return n}function OT(t){return 0===t.length?0:t[0]===FT.FIRST_DIM_SIZE?t.length-1:t.length}function zT(t,e){if(null==t||null==e)return;const n=t.length,r=e.length;if(n>=r)throw new Error("defaultValue.shape=".concat(t," and ragged tensor flatValues.shape=").concat(e,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(r,")"));for(let a=0;a<Math.min(n,r-1);++a){const n=t[a],r=e[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error("defaultValue.shape=".concat(t,", and ragged tensor input flatValues.shape=").concat(e," are incompatible: defaultValue.shape[").concat(a-t.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(a-t.length,"] = ").concat(r))}}!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(FT||(FT={}));const LT=30;function MT(t){return t<=LT?t:gy(t,Math.floor(Math.sqrt(t)))}function PT(t,e,n){return[n*("number"===typeof t?t:t[0]),e*("number"===typeof t?t:t[1])]}function BT(t,e,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let a=0;a<n;++a)r=r.concat([t[a+1]/e[a],e[a]]);r=r.concat(t.slice(n+1))}return r}function WT(t,e){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(e);for(let r=e+1;r<t;++r)r<=2*e?(n.push(r),n.push(r-(e+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<t;++n)n>=2*e+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function UT(t,e,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(t[0]/n):a.push(t[0]*n);for(let s=1;s<t.length;++s)s<=e.length?r?a.push(e[s-1]*t[s]):a.push(t[s]/e[s-1]):a.push(t[s]);return a}function VT(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function jT(t,e,n){const r=t.slice(0,1);for(let a=0;a<n;++a)r.push(t[a+1]-e[a][0]-e[a][1]);return r}function GT(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(r,"."));if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(e.shape[r-1]," vs. ").concat(n));if(0===Qb(t.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(t.shape,"."));const a=e.shape,s=a[a.length-1];let o=1;for(let h=0;h<a.length-1;++h)o*=a[h];const i=t.shape,l=a.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=i[h],l.push(i[h]);const u=[...my(t.shape).map((t=>t/c)),1].slice(0,s);return[l,o,c,u]}function HT(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,a=e.rank>1?e.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(e.shape,", shape: ").concat(t)+", sliceDim: ".concat(r,", and batchDim: ").concat(a,".");if(n.rank<a)throw new Error(s+" update.rank < ".concat(a,". "));if(t.length<r+(n.rank-a))throw new Error(s+" Output shape length < ".concat(r+(n.rank-a)));if(n.rank!==a+t.length-r)throw new Error(s+" update.rank != ".concat(a+t.length-r));for(let o=0;o<a;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(e.shape[o],")."));for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==t[o+r])throw new Error(s+" updates.shape[".concat(o+a,"] (").concat(n.shape[o+a],") != shape[").concat(o+a,"] (").concat(t[o+a],")"))}function KT(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(e.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: ".concat(e.shape));if(0===t.size)throw new Error("Updates specified for empty output. updates shape: ".concat(t.shape))}HT(n,e,t)}function qT(t,e,n){const r=e.shape.length,a=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let l=a;l<s;++l)o*=n[l];const i=a<1?1:a;return{sliceRank:a,numUpdates:Qb(e.shape)/i,sliceSize:o,strides:[...my(n.slice(0,a)),1],outputSize:Qb(n)}}const XT=1.7580993408473768,JT=1.0507009873554805,YT=.3275911,ZT=.254829592,QT=-.284496736,$T=1.421413741,tA=-1.453152027,eA=1.061405429;function nA(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(t.length,", imag: ").concat(e.length,"."));const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function rA(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function aA(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=0;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function sA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let a=2;a<t.length;a+=4)n[Math.floor(a/4)]=t[a],r[Math.floor(a/4)]=t[a+1];return{real:n,imag:r}}function oA(t,e){return{real:t[2*e],imag:t[2*e+1]}}function iA(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function lA(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let a=0;a<Math.ceil(t/2);a++){const s=(e?2:-2)*Math.PI*(a/t);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function cA(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const uA="->",hA=/->/g,dA=",",pA="...";function fA(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(hA,"").length)/uA.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(uA,'").'));const[r,a]=t.split(uA);Jb(-1===r.indexOf(pA),(()=>'The ellipsis notation ("'.concat(pA,'") is not supported yet.')));const s=r.split(dA),o=s.length;if(e!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(e));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<a.length;++h){const t=a[h];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error("Output subscripts contain the label ".concat(t," ")+"not present in the input subscripts.");-1===i.indexOf(t)&&i.push(t)}for(let h=0;h<r.length;++h){const t=r[h];-1===i.indexOf(t)&&t!==dA&&i.push(t)}const l=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");l[h]=[];for(let t=0;t<s[h].length;++t)l[h].push(i.indexOf(s[h][t]))}const c=i.length,u=[];for(let h=a.length;h<c;++h)u.push(h);return{allDims:i,summedDims:u,idDims:l}}function gA(t,e){let n=new Array(t);n.fill(-1);for(let a=0;a<e.length;++a)n[e[a]]=a;const r=[];for(let a=0;a<t;++a)-1===n[a]&&r.push(a);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function mA(t,e,n){const r=new Array(t);for(let a=0;a<n.length;++a){const t=n[a].shape;for(let n=0;n<e[a].length;++n)void 0===r[e[a][n]]?r[e[a][n]]=t[n]:Jb(r[e[a][n]]===t[n],(()=>"Expected dimension ".concat(r[e[a][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(t),", ")+"but got dimension ".concat(t[n])))}}function bA(t,e){const n=t,r=[];let a=0;0===t.length&&n.push(-1),a=t.length+1;for(let o=0;o<a;++o)r.push([]);const s=[];for(let o=0;o<n.length;++o){const t=vA(e,n[o]);for(const e of t)-1===s.indexOf(e)&&(r[o].push(e),s.push(e))}return{path:n,steps:r}}function yA(t){return t.every(((t,e)=>t===e))}function vA(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function wA(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof e)Jb(t.shape[n]%e===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{const a=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Jb(a<=1,(()=>"There should be only one negative value in split array."));const s=e.indexOf(-1);if(-1!==s){const r=e.reduce(((t,e)=>e>0?t+e:t));e[s]=t.shape[n]-r}Jb(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function xA(t){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(t)}function kA(t,e){return"indices(".concat(t,", 0) is invalid: ").concat(e," < 0")}function SA(t,e,n){return"indices(".concat(t,", 0) is invalid: ").concat(e," >= ").concat(n)}function IA(t,e){return"only one output dimension may be -1, not both ".concat(t," and ").concat(e)}function NA(t,e){return"size ".concat(t," must be non-negative, not ").concat(e)}function CA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function EA(t,e){const n=Qb(t),r=Qb(e);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(r,". inputShape=").concat(t," outputShape= ").concat(e)}function TA(t,e){const n=Qb(t),r=Qb(e);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(r,". inputShape=").concat(t," outputShape=").concat(e)}function AA(){return"segment ids must be >= 0"}function RA(){return"segment ids are not increasing"}function FA(t,e){return"Segment id ".concat(t," out of range [0, ").concat(e,"), possibly because segmentIds input is not sorted.")}function _A(t,e,n){return"Bad: indices[".concat(t,"] == ").concat(e," out of range [0, ").concat(n,")")}function DA(t,e){let n,r=!1;for(t<=LT?(n=t,r=!0):n=gy(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=gy(t,n+1);return n}function OA(t,e,n){const r=[],a=t.length;for(let s=0;s<a;s++)s!==e?r.push(t[s]):r.push(n);return r}function zA(t,e,n,r){const a=e.shape.length,s=t.shape.length;if(0!==r&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-".concat(a,", ").concat(a,"], but got ").concat(r));if(r<0&&(r+=a),r>s)throw new Error("batchDims (".concat(r,") must be less than rank(x) (\n    ").concat(s,")."));if(n<r)throw new Error("batchDims (".concat(r,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<r;++h)if(t.shape[h]!==e.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(t.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(e.shape[h],"."));const o=t.shape[n],i=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)i.push(t.shape[h]),l*=t.shape[h];for(let h=r;h<n;h++)i.push(t.shape[h]),c*=t.shape[h];for(let h=r;h<a;h++)i.push(e.shape[h]);for(let h=n+1;h<s;h++)i.push(t.shape[h]),u*=t.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:i}}function LA(t){try{return t.map((t=>vk(t)))}catch(w1){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(w1))}}function MA(t){return t.map((t=>yk(t)))}function PA(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const r=fI(t,"int32"),a=fI([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const e=r.indexToLoc(n[s]),o=s*t.length;a.values.set(e,o)}return a.toTensor()}!function(){for(const t of qI)RI(t)}();const BA={kernelName:Oy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,FE(gI(n,"float32"),-1))}}},WA={kernelName:zy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=kI(gI(n,"float32")),r=xI(LI(NI(1),e));return UC(vI(t,r))}}}},UA={kernelName:Ly,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=xI(LI(kI(gI(n,"float32")),1));return vI(t,e)}}}},VA={kernelName:My,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{let e=t;const r=WI(n.shape,a);return r.length>0&&(e=kC(e,r)),BN(e,n.shape)},b:()=>{let e=t;const n=WI(r.shape,a);return n.length>0&&(e=kC(e,n)),BN(e,r.shape)}}}},jA={kernelName:Py,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},GA={kernelName:Uy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SI(n)}}},HA={kernelName:Vy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>SI(n)}}},KA={kernelName:jy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,xI(LI(NI(1),kI(gI(n,"float32")))))}}},qA={kernelName:Gy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=xI(bI(NI(1),kI(gI(n,"float32"))));return vI(t,e)}}}},XA={kernelName:qy,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{const e=bI(kI(n),kI(r));let s=wI(t,vI(r,e));const o=WI(n.shape,a);return o.length>0&&(s=kC(s,o)),BN(s,n.shape)},b:()=>{const e=bI(kI(n),kI(r));let s=UC(wI(t,vI(n,e)));const o=WI(r.shape,a);return o.length>0&&(s=kC(s,o)),BN(s,r.shape)}}}},JA={kernelName:Hy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,bI(kI(gI(n,"float32")),1))}}},YA={kernelName:Ky,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,LI(NI(1),kI(gI(n,"float32"))))}}};const ZA=gS({avgPool3dGrad_:function(t,e,n,r,a,s){const o=pS(t,"dy","avgPool3dGrad"),i=pS(e,"input","avgPool3dGrad");let l=o,c=i,u=!1;4===i.rank&&(u=!0,l=BN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=BN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Jb(5===l.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),Jb(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),PN("avgPool3dGrad",a,s);const h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=aS.runKernel(Zy,h,d);return u?BN(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),QA={kernelName:Yy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>ZA(t,r,a,s,o,i)}}};const $A=gS({avgPoolGrad_:function(t,e,n,r,a){const s=pS(t,"dy","avgPoolGrad"),o=pS(e,"input","avgPoolGrad");Jb(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,l=s,c=!1;3===o.rank&&(c=!0,i=BN(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=BN(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Jb(4===l.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,"."))),Jb(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:l,input:i},h={filterSize:n,strides:r,pad:a},d=aS.runKernel(Jy,u,h);return c?BN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),tR={kernelName:Xy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:a,strides:s,pad:o}=n;return{x:()=>$A(t,r,a,s,o)}}},eR={kernelName:Qy,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,a]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>OC(t,a,!1,!1),b:()=>OC(t,r,!0,!1)}:s&&!o?{a:()=>OC(a,t,!1,!0),b:()=>OC(r,t,!1,!1)}:{a:()=>OC(a,t,!0,!0),b:()=>OC(t,r,!0,!0)}:{a:()=>OC(t,a,!1,!0),b:()=>OC(r,t,!0,!1)}}};const nR=gS({spaceToBatchND_:function(t,e,n){const r=pS(t,"x","spaceToBatchND");Jb(r.rank>=1+e.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(e.length))),Jb(n.length===e.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(e.length))),Jb(r.shape.reduce(((t,r,a)=>a>0&&a<=e.length?t&&(r+n[a-1][0]+n[a-1][1])%e[a-1]===0:t),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(e.toString())));const a={x:r},s={blockShape:e,paddings:n};return aS.runKernel(px,a,s)}}),rR={kernelName:$y,gradFunc:(t,e,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>nR(t,r,a)}}},aR={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])o[l]=1;else if(1!==a[l])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>kC(t,i,!0)}}},sR={kernelName:rv,gradFunc:t=>({x:()=>t.clone()})},oR={kernelName:av,gradFunc:t=>({x:()=>SI(t)})},iR={kernelName:sv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>wE(DC(bC(r,a),hT(r,s)),t,SI(t))}}},lR={kernelName:iv,inputsToSave:["x"],gradFunc:BA.gradFunc},cR={kernelName:lv,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:a}=n,s=sy(a,e[0].shape)[0],o=r.map((t=>t[s]));return dE(t,o,s).map((t=>()=>t))}},uR={kernelName:cv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return Jb(ON(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>eC(r.shape,t,a,o,i,l),filter:()=>AE(r,t,a.shape,o,i,l)}}},hR={kernelName:hv,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>$N(t,a,s,o,i,1,l),filter:()=>AE(t,r,a.shape,s,o,i,l)}}};const dR=gS({conv3DBackpropFilter_:function(t,e,n,r,a){let s=t;4===t.rank&&(s=BN(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=BN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),Jb(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),Jb(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),Jb(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Jb(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Jb(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return aS.runKernel(pv,i,l)}}),pR={kernelName:dv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s}=n;Jb(ON(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[o,i]=e;return{x:()=>aC(o.shape,t,i,a,s),filter:()=>dR(o,t,i.shape,a,s)}}};const fR=gS({sin_:function(t){const e={x:pS(t,"x","sin","float32")};return aS.runKernel(ox,e)}}),gR={kernelName:gv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(UC(fR(gI(n,"float32"))),t)}}};const mR=gS({sinh_:function(t){const e={x:pS(t,"x","sinh")};return aS.runKernel(ix,e)}}),bR={kernelName:mv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(mR(gI(n,"float32")),t)}}};const yR=gS({cumsum_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:pS(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return aS.runKernel(yv,a,s)}}),vR={kernelName:yv,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const e=AC([a],r.rank);let n=yR(t,a,s,!o);return null!=e&&(n=SE(n,e)),n}}}},wR={kernelName:kv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;Jb(ON(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[l,c]=e;return Jb(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(l.rank,"."))),Jb(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),Jb(l.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(l.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),Jb(zN(a,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(i,"'."))),PN("depthwiseConv2d",s,o),{x:()=>PE(l.shape,t,c,a,s,i,o),filter:()=>ME(l,t,c.shape,a,s,i,o)}}},xR={kernelName:Cv,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,a]=e,s={x:r,filter:a,dy:t},o={x:r,filter:a,dy:t};return{x:()=>aS.runKernel(Ev,s,n),filter:()=>aS.runKernel(Tv,o,n)}}},kR={kernelName:_v,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>aS.runKernel(Dv,r)}}},SR={kernelName:Ov,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=wI(uC(UC(kI(n))),2/Math.sqrt(Math.PI));return{x:()=>wI(t,r)}}},IR={kernelName:Lv,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,n)}}},NR={kernelName:Mv,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>BN(t,n.shape)}}},CR={kernelName:Pv,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,uC(n))}}},ER={kernelName:Vv,gradFunc:t=>({x:()=>SI(t)})},TR={kernelName:jv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{const e=vI(t,gI(r,"float32")),s=WI(n.shape,a);return s.length>0?BN(kC(e,s),n.shape):e},b:()=>{let e=wI(t,gI(n,"float32"));const s=WI(r.shape,a);s.length>0&&(e=BN(kC(e,s),r.shape));const o=kI(r);return UC(vI(e,gI(o,"float32")))}}}};const AR=gS({rsqrt_:function(t){const e={x:pS(t,"x","rsqrt","float32")};return aS.runKernel($w,e)}}),RR={kernelName:Gv,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=e,l=null==i?NI(1):i,c=WI(s.shape,a.shape),u=[];if(1===s.rank){for(let t=0;t<a.shape.length-1;++t)u.push(a.shape[t]);u.push(1)}const h=LI(a,s),d=wI(t,l),p=AR(bI(o,NI(r))),f=wI(wI(wI(p,p),p),NI(-.5));return{x:()=>1===s.rank?BN(wI(wI(t,dC(BN(p,[1,1,1,s.shape[0]]),u)),l),a.shape):BN(wI(wI(t,p),l),a.shape),mean:()=>{let t=wI(wI(p,NI(-1)),d);return 1===s.rank&&(t=kC(t,c)),BN(t,s.shape)},variance:()=>{let t=wI(wI(f,h),d);return 1===s.rank&&(t=kC(t,c)),BN(t,s.shape)},scale:()=>{const e=wI(h,p);let n=wI(t,e);return 1===s.rank&&(n=kC(n,c)),BN(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=kC(e,c)),BN(e,s.shape)}}}};const FR=gS({unsortedSegmentSum_:function(t,e,n){const r=pS(t,"x","unsortedSegmentSum"),a=pS(e,"segmentIds","unsortedSegmentSum","int32");Jb(ty(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return aS.runKernel(Mx,s,o)}}),_R={kernelName:Hv,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,a]=e,{axis:s,batchDims:o}=n,i=sy(s,r.shape)[0],l=(t,e,n)=>()=>{const r=t.shape,a=e.size,o=r.slice(0,i),l=o.length,c=r.slice(s,r.length).slice(1),u=c.length,h=DR(0,l),d=DR(l+1,l+1+u),p=OR([o,[a],c]),f=BN(n,p),g=BN(e,[a]),m=OR([[l],h,d]),b=SE(f,m);let y=FR(b,g,t.shape[i]);const v=RC(m);return y=SE(y,v),y};if(1===o){const e=r.shape[0],n=r.split(e,0);return{x:()=>{const e=fE(n.map(((e,n)=>l(e,a.slice(n,1),t.slice(n,1))())));return e.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,t),indices:()=>a}}};function DR(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function OR(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const zR={kernelName:Xv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>SI(n),b:()=>SI(r)}}},LR={kernelName:Jv,gradFunc:t=>({x:()=>gI(t,"float32")})},MR={kernelName:Qv,gradFunc:t=>({x:()=>SI(t)})},PR={kernelName:$v,gradFunc:t=>({x:()=>SI(t)})},BR={kernelName:tw,gradFunc:t=>({x:()=>SI(t)})},WR={kernelName:ew,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:a}=n,s=mC(r,0);return{x:()=>wE(s,t,wI(t,a))}}},UR={kernelName:ow,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,bI(n,1))}}},VR={kernelName:sw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,gI(n,"float32"))}}},jR={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;return{logits:()=>{const e=uC(r);return LI(t,wI(kC(t,a,!0),e))}}}};const GR=gS({localResponseNormalizationBackprop_:function(t,e,n){const r={x:t,y:e,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return aS.runKernel(hw,r,a)}}),HR={kernelName:uw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>GR(r,a,t,s,o,i,l)}}};function KR(t,e,n,r){return e.rank<n.rank&&(e=BN(e,EC(e.shape,r))),t.rank<n.rank&&(t=BN(t,EC(t.shape,r))),{x:()=>wI(t,gI(cC(n,e),t.dtype))}}const qR={kernelName:dw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:a}=r,s=e[0],o=KR(t,e[1],s,sy(a,s.shape));return{x:()=>o.x()}}},XR={kernelName:pw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>wI(t,gI(bC(n,r),"float32")),b:()=>wI(t,gI(gT(n,r),"float32"))}}};const JR=gS({maxPool3dGrad_:function(t,e,n,r,a,s,o){const i=pS(t,"dy","maxPool3dGrad"),l=pS(e,"input","maxPool3dGrad"),c=pS(n,"output","maxPool3dGrad");let u=i,h=l,d=c,p=!1;4===l.rank&&(p=!0,u=BN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=BN(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=BN(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Jb(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Jb(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Jb(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),PN("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},g={filterSize:r,strides:a,pad:s,dimRoundingMode:o},m=aS.runKernel(bw,f,g);return p?BN(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),YR={kernelName:mw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>JR(t,r,a,s,o,i,l)}}};const ZR=gS({maxPoolGrad_:function(t,e,n,r,a,s,o){const i=pS(t,"dy","maxPoolGrad"),l=pS(e,"input","maxPoolGrad"),c=pS(n,"output","maxPoolGrad");Jb(l.rank===i.rank,(()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),Jb(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),Jb(4===l.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,"."))),PN("maxPoolGrad",s,o);const u={dy:i,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return aS.runKernel(gw,u,h)}}),QR={kernelName:fw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,a]=e,{filterSize:s,strides:o,pad:i}=n;return{x:()=>ZR(t,r,a,s,o,i)}}},$R={kernelName:vw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n,s=sy(a,r.shape),o=Qb(CC(r.shape,s)[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=BN(t,e);return vI(wI(n,HC(r.shape,"float32")),o)}}}},tF={kernelName:ww,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:a}=r,[s,o]=e,i=KR(t,o,s,sy(a,s.shape));return{x:()=>i.x()}}},eF={kernelName:xw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>wI(t,gI(hT(n,r),"float32")),b:()=>wI(t,gI(mC(n,r),"float32"))}}},nF={kernelName:kw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>sE(t,s,r.shape)}}},rF={kernelName:Sw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{const e=WI(n.shape,a);return e.length>0?BN(kC(t,e),n.shape):t},b:()=>{const e=wI(t,UC(fC(vI(n,r)))),s=WI(r.shape,a);return s.length>0?BN(kC(e,s),r.shape):e}}}},aF={kernelName:Nw,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{const e=wI(t,gI(r,"float32")),s=WI(n.shape,a);return s.length>0?BN(kC(e,s),n.shape):e},b:()=>{const e=wI(t,gI(n,"float32")),s=WI(r.shape,a);return s.length>0?BN(kC(e,s),r.shape):e}}}},sF={kernelName:Cw,gradFunc:t=>({x:()=>UC(t)})},oF={kernelName:_w,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>GC(n.shape,"float32")}}},iF={kernelName:Fw,gradFunc:t=>({x:()=>SI(t)})},lF={kernelName:Dw,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return vE(t,r).map((t=>()=>t))}},cF={kernelName:Ow,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:a}=n,s=a.map((t=>t[0]));return{x:()=>sE(t,s,r.shape)}}},uF={kernelName:zw,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,a]=e,s=n,o=r,i=UI(s.shape,o.shape);return{a:()=>{const e=gI(o,"float32");let n=wI(t,wI(e,zI(s,LI(e,NI(1)))));const r=WI(s.shape,i);return r.length>0&&(n=kC(n,r)),BN(n,s.shape)},b:()=>{const e=mC(s,0),n=wE(e,vC(s),SI(s));let r=wI(t,wI(a,n));const l=WI(o.shape,i);return l.length>0&&(r=kC(r,l)),BN(r,o.shape)}}}},hF={kernelName:Lw,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,a=mC(n,0);return{x:()=>wE(a,t,wI(t,r)),alpha:()=>{let e=wE(a,SI(t),wI(t,n));const s=WI(r.shape,t.shape);return s.length>0&&(e=kC(e,s)),BN(e,r.shape)}}}};const dF=gS({cumprod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:pS(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return aS.runKernel(bv,a,s)}});function pF(t,e,n){const r=t.shape.length,a=r-n.length,s=AC(n,r);let o=t;null!=s&&(o=SE(t,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);i.push(l);let c=function(t,e,n){const r=t.shape.slice();r[n]=1;const a=BN(e,r),s=dF(t,n,!0,!1),o=dF(t,n,!0,!0),i=wI(s,o);return wI(a,i)}(o.reshape(i),e,a);if(c=c.reshape(o.shape),null!=s){const t=RC(s);c=SE(c,t)}return c}const fF={kernelName:Mw,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((t,e)=>e)):"number"===typeof a?[a]:a,{x:()=>pF(r,t,s)}}},gF={kernelName:Rv,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{const e=vI(t,gI(r,"float32")),s=WI(n.shape,a);return s.length>0?BN(kC(e,s),n.shape):e},b:()=>{let e=wI(t,gI(n,"float32"));const s=WI(r.shape,a);s.length>0&&(e=BN(kC(e,s),r.shape));const o=kI(r);return UC(vI(e,gI(o,"float32")))}}}},mF={kernelName:jw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,UC(kI(n)))}}},bF={kernelName:Yw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=wI(hT(n,6),FE(n));return{x:()=>wI(t,gI(r,"float32"))}}},yF={kernelName:Gw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,gI(FE(n),"float32"))}}},vF={kernelName:Hw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>BN(t,n.shape)}}},wF={kernelName:Xw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>aS.runKernel(Jw,a,n)}}},xF={kernelName:Kw,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,a={dy:t,images:r};return{images:()=>aS.runKernel(qw,a,n)}}},kF={kernelName:Zw,gradFunc:(t,e,n)=>{const{dims:r}=n,a=sy(r,t.shape);return{x:()=>eE(t,a)}}},SF={kernelName:Qw,gradFunc:t=>({x:()=>SI(t)})},IF={kernelName:$w,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>UC(vI(t,wI(zI(n,1.5),2)))}}};const NF=gS({logicalNot_:function(t){const e={x:pS(t,"x","logicalNot","bool")};return aS.runKernel(lw,e)}}),CF={kernelName:rx,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>gI(SI(n),"float32"),t:()=>wI(t,gI(n,t.dtype)),e:()=>wI(t,gI(NF(n),t.dtype))}}},EF={kernelName:ax,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=mC(n,NI(0)),r=NI(XT),a=NI(JT),s=wI(t,a),o=wI(wI(t,r),uC(gI(n,"float32")));return wE(e,s,o)}}}},TF={kernelName:cx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,wI(n,LI(NI(1),n)))}}},AF={kernelName:lx,gradFunc:t=>({x:()=>SI(t)})};const RF=gS({cos_:function(t){const e={x:pS(t,"x","cos","float32")};return aS.runKernel(gv,e)}}),FF={kernelName:ox,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(RF(gI(n,"float32")),t)}}};const _F=gS({cosh_:function(t){const e={x:pS(t,"x","cosh","float32")};return aS.runKernel(mv,e)}}),DF={kernelName:ix,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(_F(gI(n,"float32")),t)}}},OF={kernelName:sx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:a,size:s}=n,o=r.shape,[i,l]=yN(r,a,s),c=[];for(let u=0;u<t.rank;u++)c.push([i[u],o[u]-i[u]-l[u]]);return{x:()=>qC(t,c)}}},zF={kernelName:gx,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:a}=n,s=wI(t,r);return{logits:()=>LI(s,wI(kC(s,[a],true),r))}}},LF={kernelName:ux,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,aE(n))}}};const MF=gS({batchToSpaceND_:function(t,e,n){const r=pS(t,"x","batchToSpaceND"),a=e.reduce(((t,e)=>t*e));Jb(r.rank>=1+e.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(e.length))),Jb(n.length===e.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(e.length))),Jb(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(e.join(" * ")," === ").concat(a)));const s={x:r},o={blockShape:e,crops:n};return aS.runKernel($y,s,o)}}),PF={kernelName:px,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>MF(t,r,a)}}},BF={kernelName:fx,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>XN(t,r)}}};const WF=[BA,WA,UA,VA,jA,GA,HA,KA,qA,XA,JA,YA,QA,tR,eR,rR,aR,sR,oR,iR,lR,cR,hR,uR,pR,gR,bR,vR,wR,xR,gF,kR,SR,IR,NR,CR,TR,ER,RR,_R,zR,LR,MR,PR,BR,WR,UR,VR,jR,HR,qR,qR,XR,YR,QR,$R,tF,eF,nF,rF,aF,sF,oF,iF,lF,cF,cF,uF,hF,fF,mF,bF,yF,vF,wF,xF,kF,SF,IF,CF,EF,TF,AF,FF,DF,OF,zF,LF,PF,PF,BF,BF,{kernelName:hx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,wI(xI(gI(n,"float32")),2))}}},{kernelName:xx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=NI(2);return{a:()=>wI(t,wI(a,LI(n,r))),b:()=>wI(t,wI(a,LI(r,n)))}}},{kernelName:kx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(t,wI(gI(n,"float32"),2))}}},{kernelName:Bx,gradFunc:t=>({x:()=>SI(t)})},{kernelName:Tx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,a=UI(n.shape,r.shape);return{a:()=>{let e=t;const r=WI(n.shape,a);return r.length>0&&(e=kC(e,r)),BN(e,n.shape)},b:()=>{let e=t;const n=WI(r.shape,a);return n.length>0&&(e=kC(e,n)),BN(UC(e),r.shape)}}}},{kernelName:dx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,a=r.shape.slice(),{axis:s}=n;sy(s,r.shape).forEach((t=>{a[t]=1}));const o=BN(t,a),i=wI(o,HC(r.shape,"float32"));return{x:()=>i}}},{kernelName:Ax,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vI(t,kI(RF(n)))}}},{kernelName:Rx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wI(LI(NI(1),kI(n)),t)}}},{kernelName:Fx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:a}=n;return{x:()=>{let e=SI(r);if(1===r.rank)for(let n=0;n<a[0];++n)e=bI(e,sE(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)e=bI(e,sE(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)e=bI(e,sE(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)e=bI(e,sE(t,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Ox,gradFunc:(t,e,n)=>{const r=n,{perm:a}=r,s=RC(a);return{x:()=>SE(t,s)}}},{kernelName:Lx,gradFunc:(t,e,n)=>{const r=n,{axis:a}=r;return{value:()=>fE(t,a)}}},{kernelName:Mx,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=VI(e,SI(e)),r=gC(t,n);let a=bC(e,NI(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=hC(a,i+1);a=DC(a,HC(r.shape,"bool"));const o=SI(r);return wE(a,r,o)}(t,n)}}},{kernelName:Px,gradFunc:t=>({x:()=>SI(t)})}];for(const n of WF)$x(n);Pk().prototype.abs=function(){return this.throwIfDisposed(),PI(this)};const UF=gS({acos_:function(t){const e={x:pS(t,"x","acos")};return aS.runKernel(zy,e)}});Pk().prototype.acos=function(){return this.throwIfDisposed(),UF(this)};const VF=gS({acosh_:function(t){const e={x:pS(t,"x","acosh")};return aS.runKernel(Ly,e)}});Pk().prototype.acosh=function(){return this.throwIfDisposed(),VF(this)},Pk().prototype.add=function(t){return this.throwIfDisposed(),bI(this,t)},Pk().prototype.all=function(t,e){return this.throwIfDisposed(),xN(this,t,e)},Pk().prototype.any=function(t,e){return this.throwIfDisposed(),kN(this,t,e)},Pk().prototype.argMax=function(t){return this.throwIfDisposed(),SN(this,t)};const jF=gS({argMin_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:pS(t,"x","argMin")},r={axis:e};return aS.runKernel(Vy,n,r)}});Pk().prototype.argMin=function(t){return this.throwIfDisposed(),jF(this,t)},Pk().prototype.asScalar=function(){return this.throwIfDisposed(),Jb(1===this.size,(()=>"The array must have only 1 element.")),BN(this,[])},Pk().prototype.asType=function(t){return this.throwIfDisposed(),gI(this,t)},Pk().prototype.as1D=function(){return this.throwIfDisposed(),BN(this,[this.size])},Pk().prototype.as2D=function(t,e){return this.throwIfDisposed(),BN(this,[t,e])},Pk().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),BN(this,[t,e,n])},Pk().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),BN(this,[t,e,n,r])},Pk().prototype.as5D=function(t,e,n,r,a){return this.throwIfDisposed(),BN(this,[t,e,n,r,a])};const GF=gS({asin_:function(t){const e={x:pS(t,"x","asin")};return aS.runKernel(jy,e)}});Pk().prototype.asin=function(){return this.throwIfDisposed(),GF(this)};const HF=gS({asinh_:function(t){const e={x:pS(t,"x","asinh")};return aS.runKernel(Gy,e)}});Pk().prototype.asinh=function(){return this.throwIfDisposed(),HF(this)};const KF=gS({atan_:function(t){const e={x:pS(t,"x","atan")};return aS.runKernel(Hy,e)}});Pk().prototype.atan=function(){return this.throwIfDisposed(),KF(this)};const qF=gS({atan2_:function(t,e){let n=pS(t,"a","atan2"),r=pS(e,"b","atan2");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(qy,a)}});Pk().prototype.atan2=function(t){return this.throwIfDisposed(),qF(this,t)};const XF=gS({atanh_:function(t){const e={x:pS(t,"x","atanh")};return aS.runKernel(Ky,e)}});Pk().prototype.atanh=function(){return this.throwIfDisposed(),XF(this)},Pk().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),WN(this,t,e,n,r)},Pk().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),MF(this,t,e)},Pk().prototype.batchNorm=function(t,e,n,r,a){return this.throwIfDisposed(),VN(this,t,e,n,r,a)},Pk().prototype.broadcastTo=function(t){return this.throwIfDisposed(),KN(this,t)},Pk().prototype.cast=function(t){return this.throwIfDisposed(),gI(this,t)};const JF=gS({ceil_:function(t){const e={x:pS(t,"x","ceil","float32")};return aS.runKernel(av,e)}});Pk().prototype.ceil=function(){return this.throwIfDisposed(),JF(this)},Pk().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),qN(this,t,e)},Pk().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Mk&&(t=[t]),XN([this,...t],e)},Pk().prototype.conv1d=function(t,e,n,r,a,s){return this.throwIfDisposed(),tC(this,t,e,n,r,a,s)},Pk().prototype.conv2dTranspose=function(t,e,n,r,a){return this.throwIfDisposed(),nC(this,t,e,n,r,a)},Pk().prototype.conv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),$N(this,t,e,n,r,a,s)},Pk().prototype.cos=function(){return this.throwIfDisposed(),RF(this)},Pk().prototype.cosh=function(){return this.throwIfDisposed(),_F(this)},Pk().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),dF(this,t,e,n)},Pk().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),yR(this,t,e,n)};const YF=gS({depthToSpace_:function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=pS(t,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];Jb(e>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(e))),Jb(a*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(a," and ").concat(e,"  for depthToSpace with input shape\n    ").concat(r.shape))),Jb(s*e>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(e," for depthToSpace with input shape\n        ").concat(r.shape))),Jb(o%(e*e)===0,(()=>"Dimension size must be evenly divisible by ".concat(e*e," but is ").concat(o," for depthToSpace with input shape ").concat(r.shape)));const i={x:r},l={blockSize:e,dataFormat:n};return aS.runKernel(xv,i,l)}});Pk().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),YF(this,t,e)},Pk().prototype.depthwiseConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),iC(this,t,e,n,r,a,s)};const ZF=gS({dilation2d_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=pS(t,"x","dilation2d"),i=pS(e,"filter","dilation2d");Jb(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),Jb(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Jb("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let l=o,c=!1;3===o.rank&&(l=BN(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),Jb(l.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(l.shape[3]," vs ").concat(i.shape[2])));const u={x:l,filter:i},h={strides:n,pad:r,dilations:a},d=aS.runKernel(Cv,u,h);return c?BN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});Pk().prototype.dilation2d=function(t,e,n,r,a){return this.throwIfDisposed(),ZF(this,t,e,n,r,a)};const QF=gS({divNoNan_:function(t,e){let n=pS(t,"a","div"),r=pS(e,"b","div");[n,r]=Yk(n,r);const a=vI(n,r),s=SI(a),o=cC(r,s);return wE(o,s,a)}});Pk().prototype.divNoNan=function(t){return this.throwIfDisposed(),QF(this,t)},Pk().prototype.div=function(t){return this.throwIfDisposed(),vI(this,t)};const $F=gS({dot_:function(t,e){const n=pS(t,"t1","dot"),r=pS(e,"t2","dot");Jb((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(r.rank,".")));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Jb(a===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(a," and ").concat(s,"."))),1===n.rank&&1===r.rank){const t=BN(n,[1,-1]),e=BN(r,[-1,1]),a=OC(t,e);return BN(a,[])}if(1===n.rank&&2===r.rank){const t=BN(n,[1,-1]),e=BN(r,[r.shape[0],r.shape[1]]),a=OC(t,e);return BN(a,[a.size])}if(2===n.rank&&1===r.rank){const t=BN(r,[-1,1]),e=OC(n,t);return BN(e,[e.size])}{const t=BN(r,[r.shape[0],r.shape[1]]);return OC(n,t)}}});Pk().prototype.dot=function(t){return this.throwIfDisposed(),$F(this,t)},Pk().prototype.elu=function(){return this.throwIfDisposed(),lC(this)},Pk().prototype.equal=function(t){return this.throwIfDisposed(),cC(this,t)};const t_=gS({erf_:function(t){let e=pS(t,"x","erf");Jb("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=gI(e,"float32"));const n={x:e};return aS.runKernel(Ov,n)}});Pk().prototype.erf=function(){return this.throwIfDisposed(),t_(this)};const e_=gS({euclideanNorm_:function(t){return yT(t,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Pk().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),e_(this,t,e)},Pk().prototype.exp=function(){return this.throwIfDisposed(),uC(this)},Pk().prototype.expandDims=function(t){return this.throwIfDisposed(),hC(this,t)};const n_=gS({expm1_:function(t){const e={x:pS(t,"x","expm1")};return aS.runKernel(Pv,e)}});Pk().prototype.expm1=function(){return this.throwIfDisposed(),n_(this)},Pk().prototype.fft=function(){return this.throwIfDisposed(),NE(this)},Pk().prototype.flatten=function(){return this.throwIfDisposed(),BN(this,[this.size])},Pk().prototype.floor=function(){return this.throwIfDisposed(),fC(this)},Pk().prototype.floorDiv=function(t){return this.throwIfDisposed(),yI(this,t)},Pk().prototype.gather=function(t,e,n){return this.throwIfDisposed(),gC(this,t,e,n)},Pk().prototype.greaterEqual=function(t){return this.throwIfDisposed(),bC(this,t)},Pk().prototype.greater=function(t){return this.throwIfDisposed(),mC(this,t)},Pk().prototype.ifft=function(){return this.throwIfDisposed(),EE(this)},Pk().prototype.irfft=function(){return this.throwIfDisposed(),TE(this)};const r_=gS({isFinite_:function(t){const e={x:pS(t,"x","isFinite")};return aS.runKernel(Qv,e)}});Pk().prototype.isFinite=function(){return this.throwIfDisposed(),r_(this)};const a_=gS({isInf_:function(t){const e={x:pS(t,"x","isInf")};return aS.runKernel($v,e)}});Pk().prototype.isInf=function(){return this.throwIfDisposed(),a_(this)};const s_=gS({isNaN_:function(t){const e={x:pS(t,"x","isNaN")};return aS.runKernel(tw,e)}});Pk().prototype.isNaN=function(){return this.throwIfDisposed(),s_(this)},Pk().prototype.leakyRelu=function(t){return this.throwIfDisposed(),yC(this,t)},Pk().prototype.lessEqual=function(t){return this.throwIfDisposed(),hT(this,t)},Pk().prototype.less=function(t){return this.throwIfDisposed(),gT(this,t)};const o_=gS({localResponseNormalization_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=pS(t,"x","localResponseNormalization");Jb(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),Jb(ty(e),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(e,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=BN(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:n,alpha:r,beta:a},u=aS.runKernel(uw,l,c);return i?BN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Pk().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),o_(this,t,e,n,r)};const i_=gS({logSigmoid_:function(t){const e=pS(t,"x","logSigmoid");return II((t=>({value:UC(hE(UC(t))),gradFunc:e=>wI(e,aE(UC(t)))})))(e)}});Pk().prototype.logSigmoid=function(){return this.throwIfDisposed(),i_(this)},Pk().prototype.logSoftmax=function(t){return this.throwIfDisposed(),SC(this,t)},Pk().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),_C(this,t,e)},Pk().prototype.log=function(){return this.throwIfDisposed(),vC(this)},Pk().prototype.log1p=function(){return this.throwIfDisposed(),wC(this)},Pk().prototype.logicalAnd=function(t){return this.throwIfDisposed(),DC(this,t)},Pk().prototype.logicalNot=function(){return this.throwIfDisposed(),NF(this)};const l_=gS({logicalOr_:function(t,e){const n=pS(t,"a","logicalOr","bool"),r=pS(e,"b","logicalOr","bool");UI(n.shape,r.shape);const a={a:n,b:r};return aS.runKernel(cw,a)}});Pk().prototype.logicalOr=function(t){return this.throwIfDisposed(),l_(this,t)};const c_=gS({logicalXor_:function(t,e){const n=pS(t,"a","logicalXor","bool"),r=pS(e,"b","logicalXor","bool");return UI(n.shape,r.shape),DC(l_(t,e),NF(DC(t,e)))}});Pk().prototype.logicalXor=function(t){return this.throwIfDisposed(),c_(this,t)},Pk().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),OC(this,t,e,n)},Pk().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),zC(this,t,e,n,r)},Pk().prototype.max=function(t,e){return this.throwIfDisposed(),xC(this,t,e)},Pk().prototype.maximum=function(t){return this.throwIfDisposed(),VI(this,t)},Pk().prototype.mean=function(t,e){return this.throwIfDisposed(),MC(this,t,e)},Pk().prototype.min=function(t,e){return this.throwIfDisposed(),PC(this,t,e)},Pk().prototype.minimum=function(t){return this.throwIfDisposed(),BC(this,t)};const u_=gS({mirrorPad_:function(t,e,n){Jb("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const r=pS(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Jb(e.length===r.rank,(()=>"Padding doesn't match input. Must be ".concat(r.rank,". ")+"Got ".concat(e.length,".")));const a="reflect"===n?1:0;for(let i=0;i<r.rank;i++)Jb(2===e[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Jb(e[i][0]>=0&&e[i][0]<=r.shape[i]-a&&e[i][1]>=0&&e[i][1]<=r.shape[i]-a,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(r.shape[i]-a," or less than 0 for input of ")+"shape ".concat(r.shape)));const s={paddings:e,mode:n},o={x:r};return aS.runKernel(kw,o,s)}});Pk().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),u_(this,t,e)};const h_=gS({mod_:function(t,e){let n=pS(t,"a","mod"),r=pS(e,"b","mod");[n,r]=Yk(n,r);const a={a:n,b:r};return aS.runKernel(Sw,a)}});Pk().prototype.mod=function(t){return this.throwIfDisposed(),h_(this,t)},Pk().prototype.mul=function(t){return this.throwIfDisposed(),wI(this,t)},Pk().prototype.neg=function(){return this.throwIfDisposed(),UC(this)},Pk().prototype.norm=function(t,e,n){return this.throwIfDisposed(),yT(this,t,e,n)},Pk().prototype.notEqual=function(t){return this.throwIfDisposed(),VC(this,t)},Pk().prototype.oneHot=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),jC(this,t,e,n)},Pk().prototype.onesLike=function(){return this.throwIfDisposed(),KC(this)},Pk().prototype.pad=function(t,e){return this.throwIfDisposed(),qC(this,t,e)};const d_=gS({pool_:function(t,e,n,r,a,s,o){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=pS(t,"x","maxPool");let l=i,c=!1;3===i.rank&&(c=!0,l=BN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Jb(zN(s,a),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(a,"'")));const u=NN(l.shape,e,s,a,r),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))),r=n.map((t=>t-1)),a=r.map((t=>Math.floor(t/2))),s=r.map(((t,e)=>t-a[e]));return r.map(((t,e)=>[a[e],s[e]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(t,e,n){const r=n.map((t=>t[0])),a=n.map((t=>t[1])),s=t.concat(r,a),o=e.map(((t,e)=>(t-s[e]%t)%t)),i=a.map(((t,e)=>t+o[e])),l=e.map(((t,e)=>[r[e],i[e]])),c=e.map(((t,e)=>[0,o[e]]));return[l,c]}([u.inHeight,u.inWidth],h,d),m=p?r:"valid",b=p?l:nR(l,h,f),y=("avg"===n?()=>WN(b,e,s,m,o):()=>zC(b,e,s,m,o))(),v=p?y:MF(y,h,g);return c?BN(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Pk().prototype.pool=function(t,e,n,r,a,s){return this.throwIfDisposed(),d_(this,t,e,n,r,a,s)},Pk().prototype.pow=function(t){return this.throwIfDisposed(),zI(this,t)},Pk().prototype.prelu=function(t){return this.throwIfDisposed(),XC(this,t)};const p_=gS({prod_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=pS(t,"x","prod");"bool"===r.dtype&&(r=gI(r,"int32"));const a={x:r},s={axis:e,keepDims:n};return aS.runKernel(Mw,a,s)}});Pk().prototype.prod=function(t,e){return this.throwIfDisposed(),p_(this,t,e)};const f_=gS({reciprocal_:function(t){const e={x:pS(t,"x","reciprocal")};return aS.runKernel(jw,e)}});Pk().prototype.reciprocal=function(){return this.throwIfDisposed(),f_(this)},Pk().prototype.relu=function(){return this.throwIfDisposed(),tE(this)},Pk().prototype.relu6=function(){return this.throwIfDisposed(),RE(this)},Pk().prototype.reshapeAs=function(t){return this.throwIfDisposed(),BN(this,t.shape)},Pk().prototype.reshape=function(t){return this.throwIfDisposed(),BN(this,t)},Pk().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),lT(this,t,e,n)},Pk().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),cT(this,t,e,n)},Pk().prototype.reverse=function(t){return this.throwIfDisposed(),eE(this,t)},Pk().prototype.rfft=function(){return this.throwIfDisposed(),CE(this)},Pk().prototype.round=function(){return this.throwIfDisposed(),dT(this)},Pk().prototype.rsqrt=function(){return this.throwIfDisposed(),AR(this)},Pk().prototype.selu=function(){return this.throwIfDisposed(),nE(this)},Pk().prototype.separableConv2d=function(t,e,n,r,a,s){return this.throwIfDisposed(),rE(this,t,e,n,r,a,s)},Pk().prototype.sigmoid=function(){return this.throwIfDisposed(),aE(this)};const g_=gS({sign_:function(t){const e={x:pS(t,"x","sign")};return aS.runKernel(lx,e)}});Pk().prototype.sign=function(){return this.throwIfDisposed(),g_(this)},Pk().prototype.sin=function(){return this.throwIfDisposed(),fR(this)},Pk().prototype.sinh=function(){return this.throwIfDisposed(),mR(this)},Pk().prototype.slice=function(t,e){return this.throwIfDisposed(),sE(this,t,e)},Pk().prototype.softmax=function(t){return this.throwIfDisposed(),uE(this,t)},Pk().prototype.softplus=function(){return this.throwIfDisposed(),hE(this)},Pk().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),nR(this,t,e)},Pk().prototype.split=function(t,e){return this.throwIfDisposed(),dE(this,t,e)},Pk().prototype.sqrt=function(){return this.throwIfDisposed(),xI(this)},Pk().prototype.square=function(){return this.throwIfDisposed(),kI(this)},Pk().prototype.squaredDifference=function(t){return this.throwIfDisposed(),ST(this,t)},Pk().prototype.squeeze=function(t){return this.throwIfDisposed(),pE(this,t)},Pk().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Mk?[this,t]:[this,...t];return fE(n,e)},Pk().prototype.step=function(t){return this.throwIfDisposed(),FE(this,t)};const m_=gS({stridedSlice_:function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const c={x:pS(t,"x","stridedSlice","string_or_numeric")},u={begin:e,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};return aS.runKernel(Ix,c,u)}});Pk().prototype.stridedSlice=function(t,e,n,r,a,s,o,i){return this.throwIfDisposed(),m_(this,t,e,n,r,a,s,o,i)},Pk().prototype.sub=function(t){return this.throwIfDisposed(),LI(this,t)},Pk().prototype.sum=function(t,e){return this.throwIfDisposed(),kC(this,t,e)};const b_=gS({tan_:function(t){const e={x:pS(t,"x","tan","float32")};return aS.runKernel(Ax,e)}});Pk().prototype.tan=function(){return this.throwIfDisposed(),b_(this)},Pk().prototype.tanh=function(){return this.throwIfDisposed(),gE(this)},Pk().prototype.tile=function(t){return this.throwIfDisposed(),dC(this,t)},Pk().prototype.toBool=function(){return this.throwIfDisposed(),gI(this,"bool")},Pk().prototype.toFloat=function(){return this.throwIfDisposed(),gI(this,"float32")},Pk().prototype.toInt=function(){return this.throwIfDisposed(),gI(this,"int32")};const y_=gS({topk_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=pS(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(e<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(e));if(e>a)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a,") ")+"but got ".concat(e));const s={x:r},o={k:e,sorted:n},[i,l]=aS.runKernel(_x,s,o);return{values:i,indices:l}}});Pk().prototype.topk=function(t,e){return this.throwIfDisposed(),y_(this,t,e)},Pk().prototype.transpose=function(t){return this.throwIfDisposed(),SE(this,t)};const v_=gS({unique_:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=pS(t,"x","unique","string_or_numeric");Jb(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:e},[s,o]=aS.runKernel(zx,r,a);return{values:s,indices:o}}});Pk().prototype.unique=function(t){return this.throwIfDisposed(),v_(this,t)},Pk().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),FR(this,t,e)},Pk().prototype.unstack=function(t){return this.throwIfDisposed(),vE(this,t)},Pk().prototype.where=function(t,e){return this.throwIfDisposed(),wE(t,this,e)},Pk().prototype.zerosLike=function(){return this.throwIfDisposed(),SI(this)};class w_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,w_.prototype)}}class x_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,x_.prototype)}}class k_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,k_.prototype)}}class S_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,S_.prototype)}}class I_ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,I_.prototype)}}Error;class N_{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(t,"."));if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function C_(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function E_(t,e){if(!t)throw new I_(e)}function T_(t,e){let n=0;for(const r of t)r===e&&n++;return n}function A_(t){return 1===t.length?t[0]:t}function R_(t){return Array.isArray(t)?t:[t]}function F_(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function __(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let D_={};function O_(t){if(null===t||void 0===t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function z_(t){if(null!=t&&"object"===typeof t)if(Array.isArray(t))t.forEach((t=>z_(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"===typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!==typeof e.value?z_(e):t[n]=e.value)}}}function L_(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof t){const a=t;let s;if(a in n)s=n[a];else if(a in D_)s=D_[a];else if(s=e[a],null==s)throw new k_("Unknown ".concat(r,": ").concat(t,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=t;if(null==s.className||null==s.config)throw new k_("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in D_?[i,l]=D_.className:o in e&&([i,l]=e[o]),null==i)throw new k_("Unknown ".concat(r,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=l){const t={};for(const n of Object.keys(D_))t[n]=D_[n];for(const a of Object.keys(n))t[a]=n[a];s.config.customObjects=t;const e=Object.assign({},D_);for(const a of Object.keys(n))D_[a]=n[a];z_(s.config);const r=l(i,s.config,n,a);return D_=Object.assign({},e),r}{const t=Object.assign({},D_);for(const r of Object.keys(n))D_[r]=n[r];const e=new i(s.config);return D_=Object.assign({},t),e}}}function M_(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function P_(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function B_(t){if(null==t)throw new k_("Invalid value in obj: ".concat(JSON.stringify(t)));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function W_(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new k_("".concat(n," is not a valid ").concat(e,".  Valid values are ").concat(t," or null/undefined."))}function U_(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return E_(n>=0),E_(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function V_(t,e){Array.isArray(t)?(Jb(t.length>0,(()=>"".concat(e," is unexpectedly an empty array."))),t.forEach(((t,n)=>V_(t,"element ".concat(n+1," of ").concat(e))))):Jb(Number.isInteger(t)&&t>0,(()=>"Expected ".concat(e," to be a positive integer, but got ")+"".concat(j_(t),".")))}function j_(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>j_(t))).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}function G_(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let H_=0;function K_(){return H_++}const q_={};function X_(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t in q_||(q_[t]=0),q_[t]+=1,t+q_[t].toString()}const J_=["channelsFirst","channelsLast"],Y_=["nearest","bilinear"],Z_=["valid","same","causal"],Q_=["max","avg"],$_=["sum","mul","concat","ave"],tD=new Map;function eD(t){W_(J_,"DataFormat",t)}function nD(t){W_(Z_,"PaddingMode",t)}function rD(t){W_(Q_,"PoolMode",t)}const aD=[],sD="/";function oD(t,e){aD.push(t);try{const t=e();return aD.pop(),t}catch(v1){throw aD.pop(),v1}}function iD(t){if(!uD(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===aD.length?"":aD.join(sD)+sD)+t}function lD(t){if(!uD(t))throw new Error("Not a valid tensor name: '"+t+"'");tD.has(t)||tD.set(t,0);const e=tD.get(t);if(tD.set(t,tD.get(t)+1),e>0){const n="".concat(t,"_").concat(e);return tD.set(n,1),n}return t}const cD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function uD(t){return!!t.match(cD)}function hD(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let a=e;a<n;++a)r*=t[a];return r}function dD(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function pD(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function fD(t,e){if(e<t)throw new k_("end (".concat(e,") < begin (").concat(t,") is forbidden."));const n=[];for(let r=t;r<e;++r)n.push(r);return n}let gD;function mD(){return null==gD&&(gD=ES().epsilon()),gD}function bD(t,e){return gI(t,e)}function yD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),BN(t,n)}function vD(t,e,n){return SS((()=>{switch(t.rank){case 1:return oE(t,e,n);case 2:return iE(t,[e,0],[n,t.shape[1]]);case 3:return lE(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return cE(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return sE(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return sE(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new k_("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function wD(t,e,n){return SS((()=>{switch(t.rank){case 1:return oE(t,e,n);case 2:return iE(t,[0,e],[t.shape[0],n]);case 3:return lE(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return cE(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new k_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function xD(t,e,n,r){return SS((()=>{switch(t.rank){case 1:return oE(t,e,n);case 2:switch(r){case 1:return vD(t,e,n);case 2:return wD(t,e,n);default:throw new k_("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return vD(t,e,n);case 2:return lE(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return wD(t,e,n);default:throw new k_("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return vD(t,e,n);case 2:return cE(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return cE(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return wD(t,e,n);default:throw new k_("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new k_("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(t.rank))}}))}function kD(t){let e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),XN(t,n)}function SD(t,e){switch(t.rank){case 1:return JN([t,e]);case 2:return YN([t,e],0);case 3:return ZN([t,e],0);case 4:return QN([t,e],0);default:throw new k_("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(t.rank))}}function ID(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new k_("The length of input n (".concat(e.length,") does not match ")+"the number of dimensions in input x (".concat(t.rank,")"));return dC(t,e)}function ND(t){return ZC(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function CD(t,e,n,r){if(t.rank<2||e.rank<2)throw new S_("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(t.shape," and y shape = ").concat(e.shape));if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new S_("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(t.shape," and ")+" y shape = ".concat(e.shape))}if(2===t.rank&&2===e.rank){return BE({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?AD(t.rank,r,"channelsLast"):null,activation:n})}{const a=t.shape.slice(),s=a.pop();t=BN(t,[-1,s]);const o=e.shape.slice(),i=o.pop(),l=o.pop(),c=[...o,i],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=BN(SE(e,u),[l,-1]);const h=[...a,...c];return BN(BE({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?AD(t.rank,r,"channelsLast"):null,activation:n}),h)}}function ED(t,e,n){return SS((()=>(e=Array.isArray(e)?mE(e,"int32"):gI(e,"int32"),gC(t,e,n))))}function TD(t){return wI(t,t)}function AD(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new k_("Unexpected bias dimensions: ".concat(e.rank)+"; expected it to be 1 or ".concat(t));if(5===t){if("channelsFirst"===n)return 1===r.length?BN(e,[1,r[0],1,1,1]):BN(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?BN(e,[1,1,1,1,r[0]]):BN(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?BN(e,[1,r[0],1,1]):BN(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?BN(e,[1,1,1,r[0]]):BN(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?BN(e,[1,r[0],1]):BN(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?BN(e,[1,1,r[0]]):BN(e,[1].concat(r))}else if(t<3)return e;throw new k_("Unsupported input rank by biasAdd: ".concat(e.rank))}function RD(t,e,n){return SS((()=>(null==n&&(n="channelsLast"),eD(n),bI(t,AD(t.rank,e,n)))))}function FD(t,e,n,r){return SS((()=>IE(t,e,n,r)))}function _D(t,e){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t():e()}const DD=["fanIn","fanOut","fanAvg"],OD=["normal","uniform","truncatedNormal"];class zD extends TI{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class LD extends zD{apply(t,e){return GC(t,e)}}LD.className="Zeros",RI(LD);class MD extends zD{apply(t,e){return HC(t,e)}}MD.className="Ones",RI(MD);class PD extends zD{constructor(t){if(super(),"object"!==typeof t)throw new k_("Expected argument of type ConstantConfig but got ".concat(t));if(void 0===t.value)throw new k_("config must have value set but got ".concat(t));this.value=t.value}apply(t,e){return SS((()=>wI(NI(this.value),HC(t,e))))}getConfig(){return{value:this.value}}}PD.className="Constant",RI(PD);class BD extends zD{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return QC(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}BD.className="RandomUniform",RI(BD);class WD extends zD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new S_("randomNormal does not support dType ".concat(e,"."));return ND(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}WD.className="RandomNormal",RI(WD);class UD extends zD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new S_("truncatedNormal does not support dType ".concat(e,"."));return yE(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}UD.className="TruncatedNormal",RI(UD);class VD extends zD{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return SS((()=>{if(2!==t.length||t[0]!==t[1])throw new k_("Identity matrix initializer can only be used for 2D square matrices.");return wI(this.gain,pC(t[0]))}))}getConfig(){return{gain:this.gain}}}VD.className="Identity",RI(VD);class jD extends zD{constructor(t){if(super(),t.scale<0)throw new k_("scale must be a positive float. Got: ".concat(t.scale));var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,W_(DD,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){W_(OD,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t){let e,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(eD(r),2===t.length)e=t[0],n=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===r){const r=hD(t,2);e=t[1]*r,n=t[0]*r}else if("channelsLast"===r){const r=hD(t,0,t.length-2);e=t[t.length-2]*r,n=t[t.length-1]*r}}else{const r=hD(t);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}(t),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new S_("".concat(this.getClassName()," does not support dType ").concat(e,"."));return yE(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return QC(t,-n,n,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}jD.className="VarianceScaling",RI(jD);class GD extends jD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return jD.className}}GD.className="GlorotUniform",RI(GD);class HD extends jD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return jD.className}}HD.className="GlorotNormal",RI(HD);class KD extends jD{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return jD.className}}KD.className="HeNormal",RI(KD);class qD extends jD{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return jD.className}}qD.className="HeUniform",RI(qD);class XD extends jD{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return jD.className}}XD.className="LeCunNormal",RI(XD);class JD extends jD{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return jD.className}}JD.className="LeCunUniform",RI(JD);class YD extends zD{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return SS((()=>{if(t.length<2)throw new S_("Shape must be at least 2D.");if("int32"!==e&&"float32"!==e&&void 0!==e)throw new TypeError("Unsupported data type ".concat(e,"."));const n=Qb(t.slice(0,-1)),r=t[t.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(a,") elements: ")+"Slowness may result.");const s=ND([Math.max(r,n),Math.min(r,n)],0,1,e,this.seed),o=NT.qr(s,!1);let i=o[0];const l=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return i=wI(i,l.sign()),n<r&&(i=i.transpose()),wI(NI(this.gain),i.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}YD.className="Orthogonal",RI(YD);const ZD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function QD(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return L_(t,AI.getMap().classNameMap,e,"initializer")}function $D(t){return O_(t)}function tO(t){if("string"===typeof t){const e=t in ZD?ZD[t]:t;if("GlorotNormal"===e)return new HD;if("GlorotUniform"===e)return new GD;if("HeNormal"===e)return new KD;if("HeUniform"===e)return new qD;if("LeCunNormal"===e)return new XD;if("LeCunUniform"===e)return new JD;{const t={};return t.className=e,t.config={},QD(t)}}return t instanceof zD?t:QD(t)}function eO(t){return Array.isArray(t)&&Array.isArray(t[0])}function nO(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function rO(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new k_("Expected Tensor length to be 1; got ".concat(t.length));e=t[0]}else e=t;return e}function aO(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new k_("Expected exactly 1 Shape; got ".concat(t.length))}return t}function sO(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const oO="Variable";class iO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:oO,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=K_(),n=null==n?oO:n,this.originalName=iD(n),this.name=lD(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return aS.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function lO(t){return t.map((t=>t.read()))}function cO(t){t.forEach((t=>{t[0].write(t[1])}))}class uO{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class hO{constructor(t,e,n,r,a,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=K_(),null!=s&&(this.originalName=iD(s),this.name=lD(this.originalName)),this.rank=e.length}}let dO=0;class pO{constructor(t,e){this.callArgs=e,this.id=dO++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let fO=0;class gO extends TI{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=fO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=F_(t)+"_"+X_(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new x_("The layer has never been called "+"and thus has no defined ".concat(e,"."));if(this.inboundNodes.length<=t)throw new k_("Asked to get ".concat(e," at node ").concat(t,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[t]}getInputAt(t){return A_(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return A_(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new w_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new w_("Layer ".concat(this.name)+" is not connected, no input to return.");return A_(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new w_("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new w_("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return A_(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=R_(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=R_(this.inputSpec);if(e.length!==n.length)throw new k_("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(e.length," input tensors. ")+"Input received: ".concat(t));for(let r=0;r<e.length;r++){const t=e[r],a=n[r];if(null==a)continue;const s=t.rank;if(null!=a.ndim&&s!==a.ndim)throw new k_("Input ".concat(r," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(s));if(null!=a.maxNDim&&s>a.maxNDim)throw new k_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(s));if(null!=a.minNDim&&s<a.minNDim)throw new k_("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(s,"."));if(null!=a.dtype&&t.dtype!==a.dtype)throw new k_("Input ".concat(r," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(t.dtype,"."));if(a.axes){const e=t.shape;for(const t in a.axes){const n=Number(t),s=a.axes[t],o=n>=0?e[n]:e[e.length+n];if(null!=s&&-1===[s,null].indexOf(o))throw new k_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(s," but got shape ").concat(e,"."))}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){const n=a.shape[e],s=t.shape[e];if(null!=n&&null!=s&&n!==s)throw new k_("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(t.shape,"."))}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=R_(t),r=function(t){let e=!0;for(const n of R_(t))if(!(n instanceof hO)){e=!1;break}return e}(t),a=function(t){let e=!0;for(const n of R_(t))if(n instanceof hO){e=!1;break}return e}(t);if(r===a)throw new k_("Arguments to apply() must be all SymbolicTensors or all Tensors");return oD(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of R_(t))e.push(n.shape);this.build(A_(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let r=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,r);const a=R_(r),s=[];for(let t of a)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=A_(s),null!=this.activityRegularizer)throw new S_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=R_(t);const e=[];for(const n of t)e.push(n.shape);return A_(e)}(t),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new hO(s,n,this,R_(t),e,this.name,r))):new hO(s,r,this,R_(t),e,this.name),this.addInboundNode(t,a,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new S_("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(t),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(t),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new w_("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new w_("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new x_("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return sO(this.weights)}build(t){this.built=!0}getWeights(){return lO(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(t){SS((()=>{const e=this.weights;if(e.length!==t.length)throw new k_('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(t.length,", ")+"but the layer was expecting ".concat(e.length," weights. ")+"Provided weights: ".concat(t,"..."));if(0===e.length)return;const n=[],r=lO(e);for(let a=0;a<r.length;++a){const s=r[a],o=e[a],i=t[a];if(!$b(s.shape,i.shape))throw new k_("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}cO(n)}))}addWeight(t,e,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(t))throw new k_("Duplicate weight name ".concat(t," for layer ").concat(this.name));this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():tO("zeros"));const l=r.apply(e,n),c=new iO(l,n,t,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=R_(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");e.forEach((t=>{if(null!=t)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const r=this.computeMask(t,n),a=R_(e),s=R_(r);if(a.length!==s.length)throw new Error("".concat(this.name," outputs ").concat(a.length," tensors ")+"but ".concat(a.length," masks for those tensors"));for(let o=0;o<a.length;o++)a[o].kerasMask=s[o]}addInboundNode(t,e,n,r,a,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=R_(t);e=R_(e),n=R_(n),r=R_(r),a=nO(a),s=nO(s);const l=[],c=[],u=[];for(const h of i)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new pO({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:i,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let t=0;return 0===--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function mO(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=mO(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class bO extends gO{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:X_("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new k_("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new k_("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new k_("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new hO(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new pO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new k_("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}bO.className="InputLayer",RI(bO);class yO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof yO)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new k_("Duplicate key: name=".concat(t.name,", id=").concat(t.id));return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return gI(e,t.dtype)}catch(w1){throw new k_("The dtype of the feed (".concat(e.dtype,") can not be cast to the dtype ")+"of the key '".concat(t.name,"' (").concat(t.dtype,")."))}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof hO){if(null==this.id2Value[t.id])throw new k_("Nonexistent key: ".concat(t.name));return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new k_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Value[e]}}getMask(t){if(t instanceof hO){if(null==this.id2Value[t.id])throw new k_("Nonexistent key: ".concat(t.name));return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new k_("Feed dict has no SymbolicTensor name: ".concat(t));return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&IS(this.id2Mask)}}const vO=new N_,wO=new N_;function xO(t,e,n,r){const a=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],i=o.map((t=>t.name)),l=[],c=e.names();for(const f of i)-1!==c.indexOf(f)?l.push(e.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=i.join(",")+"|"+e.names().sort().join(",");let h,d=vO.get(u);if(null==d){const t=function(t,e){Jb(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const a=SO(t[0],e);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of t){const{sorted:t,recipientMap:o}=SO(s,e);for(const e of t)a.has(e.name)||(n.push(e),a.add(e.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:kO(r)}}(o,e);d=t.sorted,h=t.recipientCounts,vO.put(u,d),wO.put(u,h)}h={},a||Object.assign(h,wO.get(u));const p=new yO(e);for(let f=0;f<d.length;++f){if(null!=r){const t=kS().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[f],s=t.sourceLayer;if(s instanceof bO)continue;const o=[],c=[],u=[];let g=!1;for(const n of t.inputs){const t=p.getValue(n),r=p.getMask(n);o.push(t),c.push(r),null!=r&&(g=!0),a||(h[n.name]--,0!==h[n.name]||e.hasKey(n)||-1!==i.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||u.push(t))}g&&((n=n||{}).mask=c[0]);const m=R_(s.apply(o,n));let b=null;s.supportsMasking&&(b=s.computeMask(o,c));const y=IO(t),v=Array.isArray(y)?y:[y];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],m[e],Array.isArray(b)?b[0]:b);const t=i.indexOf(v[e].name);-1!==t&&(l[t]=m[e])}a||IS(u)}return p.disposeMasks(),s?l:l[0]}function kO(t){const e={};for(const n in t)e[n]=t[n].size;return e}function SO(t,e){const n=new Set,r=[],a={};for(const i of e.names())n.add(i);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==a[e.name]&&(a[e.name]=new Set),a[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:a}}function IO(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}function NO(t,e){return SS((()=>xI(kC(wI(t,t),e,!0))))}Ay().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=vO&&vO.setMaxEntries(t),null!=wO&&wO.setMaxEntries(t)}));class CO extends TI{getConfig(){return{}}}class EO extends CO{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return SS((()=>{const e=NO(t,this.axis),n=qN(e,0,this.maxValue);return wI(t,vI(n,bI(mD(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}EO.className="MaxNorm",RI(EO);class TO extends CO{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return SS((()=>vI(t,bI(mD(),NO(t,this.axis)))))}getConfig(){return{axis:this.axis}}}TO.className="UnitNorm",RI(TO);class AO extends CO{apply(t){return tE(t)}}AO.className="NonNeg",RI(AO);class RO extends CO{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return SS((()=>{const e=NO(t,this.axis),n=bI(wI(this.rate,qN(e,this.minValue,this.maxValue)),wI(1-this.rate,e));return wI(t,vI(n,bI(mD(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}RO.className="MinMaxNorm",RI(RO);const FO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _O(t){return O_(t)}function DO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return L_(t,AI.getMap().classNameMap,e,"constraint")}function OO(t){if(null==t)return null;if("string"===typeof t){return DO({className:t in FO?FO[t]:t,config:{}})}return t instanceof CO?t:DO(t)}async function zO(t){if(null==t)return;const e=[],n=[],r=[];for(const a in t){const s=t[a];if("number"!==typeof s){const t=s;e.push(t.data()),n.push(a),r.push(t)}}if(e.length>0){const a=await Promise.all(e);for(let e=0;e<a.length;++e)t[n[e]]=a[e][0];IS(r)}}function LO(t){if(null!=t)for(const e in t){const n=t[e];"number"!==typeof n&&n.dispose()}}var MO;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(MO||(MO={}));class PO{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class BO{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class WO extends PO{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"===typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const a=SS((()=>bI(this.totals[r],wI(t,n))));this.totals[r]=a,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?e[n]=this.totals[n]/this.seen:SS((()=>{const t=wI(vI(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),NS(e[n])})))}}class UO extends PO{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const o=r[s];t.push(o.data()),e.push(a),n.push(s)}}const r=await Promise.all(t);for(let a=0;a<r.length;++a){this.history[e[a]][n[a]].dispose(),this.history[e[a]][n[a]]=r[a][0]}}}class VO extends PO{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||TT,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");dy(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,a=null!=n?n():bk();return function(){const s=null!=n?n():bk();return s-a<e||(a=s,r=t(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await zO(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await zO(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await zO(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await zO(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await zO(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):dy(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await zO(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await zO(t),await this.trainEnd(t))}}function jO(t,e){if(null==t&&(t={}),t instanceof PO)return[t];if(Array.isArray(t)&&t[0]instanceof PO)return t;return R_(t).map((t=>new VO(t,e)))}class GO{constructor(){}static registerCallbackConstructor(t,e){Jb(t>=0&&Number.isInteger(t),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(t))),GO.checkForDuplicate(e),null==GO.constructors[t]&&(GO.constructors[t]=[]),GO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in GO.constructors){GO.constructors[+e].forEach((e=>{if(e===t)throw new k_("Duplicate callback constructor.")}))}}static clear(){GO.constructors={}}static createCallbacks(t){const e=[];for(const n in GO.constructors){const r=+n;t>=r&&e.push(...GO.constructors[r])}return e.map((t=>new t))}}function HO(t,e,n,r,a,s,o,i,l){const c=new UO,u=[new WO,...GO.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new BO(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:c}}function KO(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return L_(t,AI.getMap().classNameMap,e,"layer",n)}function qO(t,e){return SS((()=>{"float32"!==t.dtype&&(t=gI(t,"float32"));const n=kC(TD(t),e,!0),r=DI(n.shape,mD()),a=xI(VI(n,r));return vI(t,a)}))}function XO(t,e){return SS((()=>MC(TD(LI(e,t)),-1)))}function JO(t,e){return SS((()=>MC(PI(LI(e,t)),-1)))}function YO(t,e){return SS((()=>{const n=LI(t,e),r=qN(PI(t),mD(),Number.MAX_VALUE),a=PI(vI(n,r));return wI(100,MC(a,-1))}))}function ZO(t,e){return SS((()=>{const n=qN(e,mD(),Number.MAX_VALUE),r=vC(bI(1,n)),a=qN(t,mD(),Number.MAX_VALUE),s=vC(bI(1,a));return MC(TD(LI(r,s)),-1)}))}function QO(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return SS((()=>{if(n)e=uE(e);else{const t=kC(e,e.shape.length-1,!0);e=vI(e,t)}return e=qN(e,mD(),1-mD()),UC(kC(wI(gI(t,"float32"),vC(e)),e.shape.length-1))}))}function $O(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return SS((()=>{const r=gI(fC(function(t){const e=[hD(t.shape)];return BN(t,e)}(t)),"int32"),a=(e=qN(e,mD(),1-mD())).shape;return QO(BN(jC(r,a[a.length-1]),a),e,n)}))}function tz(t,e){return SS((()=>{let n;return n=qN(e,mD(),1-mD()),n=vC(vI(n,LI(1,n))),MC(function(t,e){if(!$b(t.shape,e.shape))throw new k_("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(t.shape)," and ").concat(JSON.stringify(e.shape)));return SS((()=>{const n=tE(e),r=UC(PI(e));return bI(LI(n,wI(e,t)),wC(uC(r)))}))}(t,n),-1)}))}function ez(t,e){return SS((()=>{const n=qN(t,mD(),1),r=qN(e,mD(),1);return kC(wI(t,vC(vI(n,r))),-1)}))}function nz(t,e){return SS((()=>{const n=qO(t,-1),r=qO(e,-1),a=wI(n,r);return UC(kC(a,-1))}))}GO.constructors={};const rz={meanSquaredError:XO,meanAbsoluteError:JO,meanAbsolutePercentageError:YO,meanSquaredLogarithmicError:ZO,squaredHinge:function(t,e){return SS((()=>{const n=VI(0,LI(1,wI(t,e)));return MC(TD(n),-1)}))},hinge:function(t,e){return SS((()=>{const n=VI(0,LI(1,wI(t,e)));return MC(n,-1)}))},categoricalHinge:function(t,e){return SS((()=>{const n=kC(wI(t,e),-1),r=xC(wI(LI(1,t),e),-1);return VI(0,bI(1,LI(r,n)))}))},logcosh:function(t,e){return SS((()=>{const n=Math.log(2),r=LI(e,t),a=LI(bI(r,hE(wI(-2,r))),n);return MC(a,-1)}))},categoricalCrossentropy:QO,sparseCategoricalCrossentropy:$O,binaryCrossentropy:tz,kullbackLeiblerDivergence:ez,poisson:function(t,e){return SS((()=>{const n=vC(bI(mD(),e));return MC(LI(e,wI(t,n)),-1)}))},cosineProximity:nz};function az(t){if("string"===typeof t){if(t in rz)return rz[t];let e="Unknown loss ".concat(t);throw t.toLowerCase().includes("softmaxcrossentropy")&&(e="Unknown loss ".concat(t,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new k_(e)}return t}function sz(t,e){return SS((()=>{const n=wI(.5,KC(e)),r=bD(mC(e,n),t.dtype);return MC(cC(t,r),-1)}))}function oz(t,e){return SS((()=>bD(cC(SN(t,-1),SN(e,-1)),"float32")))}function iz(t,e){return SS((()=>gI(kC(DC(cC(t,1),cC(e,1))),"float32")))}function lz(t,e){return tz(t,e)}function cz(t,e){return t.rank===e.rank&&(t=pE(t,[t.rank-1])),(e=SN(e,-1)).dtype!==t.dtype&&(e=gI(e,t.dtype)),gI(cC(t,e),"float32")}const uz=QO,hz=$O,dz={binaryAccuracy:sz,categoricalAccuracy:oz,precision:function(t,e){return SS((()=>{const n=iz(t,e),r=function(t,e){return SS((()=>gI(kC(DC(cC(t,0),cC(e,1))),"float32")))}(t,e),a=bI(n,r);return gI(wE(mC(a,0),vI(n,a),0),"float32")}))},categoricalCrossentropy:uz,sparseCategoricalCrossentropy:hz,mse:XO,MSE:XO,mae:JO,MAE:JO,mape:YO,MAPE:YO,cosine:nz};function pz(t){if("string"===typeof t&&t in dz)return dz[t];if("string"!==typeof t&&null!=t)return t;throw new k_("Unknown metric ".concat(t))}function fz(t){if(E_(null!==t,"Unknown LossOrMetricFn ".concat(t)),"string"===typeof t)return t;{let e;for(const n of Object.keys(rz))if(rz[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(dz))if(dz[n]===t){e=n;break}return void 0!==e?e:t.name}}const gz=1048576;function mz(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t||"object"!==typeof t||Object.getPrototypeOf(t)!==Object.prototype||!bz(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>gz&&console.warn('User-defined metadata of model "'.concat(e,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(gz,"."))}}function bz(t){if(null===t)return!0;if("object"===typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!==typeof n)return!1;if(!bz(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!bz(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function yz(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(t){let e=!0;const n=[],r=[];for(const a in t.nodesByDepth)n.push(t.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){e=!1;break}r.push(...a)}if(e)for(const a of t.layers){let t=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!a){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),vz(s,n,r),r("=".repeat(e));const i=t.layers;for(let u=0;u<i.length;++u)a?wz(i[u],n,r):xz(i[u],n,o,r),r((u===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?sO(t.collectedTrainableWeights):sO(t.trainableWeights);return e}(t),c=sO(t.nonTrainableWeights);r("Total params: ".concat(l+c)),r("Trainable params: ".concat(l)),r("Non-trainable params: ".concat(c)),r("_".repeat(e))}function vz(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<t.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=t[a],r=r.slice(0,e[a]),r+=" ".repeat(e[a]-r.length);n(r)}function wz(t,e,n){let r,a;try{a=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(w1){a="multiple"}try{r=JSON.stringify(t.outputShape)}catch(w1){r="multiple"}const s=t.name,o=t.getClassName();vz(["".concat(s," (").concat(o,")"),a,r,t.countParams().toString()],e,n)}function xz(t,e,n,r){let a,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(w1){s="multiple"}try{a=JSON.stringify(t.outputShape)}catch(w1){a="multiple"}const o=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t){const e=u.inboundLayers[t].name,n=u.nodeIndices[t],r=u.tensorIndices[t];o.push("".concat(e,"[").concat(n,"][").concat(r,"]"))}const i=t.name,l=t.getClassName(),c=0===o.length?"":o[0];vz(["".concat(i," (").concat(l,")"),s,a,t.countParams().toString(),c],e,r);for(let u=1;u<o.length;++u)vz(["","","","",o[u]],e,r)}function kz(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"===typeof n}function Sz(t,e){if(null===t)return null;if("string"===typeof t)return __(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];kz(e,a,r)?n.push(r):n.push(Sz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"===typeof r)e[n]=r;else{const t=__(n);e[t]=Sz(r,t)}}return e}}function Iz(t,e){if(null===t||void 0===t)return null;if("string"===typeof t)return F_(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let a=0;a<r;++a){const r=t[a];kz(e,a,r)?n.push(r):n.push(Iz(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n],a=F_(n);e[a]="name"!==n&&"className"!==n||"string"!==typeof r?Iz(r,n):r}return e}}const Nz="4.17.0";class Cz extends gO{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=X_(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],P_(this.inputs).length!==this.inputs.length)throw new k_("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((t=>t.name))));P_(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((t=>t.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const t=b.sourceLayer,e=b.nodeIndex,n=b.tensorIndex;E_(0===e,"input layer has >1 nodes"),E_(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const e=this.inputLayers[b];if(!(e instanceof bO))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(t.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(e.getClassName(),"."));this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},a={},s={},o=[],i=(t,e,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new x_("The tensor ".concat(t.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==e.indexOf(c))return;this.containerNodes.add(Cz.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let s=0;s<u;s++){const t=c.inputTensors[s],r=c.inboundLayers[s],a=c.nodeIndices[s],o=c.tensorIndices[s];i(t,e,n,r,a,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const b of this.outputs)i(b,l,c);const u=o.slice().reverse();for(const b of u){n[b.id]=b,b.id in e||(e[b.id]=0);let t=e[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];t=Math.max(t,s),r[b.outboundLayer.id]=t,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=t;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],o=a.inboundNodes[s],i=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(t+1,i),n[o.id]=o}}const h={};for(const b in e){const t=e[b];t in h||(h[t]=[]),h[t].push(n[b])}const d={};for(const b in r){const t=r[b];t in d||(d[t]=[]),d[t].push(a[b])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(M_);this.layers=[];for(const b of p){const t=d[b];t.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Cz&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(M_);const f=this.inputs.slice(),g=[];for(const b of p)for(const t of h[b]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new x_("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(e.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const e of t.outputTensors)f.push(e);g.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map((t=>t.name));for(const b of m){const t=m.filter((t=>t===b)).length;if(1!==t)throw new x_('The name "'.concat(b,'" is used ').concat(t," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new pO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new k_("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(t=>{const e=Object.keys(t);if(0===e.length)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[t,e]of o.weights.entries()){const s=a?"".concat(e.name.split("/").slice(0,-1).join("/")+"/").concat(t):e.originalName;if(null!=n[s])throw new k_("Duplicate weight name: ".concat(s));n[s]=e,r++}const s=[];for(const o in t){let r=o;if(null==n[o]){const t=o.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[o]]);else if(e)throw new k_("Provided weight data has no target variable: ".concat(o));delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new k_("".concat(t.length," of ").concat(r," weights are not set: ")+"".concat(t))}cO(s)}parseWeights(t){for(const e in Object.keys(t)){const n=e.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((t=>t.startsWith("_")?t.slice(1):t)).filter((t=>!r.includes(t))).join("/");a!==e&&(t[a]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers ".concat(Nz),e.backend="TensorFlow.js",e}toJSON(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Iz(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return SS((()=>{t=R_(t);const n=new yO;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return xO(this.outputs,n,e)}))}computeMask(t,e){return SS((()=>{let n;return t=R_(t),n=null==e?C_(null,t.length):R_(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=nO(t);if(e.length!==this.inputLayers.length)throw new k_("Invalid inputShape argument ".concat(t,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<e.length;o++){const t=this.inputLayers[o],r=e[o];n[t.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(M_);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],a=e.nodeIndices[o],s=e.tensorIndices[o],i=n["".concat(t.name,"_").concat(a,"_").concat(s)];r.push(i)}const a=nO(t.computeOutputShape(A_(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n["".concat(t.name,"_").concat(s,"_").concat(e)]=a[e]}}}const a=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],e=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r="".concat(t.name,"_").concat(e,"_").concat(n);s.push(r)}for(let o=0;o<s.length;o++){const t=s[o];E_(t in n),a.push(n[t])}return A_(a)}runInternalGraph(t,e){null==e&&(e=C_(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],a=t[i],s=e[i];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(M_);for(const i of r){const t=this.nodesByDepth[i];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),i=R_(t.call(e,c)),l=R_(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),i=R_(t.call(r,c)),l=R_(t.computeMask(r,o));if(t.activityRegularizer)throw new S_("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<a.length;++t){const e=a[t],r=i[t],s=l[t];n[e.id]=[r,s]}}}}const a=[],s=[],o=[];for(const i of this.outputs){E_(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[t,e]=n[i.id];o.push(t.shape),a.push(t),s.push(e)}return[a,s,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof Cz?1:0;for(let t=0;t<r.inboundNodes.length;t++){const a=Cz.nodeKey(r,t);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new k_("Provide either a layer name or layer index");if("number"===typeof t)return this.findLayer(t);for(const n of this.layers)if(n.name===t)return n;throw new k_("No such layer: ".concat(t))}findLayer(t){if(this.layers.length<=t)throw new k_("Was asked to retrieve layer at index ".concat(t,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[t]}calculateLosses(){return SS((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=Cz.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const t=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const t=s.inboundNodes[n],r=Cz.nodeKey(s,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(w1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(t.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const a=t.inboundLayers[r],s=t.nodeIndices[r],i=t.tensorIndices[r];let l=e[Cz.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=s.name,o.className=t,o.config=r,o.inboundNodes=a,n.push(o)}t.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const t=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=Cz.nodeKey(t,n);if(!this.containerNodes.has(a))continue;let o=e[a];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];r.push([t.name,o,i])}t.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=Cz.nodeKey(t,n);if(!this.containerNodes.has(r))continue;let o=e[r];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];a.push([t.name,o,i])}return t.outputLayers=a,t}static fromConfig(t,e){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(t,e){t.name in a?a[t.name].push(e):a[t.name]=[e]}function o(t,e){const n=[];let a;for(const o of e){const i=o[0],l=o[1],c=o[2];if(a=null==o[3]?{}:o[3],!(i in r))return void s(t,e);const u=r[i];if(u.inboundNodes.length<=l)return void s(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(A_(n),a)}function i(t){const a=t.name,o=KO(t,null!=e.customObjects?e.customObjects:{});o.setFastWeightInitDuringBuild(n),r[a]=o;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new k_("Corrupted configuration, expected array for nodeData: ".concat(t));s(o,t)}))}const l=e.name,c=e.layers;for(const f of c)i(f);for(;!B_(a);)for(const t of c){const e=r[t.name];if(e.name in a){const t=a[e.name];delete a[e.name];for(const n of t)o(e,n)}}const u=[],h=[],d=e.inputLayers;for(const f of d){const t=f[0],e=f[1],n=f[2];E_(t in r);const a=r[t].inboundNodes[e].outputTensors;u.push(a[n])}const p=e.outputLayers;for(const f of p){const t=f[0],e=f[1],n=f[2];E_(t in r);const a=r[t].inboundNodes[e].outputTensors;h.push(a[n])}return new t({inputs:u,outputs:h,name:l})}get stateful(){if(this._stateful)throw new k_("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){SS((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function Ez(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"===typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(t.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return t}if("object"===typeof t&&Object.keys(t).length>0&&"object"===typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(e," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(t)))}function Tz(t,e){return Ez(t,e,"classWeight")}async function Az(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=SS((()=>{if(1===t.shape.length)return mI(t);if(2===t.shape.length){if(t.shape[1]>1){return SN(t,1)}if(1===t.shape[1])return BN(t,[t.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await e.data());IS(e);const a=[];return r.forEach((t=>{if(null==n[t])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(t," exists in the data but not in ")+"classWeight");a.push(n[t])})),mE(a,"float32")}return null}function Rz(t,e){return wI(t,e)}function Fz(t,e){let n,r;const a=e;n=a.xs,r=a.ys,Jb(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(e)));const s=_z("input",t.inputNames,n),o=_z("output",t.outputNames,r),i=s[0].shape[0];Jb(s.length===t.inputs.length,(()=>"LayersModel has ".concat(t.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(t.inputNames),")"))),Jb(o.length===t.outputs.length,(()=>"LayersModel has ".concat(t.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(t.outputNames),")")));for(let l=0;l<s.length;l++)Jb(s[l].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(t.inputNames[l]," has ").concat(s[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));for(let l=0;l<o.length;l++)Jb(o[l].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(t.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(t.inputNames[0],".")));return{xs:s,ys:o}}function _z(t,e,n){if(n instanceof Mk)return[n];if(Array.isArray(n))return Jb(n.length===e.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(e.length," to match the ").concat(t," keys ").concat(e,"."))),n;{const r=[];for(const a of e){if(null==n[a])throw new k_("The feature data generated by the dataset lacks the required "+"".concat(t," key '").concat(a,"'."));r.push(n[a])}return r}}async function Dz(t,e,n){const r=null!=n.batchesPerEpoch;if(Jb(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Jb(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Jb(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Jb(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Jb(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(Oz(n.validationData))Jb(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const t=function(t){if(3===t.length)throw new S_("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let c;c=a?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const u=jO(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=HO(u,h,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,a,c);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let u=0,h=0;for(r||(g=await e.iterator());!r||u<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:a}=Fz(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=Tz(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await Az(a[t],null,e[t]))}const c=r.concat(a).concat(o),p=i(c);IS(c);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,NS(n)}await d.onBatchEnd(h,s),LO(s),h++,u++}if(r?u>=n.batchesPerEpoch:e.done){if(a){let e;e=Oz(n.validationData)?R_(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):R_(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c["val_".concat(t.metricsNames[n])]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Oz(t){return"function"===typeof t.iterator}function zz(t){Jb(t>0&&Number.isInteger(t),(()=>"batchSize is required to be a positive integer, but got ".concat(t)))}function Lz(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>vD(t,e,n-e))):vD(t,e,n-e)}function Mz(t,e){return SS((()=>null==t?null:Array.isArray(t)?t.map((t=>Mz(t,e))):ED(t,"int32"===e.dtype?e:gI(e,"int32"))))}function Pz(t,e){const n=[];let r=0,a=null;for(;r<t;)a=r+e,a>=t&&(a=t),n.push([r,a]),r=a;return n}function Bz(t){const e=[];t instanceof Mk&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(yD(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Wz(t,e){if(null==t)return;const n=[];if(e instanceof Mk)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const a in e){const t=e[a];n.push(t.id)}const r=[];if(t instanceof Mk)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const a in t){const e=t[a];-1===n.indexOf(e.id)&&r.push(e)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function Uz(t){return Array.isArray(t)}function Vz(t){return!function(t){return t instanceof Mk}(t)&&!Uz(t)}function jz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==e||0===e.length){if(null!=t){let e=!1;if(Uz(t)&&t.length>0)e=!0;else if(Vz(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new k_("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(t))}return[]}if(null==t)return e.map((t=>null));if(Vz(t)){r=[];for(const n of e){if(null==t[n])throw new k_('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(e));r.push(t[n])}}else if(Uz(t)){if(t.length!==e.length)throw new k_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(e.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(t));r=t}else{if(e.length>1)throw new k_("The model ".concat(s," expects ").concat(e.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(t.shape));r=[t]}if(r=Bz(r),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new k_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(t.shape));for(let e=0;e<n[o].length;++e){if(0===e&&!a)continue;const r=t.shape[e],i=n[o][e];if(null!=i&&i>=0&&r!==i)throw new k_("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(t.shape[0])+" examples, each with shape [".concat(t.shape.slice(1,t.shape.length),"]")+" (tensor shape [".concat(t.shape,"])"))}}return r}function Gz(t,e,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(t)){if(t.length!==e.length)throw new k_("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(e.length," Tensor(s),")+" but instead got ".concat(t.length," Tensors(s)."));r=t}else{if(e.length>1)throw new k_("The model expects ".concat(e.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(t.shape),"."));r=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=r[o];if(t.shape.length!==n[o].length)throw new k_("Error when checking ".concat(s,": expected ").concat(e[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(t.shape)));for(let r=0;r<n[o].length;++r){if(0===r&&!a)continue;const i=t.shape[r],l=n[o][r];if(null!=l&&l!==i)throw new k_("Error when checking ".concat(s,": expected ")+"".concat(e[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(t.shape),"."))}}}class Hz extends Cz{constructor(t){super(t),this.isTraining=!1}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new k_("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");yz(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"===typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>CT.adagrad(.01),Adadelta:()=>CT.adadelta(1,.95,mD()),Adam:()=>CT.adam(.001,.9,.999,mD()),Adamax:()=>CT.adamax(.002,.9,.999,mD(),0),RMSProp:()=>CT.rmsprop(.001,.9,0,mD()),SGD:()=>CT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new k_("Unknown Optimizer ".concat(t))}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof FI))throw new k_("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"===typeof t.loss||"function"===typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new k_("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(t.loss,"."));const n=t.loss;e=n.map((t=>az(t)))}else{const n=az(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new k_('Unknown entry in loss dictionary: "'.concat(e,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==t.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),e.push(az(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const t=this.internalOutputShapes[s],e=this.outputNames[s];this.feedOutputNames.push(e),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],oD("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"===typeof t||"function"===typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!==typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(t));n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),a=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};oD("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,r,s;for(const o of e){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let a;1===e[e.length-1]||this.lossFunctions[t]===tz?-1!==["accuracy","acc"].indexOf(o)?r=sz:-1!==["crossentropy","ce"].indexOf(o)&&(r=lz):this.lossFunctions[t]===$O?-1!==["accuracy","acc"].indexOf(o)?r=cz:-1!==["crossentropy","ce"].indexOf(o)&&(r=hz):-1!==["accuracy","acc"].indexOf(o)?r=oz:-1!==["crossentropy","ce"].indexOf(o)&&(r=uz),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const t=pz(o);s=t,n=""+fz(o)}let e;oD(n,(()=>{e=s})),a(t,n,e)}})(r[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;zz(r);const a=this.standardizeUserDataXY(t,e,!0,r);try{const t=a[0].concat(a[1]);this.makeTestFunction();const e=this.testFunction;return A_(this.testLoop(e,t,r,n.verbose,n.steps))}finally{Wz(a[0],t),Wz(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,a=t.testFunction;let s=[];if(n.verbose>0)throw new S_("Verbose mode is not implemented yet.");Jb(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof e.next?e:await e.iterator();let i=0,l=0;for(;!r||l<n.batches;){const e=await o.next();if(s=SS((()=>{if(e.value){const{xs:n,ys:r}=Fz(t,e.value),o=n.concat(r),c=SS((()=>a(o)));if(IS(o),0===l)for(let t=0;t<c.length;++t)s.push(NI(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=SS((()=>bI(s[t],wI(u,e)))),l>0&&IS(n)}IS(c),i+=u,++l}return s})),e.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<s.length;++c){const t=s[c];s[c]=vI(s[c],i),IS(t)}return A_(s)}(this,t,e)}checkNumSamples(t,e,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=e)throw new k_("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(e))}else{if(null==t)throw new k_("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new k_("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],a=this.retrieveSymbolicTensors(r),s=new yO;if(t instanceof Mk&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new k_("The number of inputs provided (".concat(t.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const i of this.inputs){const e=t[i.name];if(null==e)throw new k_("No value is provided for the model's input ".concat(i.name));s.add(i,e)}const o=xO(a,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=C_(null,t.length);let n=t.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((t=>t.name));for(let r=0;r<t.length;++r){const o=s.indexOf(t[r]);if(-1!==o&&(e[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new k_("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return e}predictLoop(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return SS((()=>{const r=this.checkNumSamples(t);if(n)throw new S_("Verbose predictLoop() is not implemented yet.");const a=Pz(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<a.length;++e){SS((()=>{const n=a[e][0],r=a[e][1],s=Lz(t,n,r),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const i=new yO(o);return xO(this.outputs,i)})).forEach(((t,e)=>s[e].push(t)))}return A_(s.map((t=>XN(t,0))))}))}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Bz(t);Gz(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return zz(t),this.predictLoop(n,t)}finally{Wz(n,t)}}predictOnBatch(t){Gz(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new x_("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const t=this.feedOutputShapes[a];this.feedLossFns[a]===$O?r.push(t.slice(0,t.length-1).concat([1])):r.push(t)}if(function(t,e,n){const r=P_(t.map((t=>t.shape[0])));r.sort();const a=P_(e.map((t=>t.shape[0])));if(a.sort(),r.length>1)throw new k_("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((t=>t.shape)))));if(a.length>1)throw new k_("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((t=>t.shape)))));if(r.length>0&&a.length>0&&!$b(r,a))throw new k_("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(t=jz(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=jz(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const r=[XO,tz,QO];for(let a=0;a<t.length;++a){const s=t[a],o=e[a],i=n[a];if(null!=o){if(o===QO&&1===s.shape[s.shape.length-1])throw new k_("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o)){const t=s.shape.slice(1),e=i.slice(1);for(let n=0;n<t.length;++n){const r=t[n],a=e[n];if(null!=a&&r!==a)throw new k_("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&t[0].shape[0]%n!==0)throw new k_("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(t[0].shape[0]," sample(s)."));return[t,e]}async standardizeUserData(t,e,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(t,e,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Tz(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await Az(i[e],null,t[e]))}return[o,i,l]}testLoop(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return SS((()=>{const s=this.checkNumSamples(e,n,a,"steps"),o=[];if(r>0)throw new S_("Verbose mode is not implemented yet.");if(null!=a)throw new S_("steps mode in testLoop() is not implemented yet");{const r=Pz(s,n),a=mE(fD(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=vD(a,s,i-s),c=Mz(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(NI(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=bI(o[t],wI(i-s,e))}}for(let t=0;t<o.length;++t)o[t]=vI(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let a=r;if(T_(t,r)>1){const e=T_(t.slice(0,n),r);a+="_".concat(e)}e.push(a)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new yO(t),i=xO(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],i[n]);null!=a[n]&&(t=Rz(t,a[n]));const s=MC(t);e.push(s),l=0===n?t:bI(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][0],a=this.metricsTensors[n][1];t=MC(e(r[a],i[a]))}NS(t),s.push(t)}return l=MC(l),this.calculateLosses().forEach((t=>{l=bI(l,t)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>SS((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const o=new yO(s),i=xO(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=MC(r(a[t],i[t]));n=0===t?s:bI(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=MC(n(a[r],i[r]));e.push(s)}return e}))}async fit(t,e){let n,r,a,s,o,i,l,c,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;zz(d);const p=!1,f=await this.standardizeUserData(t,e,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],u=f[2];let g,m=!1;if(null!=h.validationData&&h.validationData.length>0){if(m=!0,2!==h.validationData.length)throw 3===h.validationData.length?new S_("validationData including sample weights is not supported yet."):new k_("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));o=h.validationData[0],i=h.validationData[1];const t=!0,e=await this.standardizeUserData(o,i,null,null,t,d);l=e[0],c=e[1],g=l.concat(c)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){m=!0;const t=Math.floor(n[0].shape[0]*(1-h.validationSplit)),e=n[0].shape[0];l=Lz(n,t,e),a=n,n=Lz(n,0,t),c=Lz(r,t,e),s=r,r=Lz(r,0,t),g=l.concat(c)}else null!=h.validationSteps&&(m=!0);const b=n.concat(r).concat(u);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,x;m?(this.makeTestFunction(),w=this.testFunction,x=v.slice().concat(v.map((t=>"val_"+t)))):(w=null,g=[],x=v.slice());const k=jO(h.callbacks,h.yieldEvery);return await this.fitLoop(y,b,v,d,h.epochs,h.verbose,k,w,g,h.shuffle,x,h.initialEpoch,null,null)}finally{this.isTraining=!1,Wz(n,t),Wz(r,e),Wz(a,t),Wz(s,e),Wz(l,o),Wz(c,i),null!=u&&IS(u)}}async fitLoop(t,e,n,r,a,s,o,i,l,c,u,h,d,p){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0);let f=!1;if(null!=i&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new k_("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(e,r,d,"steps_per_epoch");let m;null!=g&&(m=fD(0,g)),null==s&&(s=1);const{callbackList:b,history:y}=HO(o,s,a,h,g,d,r,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<a;++v){await b.onEpochBegin(v);const a={};if(null!=d)throw new S_("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new S_("batch shuffling is not implemneted yet");c&&Hb(m);const s=mE(m),o=Pz(g,r);for(let c=0;c<o.length;++c){const u={};if(await b.onBatchBegin(c,u),SS((()=>{const h=o[c][0],d=o[c][1],p=vD(s,h,d-h);u.batch=c,u.size=d-h;const g=Mz(e,p),m=t(g);for(let t=0;t<n.length;++t){const e=n[t],r=m[t];u[e]=r,NS(r)}if(c===o.length-1&&f){const t=this.testLoop(i,l,r);for(let e=0;e<n.length;++e){const r=n[e],s=t[e];NS(s),a["val_"+r]=s}}})),await b.onBatchEnd(c,u),LO(u),this.stopTraining_)break}s.dispose()}if(await b.onEpochEnd(v,a),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Dz(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const i of s){const t=await i.data();o.push(t[0])}return IS(s),Wz(n[0],t),Wz(n[1],e),A_(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:a[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=kS().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-kS().numTensors}return t}getLossIdentifiers(){let t;if("string"===typeof this.loss)t=F_(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!==typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>F_(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=F_(n[r])}}return t}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[F_(fz(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>F_(fz(t))));{const t={};for(const e in this.metrics)t[e]=F_(fz(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=KO(Sz(t.optimizer_config));let n,r;if("string"===typeof t.loss)n=__(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>__(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=__(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>__(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=__(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"===typeof t){const e=(n=t,WS.getSaveHandlers(n));if(0===e.length)throw new k_("Cannot find any save handlers for URL '".concat(t,"'"));if(e.length>1)throw new k_("Found more than one (".concat(e.length,") save handlers for ")+"URL '".concat(t,"'"));t=e[0]}var n;if(null==t.save)throw new k_("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await AS(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Nz),convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await AS(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=(s=[r.data,e],wS.join(s))}var s;if(null!=this.userDefinedMetadata){const t=!0;mz(this.userDefinedMetadata,this.name,t),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,t.save(a)}setUserDefinedMetadata(t){mz(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Hz.className="Model",RI(Hz);class Kz extends Hz{}async function qz(t,e){if(null==e&&(e={}),"string"===typeof t){const a=(n=t,r=e,WS.getLoadHandlers(n,r));if(0===a.length)a.push(function(t,e){return eN(t,e)}(t,e));else if(a.length>1)throw new k_("Found more than one (".concat(a.length,") load handlers for ")+"URL '".concat(t,"'"));t=a[0]}var n,r;return async function(t,e,n){null==n&&(n={});if(null==t.load)throw new k_("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let a=r.modelTopology;null!=a.model_config&&(a=a.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,i=KO(Sz(a),e,o),l=r.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=r.userDefinedMetadata&&i.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new k_("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=RS(t,e),r={},a=[];return e.forEach((t=>{"optimizer"===t.group?a.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);i.loadWeights(t,s),null!=i.optimizer&&e.length>0&&await i.optimizer.setWeights(e),IS(t),IS(e.map((t=>t.tensor)))}return i}(t,void 0,e)}Kz.className="Functional",RI(Kz);class Xz extends Hz{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:X_("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new k_("Negative dimension size caused by adding layer "+"".concat(t.name," with input shape [")+"".concat(t.inboundNodes[0].inputTensors[0].shape,"]"))}add(t){const e=t instanceof Xz||t instanceof Hz;let n;if(e){if(n=t,1!==n.outputs.length)throw new k_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new k_("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new k_("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new k_("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new bO({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new k_("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(t.name," ")+"which has ".concat(t.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new k_("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=mO(this.outputs[0])}this.inboundNodes=[],new pO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:C_(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(aO(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Hz({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new x_("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new x_("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new x_("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new x_("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new k_("Legacy serialization format not supported yet.");n=e}else Jb(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=e.layers,delete e.layers,a=e;const s=new t(a);if(!(s instanceof Xz))throw new S_("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const t=KO(o,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(t){if(null==this.model)throw new k_("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new k_("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}Xz.className="Sequential",RI(Xz);class Jz extends TI{getConfig(){return{}}}class Yz extends Jz{apply(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==e)throw new S_("Support for alpha values other than 1 (".concat(e,") is not implemented ")+"yet.");return lC(t)}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Yz.className="elu",RI(Yz);class Zz extends Jz{apply(t){return nE(t)}}Zz.className="selu",RI(Zz);class Qz extends Jz{apply(t){return tE(t)}}Qz.className="relu",RI(Qz);class $z extends Jz{apply(t){return SS((()=>BC(6,tE(t))))}}$z.className="relu6",RI($z);class tL extends Jz{apply(t){return t}}tL.className="linear",RI(tL);class eL extends Jz{apply(t){return aE(t)}}eL.className="sigmoid",RI(eL);class nL extends Jz{apply(t){return function(t){return SS((()=>{const e=bI(.5,wI(.2,t));return qN(e,0,1)}))}(t)}}nL.className="hardSigmoid",RI(nL);class rL extends Jz{apply(t){return hE(t)}}rL.className="softplus",RI(rL);class aL extends Jz{apply(t){return function(t){return SS((()=>vI(t,bI(PI(t),1))))}(t)}}aL.className="softsign",RI(aL);class sL extends Jz{apply(t){return gE(t)}}sL.className="tanh",RI(sL);class oL extends Jz{apply(t){return uE(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}oL.className="softmax",RI(oL);class iL extends Jz{apply(t){return SC(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}iL.className="logSoftmax",RI(iL);class lL extends Jz{apply(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return SS((()=>wI(aE(wI(t,e)),t)))}}lL.className="swish",RI(lL);class cL extends Jz{apply(t){return SS((()=>wI(t,gE(hE(t)))))}}function uL(t){return t.getClassName()}function hL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return L_(t,AI.getMap().classNameMap,e,"activation")}function dL(t){if(null==t){const t={className:"linear",config:{}};return hL(t)}if("string"===typeof t){const e={};return e.className=t,e.config={},hL(e)}return t instanceof Jz?t:hL(t)}function pL(t){if(null!=t&&"object"!==typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(t))}cL.className="mish",RI(cL);class fL extends TI{}class gL extends fL{constructor(t){super(),pL(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return SS((()=>{let e=GC([1]);return this.hasL1&&(e=bI(e,kC(wI(this.l1,PI(t))))),this.hasL2&&(e=bI(e,kC(wI(this.l2,TD(t))))),BN(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}gL.className="L1L2",RI(gL);const mL={l1l2:"L1L2"};function bL(t){return O_(t)}function yL(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return L_(t,AI.getMap().classNameMap,e,"regularizer")}function vL(t){if(null==t)return null;if("string"===typeof t){return yL({className:t in mL?mL[t]:t,config:{}})}return t instanceof fL?t:yL(t)}class wL extends gO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=rO(t);let n=tE(t);return null!=this.maxValue&&(n=qN(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}wL.className="ReLU",RI(wL);class xL extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=rO(t);return yC(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}xL.className="LeakyReLU",RI(xL);class kL extends gO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=tO(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vL(t.alphaRegularizer),this.alphaConstraint=OO(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!==typeof t.sharedAxes)throw new k_("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(t.sharedAxes));this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=aO(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new uO({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=rO(t),XC(t,this.alpha.read())}getConfig(){const t={alphaInitializer:$D(this.alphaInitializer),alphaRegularizer:bL(this.alphaRegularizer),alphaConstraint:_O(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}kL.className="PReLU",RI(kL);class SL extends gO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new S_("Non-default alpha value (".concat(t.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=rO(t);return lC(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}SL.className="ELU",RI(SL);class IL extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=rO(t);return wI(n,gI(mC(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}IL.className="ThresholdedReLU",RI(IL);class NL extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new oL).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){return SS((()=>{let n=rO(t);const r=e.mask;if(null!=r){const t=wI(LI(HC(n.shape),gI(r,n.dtype)),NI(-1e9));n=bI(n,t)}return this.axis instanceof Array?this.axis.length>1?uC(LI(n,_C(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function CL(t,e,n){if("number"===typeof t)return C_(t,e);if(t.length!==e)throw new k_("The ".concat(n," argument must be an integer or tuple of ").concat(e," integers.")+" Received: ".concat(t.length," elements."));for(let a=0;a<e;++a){const s=t[a];if((r=s)!==parseInt(r.toString(),10))throw new k_("The ".concat(n," argument must be an integer or tuple of ").concat(e)+" integers. Received: ".concat(JSON.stringify(t)," including a")+" non-integer number ".concat(s))}return t;var r}function EL(t,e,n,r){if(null==t)return t;let a;return a="same"===n?t:t-(e+(e-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function TL(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+pD([n-e,0]);else{if("same"!==r)throw new k_("Unsupport padding mode: ".concat(r,"."));t*=e}return t}function AL(t,e){return SS((()=>(eD(e),"channelsFirst"===e?SE(t,[0,2,3,1]):t)))}function RL(t,e){return SS((()=>(eD(e),"channelsFirst"===e?SE(t,[0,2,3,4,1]):t)))}function FL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return SS((()=>{if(null==s&&(s="channelsLast"),eD(s),3!==t.shape.length)throw new k_("The input of a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead."));if(3!==e.shape.length)throw new k_("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new k_("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(e.shape.length," instead"));if("channelsFirst"===s&&(t=SE(t,[0,2,1])),"causal"===a)throw new S_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=tC(t,e,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=RD(i,n)),i}))}function _L(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return SS((()=>{if(null==s&&(s="channelsLast"),eD(s),3!==t.rank&&4!==t.rank)throw new k_("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));if(3!==e.rank&&4!==e.rank)throw new k_("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(t.rank,"."));let l=AL(t,s);if("causal"===a)throw new S_("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=LE({x:l,filter:e,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=SE(l,[0,3,1,2])),l}))}function DL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return SS((()=>{if(null==s&&(s="channelsLast"),eD(s),4!==t.rank&&5!==t.rank)throw new k_("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(t.rank,"."));if(4!==e.rank&&5!==e.rank)throw new k_("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(t.rank,"."));let i=RL(t,s);if("causal"===a)throw new S_("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=rC(i,e,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=RD(i,n)),"channelsFirst"===s&&(i=SE(i,[0,4,1,2,3])),i}))}NL.className="Softmax",RI(NL);class OL extends gO{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",OL.verifyArgs(e),this.rank=t,V_(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new S_("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=CL(e.kernelSize,t,"kernelSize"),this.strides=CL(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,nD(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,eD(this.dataFormat),this.activation=dL(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=tO(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=OO(e.biasConstraint),this.biasRegularizer=vL(e.biasRegularizer),this.activityRegularizer=vL(e.activityRegularizer),this.dilationRate=CL(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new k_("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new k_("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new k_("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(t){if(E_("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!==typeof t.kernelSize&&!U_(t.kernelSize,"number",1,3))throw new k_("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(t.kernelSize),"."))}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:uL(this.activation),useBias:this.useBias,biasInitializer:$D(this.biasInitializer),biasRegularizer:bL(this.biasRegularizer),activityRegularizer:bL(this.activityRegularizer),biasConstraint:_O(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class zL extends OL{constructor(t,e){super(t,e),this.kernel=null,zL.verifyArgs(e),this.filters=e.filters,V_(this.filters,"filters"),this.kernelInitializer=tO(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=OO(e.kernelConstraint),this.kernelRegularizer=vL(e.kernelRegularizer)}build(t){t=aO(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new k_("The channel dimension of the input should be defined. "+"Found ".concat(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return SS((()=>{let e;t=rO(t);const n=null==this.bias?null:this.bias.read(),r=G_(this.activation.getClassName());if(null!=r&&2===this.rank)e=_L(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=FL(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=_L(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new S_("convolutions greater than 3D are not implemented yet.");e=DL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=aO(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<n.length;++a){const t=EL(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:$D(this.kernelInitializer),kernelRegularizer:bL(this.kernelRegularizer),kernelConstraint:_O(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!==typeof t.filters||t.filters<1)throw new k_("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(t.filters)))}}class LL extends zL{constructor(t){super(2,t),LL.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!U_(t.kernelSize,"number",1,2))throw new k_("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(t.kernelSize),"."))}}LL.className="Conv2D",RI(LL);class ML extends zL{constructor(t){super(3,t),ML.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new k_("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(t.kernelSize),"."))}}ML.className="Conv3D",RI(ML);class PL extends LL{constructor(t){if(super(t),this.inputSpec=[new uO({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new k_("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(4!==(t=aO(t)).length)throw new k_("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new k_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new uO({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return SS((()=>{let e=rO(t);if(4!==e.shape.length)throw new k_("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[r,TL(o,u,l,this.padding),TL(i,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=SE(e,[0,2,3,1]));let p=nC(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=SE(p,[0,3,1,2])),null!=this.bias&&(p=RD(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=aO(t)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=TL(e[r],i,s,this.padding),e[a]=TL(e[a],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}PL.className="Conv2DTranspose",RI(PL);class BL extends ML{constructor(t){if(super(t),this.inputSpec=[new uO({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new k_("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(t){if(5!==(t=aO(t)).length)throw new k_("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new k_("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new uO({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return SS((()=>{let e=rO(t);if(5!==e.shape.length)throw new k_("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(e.shape.length));const n=e.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,TL(i,p,u,this.padding),TL(l,f,h,this.padding),TL(c,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=SE(e,[0,2,3,4,1]));let b=sC(e,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=SE(b,[0,4,1,2,3])),null!==this.bias&&(b=RD(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(t){const e=(t=aO(t)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=TL(e[r],c,o,this.padding),e[a]=TL(e[a],u,i,this.padding),e[s]=TL(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}BL.className="Conv3DTranspose",RI(BL);class WL extends zL{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new k_("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new k_("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new k_("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(e.padding)));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=tO(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vL(e.depthwiseRegularizer),this.depthwiseConstraint=OO(e.depthwiseConstraint),this.pointwiseInitializer=tO(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vL(e.pointwiseRegularizer),this.pointwiseConstraint=OO(e.pointwiseConstraint)}build(t){if((t=aO(t)).length<this.rank+2)throw new k_("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(t)));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new k_("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(t[e])));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new uO({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return SS((()=>{let e;if(t=rO(t),1===this.rank)throw new S_("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=SE(t,[0,2,3,1])),e=rE(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=RD(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=SE(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=$D(this.depthwiseInitializer),t.pointwiseInitializer=$D(this.pointwiseInitializer),t.depthwiseRegularizer=bL(this.depthwiseRegularizer),t.pointwiseRegularizer=bL(this.pointwiseRegularizer),t.depthwiseConstraint=_O(this.depthwiseConstraint),t.pointwiseConstraint=_O(this.pointwiseConstraint),t}}WL.className="SeparableConv";class UL extends WL{constructor(t){super(2,t)}}UL.className="SeparableConv2D",RI(UL);class VL extends zL{constructor(t){super(1,t),VL.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!==typeof t.kernelSize&&!U_(t.kernelSize,"number",1,1))throw new k_("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(t.kernelSize),"."))}}VL.className="Conv1D",RI(VL);class jL extends gO{constructor(t){super(t),"number"===typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"===typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return SS((()=>{if(t=rO(t),"channelsLast"===this.dataFormat){const e=xD(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return xD(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=xD(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return xD(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}jL.className="Cropping2D",RI(jL);class GL extends gO{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,W_(Y_,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return SS((()=>{let e=rO(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=SE(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?IT.resizeNearestNeighbor(e,[t,r]):IT.resizeBilinear(e,[t,r]);return SE(a,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?IT.resizeNearestNeighbor(e,[t,r]):IT.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}GL.className="UpSampling2D",RI(GL);class HL extends OL{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=tO(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=OO(t.depthwiseConstraint),this.depthwiseRegularizer=vL(t.depthwiseRegularizer)}build(t){if((t=aO(t)).length<4)throw new k_("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(t),"."));const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new k_("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(t[e],")."));const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return SS((()=>{let e=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return SS((()=>{null==a&&(a="channelsLast"),eD(a);let o=AL(t,a);if(4!==t.rank)throw new k_("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));if(4!==e.rank)throw new k_("depthwiseKernel is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));return o=iC(o,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=SE(o,[0,3,1,2])),o}))}(t=rO(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=RD(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=aO(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=EL(e,this.kernelSize[0],this.padding,this.strides[0]),s=EL(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,a,s]:[t[0],a,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=$D(this.depthwiseInitializer),t.depthwiseRegularizer=bL(this.depthwiseRegularizer),t.depthwiseConstraint=_O(this.depthwiseRegularizer),t}}function KL(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new k_("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function a(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=a(e),constants:n=a(n)}}function qL(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return SS((()=>{const l=e.shape.length;if(l<3)throw new k_("Input should be at least 3D, but is ".concat(l,"D."));const c=[1,0].concat(fD(2,l));if(e=SE(e,c),null!=s)throw new S_("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=gI(gI(a,"bool"),"float32"),a.rank===l-1&&(a=hC(a,-1)),a=SE(a,c)),r&&(e=eE(e,0),null!=a&&(a=eE(a,0)));const u=[];let h,d=n;const p=e.shape[0],f=vE(e);let g,m;null!=a&&(g=vE(a));for(let e=0;e<p;++e){const n=f[e],r=SS((()=>t(n,d)));if(null==a)h=r[0],d=r[1];else{const t=SS((()=>{const t=g[e],n=LI(KC(t),t);return{output:bI(wI(r[0],t),wI(d[0],n)),newStates:d.map(((e,a)=>bI(wI(r[1][a],t),wI(e,n))))}}));h=t.output,d=t.newStates}i&&u.push(h)}if(i){m=fE(u,1)}return[h,m,d]}))}HL.className="DepthwiseConv2D",RI(HL);class XL extends gO{constructor(t){let e;if(super(t),null==t.cell)throw new k_("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new nM({cells:t.cell}):t.cell,null==e.stateSize)throw new k_("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new uO({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return fD(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){eO(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return SS((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new S_("Constants support is not implemented in RNN yet.");eO(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new uO({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!$b(this.stateSpec.map((t=>t.shape[t.shape.length-1])),a))throw new k_("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((t=>new uO({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];SS((()=>{if(!this.stateful)throw new w_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new k_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>GC([n,t]))):this.states_=[GC([n,this.cell.stateSize])];else if(null==t)IS(this.states_),null!=this.keptStates&&(IS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>GC([n,t]))):this.states_[0]=GC([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new k_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));!0===e?this.keptStates.push(this.states_.slice()):IS(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,a];if(!$b(r.shape,s))throw new k_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(r.shape));this.states_[e]=r}}this.states_=this.states_.map((t=>NS(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=KL(t,n,r,this.numConstants);t=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new uO({shape:t.shape}));o=o.concat(this.stateSpec)}null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof hO){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return SS((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let a=null==e?null:e.initialState;t=rO(t),null==a&&(a=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new k_("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=qL(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],c=i[1],u=i[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return SS((()=>{let e=GC(t.shape);return e=kC(e,[1,2]),e=yD(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?ID(e,[1,t]):e)):this.cell.stateSize>1?[ID(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===XL.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=KO(e.cell,n);return new t(Object.assign(e,{cell:r}))}}XL.className="RNN",RI(XL);class JL extends gO{}class YL extends JL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,V_(this.units,"units"),this.activation=dL(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=tO(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tO(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tO(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vL(t.kernelRegularizer),this.recurrentRegularizer=vL(t.recurrentRegularizer),this.biasRegularizer=vL(t.biasRegularizer),this.kernelConstraint=OO(t.kernelConstraint),this.recurrentConstraint=OO(t.recurrentConstraint),this.biasConstraint=OO(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=aO(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return SS((()=>{if(2!==t.length)throw new k_("SimpleRNNCell expects 2 input Tensors, got ".concat(t.length,"."));let n=t[1];t=t[0];const r=null!=e.training&&e.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rM({ones:()=>KC(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rM({ones:()=>KC(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=CD(null!=s?wI(t,s):t,this.kernel.read()),null!=this.bias&&(a=RD(a,this.bias.read())),null!=o&&(n=wI(n,o));let i=bI(a,CD(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:uL(this.activation),useBias:this.useBias,kernelInitializer:$D(this.kernelInitializer),recurrentInitializer:$D(this.recurrentInitializer),biasInitializer:$D(this.biasInitializer),kernelRegularizer:bL(this.kernelRegularizer),recurrentRegularizer:bL(this.recurrentRegularizer),biasRegularizer:bL(this.biasRegularizer),activityRegularizer:bL(this.activityRegularizer),kernelConstraint:_O(this.kernelConstraint),recurrentConstraint:_O(this.recurrentConstraint),biasConstraint:_O(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}YL.className="SimpleRNNCell",RI(YL);class ZL extends XL{constructor(t){t.cell=new YL(t),super(t)}call(t,e){return SS((()=>{null!=this.cell.dropoutMask&&(IS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(IS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return new t(e)}}ZL.className="SimpleRNN",RI(ZL);class QL extends JL{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new k_("GRUCell does not support reset_after parameter set to true.");this.units=t.units,V_(this.units,"units"),this.activation=dL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=dL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=tO(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tO(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tO(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vL(t.kernelRegularizer),this.recurrentRegularizer=vL(t.recurrentRegularizer),this.biasRegularizer=vL(t.biasRegularizer),this.kernelConstraint=OO(t.kernelConstraint),this.recurrentConstraint=OO(t.recurrentConstraint),this.biasConstraint=OO(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=aO(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return SS((()=>{if(2!==t.length)throw new k_("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rM({ones:()=>KC(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rM({ones:()=>KC(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(t=wI(t,a[0]));let c=CD(t,this.kernel.read());this.useBias&&(c=RD(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=wI(r,s[0]));const u=this.recurrentKernel.read(),[h,d]=dE(u,[2*this.units,this.units],u.rank-1),p=CD(r,h),[f,g,m]=dE(c,3,c.rank-1),[b,y]=dE(p,2,p.rank-1);o=this.recurrentActivation.apply(bI(f,b)),i=this.recurrentActivation.apply(bI(g,y));const v=CD(wI(i,r),d);l=this.activation.apply(bI(m,v));const w=bI(wI(o,r),wI(bI(1,UC(o)),l));return[w,w]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:uL(this.activation),recurrentActivation:uL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:$D(this.kernelInitializer),recurrentInitializer:$D(this.recurrentInitializer),biasInitializer:$D(this.biasInitializer),kernelRegularizer:bL(this.kernelRegularizer),recurrentRegularizer:bL(this.recurrentRegularizer),biasRegularizer:bL(this.biasRegularizer),activityRegularizer:bL(this.activityRegularizer),kernelConstraint:_O(this.kernelConstraint),recurrentConstraint:_O(this.recurrentConstraint),biasConstraint:_O(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}QL.className="GRUCell",RI(QL);class $L extends XL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new QL(t),super(t)}call(t,e){return SS((()=>{null!=this.cell.dropoutMask&&(IS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(IS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}$L.className="GRU",RI($L);class tM extends JL{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,V_(this.units,"units"),this.activation=dL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=dL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=tO(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tO(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tO(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=vL(t.kernelRegularizer),this.recurrentRegularizer=vL(t.recurrentRegularizer),this.biasRegularizer=vL(t.biasRegularizer),this.kernelConstraint=OO(t.kernelConstraint),this.recurrentConstraint=OO(t.recurrentConstraint),this.biasConstraint=OO(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=aO(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends zD{apply(e,r){const a=t.apply([n]),s=(new MD).apply([n]),o=t.apply([2*n]);return SD(SD(a,s),o)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return SS((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new k_("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));let r=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rM({ones:()=>KC(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rM({ones:()=>KC(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,c,u;0<this.dropout&&this.dropout<1&&(t=wI(t,s[0]));let h=CD(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=wI(r,o[0])),h=bI(h,CD(r,this.recurrentKernel.read())),this.useBias&&(h=RD(h,this.bias.read()));const[d,p,f,g]=dE(h,4,h.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=bI(wI(l,a),wI(i,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=wI(u,this.activation.apply(c));return[m,m,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:uL(this.activation),recurrentActivation:uL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:$D(this.kernelInitializer),recurrentInitializer:$D(this.recurrentInitializer),biasInitializer:$D(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:bL(this.kernelRegularizer),recurrentRegularizer:bL(this.recurrentRegularizer),biasRegularizer:bL(this.biasRegularizer),activityRegularizer:bL(this.activityRegularizer),kernelConstraint:_O(this.kernelConstraint),recurrentConstraint:_O(this.recurrentConstraint),biasConstraint:_O(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}tM.className="LSTMCell",RI(tM);class eM extends XL{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new tM(t),super(t)}call(t,e){return SS((()=>{null!=this.cell.dropoutMask&&(IS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(IS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}eM.className="LSTM",RI(eM);class nM extends JL{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return SS((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=i.call(s,e),a.push(s.slice(1))}n=[];for(const t of a.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;eO(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{oD("RNNCell_".concat(r),(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of e.cells)r.push(KO(a,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return lO(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,a=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],a[t]])}cO(e)}}function rM(t){const{ones:e,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):FD(e(),n),i=()=>_D(o,e,r);if(!a||a<=1)return NS(i().clone());return Array(a).fill(void 0).map(i).map((t=>NS(t.clone())))}nM.className="StackedRNNCells",RI(nM);var aM=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(t);a<r.length;a++)e.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(t,r[a])&&(n[r[a]]=t[r[a]])}return n};class sM extends XL{constructor(t){if(t.unroll)throw new S_("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new S_("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new uO({ndim:5})]}call(t,e){return SS((()=>{if(null!=this.cell.dropoutMask&&(IS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(IS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new k_("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,a=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:a})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return SS((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),a=GC([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(a):[a]}))}resetStates(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];SS((()=>{if(!this.stateful)throw new w_("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new k_("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GC(a))):this.states_=[GC(a)];else if(null==t)IS(this.states_),null!=this.keptStates&&(IS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GC(a))):this.states_[0]=GC(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new k_("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(t.length," state value(s). Input ")+"received: ".concat(t));e?this.keptStates.push(this.states_.slice()):IS(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=a;if(!$b(n.shape,r))throw new k_("State ".concat(e," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[e]=n}}this.states_=this.states_.map((t=>NS(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===e,l=t[i?3:2],c=t[i?4:3],u=EL(l,r[0],a,s[0],o[0]),h=EL(c,r[1],a,s[1],o[1]);return[...t.slice(0,2),...i?[n,u,h]:[u,h,n]]}}sM.className="ConvRNN2D";class oM extends tM{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,V_(this.filters,"filters"),this.kernelSize=CL(n,2,"kernelSize"),this.kernelSize.forEach((t=>V_(t,"kernelSize"))),this.strides=CL(r||1,2,"strides"),this.strides.forEach((t=>V_(t,"strides"))),this.padding=a||"valid",nD(this.padding),this.dataFormat=s||"channelsLast",eD(this.dataFormat),this.dilationRate=CL(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>V_(t,"dilationRate")))}build(t){var e;t=aO(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new k_("The channel dimension of the input should be defined. "+"Found ".concat(t[n]));const r=t[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends zD{apply(t,e){return kD([n.apply([r]),HC([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return SS((()=>{if(3!==t.length)throw new k_("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(t.length,"."));const n=e.training||!1,r=t[0],a=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rM({ones:()=>KC(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(t,e,n)=>e&&e[n]?wI(e[n],t):t;let l=i(r,o,0),c=i(r,o,1),u=i(r,o,2),h=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rM({ones:()=>KC(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(a,d,0),f=i(a,d,1),g=i(a,d,2),m=i(a,d,3);const[b,y,v,w]=dE(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?dE(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,x,this.padding),c=this.inputConv(c,y,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[N,C,E,T]=dE(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),g=this.recurrentConv(g,E),m=this.recurrentConv(m,T);const A=this.recurrentActivation.apply(bI(l,p)),R=this.recurrentActivation.apply(bI(c,f)),F=bI(wI(R,s),wI(A,this.activation.apply(bI(u,g)))),_=wI(this.recurrentActivation.apply(bI(h,m)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=aM(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,e,n,r){const a=$N(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?RD(a,n,this.dataFormat):a}recurrentConv(t,e){return $N(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}oM.className="ConvLSTM2DCell",RI(oM);class iM extends sM{constructor(t){const e=new oM(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}iM.className="ConvLSTM2D",RI(iM);class lM extends gO{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return _D((()=>FD(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}lM.className="Dropout",RI(lM);class cM extends lM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}cM.className="SpatialDropout1D",RI(cM);class uM extends gO{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,V_(this.units,"units"),this.activation=dL(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=tO(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=tO(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=OO(t.kernelConstraint),this.biasConstraint=OO(t.biasConstraint),this.kernelRegularizer=vL(t.kernelRegularizer),this.biasRegularizer=vL(t.biasRegularizer),this.activityRegularizer=vL(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=aO(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=aO(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t),r=G_(this.activation.getClassName());let a;return null!=r?a=CD(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=CD(n,this.kernel.read()),null!=this.bias&&(a=RD(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const t={units:this.units,activation:uL(this.activation),useBias:this.useBias,kernelInitializer:$D(this.kernelInitializer),biasInitializer:$D(this.biasInitializer),kernelRegularizer:bL(this.kernelRegularizer),biasRegularizer:bL(this.biasRegularizer),activityRegularizer:bL(this.activityRegularizer),kernelConstraint:_O(this.kernelConstraint),biasConstraint:_O(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}uM.className="Dense",RI(uM);class hM extends gO{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=aO(t);for(const e of t.slice(1))if(null==e)throw new k_('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(t.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],hD(t,1)]}call(t,e){return SS((()=>{this.invokeCallHook(t,e);let n=rO(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=SE(n,t)}return function(t){if(t.rank<=1)throw new k_("batchFlatten requires a minimum rank of 2. Got rank: ".concat(t.rank,"."));const e=[t.shape[0],hD(t.shape,1)];return BN(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}hM.className="Flatten",RI(hM);class dM extends gO{constructor(t){super(t),this.supportsMasking=!0,this.activation=dL(t.activation)}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t);return this.activation.apply(n)}))}getConfig(){const t={activation:uL(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}dM.className="Activation",RI(dM);class pM extends gO{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return SS((()=>{return t=rO(t),e=t,n=this.n,SS((()=>{if(2!==e.shape.length)throw new k_("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return ID(yD(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}pM.className="RepeatVector",RI(pM);class fM extends gO{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let a=1,s=null;for(let i=0;i<r.length;++i){const t=r[i];if(this.isUnknown(t)){if(null!==s)throw new k_("Can only specifiy one unknown dimension.");s=i}else a*=t}const o=hD(t);if(null!==s){if(0===a||o%a!==0)throw new k_(n);r[s]=o/a}else if(o!==a)throw new k_(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return BN(n,a)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}fM.className="Reshape",RI(fM);class gM extends gO{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(t.dims," instead."));const e=fD(1,t.dims.length+1);if(!$b(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new uO({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=aO(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return SE(rO(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}gM.className="Permute",RI(gM);class mM extends gO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=rO(t);return kN(VC(n,this.maskValue),-1)}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t),r=kN(VC(n,this.maskValue),-1,!0);return wI(n,gI(r,n.dtype))}))}}mM.className="Masking",RI(mM);class bM extends gO{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(R_(t.inputLength))}this.inputDim=t.inputDim,V_(this.inputDim,"inputDim"),this.outputDim=t.outputDim,V_(this.outputDim,"outputDim"),this.embeddingsInitializer=tO(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vL(t.embeddingsRegularizer),this.activityRegularizer=vL(t.activityRegularizer),this.embeddingsConstraint=OO(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return SS((()=>this.maskZero?(t=rO(t),VC(t,SI(t))):null))}computeOutputShape(t){if(t=aO(t),null==this.inputLength)return[...t,this.outputDim];const e=R_(this.inputLength);if(e.length!==t.length-1)throw new k_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));{let n=0;for(let r=0;r<e.length;++r){const a=e[r],s=t[r+1];if(null!=a&&null!=s&&a!==s)throw new k_('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(t));null==a&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return SS((()=>{this.invokeCallHook(t,e);let n=rO(t);"int32"!==n.dtype&&(n=bD(n,"int32"));const r=ED(this.embeddings.read(),BN(n,[n.size]));return BN(r,aO(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:$D(this.embeddingsInitializer),embeddingsRegularizer:bL(this.embeddingsRegularizer),activityRegularizer:bL(this.activityRegularizer),embeddingsConstraint:_O(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}bM.className="Embedding",RI(bM);class yM extends gO{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new S_}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],s=e[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new k_("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(a)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[aO(t)]),t.length<2)throw new k_("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(t.length," input(s)."));let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=P_(e),e.length>1)throw new k_("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(t),"."));let n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const e=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===P_(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return SS((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=pD(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=yD(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const s of t){const t=s.rank;if(null==t){const t=s.shape,r=t[0],a=t.slice(1).concat([r]);let o=BN(s,[r].concat(hD(t.slice(1))));o=SE(o,[1,0]),o=BN(o,a),e.push(o),n=!0}else if(t>1){const r=fD(1,t).concat([0]);e.push(SE(s,r)),n=!0}else e.push(s)}let r=this.mergeFunction(e);const a=r.rank;if(n)if(null==a){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=BN(SE(BN(r,[-1,e]),[1,0]),n)}else if(a>1){const t=[a-1].concat(fD(0,a-1));r=SE(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=P_(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return SS((()=>{if(null==e)return null;if(!Array.isArray(e))throw new k_("`mask` should be an Array");if(!Array.isArray(t))throw new k_("`inputs` should be an Array");if(e.length!==t.length)throw new k_("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(t.length," vs ").concat(e.length,")"));if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:hC(t,0))))[0];for(let t=1;t<e.length-1;++t)n=DC(n,e[t]);return n}))}}class vM extends yM{constructor(t){super(t)}mergeFunction(t){return SS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bI(e,t[n]);return e}))}}vM.className="Add",RI(vM);class wM extends yM{constructor(t){super(t)}mergeFunction(t){return SS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=wI(e,t[n]);return e}))}}wM.className="Multiply",RI(wM);class xM extends yM{constructor(t){super(t)}mergeFunction(t){return SS((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bI(e,t[n]);return wI(1/t.length,e)}))}}xM.className="Average",RI(xM);class kM extends yM{constructor(t){super(t)}mergeFunction(t){return SS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=VI(e,t[n]);return e}))}}kM.className="Maximum",RI(kM);class SM extends yM{constructor(t){super(t)}mergeFunction(t){return SS((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=BC(e,t[n]);return e}))}}SM.className="Minimum",RI(SM);class IM extends yM{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new k_("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let a=!1;for(const t of n)if($b(t,e)){a=!0;break}a||n.push(e)}if(n.length>1)throw new k_("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return SS((()=>kD(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new k_("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of e.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new k_("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new k_("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new k_("Mismatch in the length of mask (".concat(e.length,") ")+"and the legnth of inputs (".concat(t.length,")"));return SS((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let s=0;s<t.length;++s)null==e[s]?r.push(gI(KC(t[s]),"bool")):e[s].rank<t[s].rank?r.push(hC(e[s],-1)):r.push(e[s]);const a=XN(r,this.axis);return xN(a,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function NM(t,e){for(;t<0;)t+=e;return t}IM.className="Concatenate",RI(IM);class CM extends yM{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Jb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new S_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new k_("Dimension incompatibility: "+"".concat(e[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(t){if(2!==t.length)throw new k_("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(t.length," input(s)."));let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>NM(e,t[n].shape.length))):[NM(this.axes,n.shape.length),NM(this.axes,r.shape.length)],this.normalize&&(n=qO(n,e[0]),r=qO(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new S_("batchDot is not implemented for tensors of 4D or higher rank yet");if(Jb(t.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(t.shape.length))),Jb(t.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(e.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new S_("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,a=e.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return SS((()=>{let n,o;if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=BN(e,e.shape.concat(t))}else if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=BN(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?kC(wI(t,e),s[0]):kC(wI(SE(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;o=OC(t,e,n,r)}if(n>0){let t;t=r>a?r+a-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);o=pE(o,e)}return 1===o.shape.length&&(o=hC(o,1)),o}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[NM(this.axes,t.length),NM(this.axes,e.length)],n}computeOutputShape(t){Jb(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new S_("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=e.concat(n);return 1===a.length&&a.push(1),a}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}CM.className="Dot",RI(CM);class EM extends gO{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t);return _D((()=>bI(ND(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}EM.className="GaussianNoise",RI(EM);class TM extends gO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return SS((()=>{this.invokeCallHook(t,e);const n=rO(t);if(this.rate>0&&this.rate<1){return _D((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return wI(n,ND(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}TM.className="GaussianDropout",RI(TM);class AM extends gO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||rO(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return SS((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),r=()=>{const e=rO(t),r=-1.7580993408473766;let a=bC(QC(n),this.rate);a=bD(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=bI(wI(e,a),wI(bI(a,-1),r));return bI(wI(i,s),o)};return _D(r,(()=>rO(t)),e.training||!1)}return t}))}}function RM(t,e,n,r,a){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===t.rank)s=jN(t,e,n,r,a,o);else if(3===t.rank)s=GN(t,e,n,r,a,o);else{if(4!==t.rank)throw new S_("batchNormalization is not implemented for array of rank ".concat(t.rank," ")+"yet");s=HN(t,e,n,r,a,o)}return s}function FM(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return $b(r.slice().sort(),fD(0,t.rank-1))?function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return SS((()=>{const s=WC(t,r),o=s.mean,i=s.variance;return[RM(t,o,i,n,e,a),o,i]}))}(t,e,n,r,a):function(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return SS((()=>{const s=WC(t,r),o=s.mean,i=s.variance,l=[];for(const e of fD(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=BN(o,l),u=BN(i,l),h=null==e?null:BN(e,l),d=null==n?null:BN(n,l);return[RM(t,c,u,d,h,a),o,i]}))}(t,e,n,r,a)}AM.className="AlphaDropout",RI(AM);class _M extends gO{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=tO(t.betaInitializer||"zeros"),this.gammaInitializer=tO(t.gammaInitializer||"ones"),this.movingMeanInitializer=tO(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=tO(t.movingVarianceInitializer||"ones"),this.betaConstraint=OO(t.betaConstraint),this.gammaConstraint=OO(t.gammaConstraint),this.betaRegularizer=vL(t.betaRegularizer),this.gammaRegularizer=vL(t.gammaRegularizer)}build(t){t=aO(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new k_("Axis ".concat(e," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(t),"."));this.inputSpec=[new uO({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return SS((()=>{const n=null!=e.training&&e.training,r=rO(t),a=r.shape,s=a.length,o=fD(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=C_(1,s);l[i]=a[i];const c=o.slice();c.sort();const u=!$b(c,fD(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=BN(this.movingMean.read(),l),e=BN(this.movingVariance.read(),l),n=this.center?BN(this.beta.read(),l):null,a=this.scale?BN(this.gamma.read(),l):null;return RM(r,t,e,n,a,this.epsilon)}return RM(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=FM(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{SS((()=>{const r=1-n,a=t.read(),s=wI(LI(a,e),r);t.write(LI(a,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:$D(this.betaInitializer),gammaInitializer:$D(this.gammaInitializer),movingMeanInitializer:$D(this.movingMeanInitializer),movingVarianceInitializer:$D(this.movingVarianceInitializer),betaRegularizer:bL(this.betaRegularizer),gammaRegularizer:bL(this.gammaRegularizer),betaConstraint:_O(this.betaConstraint),gammaConstraint:_O(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}_M.className="BatchNormalization",RI(_M);class DM extends gO{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=tO(t.betaInitializer||"zeros"),this.gammaInitializer=tO(t.gammaInitializer||"ones"),this.betaRegularizer=vL(t.betaRegularizer),this.gammaRegularizer=vL(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=aO(t)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==P_(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=rO(t),r=n.shape,a=r.length;return SS((()=>{let{mean:t,variance:e}=WC(n,this.axis,!0);const s=C_(1,a);for(const n of this.axis)s[n]=r[n];const o=t=>null!=t&&t.shape.length!==a?BN(t,s):t;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),u.push(1)):(c.push(1),u.push(r[n]));return t=dC(t,c),e=dC(e,c),null!=i&&(i=dC(i,u)),null!=l&&(l=dC(l,u)),RM(n,t,e,l,i,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:$D(this.betaInitializer),gammaInitializer:$D(this.gammaInitializer),betaRegularizer:bL(this.betaRegularizer),gammaRegularizer:bL(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}DM.className="LayerNormalization",RI(DM);class OM extends gO{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new k_("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(t.padding.length," array."));let e,n;if("number"===typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new k_("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(t.padding[0].length," array."));if(e=t.padding[0],2!==t.padding[1].length)throw new k_("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(t.padding[1].length," array."));n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new uO({ndim:4})]}computeOutputShape(t){let e,n;return t=aO(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return SS((()=>{return e=rO(t),n=this.padding,r=this.dataFormat,SS((()=>{if(4!==e.rank)throw new k_("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new k_("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new k_("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],qC(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function zM(t,e,n,r,a,s){return SS((()=>{let o;eD(a),rD(s),nD(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=AL(t,a);const i="same"===r?"same":"valid";return o="max"===s?zC(t,e,n,i):WN(t,e,n,i),"channelsFirst"===a&&(o=SE(o,[0,3,1,2])),o}))}function LM(t,e,n,r,a,s){return SS((()=>{let o;eD(a),rD(s),nD(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),t=RL(t,a);const i="same"===r?"same":"valid";return o="max"===s?LC(t,e,n,i):UN(t,e,n,i),"channelsFirst"===a&&(o=SE(o,[0,4,1,2,3])),o}))}OM.className="ZeroPadding2D",RI(OM);class MM extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"===typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!==typeof t.poolSize[0])throw new k_("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.poolSize)));this.poolSize=t.poolSize}if(V_(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"===typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!==typeof t.strides[0])throw new k_("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(t.strides)));this.strides=t.strides}V_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,nD(this.padding),this.inputSpec=[new uO({ndim:3})]}computeOutputShape(t){const e=EL((t=aO(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return SS((()=>{this.invokeCallHook(t,e),t=yD(rO(t),2);const n=this.poolingFunction(rO(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return pE(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class PM extends MM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),zM(t,e,n,r,a,"max")}}PM.className="MaxPooling1D",RI(PM);class BM extends MM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),zM(t,e,n,r,a,"avg")}}BM.className="AveragePooling1D",RI(BM);class WM extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new k_("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides];V_(this.poolSize,"poolSize"),V_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),nD(this.padding),this.inputSpec=[new uO({ndim:4})]}computeOutputShape(t){t=aO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=EL(e,this.poolSize[0],this.padding,this.strides[0]),n=EL(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return SS((()=>(this.invokeCallHook(t,e),this.poolingFunction(rO(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class UM extends WM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),zM(t,e,n,r,a,"max")}}UM.className="MaxPooling2D",RI(UM);class VM extends WM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),zM(t,e,n,r,a,"avg")}}VM.className="AveragePooling2D",RI(VM);class jM extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new k_("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(t.strides.length,"."));this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];V_(this.poolSize,"poolSize"),V_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),nD(this.padding),this.inputSpec=[new uO({ndim:5})]}computeOutputShape(t){t=aO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=EL(e,this.poolSize[0],this.padding,this.strides[0]),n=EL(n,this.poolSize[1],this.padding,this.strides[1]),r=EL(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return SS((()=>(this.invokeCallHook(t,e),this.poolingFunction(rO(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class GM extends jM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),LM(t,e,n,r,a,"max")}}GM.className="MaxPooling3D",RI(GM);class HM extends jM{constructor(t){super(t)}poolingFunction(t,e,n,r,a){return eD(a),nD(r),LM(t,e,n,r,a,"avg")}}HM.className="AveragePooling3D",RI(HM);class KM extends gO{constructor(t){super(t),this.inputSpec=[new uO({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new S_}}class qM extends KM{constructor(t){super(t||{})}call(t,e){return SS((()=>{const e=rO(t);return MC(e,1)}))}}qM.className="GlobalAveragePooling1D",RI(qM);class XM extends KM{constructor(t){super(t||{})}call(t,e){return SS((()=>{const e=rO(t);return xC(e,1)}))}}XM.className="GlobalMaxPooling1D",RI(XM);class JM extends gO{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),this.inputSpec=[new uO({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new S_}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class YM extends JM{call(t,e){return SS((()=>{const e=rO(t);return"channelsLast"===this.dataFormat?MC(e,[1,2]):MC(e,[2,3])}))}}YM.className="GlobalAveragePooling2D",RI(YM);class ZM extends JM{call(t,e){return SS((()=>{const e=rO(t);return"channelsLast"===this.dataFormat?xC(e,[1,2]):xC(e,[2,3])}))}}ZM.className="GlobalMaxPooling2D",RI(ZM);class QM extends gO{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=KO(e.layer,n);delete e.layer;const a={layer:r};return Object.assign(a,e),new t(a)}}class $M extends QM{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=aO(t)).length<3)throw new k_("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(t)));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=aO(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return SS((()=>qL(((t,n)=>[rO(this.layer.call(t,e)),[]]),t=rO(t),[],!1,null,null,!1,!0)[1]))}}$M.className="TimeDistributed",RI($M);class tP extends QM{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=KO(n),e.goBackwards=!0!==e.goBackwards;const r={};var a;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=KO(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,a=this.mergeMode,W_($_,"BidirectionalMergeMode",a),t.weights)throw new S_("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,a=this.forwardLayer.computeOutputShape(t);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),e=a[0]):e=a[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):A_(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const a=KL(t,n,r,this.numConstants);if(t=a.inputs,n=a.initialState,r=a.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new k_("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new uO({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new S_("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof hO;for(const l of s)if(l instanceof hO!==i)throw new k_("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[t].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,e);return this.inputSpec=a,i}return super.apply(t,e)}call(t,e){return SS((()=>{const n=e.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(t,e),a=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),a=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=eE(a,1)),"concat"===this.mergeMode?o=kD([r,a]):"sum"===this.mergeMode?o=bI(r,a):"ave"===this.mergeMode?o=wI(.5,bI(r,a)):"mul"===this.mergeMode?o=wI(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){oD(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),oD(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=KO(e.layer);if(delete e.layer,null!=e.numConstants)throw new S_("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}tP.className="Bidirectional",RI(tP);class eP extends gO{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return SS((()=>("float32"!==(t=rO(t)).dtype&&(t=bD(t,"float32")),bI(wI(t,this.scale),this.offset))))}}eP.className="Rescaling",RI(eP);const{resizeBilinear:nP,cropAndResize:rP}=IT;class aP extends gO{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,r,a,s,o,i){return SS((()=>{let l,c=!1;const u=[e/s,n/o,(r+e)/s,(a+n)/o],h=[];3===t.rank?(c=!0,l=fE([t])):l=t;for(let t=0;t<l.shape[0];t++)h.push(u);const d=yS(h,[h.length,4]),p=$C(0,h.length,1,"int32"),f=rP(l,d,p,[r,a],"nearest");return bD(c?rO(vE(f)):f,i)}))}upsize(t,e,n,r){return SS((()=>bD(nP(t,[e,n]),r)))}call(t,e){return SS((()=>{const e=rO(t),n=e.dtype,r=e.shape,a=r[r.length-3],s=r[r.length-2];let o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let i=0;return s!==this.width&&(i=Math.floor((s-this.width)/2),0===i&&(i=1)),o>=0&&i>=0?this.centerCrop(e,o,i,this.height,this.width,a,s,n):this.upsize(t,this.height,this.width,n)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=aO(t)).length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}}aP.className="CenterCrop",RI(aP);class sP extends gO{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=aO(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return SS((()=>{let n;if("int32"!==(t=rO(t)).dtype&&(t=bD(t,"int32")),"undefined"!==typeof e.countWeights){if("count"!==this.outputMode)throw new k_("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(e.countWeights));n=rO(e.countWeights)}const r=xC(t),a=PC(t),s=mC(this.numTokens,r).bufferSync().get(0),o=bC(a,0).bufferSync().get(0);if(!s||!o)throw new k_("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(t,e,n,r){let a=rO(t);if("int32"!==a.dtype&&(a=bD(a,"int32")),"int"===e)return a;const s=a.shape;if(0===a.rank&&(a=hC(a,-1)),"oneHot"===e&&1!==a.shape[a.shape.length-1]&&(a=hC(a,-1)),a.rank>2)throw new k_("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(e," and input shape ").concat(s)+" which would result in output rank ".concat(a.rank,"."));const o=["multiHot","oneHot"].includes(e),i=a;let l;if(l=oC(i,"undefined"!==typeof r&&"count"===e?r:[],n,o),"tfIdf"!==e)return l;if(r)return wI(l,r);throw new k_("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,n)}))}}sP.className="CategoryEncoding",RI(sP);const oP=new Set(["bilinear","nearest"]);class iP extends gO{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!oP.has(t.interpolation))throw new k_("Invalid interpolation parameter: ".concat(t.interpolation," is not implemented"));this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=aO(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return SS((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return IT.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return IT.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...oP]," are supported"))}))}}iP.className="Resizing",RI(iP);class lP{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}lP.className="RandomSeed";class cP extends gO{constructor(t){super(t),this.randomGenerator=new lP(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}cP.className="BaseRandomLayer";const uP=new Set(["bilinear","nearest"]);class hP extends cP{constructor(t){super(t);const{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new k_("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new k_("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new k_("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!uP.has(n))throw new k_("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=aO(t))[2];return[this.imgHeight,-1,e]}call(t,e){return SS((()=>{const e=rO(t);this.imgHeight=e.shape[e.shape.length-3];const n=e.shape[e.shape.length-2];this.widthFactor=QC([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return IT.resizeBilinear(t,a);case"nearest":return IT.resizeNearestNeighbor(t,a);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...uP]," are supported"))}}))}}hP.className="RandomWidth",RI(hP);var dP,pP;Ay().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(dP||(dP={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(pP||(pP={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function fP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(yP(t)){const a=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const o=fP(t[s],e,n,r);a[s]=o}return r.delete(t),t.__proto__&&(a.__proto__=t.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(t))}return n.set(t,a.value),a.value}function gP(t){return mP(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:bP)}function mP(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=e(t);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(yP(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=mP(t.map((t=>t[s])),e,n);a[s]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function bP(t){return null===t?null:yP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function yP(t){let e=!1;if(Ay().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(4222);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof Mk)&&!(t instanceof Promise)&&!e)}function vP(t){return function(t,e){return fP(t,e)}(t,wP)}function wP(t){return t instanceof Mk?{value:t.clone(),recurse:!1}:yP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class xP{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class kP extends xP{constructor(){super(kP.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function SP(t){return new EP(t)}function IP(t,e){return new PP(t,e)}kP.INITIAL_CAPACITY=32;class NP{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new OP(this,t)}filter(t){return new _P(this,t)}map(t){return new DP(this,t)}mapAsync(t){return new zP(this,t)}serialMapAsync(t){return new zP(this,t).serial()}flatmap(t){return new MP(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t){return new FP(this,t,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:bP;return this.rowMajorBatch(t,e).map((t=>gP(t,n)))}concatenate(t,e){return new PP(new CP([this,t]),e)}take(t){return t<0||null==t?this:new RP(this,t)}skip(t){return t<0||null==t?this:new AP(this,t)}prefetch(t){return new WP(this,t)}shuffle(t,e){return new UP(this,t,e)}serial(){return new TP(this)}}class CP extends NP{constructor(t){super(),this.items=t,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:vP(t),done:!1}}}class EP extends NP{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(v1){throw v1.message="Error thrown while iterating through a dataset: ".concat(v1.message),v1}}}class TP extends NP{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class AP extends NP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;IS(t.value)}return this.upstream.next()}}class RP extends NP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class FP extends NP{constructor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class _P extends NP{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;IS(t.value)}}}class DP extends NP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Qk(t.value),n=this.transform(t.value),r=Qk(n);for(const a of e)Zk(a,r)||a.dispose();return{value:n,done:!1}}}class OP extends NP{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(v1){if(!this.handler(v1))return{value:null,done:!0}}}}class zP extends NP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Qk(t.value),n=await this.transform(t.value),r=Qk(n);for(const a of e)Zk(a,r)||a.dispose();return{value:n,done:!1}}}class LP extends NP{constructor(){super(),this.outputQueue=new kP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class MP extends LP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Qk(t.value),n=this.transform(t.value),r=Qk(n);this.outputQueue.pushAll(n);for(const a of e)Zk(a,r)||a.dispose();return!0}}class PP extends NP{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var BP;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(BP||(BP={}));class WP extends NP{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new xP(e)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class UP extends WP{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Vo.alea(n||bk().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class VP{constructor(){this.size=null}batch(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Jb(t>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(t))),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),jP((async()=>(await n.iterator()).columnMajorBatch(t,e,GP)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,jP((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,jP((async()=>(await e.iterator()).filter((e=>SS((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return jP((async()=>(await e.iterator()).map((e=>SS((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return jP((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return jP((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,jP((async()=>IP(SP((async()=>({value:await e.iterator(),done:!1}))).take(t))),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,jP((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=Vo.alea(e||bk().toString());return jP((async()=>{let e=a.int32();return n&&(e+=a.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,jP((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function jP(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends VP{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function GP(t){if(null===t)return null;if(function(t){return null==t||null===(e=t)||"object"!==typeof e&&"function"!==typeof e||Array.isArray(t)||"object"===typeof t&&t instanceof Mk||wk(t);var e}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Mk?fE(t):yS(t)}(t),recurse:!1}}return{value:null,recurse:!0}}VP.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function HP(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Jb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors in the CPU backend.")))}))}const KP=PA;class qP extends jb{nextDataId(){return qP.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Vb(this,xS())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Ay().get("IS_NODE")&&Hx("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&hy(n[0])){const a=n.map((t=>yk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){if(this.data.has(t)){return this.data.get(t).refCount}return 0}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,n,r,a){this.data.set(t,{values:e,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){return nA(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(t,e){if(Array.isArray(t))return t;if("float32"===e)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===e)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===e||"string"===e)return Uint8Array.from(new Int32Array(t));throw new Error("Unknown dtype ".concat(e))}(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>vk(t)));return fI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return fI(t.shape,t.dtype,e)}makeOutput(t,e,n){return xS().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=bk();t();return{kernelMs:bk()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){HP([t],"where");const e=this.readSync(t.dataId);return KP(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}qP.nextDataId=0;function XP(t){return(e,n,r)=>{const a=ly(n,e.length);for(let s=0;s<e.length;++s)a[s]=t(e[s],r);return a}}function JP(t,e,n){return YP(t,XP(e),n)}function YP(t,e,n){return r=>{let{inputs:a,attrs:s,backend:o}=r;const{x:i}=a;HP(i,t);const l=o,c=l.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=LA(c)}else u=c;const h=n||i.dtype,d=e(u,h,s);return l.makeTensorInfo(i.shape,h,d)}}CS("cpu",(()=>new qP),1);const ZP=JP(_v,(t=>t>=0?t:Math.exp(t)-1)),QP={kernelName:_v,backendName:"cpu",kernelFunc:ZP};function $P(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const tB={kernelName:Jv,backendName:"cpu",kernelFunc:$P};function eB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r;HP([a],"leakyRelu");const o=Qb(a.shape),i=n.data.get(a.dataId).values,l=iy("float32",o);for(let c=0;c<i.length;c++)l[c]=i[c]<0?s*i[c]:i[c];return n.makeTensorInfo(a.shape,"float32",l)}const nB={kernelName:ew,backendName:"cpu",kernelFunc:eB};function rB(t){return(e,n,r,a,s)=>{const o=UI(e,n),i=o.length,l=my(o),c=iy(s,Qb(o)),u=e.length,h=n.length,d=my(e),p=my(n),f=BI(e,o),g=BI(n,o);if(f.length+g.length===0)for(let m=0;m<c.length;++m)c[m]=t(r[m%r.length],a[m%a.length]);else for(let m=0;m<c.length;++m){const e=Iy(m,i,l),n=e.slice(-u);f.forEach((t=>n[t]=0));const s=Sy(n,u,d),o=e.slice(-h);g.forEach((t=>o[t]=0));const b=Sy(o,h,p);c[m]=t(r[s],a[b])}return[c,o]}}const aB=rB(((t,e)=>t<0?e*t:t));function sB(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e;HP([r,a],"prelu");const s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[i,l]=aB(r.shape,a.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",i)}const oB={kernelName:Lw,backendName:"cpu",kernelFunc:sB},iB=JP(Gw,(t=>Math.max(0,t))),lB={kernelName:Gw,backendName:"cpu",kernelFunc:iB},cB=JP(Yw,(t=>Math.min(Math.max(0,t),6))),uB={kernelName:Yw,backendName:"cpu",kernelFunc:cB},hB=XP((t=>1/(1+Math.exp(-t)))),dB=JP(cx,(t=>1/(1+Math.exp(-t)))),pB={kernelName:cx,backendName:"cpu",kernelFunc:dB};function fB(t,e,n,r,a){if("linear"===n)return $P({inputs:{x:e},backend:t});if("relu"===n)return iB({inputs:{x:e},backend:t});if("elu"===n)return ZP({inputs:{x:e},backend:t});if("relu6"===n)return cB({inputs:{x:e},backend:t});if("prelu"===n)return sB({inputs:{x:e,alpha:r},backend:t});if("leakyrelu"===n)return eB({inputs:{x:e},backend:t,attrs:{alpha:a}});if("sigmoid"===n)return dB({inputs:{x:e},backend:t});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function gB(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}const mB={kernelName:ov,backendName:"cpu",kernelFunc:gB};function bB(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return gB({inputs:{real:bB(t,e,"float32"),imag:bB(t,e,"float32")},backend:t})}const r=wy(Qb(e),n);return t.makeTensorInfo(e,n,r)}function yB(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const vB={kernelName:Vw,backendName:"cpu",kernelFunc:yB};function wB(t,e,n,r){if("int32"===r){return[e,"int32",Int32Array.from(t)]}if("bool"===r){const r=mk([0],n),[a,s]=rB(((t,e)=>t!==e?1:0))(e,[],t,r,"bool");return[s,"bool",a]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(r))}function xB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return $P({inputs:{x:a},backend:n});const t=bB(n,a.shape,a.dtype),e=xB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=gB({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),r}if("complex64"===a.dtype){const t=yB({inputs:{input:a},backend:n}),e=xB({inputs:{x:t},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(t),e}if(!cy(a.dtype,s)){const t=$P({inputs:{x:a},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:s}}const o=n.data.get(a.dataId).values,[i,l,c]=wB(o,a.shape,a.dtype,s);return n.makeTensorInfo(i,l,c)}const kB={kernelName:rv,backendName:"cpu",kernelFunc:xB};function SB(t,e,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:o,b:i}=a,l=s;HP([o,i],t);const c=l.data.get(o.dataId).values,u=l.data.get(i.dataId).values,h="string"===o.dtype?LA(c):c,d="string"===o.dtype?LA(u):u,p=r||o.dtype,[f,g]=e(o.shape,i.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:t=>{let{inputs:a,backend:s}=t;const{a:o,b:i}=a,l=s;if("complex64"===o.dtype||"complex64"===i.dtype){const t=xB({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),e=l.data.get(t.dataId),r=e.complexTensorInfos.real,a=e.complexTensorInfos.imag,s=l.data.get(r.dataId).values,c=l.data.get(a.dataId).values,u=xB({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,[m,b,y]=n(o.shape,i.shape,s,c,f,g),v=l.makeTensorInfo(y,"float32",m),w=l.makeTensorInfo(y,"float32",b),x=gB({inputs:{real:v,imag:w},backend:l});return l.disposeIntermediateTensorInfo(t),l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(w),x}{const t=l.data.get(o.dataId).values,n=l.data.get(i.dataId).values,a=r||o.dtype,[s,c]=e(o.shape,i.shape,t,n,a);return l.makeTensorInfo(c,a,s)}}}function IB(t){return(e,n,r,a,s,o)=>{const i=UI(e,n),l=Qb(i),c=i.length,u=my(i),h=iy("float32",l),d=iy("float32",l),p=BI(e,i),f=BI(n,i),g=nA(r,a),m=nA(s,o),b=e.length,y=my(e),v=n.length,w=my(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const e=x%g.length,n=x%m.length,r=t(g[2*e],g[2*e+1],m[2*n],m[2*n+1]);h[x]=r.real,d[x]=r.imag}else for(let x=0;x<h.length;x++){const e=Iy(x,c,u),n=e.slice(-b);p.forEach((t=>n[t]=0));const r=Sy(n,b,y),a=e.slice(-v);f.forEach((t=>a[t]=0));const s=Sy(a,v,w),o=t(g[2*r],g[2*r+1],m[2*s],m[2*s+1]);h[x]=o.real,d[x]=o.imag}return[h,d,i]}}const NB=rB(((t,e)=>t+e)),CB=IB(((t,e,n,r)=>({real:t+n,imag:e+r}))),EB=SB(My,NB,CB),TB={kernelName:My,backendName:"cpu",kernelFunc:EB};function AB(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=Qb(a.shape),i=ay(s,o),l=Qb(i);Jb(o===l,(()=>"The new shape (".concat(i,") has ").concat(l," elements and the old ")+"shape (".concat(a.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(a.dataId);const c=n.data.get(a.dataId);if(null!=c.complexTensorInfos){const t=c.complexTensorInfos.real,e=c.complexTensorInfos.imag;t.shape=i,e.shape=i}return{dataId:a.dataId,shape:i,dtype:a.dtype}}const RB={kernelName:Hw,backendName:"cpu",kernelFunc:AB};function FB(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;HP([a,s],"matMul");const l=a.shape.length,c=s.shape.length,u=o?a.shape[l-2]:a.shape[l-1],h=i?s.shape[c-1]:s.shape[c-2],d=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[c-2]:s.shape[c-1],f=a.shape.slice(0,-2),g=s.shape.slice(0,-2),m=Qb(f),b=Qb(g),y=UI(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);Jb(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(a.shape," and ")+"".concat(s.shape," and transposeA=").concat(o)+" and transposeB=".concat(i," must match.")));const v=i?[b,p,h]:[b,h,p],w=AB({inputs:{x:a},backend:n,attrs:{shape:o?[m,u,d]:[m,d,u]}}),x=AB({inputs:{x:s},backend:n,attrs:{shape:v}}),k=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],I=i?x.shape[1]:x.shape[2],N=Math.max(m,b),C=n.data.get(w.dataId).values,E=n.data.get(x.dataId).values,T=my(w.shape),A=my(x.shape),[R,F,_]=o?[T[0],1,T[1]]:[T[0],T[1],1],[D,O,z]=i?[1,A[1],A[0]]:[A[1],1,A[0]],L=S*I,M=fI([N,S,I],w.dtype),P=M.values,B=n.blockSize;for(let W=0;W<N;W++){const t=W%m,e=W%b;for(let n=0;n<S;n+=B){const r=Math.min(n+B,S);for(let a=0;a<I;a+=B){const s=Math.min(a+B,I);for(let o=0;o<k;o+=B){const i=Math.min(o+B,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=o;a<i;a++){r+=C[t*R+l*F+a*_]*E[a*D+n*O+e*z]}P[W*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(y,M.dtype,M.values)}const _B={kernelName:Qy,backendName:"cpu",kernelFunc:FB};const DB={kernelName:Vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let d,p,f;const g=[];d=FB({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=EB({inputs:{a:d,b:o},backend:n}),g.push(d),d=p),u&&(f=fB(n,d,u,i,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}};function OB(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const zB={kernelName:Oy,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;HP(e,"abs");let r=new Float32Array(Qb(e.shape));return r=OB(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,e.dtype)}},LB=JP(zy,(t=>Math.acos(t))),MB={kernelName:zy,backendName:"cpu",kernelFunc:LB},PB=JP(Ly,(t=>Math.acosh(t))),BB={kernelName:Ly,backendName:"cpu",kernelFunc:PB};const WB={kernelName:Py,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,r=e;HP(e,"addN");const a=r.map((t=>n.data.get(t.dataId).values)),s=fI(r[0].shape,r[0].dtype),o=s.values;for(let i=0;i<r.length;i++){const t=a[i];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function UB(t,e,n,r,a){const s=e.length,o=Qb(e),i=my(e),l=my(a),c=iy(n,Qb(a));for(let u=0;u<o;++u){const e=Iy(u,s,i),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];c[Sy(n,s,l)]=t[u]}return c}function VB(t){const{inputs:e,attrs:n,backend:r}=t,{x:a}=e,{perm:s}=n;HP(a,"transpose");const o=a.shape.length,i=new Array(o);for(let c=0;c<i.length;c++)i[c]=a.shape[s[c]];const l=UB(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:r.write(l,i,a.dtype),shape:i,dtype:a.dtype}}const jB={kernelName:Ox,backendName:"cpu",kernelFunc:VB};const GB={kernelName:By,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;HP(a,"all");const i=sy(s,a.shape);let l=i;const c=AC(l,a.shape.length);let u=a;null!=c&&(u=VB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=FC(l.length,a.shape.length)),TC("all",l,u.shape.length);const[h,d]=CC(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e&&r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=AB({inputs:{x:m},backend:n,attrs:{shape:EC(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const HB={kernelName:Wy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;HP(a,"any");const i=sy(s,a.shape);let l=i;const c=AC(l,a.shape.length);let u=a;null!=c&&(u=VB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=FC(l.length,a.shape.length)),TC("any",l,u.shape.length);const[h,d]=CC(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];e=e||r}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=AB({inputs:{x:m},backend:n,attrs:{shape:EC(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}};const KB={kernelName:Uy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;HP(a,"argMax");let o=sy(s,a.shape);const i=AC(o,a.shape.length);let l=a;const c=[];null!=i&&(l=VB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=FC(o.length,l.shape.length)),o=[o[0]],TC("argMax",o,l.shape.length);const[u,h]=CC(l.shape,o),d=wy(Qb(u),"int32"),p=Qb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a>e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}};const qB={kernelName:Vy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;HP(a,"argMin");let o=sy(s,a.shape);const i=AC(o,a.shape.length);let l=a;const c=[];null!=i&&(l=VB({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=FC(o.length,l.shape.length)),o=[o[0]],TC("argMin",o,l.shape.length);const[u,h]=CC(l.shape,o),d=wy(Qb(u),"int32"),p=Qb(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const t=g*p;let e=f[t],n=0;for(let r=0;r<p;++r){const a=f[t+r];a<e&&(e=a,n=r)}d[g]=n}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",d)}},XB=JP(jy,(t=>Math.asin(t))),JB={kernelName:jy,backendName:"cpu",kernelFunc:XB},YB=JP(Gy,(t=>Math.asinh(t))),ZB={kernelName:Gy,backendName:"cpu",kernelFunc:YB},QB=JP(Hy,(t=>Math.atan(t))),$B={kernelName:Hy,backendName:"cpu",kernelFunc:QB},tW=rB(((t,e)=>Math.atan2(t,e))),eW=SB(qy,tW),nW={kernelName:qy,backendName:"cpu",kernelFunc:eW},rW=JP(Ky,(t=>Math.atanh(t))),aW={kernelName:Ky,backendName:"cpu",kernelFunc:rW};function sW(t,e,n,r,a,s){const o=a.strideHeight,i=a.strideWidth,l=a.dilationHeight,c=a.dilationWidth,u=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=fI(a.outShape,n),m=g.values,b=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let w=0;w<a.batchSize;++w){const e=w*b,n=w*r[0];for(let g=0;g<a.inChannels;++g)for(let b=0;b<a.outHeight;++b){const w=b*o-d,x=Math.max(0,w),k=Math.min(a.inHeight,u+w),S=e+b*y;for(let e=0;e<a.outWidth;++e){const o=e*i-p,u=Math.max(0,o),d=Math.min(a.inWidth,h+o);let b=f,y=0,w=0;for(let e=x;e<k;e+=l){const a=n+e*r[1];for(let e=u;e<d;e+=c){const n=t[a+e*r[2]+g];"max"===s&&n>b?b=n:"avg"===s&&(y+=n,w++)}if(isNaN(b))break}m[S+e*v+g]="avg"===s?y/w:b}}}return g}function oW(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=fI(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=fI(e,n,t);for(let m=0;m<r.batchSize;++m)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*i-p;let b=n;for(;b<0;)b+=c;const y=Math.min(r.inHeight,h+n);for(let i=0;i<r.outWidth;++i){const h=i*l-f;let p=h;for(;p<0;)p+=u;const v=Math.min(r.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let e=b;e<y;e+=c){const o=e-n;for(let n=p;n<v;n+=u){const i=n-h,l=g.get(m,e,n,t);l>w&&(w=l,x=a?s?((m*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+i)}}o.set(x,m,e,i,t)}}return o}function iW(t,e,n,r,a,s){const o=a.strideDepth,i=a.strideHeight,l=a.strideWidth,c=a.dilationDepth,u=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,g=a.padInfo.front,m=a.padInfo.top,b=a.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=fI(a.outShape,n),w=v.values,x=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){const e=N*x,n=N*r[0];for(let v=0;v<a.inChannels;++v)for(let x=0;x<a.outDepth;++x){const N=x*o-g;let C=N;for(;C<0;)C+=c;const E=Math.min(a.inDepth,d+N),T=e+x*k;for(let e=0;e<a.outHeight;++e){const o=e*i-m;let d=o;for(;d<0;)d+=u;const g=Math.min(a.inHeight,p+o),x=T+e*S;for(let e=0;e<a.outWidth;++e){const o=e*l-b;let i=o;for(;i<0;)i+=h;const p=Math.min(a.inWidth,f+o),m=x+e*I;let k=y,S=0,N=0;for(let e=C;e<E;e+=c){const a=n+e*r[1];for(let e=d;e<g;e+=u){const n=a+e*r[2];for(let e=i;e<p;e+=h){const a=t[n+e*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[m+v]="avg"===s?S/Math.max(N,1):k}}}}return v}const lW={kernelName:Xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;HP(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(zN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=NN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))u=$P({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=my(a.shape),r=sW(t,a.shape,a.dtype,e,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const cW={kernelName:Yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;HP(a,"avgPool3d");const u=CN(a.shape,s,o,1,i,l,c),h=iW(n.data.get(a.dataId).values,a.shape,a.dtype,my(a.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const uW={kernelName:Zy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;HP([a,s],"avgPool3DGrad");const u=CN(s.shape,o,i,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,w=u.effectiveFilterDepth,x=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=w-1-u.padInfo.front,I=k-1-u.padInfo.left,N=x-1-u.padInfo.top,C=fI(s.shape,"float32"),E=1/(f*g*m),T=n.bufferSync(a);for(let A=0;A<u.batchSize;++A)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-S,s=n-N,o=r-I;let i=0;for(let e=0;e<w;e+=b){const n=(a+e)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let e=0;e<x;e+=y){const r=(s+e)/d;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let e=0;e<k;e+=v){const a=(o+e)/p;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;i+=T.get(A,n,r,a,t)}}}C.set(i*E,A,e,n,r,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const hW={kernelName:Jy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;HP([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=NN(o.shape,i,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,w=b-1-u.padInfo.top,x=fI(o.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=fI(a.shape,"float32",S);for(let N=0;N<u.batchSize;++N)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inHeight;++e)for(let n=0;n<u.inWidth;++n){const r=e-w,a=n-v;let s=0;for(let e=0;e<b;e+=g){const n=(r+e)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let e=0;e<y;e+=m){const r=(a+e)/d;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;s+=I.get(N,n,r,t)}}x.set(s*k,N,e,n,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const dW={kernelName:Gv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,scale:s,offset:o,mean:i,variance:l}=e;Jb(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),HP([a,i,l,s,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,b=p.length,y=d.length,v=h.length;let w=0,x=0,k=0,S=0;for(let I=0;I<u.length;++I)g[I]=f[w++]+(u[I]-h[x++])*p[k++]/Math.sqrt(d[S++]+c),w>=m&&(w=0),x>=v&&(x=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,g)}};function pW(t,e,n,r,a){const s=mN(r,e,n),o=Qb(n),i=my(r);if(s){const n=bN(e,i);return"string"===a?t.slice(n,n+o):t.subarray(n,n+o)}const l=fI(r,a,"string"===a?LA(t):t),c=fI(n,a);for(let u=0;u<c.size;++u){const t=c.indexToLoc(u),n=t.map(((t,n)=>t+e[n]));c.set(l.get(...n),...t)}return"string"===a?MA(c.values):c.values}function fW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r;HP(a,"slice");const[i,l]=yN(a,s,o);aN(a,i,l);const c=pW(n.data.get(a.dataId).values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}const gW={kernelName:sx,backendName:"cpu",kernelFunc:fW};const mW={kernelName:$y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;HP([a],"batchToSpaceND");const i=s.reduce(((t,e)=>t*e)),l=BT(a.shape,s,i),c=WT(l.length,s.length),u=UT(a.shape,s,i),h=VT(o,s.length),d=jT(u,o,s.length),p=AB({inputs:{x:a},backend:n,attrs:{shape:l}}),f=VB({inputs:{x:p},backend:n,attrs:{perm:c}}),g=AB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=fW({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function bW(t,e,n,r,a){const s=Qb(r),o=wy(a,n);for(let i=0;i<t.length;i++){const n=t[i];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(o[n]+=s>0?e[i]:1)}return o}function yW(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=t.shape[0],s=t.shape[1],o=fI([a,n],e.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=t.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):e.size>0?o.set(o.get(i,s)+e.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}const vW={kernelName:tv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=bW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}},wW=rB(((t,e)=>t&e)),xW={kernelName:ev,backendName:"cpu",kernelFunc:SB(ev,wW)};const kW={kernelName:nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=UI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},SW=XP((t=>Math.ceil(t))),IW=YP(av,SW),NW={kernelName:av,backendName:"cpu",kernelFunc:IW},CW=JP(sv,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),EW={kernelName:sv,backendName:"cpu",kernelFunc:CW},TW={kernelName:iv,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Qb(e.shape)),a=n.data.get(e.dataId),s=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let c=0;c<i.length;c++){const t=i[c],e=l[c];r[c]=Math.hypot(t,e)}return n.makeOutput(r,e.shape,"float32")}};function AW(t,e,n,r){const a=ly(n,Qb(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=Qb(t.shape);a.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const s="string"===n?LA(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const i=n*e[1]+r;for(let e=0;e<t.shape[1];++e)a[i+e]=s[o++]}r+=t.shape[1]}))}return a}function RW(t){const{inputs:e,backend:n}=t,{input:r}=e,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const FW={kernelName:Zv,backendName:"cpu",kernelFunc:RW};function _W(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=sy(a,e[0].shape)[0];AT(e.map((t=>t.shape)),s);let o=RT(e.map((t=>t.shape)),s);if(0===Qb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Qb(t.shape)>0));if(1===i.length)return $P({inputs:{x:i[0]},backend:n});if("complex64"===i[0].dtype){const t=i.map((t=>yB({inputs:{input:t},backend:n}))),e=i.map((t=>RW({inputs:{input:t},backend:n}))),r=_W({inputs:t,backend:n,attrs:{axis:s}}),a=_W({inputs:e,backend:n,attrs:{axis:s}}),o=gB({inputs:{real:r,imag:a},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}const l=i.map((t=>{const e=Qb(t.shape.slice(s));return AB({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),c=l.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));o=RT(l.map((t=>t.shape)),1);const u=1===l[0].shape[0],h=AW(c,o,e[0].dtype,u),d=RT(i.map((t=>t.shape)),s),p=n.makeTensorInfo(d,e[0].dtype,h);return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}const DW={kernelName:lv,backendName:"cpu",kernelFunc:_W};function OW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r;HP([a,s],"conv2d");const h=MN(l),d=EN(a.shape,s.shape,o,c,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new Dk(d.outShape,a.dtype),x=my(a.shape),k=my(s.shape),S=x[0],I=v?x[1]:x[2],N=v?x[2]:1,C=v?1:x[1],E=w.strides[0],T=v?w.strides[1]:w.strides[2],A=v?w.strides[2]:1,R=v?1:w.strides[1],F=n.data.get(a.dataId).values,_=n.data.get(s.dataId).values,D=w.values;for(let O=0;O<d.batchSize;++O){const t=O*S,e=O*E;for(let n=0;n<d.outHeight;++n){const r=e+n*T,a=n*d.strideHeight-y;for(let e=0;e<p;++e){const n=a+e*g;if(n<0||n>=d.inHeight)continue;const s=e*k[0],o=t+n*I;for(let t=0;t<d.outWidth;++t){const e=r+t*A,n=t*d.strideWidth-b;for(let t=0;t<f;++t){const r=n+t*m;if(r<0||r>=d.inWidth)continue;const a=o+r*N;let i=s+t*k[1];for(let t=0;t<d.inChannels;++t){const n=F[a+t*C];for(let t=0;t<d.outChannels;++t)D[e+t*R]+=n*_[i+t];i+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,D)}const zW={kernelName:cv,backendName:"cpu",kernelFunc:OW};const LW={kernelName:uv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;HP([a,s],"conv2dBackpropFilter");const h=MN(l),d=EN(a.shape,u,o,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,y=new Dk(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new Dk(a.shape,a.dtype,x),I=new Dk(s.shape,s.dtype,k);for(let N=0;N<g;++N){const t=Math.max(0,Math.ceil((w-N)/p)),e=Math.min(d.outHeight,(d.inHeight+w-N)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let s=0;s<d.inChannels;++s)for(let o=0;o<d.outChannels;++o){let i=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<e;++c){const t=N+c*p-w;for(let e=r;e<a;++e){const r=n+e*f-v;i+=b?S.get(l,t,r,s)*I.get(l,c,e,o):S.get(l,s,t,r)*I.get(l,o,c,e)}}y.set(i,N,n,s,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const MW={kernelName:hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r;HP([a,s],"conv2dBackpropInput");const h=my(s.shape),d=my(a.shape);let p=MN(c);const f=EN(o,s.shape,i,1,l,u,!1,p),g=new Dk(f.inShape,"float32"),m=g.values,b=n.data.get(a.dataId).values,y=n.data.get(s.dataId).values,[v,w,x]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:C,inWidth:E,outChannels:T,outHeight:A,outWidth:R,strideHeight:F,strideWidth:_}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,O=I-1-f.padInfo.left,z="channelsLast"===p,L=g.strides[0],M=z?g.strides[1]:g.strides[2],P=z?g.strides[2]:1,B=z?1:g.strides[1],W=d[0],U=z?d[1]:d[2],V=z?d[2]:1,j=z?1:d[1];for(let G=0;G<k;++G)for(let t=0;t<N;++t)for(let e=0;e<C;++e){const n=e-D,r=Math.max(0,Math.ceil(n/F)),a=Math.min(A,(S+n)/F);for(let s=0;s<E;++s){const o=s-O,i=Math.max(0,Math.ceil(o/_)),l=Math.min(R,(I+o)/_);let c=0;for(let e=r;e<a;++e){const r=e*F-n;for(let n=i;n<l;++n){const a=W*G+U*e+V*n,s=v*(S-1-r)+w*(I-1-(n*_-o))+x*t;for(let t=0;t<T;++t){c+=b[a+j*t]*y[s+t]}}}m[L*G+M*e+P*s+B*t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const PW={kernelName:dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r;HP([a,s],"conv3d");const c=TN(a.shape,s.shape,o,l,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,b=m.front,y=m.left,v=m.top,w=new Dk(c.outShape,a.dtype),x=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=w.values,I=my(a.shape),N=my(s.shape);for(let C=0;C<c.batchSize;++C){const t=C*I[0],e=C*w.strides[0];for(let n=0;n<c.outDepth;++n){const r=e+n*w.strides[1],a=n*c.strideDepth-b;for(let e=0;e<u;++e){const n=a+e*p;if(n<0||n>=c.inDepth)continue;const s=e*N[0],o=t+n*I[1];for(let t=0;t<c.outHeight;++t){const e=r+t*w.strides[2],n=t*c.strideHeight-v;for(let t=0;t<h;++t){const r=n+t*f;if(r<0||r>=c.inHeight)continue;const a=s+t*N[1],i=o+r*I[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,r=t*c.strideWidth-y;for(let t=0;t<d;++t){const e=r+t*g;if(e<0||e>=c.inWidth)continue;const s=a+t*N[2],o=i+e*c.inChannels;let l=s;for(let t=0;t<c.inChannels;++t){const e=x[o+t];for(let t=0;t<c.outChannels;++t)S[n+t]+=e*k[l+t];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const BW={kernelName:pv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r;HP([a,s],"conv3dBackpropFilterV2");const c=my(a.shape),u=my(s.shape),h=TN(a.shape,l,o,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,y=new Dk(h.filterShape,"float32"),v=y.values,[w,x,k,S]=y.strides,I=n.data.get(s.dataId).values,[N,C,E,T]=u,A=n.data.get(a.dataId).values,[R,F,_,D]=c,O=h.padInfo.front,z=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<g;++M){const t=Math.max(0,Math.ceil((O-M)/d)),e=Math.min(h.outDepth,(h.inDepth+O-M)/d),n=M*w;for(let r=0;r<m;++r){const a=Math.max(0,Math.ceil((L-r)/p)),s=Math.min(h.outHeight,(h.inHeight+L-r)/p),o=r*x+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((z-n)/f)),l=Math.min(h.outWidth,(h.inWidth+z-n)/f),c=n*k+o;for(let o=0;o<h.inChannels;++o){const u=o*S+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let u=0;u<h.batchSize;++u){const h=u*R,m=u*N;for(let u=t;u<e;++u){const t=(M+u*d-O)*F+h,e=u*C+m;for(let u=a;u<s;++u){const a=(r+u*p-L)*_+t,s=u*E+e;for(let t=i;t<l;++t){const e=t*T+s;g+=A[(n+t*f-z)*D+a+o]*I[e+c]}}}}v[u+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const WW={kernelName:fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r;HP([a],"conv3dBackpropInputV2");const c=my(a.shape),u=my(s.shape),h=TN(l,s.shape,i,1,o),d=new Dk(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,y=n.data.get(a.dataId).values,[v,w,x,k]=c,S=n.data.get(s.dataId).values,[I,N,C,E]=u,{batchSize:T,filterDepth:A,filterHeight:R,filterWidth:F,inChannels:_,inDepth:D,inHeight:O,inWidth:z,outChannels:L,outDepth:M,outHeight:P,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,j=A-1-h.padInfo.front,G=R-1-h.padInfo.top,H=F-1-h.padInfo.left;for(let K=0;K<T;++K)for(let t=0;t<_;++t)for(let e=0;e<D;++e){const n=e-j,r=Math.max(0,Math.ceil(n/W)),a=Math.min(M,(A+n)/W);for(let s=0;s<O;++s){const o=s-G,i=Math.max(0,Math.ceil(o/U)),l=Math.min(P,(R+o)/U);for(let c=0;c<z;++c){const u=c-H,h=Math.max(0,Math.ceil(u/V)),d=Math.min(B,(F+u)/V);let T=0;for(let e=r;e<a;++e){const r=e*W-n;for(let n=i;n<l;++n){const a=n*U-o;for(let s=h;s<d;++s){const o=v*K+w*e+x*n+k*s,i=I*(A-1-r)+N*(R-1-a)+C*(F-1-(s*V-u))+E*t;for(let t=0;t<L;++t){T+=y[o+t]*S[i+t]}}}}p[f*K+g*e+m*s+b*c+t]=T}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},UW=JP(gv,(t=>Math.cos(t))),VW={kernelName:gv,backendName:"cpu",kernelFunc:UW},jW=JP(mv,(t=>Math.cosh(t))),GW={kernelName:mv,backendName:"cpu",kernelFunc:jW};const HW={kernelName:vv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,[u,h,d,p]=a.shape,f=s.shape[0],[g,m]=i,b=fI([f,g,m,p],"float32"),y=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(a.dataId).values,x=my(a.shape),k=my(b.shape);for(let S=0;S<f;S++){const t=4*S,e=y[t],n=y[t+1],r=y[t+2],a=y[t+3],s=v[S];if(s>=u)continue;const o=g>1?(r-e)*(h-1)/(g-1):0,i=m>1?(a-n)*(d-1)/(m-1):0;for(let u=0;u<g;u++){const t=g>1?e*(h-1)+u*o:.5*(e+r)*(h-1);if(t<0||t>h-1)for(let e=0;e<m;e++)for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}else if("bilinear"===l){const e=Math.floor(t),r=Math.ceil(t),o=t-e;for(let t=0;t<m;t++){const l=m>1?n*(d-1)+t*i:.5*(n+a)*(d-1);if(l<0||l>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let a=n+h*x[2]+e*x[1]+s*x[0];const i=w[a];a=n+f*x[2]+e*x[1]+s*x[0];const l=w[a];a=n+h*x[2]+r*x[1]+s*x[0];const c=w[a];a=n+f*x[2]+r*x[1]+s*x[0];const d=i+(l-i)*g,p=c+(w[a]-c)*g;a=n+t*k[2]+u*k[1]+S*k[0],b.values[a]=d+(p-d)*o}}}else for(let e=0;e<m;++e){const r=m>1?n*(d-1)+e*i:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];b.values[n]=c}continue}const o=Math.round(r),l=Math.round(t);for(let t=0;t<p;t++){const n=t+o*x[2]+l*x[1]+s*x[0],r=t+e*k[2]+u*k[1]+S*k[0];b.values[r]=w[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const KW={kernelName:bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;HP(a,"cumprod");const l=AC([s],a.shape.length);let c=a;null!=l&&(c=VB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=FC(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Kk(c.dtype,"int32"),d=vy(Qb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?1:p[e];else{const n=g(b,t-1);d[e]=o?p[n]*d[n]:p[e]*d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=VB({inputs:{x:m},backend:n,attrs:{perm:RC(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const qW={kernelName:yv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;HP(a,"cumsum");const l=AC([s],a.shape.length);let c=a;null!=l&&(c=VB({inputs:{x:a},backend:n,attrs:{perm:l}}));const u=FC(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(u));const h=Kk(c.dtype,"int32"),d=wy(Qb(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=i?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let b=0;b<p.length;b+=f)for(let t=0;t<f;t++){const e=g(b,t);if(0===t)d[e]=o?0:p[e];else{const n=g(b,t-1);d[e]=o?p[n]+d[n]:p[e]+d[n]}}const m=n.makeTensorInfo(c.shape,h,d);if(null!=l){const t=VB({inputs:{x:m},backend:n,attrs:{perm:RC(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),t}return m}};const XW={kernelName:wv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=bW(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,t)}if(2===a.shape.length){const t=yW(n.bufferSync(a),n.bufferSync(s),o,i);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};const JW={kernelName:xv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r;Jb("NHWC"===o,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)));const i=a.shape[0],l=a.shape[1],c=a.shape[2],u=a.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(a.dataId).values,g=new Float32Array(i*h*d*p);let m=0;for(let b=0;b<i;++b)for(let t=0;t<h;++t){const e=Math.floor(t/s),n=t%s;for(let t=0;t<d;++t){const r=Math.floor(t/s),a=(n*s+t%s)*p;for(let t=0;t<p;++t){const n=t+a+u*(r+c*(e+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],a.dtype,g)}};function YW(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;HP([a,s],"depthwiseConv2DNative");const u=my(a.shape),h=my(s.shape);let d=l;null==d&&(d=[1,1]),Jb(zN(o,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'")));const p=EN(a.shape,s.shape,o,d,i,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:y}=p,v=y.left,w=y.top,x=p.outChannels/p.inChannels,k=new Dk(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const t=C*u[0],e=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=e+n*k.strides[1],a=n*p.strideHeight-w;for(let e=0;e<f;++e){const n=a+e*m;if(n<0||n>=p.inHeight)continue;const s=e*h[0],o=t+n*u[1];for(let t=0;t<p.outWidth;++t){const e=r+t*k.strides[2],n=t*p.strideWidth-v;for(let t=0;t<g;++t){const r=n+t*b;if(r<0||r>=p.inWidth)continue;const a=s+t*h[1],i=o+r*p.inChannels;let l=e,c=a;for(let t=0;t<p.inChannels;++t){const e=S[i+t];for(let t=0;t<x;++t)N[l+t]+=e*I[c+t];l+=x,c+=x}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const ZW={kernelName:kv,backendName:"cpu",kernelFunc:YW};const QW={kernelName:Sv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r;HP([a,s],"depthwiseConv2dNativeBackpropFilter");const h=EN(a.shape,u,o,i,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new Dk(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(a.dataId).values,x=new Dk(a.shape,a.dtype,w),k=n.data.get(s.dataId).values,S=new Dk(s.shape,s.dtype,k);for(let I=0;I<f;++I){const t=Math.max(0,Math.ceil((y-I)/d)),e=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((b-n)/p)),a=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/v),i=s%v;let l=0;for(let c=0;c<h.batchSize;++c)for(let i=t;i<e;++i){const t=I+i*d-y;for(let e=r;e<a;++e){const r=n+e*p-b;l+=x.get(c,t,r,o)*S.get(c,i,e,s)}}m.set(l,I,n,o,i)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const $W={kernelName:Iv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r;HP([a,s],"depthwiseConv2DNativeBackpropInput");const h=my(a.shape),d=my(s.shape),p=EN(u,s.shape,o,i,l,c,!0),f=new Dk(p.inShape,"float32"),g=f.values,[m,b,y]=f.strides,v=n.data.get(a.dataId).values,[w,x,k]=h,S=n.data.get(s.dataId).values,[I,N,C]=d,{batchSize:E,filterHeight:T,filterWidth:A,inChannels:R,inHeight:F,inWidth:_,outChannels:D,outHeight:O,outWidth:z,strideHeight:L,strideWidth:M}=p,P=T-1-p.padInfo.top,B=A-1-p.padInfo.left,W=D/R;for(let U=0;U<E;++U)for(let t=0;t<R;++t)for(let e=0;e<F;++e){const n=e-P,r=Math.max(0,Math.ceil(n/L)),a=Math.min(O,(T+n)/L);for(let s=0;s<_;++s){const o=s-B,i=Math.max(0,Math.ceil(o/M)),l=Math.min(z,(A+o)/M);let c=0;for(let e=r;e<a;++e){const r=e*L-n;for(let n=i;n<l;++n){const a=w*U+x*e+k*n,s=I*(T-1-r)+N*(A-1-(n*M-o))+C*t;for(let e=0;e<W;++e){c+=v[a+(t*W+e)]*S[s+e]}}}g[m*U+b*e+y*s+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const tU={kernelName:Nv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=Qb(r.shape),s=n.data.get(r.dataId).values,o=fI([a,a],r.dtype),i=o.values;for(let c=0;c<s.length;c++)i[c*a+c]=s[c];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},eU={kernelName:Cv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=n,u=c.data.get(a.dataId).values,h=a.shape.length,d=c.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:b,outHeight:y,outWidth:v,padInfo:w,strideHeight:x,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:C,outShape:E}=IN(a.shape,s.shape,o,i,"NHWC",l),T=Qb(E),A=E.length,R=ly(a.dtype,T);for(let F=0;F<f;++F)for(let t=0;t<y;++t){const e=t*x-w.top;for(let n=0;n<v;++n){const r=n*k-w.left;for(let o=0;o<b;++o){let i=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*N;if(n>=0&&n<g)for(let e=0;e<I;++e){const l=r+e*C;if(l>=0&&l<m){const r=Sy([F,n,l,o],h,my(a.shape)),c=Sy([t,e,o],p,my(s.shape)),f=u[r]+d[c];f>i&&(i=f)}}}R[Sy([F,t,n,o],A,my(E))]=i}}}return{dataId:c.write(mk(R,a.dtype),E,a.dtype),shape:E,dtype:a.dtype}}},nU={kernelName:Tv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=yy(a.shape,u.data.get(a.dataId).values),d=yy(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=IN(a.shape,s.shape,i,l,"NHWC",c);Jb(o.rank===C.length,(()=>"Error in ".concat(Tv,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(o.rank)));const E=yy(C,u.data.get(o.dataId).values),T=xy(s.shape,s.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=t,i=e)}}}T[o][i][a]+=E[A][t][n][a]}}}return{dataId:u.write(mk(T,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},rU={kernelName:Ev,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,filter:s,dy:o}=e,{strides:i,pad:l,dilations:c}=r,u=n,h=yy(a.shape,u.data.get(a.dataId).values),d=yy(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=IN(a.shape,s.shape,i,l,"NHWC",c);Jb(o.rank===C.length,(()=>"Error in ".concat(Ev,", dy ")+"must have the same rank as output ".concat(C.length,", but got ")+"".concat(o.rank)));const E=yy(C,u.data.get(o.dataId).values),T=xy(a.shape,a.dtype);for(let A=0;A<p;++A)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<y;++n){const r=n*x-v.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,o=e<0?0:e,i=r<0?0:r;for(let t=0;t<k;++t){const n=e+t*I;if(n>=0&&n<f)for(let e=0;e<S;++e){const l=r+e*N;if(l>=0&&l<g){const r=h[A][n][l][a]+d[t][e][a];r>s&&(s=r,o=n,i=l)}}}T[A][o][i][a]+=E[A][t][n][a]}}}return{dataId:u.write(mk(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const aU={kernelName:Av,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a}=e,{canvas:s,options:o}=r,{contextOptions:i,imageOptions:l}=o||{},c=(null===l||void 0===l?void 0:l.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const h=s.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],g=n.data.get(a.dataId).values,m="float32"===a.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const t=[0,0,0,255*c];for(let n=0;n<f;n++){const e=g[v*f+n];if("float32"===a.dtype){if(e<0||e>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(e,"."))}else if("int32"===a.dtype&&(e<0||e>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(e,"."));1===f?(t[0]=e*m,t[1]=e*m,t[2]=e*m):t[n]=e*m}const e=4*v;b[e+0]=Math.round(t[0]),b[e+1]=Math.round(t[1]),b[e+2]=Math.round(t[2]),b[e+3]=Math.round(t[3])}s.width=p,s.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),a}},sU=rB(((t,e)=>t*e)),oU=IB(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),iU=SB(Nw,sU,oU),lU={kernelName:Nw,backendName:"cpu",kernelFunc:iU};function cU(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;let i;HP(a,"sum"),i="bool"===a.dtype?xB({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):$P({inputs:{x:a},backend:n});const l=i.shape.length,c=sy(s,i.shape),u=AC(c,l);let h=c,d=i;null!=u&&(d=VB({inputs:{x:i},backend:n,attrs:{perm:u}}),h=FC(h.length,l)),TC("sum",h,d.shape.length);const[p,f]=CC(d.shape,h);let g=bB(n,p,Kk(d.dtype,"int32"));const m=Qb(f),b=n.data.get(g.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const t=v*m;let e=0;for(let n=0;n<m;++n)e+=y[t+n];b[v]=e}if(o){const t=g;g=AB({inputs:{x:g},backend:n,attrs:{shape:EC(g.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),g}const uU={kernelName:dx,backendName:"cpu",kernelFunc:cU};const hU={kernelName:Fv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=fA(a,s.length);mA(o.length,l,s);const{path:c,steps:u}=bA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=gA(p,l[t]);let a;yA(e)?a=s[t]:(a=VB({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);$b(a.shape,o)||(a=AB({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=iU({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=cU({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}};const dU={kernelName:Dv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:a}=e;HP([r,a],"eluGrad");const s=new Float32Array(Qb(a.shape)),o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const t=o[l];s[l]=t>=0?i[l]:i[l]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},pU=rB(((t,e)=>t===e?1:0)),fU=SB(zv,pU,null,"bool"),gU={kernelName:zv,backendName:"cpu",kernelFunc:fU},mU=YT,bU=ZT,yU=QT,vU=$T,wU=tA,xU=eA,kU=JP(Ov,(t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+mU*n);return e*(1-((((xU*r+wU)*r+vU)*r+yU)*r+bU)*r*Math.exp(-n*n))})),SU={kernelName:Ov,backendName:"cpu",kernelFunc:kU},IU=XP((t=>Math.exp(t))),NU=YP(Lv,IU,"float32"),CU={kernelName:Lv,backendName:"cpu",kernelFunc:NU};function EU(t){const{inputs:e,backend:n,attrs:r}=t,{input:a}=e,{dim:s}=r,o=a.shape.length,i=a.shape.slice();let l=s;return s<0&&(Jb(-(o+1)<=s,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+s+1),i.splice(l,0,1),AB({inputs:{x:a},backend:n,attrs:{shape:i}})}const TU={kernelName:Mv,backendName:"cpu",kernelFunc:EU},AU=XP((t=>Math.expm1(t))),RU=YP(Pv,AU),FU={kernelName:Pv,backendName:"cpu",kernelFunc:RU},_U=rB(((t,e)=>t/e)),DU=SB(Rv,_U),OU={kernelName:Rv,backendName:"cpu",kernelFunc:DU},zU=rB(((t,e)=>t-e)),LU=IB(((t,e,n,r)=>({real:t-n,imag:e-r}))),MU=SB(Tx,zU,LU),PU={kernelName:Tx,backendName:"cpu",kernelFunc:MU};function BU(t,e,n){const r=t.shape,a=r[0],s=r[1],o=n.data.get(t.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[a,s],u=Qb(c),h=iy("float32",u),d=iy("float32",u);for(let m=0;m<a;m++){const t=fW({inputs:{x:i},backend:n,attrs:{begin:[m,0],size:[1,s]}}),r=fW({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,s]}}),a=gB({inputs:{real:t,imag:r},backend:n}),{real:o,imag:c}=WU(a,e,n),u=nA(o,c);for(let e=0;e<s;e++){const t=oA(u,e);h[m*s+e]=t.real,d[m*s+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),g=gB({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function WU(t,e,n){const r=Qb(t.shape),a=n.data.get(t.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((i=r)&i-1)){const a=UU(s,o,r,e,n),i=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(i,"float32",a.real),e=n.makeTensorInfo(i,"float32",a.imag),s=n.makeTensorInfo([],"float32",gk(r,"float32")),o=$P({inputs:{x:s},backend:n}),l=OU.kernelFunc({inputs:{a:t,b:s},backend:n}),c=OU.kernelFunc({inputs:{a:e,b:o},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return a}{const t=function(t,e,n){const r=new Float32Array(2*e);for(let a=0;a<e;a++){let s=0,o=0;for(let r=0;r<e;r++){const i=cA(a*r,e,n),l=oA(t,r);s+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(s/=e,o/=e),iA(r,s,o,a)}return r}(nA(s,o),r,e);return rA(t)}var i}function UU(t,e,n,r,a){if(1===n)return{real:t,imag:e};const s=nA(t,e),o=n/2,i=aA(s),l=i.real,c=i.imag,u=[l.length],h=a.makeTensorInfo(u,"float32",l),d=a.makeTensorInfo(u,"float32",c),p=gB({inputs:{real:h,imag:d},backend:a}),f=sA(s),g=f.real,m=f.imag,b=[g.length],y=a.makeTensorInfo(b,"float32",g),v=a.makeTensorInfo(b,"float32",m),w=gB({inputs:{real:y,imag:v},backend:a}),x=UU(l,c,o,r,a),k=x.real,S=x.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),C=a.makeTensorInfo(I,"float32",S),E=gB({inputs:{real:N,imag:C},backend:a}),T=UU(g,m,o,r,a),A=T.real,R=T.imag,F=[A.length],_=a.makeTensorInfo(F,"float32",A),D=a.makeTensorInfo(F,"float32",R),O=gB({inputs:{real:_,imag:D},backend:a}),z=lA(n,r),L=[z.real.length],M=a.makeTensorInfo(L,"float32",z.real),P=a.makeTensorInfo(L,"float32",z.imag),B=gB({inputs:{real:M,imag:P},backend:a}),W=iU({inputs:{a:B,b:O},backend:a}),U=EB({inputs:{a:E,b:W},backend:a}),V=MU({inputs:{a:E,b:W},backend:a}),j=yB({inputs:{input:U},backend:a}),G=yB({inputs:{input:V},backend:a}),H=RW({inputs:{input:U},backend:a}),K=RW({inputs:{input:V},backend:a}),q=_W({inputs:[j,G],backend:a,attrs:{axis:0}}),X=_W({inputs:[H,K],backend:a,attrs:{axis:0}}),J=a.data.get(q.dataId).values,Y=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(O),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(X),{real:J,imag:Y}}const VU={kernelName:Bv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Qb(r.shape),s=r.shape[r.shape.length-1],o=AB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=BU(o,!1,n),l=AB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}};function jU(t){const{backend:e,attrs:n}=t,{shape:r,value:a,dtype:s}=n,o=s||py(a),i=ly(o,Qb(r));return function(t,e,n){t.fill(e)}(i,a),e.makeTensorInfo(r,o,i)}const GU={kernelName:Wv,backendName:"cpu",kernelFunc:jU};const HU={kernelName:Uv,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,s=r,o=iy(a.dtype,Qb(a.shape)),[i,l,c,u]=a.shape,h=s.data.get(a.dataId).values;for(let d=0;d<i;d++){const t=d*c*l*u;for(let e=0;e<l;e++){const n=e*(c*u);for(let e=0;e<c;e++){const r=e*u;for(let a=0;a<u;a++){const s=Math.round(c-e-1),i=t+n+r+a;let l=h[i];if(s>=0&&s<c){l=h[t+n+s*u+a]}o[i]=l}}}}return{dataId:s.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},KU=XP((t=>Math.floor(t))),qU=YP(Vv,KU),XU={kernelName:Vv,backendName:"cpu",kernelFunc:qU},JU=rB(((t,e)=>Math.floor(t/e))),YU=SB(jv,JU,null,"int32"),ZU={kernelName:jv,backendName:"cpu",kernelFunc:YU};const QU={kernelName:jx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=OW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const t=AB({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=EB({inputs:{a:g,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else g=EB({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=g;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const t=AB({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=fB(n,g,p,t,f),n.disposeIntermediateTensorInfo(t)}else g=fB(n,g,p,i,f);n.disposeIntermediateTensorInfo(t)}return g}};const $U={kernelName:Gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=YW({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=g;g=EB({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=g;g=fB(n,g,p,i,f),n.disposeIntermediateTensorInfo(t)}return g}};function tV(t,e,n,r,a,s,o,i,l){const c=fI([r,s],n);for(let u=0;u<r;u++){const n=[];let r=0;for(let e=0;e<a;e++){const s=t[u*a+e];r+=s*o[e],n.push(s)}if(r<0||r>=l/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let t=0;t<s;t++)c.values[u*s+t]=e.get(...e.indexToLoc(r*s+t))}return c}const eV={kernelName:Kv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=Qb(r.shape),o=a.shape,i=o[o.length-1],[l,c,u,h]=GT(r,a);if(0===c)return n.makeTensorInfo(l,r.dtype,[]);const d=tV(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,c,i,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}};function nV(t,e,n){const r=fI(n,t.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],o=n[2],i=e.locToIndex([s,o]);n[2]=e.values[i];const l=t.locToIndex(n);0<=l&&l<t.values.length&&(r.values[a]=t.values[l])}return r}const rV={kernelName:Hv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r;HP([a,s],"gatherV2");const l=sy(o,a.shape)[0],c=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<c.length;++v){const t=c[v];Jb(t<=u-1&&t>=0,(()=>"GatherV2: the index value ".concat(t," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=Qb(s.shape),p=zA(a,s,l,h),f=AB({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=AB({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),y=nV(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},aV=rB(((t,e)=>t>e?1:0)),sV=SB(qv,aV,null,"bool"),oV={kernelName:qv,backendName:"cpu",kernelFunc:sV},iV=rB(((t,e)=>t>=e?1:0)),lV=SB(Xv,iV,null,"bool"),cV={kernelName:Xv,backendName:"cpu",kernelFunc:lV};const uV={kernelName:Yv,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,a=Qb(r.shape),s=r.shape[r.shape.length-1],o=AB({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=BU(o,!0,n),l=AB({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}},hV=JP(Qv,(t=>Number.isFinite(t)?1:0),"bool"),dV={kernelName:Qv,backendName:"cpu",kernelFunc:hV},pV=JP($v,(t=>Math.abs(t)===1/0?1:0),"bool"),fV={kernelName:$v,backendName:"cpu",kernelFunc:pV},gV=JP(tw,(t=>Number.isNaN(t)?1:0),"bool"),mV={kernelName:tw,backendName:"cpu",kernelFunc:gV},bV=rB(((t,e)=>t<e?1:0)),yV=SB(nw,bV,null,"bool"),vV={kernelName:nw,backendName:"cpu",kernelFunc:yV},wV=rB(((t,e)=>t<=e?1:0)),xV=SB(rw,wV,null,"bool"),kV={kernelName:rw,backendName:"cpu",kernelFunc:xV};function SV(t,e,n){const r=(e-t)/(n-1),a=wy(n,"float32");a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const IV={kernelName:aw,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=SV(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},NV=XP((t=>Math.log(t))),CV=YP(sw,NV),EV={kernelName:sw,backendName:"cpu",kernelFunc:CV},TV=JP(ow,(t=>Math.log1p(t))),AV={kernelName:ow,backendName:"cpu",kernelFunc:TV},RV=rB(((t,e)=>t&&e)),FV=SB(iw,RV,null,"bool"),_V={kernelName:iw,backendName:"cpu",kernelFunc:FV},DV=JP(lw,(t=>t?0:1),"bool"),OV={kernelName:lw,backendName:"cpu",kernelFunc:DV},zV=rB(((t,e)=>t||e)),LV=SB(cw,zV,null,"bool"),MV={kernelName:cw,backendName:"cpu",kernelFunc:LV};const PV={kernelName:uw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r;HP(a,"LRN");const c=a.shape[3],u=c-1,h=n.data.get(a.dataId).values,d=Qb(a.shape),p=new Float32Array(d);function f(t){const e=t%c;let n=t-e+Math.max(0,e-s);const r=t-e+Math.min(e+s,u);let a=0;for(;n<=r;n++){const t=h[n];a+=t*t}return a}for(let g=0;g<d;g++){const t=f(g),e=h[g]*Math.pow(o+i*t,-l);p[g]=e}return n.makeTensorInfo(a.shape,a.dtype,p)}};const BV={kernelName:hw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r;HP(o,"LRNGrad");const h=Qb(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(a.dataId).values,g=n.data.get(s.dataId).values,m=new Float32Array(h),b=h;for(let y=0;y<b;y++){const t=y%d,e=y-t+Math.max(0,t-i),n=y-t+Math.min(d,t+i+1);let r=0;for(let a=e;a<n;a++)r+=Math.pow(f[a],2);r=c*r+l;for(let a=e;a<n;a++){let t=-2*c*u*f[a]*g[y]/r;y===a&&(t+=Math.pow(r,-u)),t*=p[y],m[a]+=t}}return n.makeTensorInfo(o.shape,a.dtype,m)}};function WV(t,e,n,r){const a=iy(r,Qb(n));for(let s=0;s<a.length;++s){const n=s*e;let r=t[n];for(let a=0;a<e;++a){const e=t[n+a];(Number.isNaN(e)||e>r)&&(r=e)}a[s]=r}return a}function UV(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=n;let l=a.shape;const c=l.length,u=sy(s,l);let h=u;const d=AC(h,c);let p=i.data.get(a.dataId).values;if(null!=d){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=UB(p,l,a.dtype,d,t),h=FC(h.length,c),l=t}HP(a,"max"),TC("max",h,c);const[f,g]=CC(l,h),m=WV(p,Qb(g),f,a.dtype),b=i.write(m,f,a.dtype);let y=f;if(o){y=EC(f,u)}return{dataId:b,shape:y,dtype:a.dtype}}const VV={kernelName:dw,backendName:"cpu",kernelFunc:UV},jV=rB(((t,e)=>Math.max(t,e))),GV=SB(pw,jV),HV={kernelName:pw,backendName:"cpu",kernelFunc:GV};const KV={kernelName:fw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;HP(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(zN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=NN(a.shape,s,o,1,i,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))u=$P({inputs:{x:a},backend:n});else{const t=n.data.get(a.dataId).values,e=my(a.shape),r=sW(t,a.shape,a.dtype,e,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};const qV={kernelName:mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r;HP(a,"maxPool3d");const u=CN(a.shape,s,o,1,i,l,c),h=iW(n.data.get(a.dataId).values,a.shape,a.dtype,my(a.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const XV={kernelName:bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,{filterSize:o,strides:i,pad:l,dimRoundingMode:c}=r;HP([a,s],"maxPool3DGrad");const u=CN(s.shape,o,i,1,l,c),h=function(t,e){const n=fI(e.outShape,"int32"),r=e.strideDepth,a=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let b=0;b<e.outDepth;++b){const y=b*r-d;let v=y;for(;v<0;)v+=o;const w=Math.min(e.inDepth,c+y);for(let r=0;r<e.outHeight;++r){const c=r*a-p;let d=c;for(;d<0;)d+=i;const x=Math.min(e.inHeight,u+c);for(let a=0;a<e.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(e.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let e=v;e<w;e+=o){const n=e-y;for(let r=d;r<x;r+=i){const a=r-c;for(let s=k;s<S;s+=l){const o=s-p,i=t.get(g,e,r,s,m);i>=I&&(I=i,N=n*u*h+a*u+o)}}}n.set(N,g,b,r,a,m)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,m=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,x=y-1-u.padInfo.front,k=w-1-u.padInfo.left,S=v-1-u.padInfo.top,I=fI(s.shape,"float32"),N=n.bufferSync(a);for(let C=0;C<u.batchSize;++C)for(let t=0;t<u.inChannels;++t)for(let e=0;e<u.inDepth;++e)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=e-x,s=n-S,o=r-k;let i=0;for(let e=0;e<y;e+=g){const n=(a+e)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=m){const a=(s+r)/p;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let s=0;s<w;s+=b){const l=(o+s)/f;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;const c=y*v*w-1-h.get(C,n,a,l,t)===e*v*w+r*w+s?1:0;if(0===c)continue;i+=N.get(C,n,a,l,t)*c}}}I.set(i,C,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const JV={kernelName:gw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;HP([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=NN(i.shape,l,c,1,u,h),p=n.data.get(i.dataId).values,f=fI(d.outShape,i.dtype,oW(p,i.shape,i.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,k=v-1-d.padInfo.top,S=fI(i.shape,"float32"),I=n.data.get(a.dataId).values,N=fI(a.shape,"float32",I);for(let C=0;C<d.batchSize;++C)for(let t=0;t<d.inChannels;++t)for(let e=0;e<d.inHeight;++e)for(let n=0;n<d.inWidth;++n){const r=e-k,a=n-x;let s=0;for(let e=0;e<v;e+=b){const n=(r+e)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<w;r+=y){const o=(a+r)/m;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const i=v*w-1-f.get(C,n,o,t)===e*w+r?1:0;if(0===i)continue;s+=N.get(C,n,o,t)*i}}S.set(s,C,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const YV={kernelName:yw,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;HP(a,"MaxPoolWithArgmax");const u=c.data.get(a.dataId).values,h=NN(a.shape,s,o,[1,1],i),[d,p]=function(t,e,n,r,a){const s=sW(t,0,n,my(e),a,"max"),o=oW(t,e,n,a,!0,r);return[s.values,o.values]}(u,a.shape,a.dtype,l,h),f=c.write(d,h.outShape,a.dtype),g=c.write(p,h.outShape,a.dtype);return[{dataId:f,shape:h.outShape,dtype:a.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const ZV={kernelName:vw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=sy(s,a.shape),l=Qb(CC(a.shape,i)[1]),c=[],u=n.makeTensorInfo([],"float32",new Float32Array([l]));c.push(u);const h=xB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const d=DU({inputs:{a:h,b:u},backend:n});c.push(d);const p=cU({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}};const QV={kernelName:ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;HP(a,"min");const i=sy(s,a.shape);let l=i;const c=AC(l,a.shape.length);let u=a;null!=c&&(u=VB({inputs:{x:a},backend:n,attrs:{perm:c}}),l=FC(l.length,a.shape.length)),TC("min",l,u.shape.length);const[h,d]=CC(u.shape,l),p=Qb(d),f=wy(Qb(h),u.dtype),g=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const t=b*p;let e=g[t];for(let n=0;n<p;++n){const r=g[t+n];(Number.isNaN(r)||r<e)&&(e=r)}f[b]=e}null!=c&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(h,u.dtype,f);if(o){const t=AB({inputs:{x:m},backend:n,attrs:{shape:EC(h,i)}});return n.disposeIntermediateTensorInfo(m),t}return m}},$V=rB(((t,e)=>Math.min(t,e))),tj=SB(xw,$V),ej={kernelName:xw,backendName:"cpu",kernelFunc:tj};const nj={kernelName:kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,mode:o}=r;HP(a,"mirrorPad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=s.map(((t,e)=>t[0]+a.shape[e])),u="reflect"===o?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=my(a.shape),f=Qb(i),g=i.length,m=my(i),b=iy(a.dtype,f);for(let y=0;y<f;y++){let t=Iy(y,g,m);for(let n=0;n<g;n++)t[n]<l[n]?t[n]=2*l[n]-t[n]-u:t[n]>=c[n]&&(t[n]=2*(c[n]-1)-t[n]+u);t=t.map(((t,e)=>t-l[e]));const e=Sy(t,d,p);b[y]=h[e]}return{dataId:n.write(b,i,a.dtype),shape:i,dtype:a.dtype}}},rj=rB(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),aj=SB(Sw,rj),sj={kernelName:Sw,backendName:"cpu",kernelFunc:aj};function oj(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=a.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(i));const l=sy([i],a.shape),c=UV({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=EC(c.shape,l),h=AB({inputs:{x:c},backend:n,attrs:{shape:u}}),d=MU({inputs:{a:a,b:h},backend:n}),p=NU({inputs:{x:d},backend:n}),f=cU({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=AB({inputs:{x:f},backend:n,attrs:{shape:u}}),m=DU({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const ij={kernelName:gx,backendName:"cpu",kernelFunc:oj};const lj={kernelName:Iw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r;HP(a,"multinomial");const l=i?a:oj({inputs:{logits:a},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=wy(Qb(d),"int32");for(let f=0;f<c;++f){const t=f*u,e=new Float32Array(u-1);e[0]=h[t];for(let a=1;a<e.length;++a)e[a]=e[a-1]+h[t+a];const n=Vo.alea(o.toString()),r=f*s;for(let a=0;a<s;++a){const t=n();p[r+a]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){p[r+a]=n;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function cj(t,e,n){const r=gk(-1,n);return sU([],e,r,t,n)}const uj={kernelName:Cw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;HP(r,"neg");const a=n.data.get(r.dataId).values,[s,o]=cj(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}},hj=YE;const dj={kernelName:Tw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r;HP(a,"NonMaxSuppression");const c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=hj(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},pj=ZE;const fj={kernelName:Aw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r;HP(a,"NonMaxSuppressionPadded");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=pj(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},gj=QE;const mj={kernelName:Rw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r;HP(a,"NonMaxSuppressionWithScore");const u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=gj(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},bj=rB(((t,e)=>t!==e?1:0)),yj=SB(Ew,bj,null,"bool"),vj={kernelName:Ew,backendName:"cpu",kernelFunc:yj};const wj={kernelName:_w,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r;HP(a,"oneHot");const c=Qb(a.shape),u=new Float32Array(c*o);u.fill(l);const h=n.data.get(a.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=i);return n.makeTensorInfo([...a.shape,o],s,u)}};function xj(t){const{inputs:e,backend:n}=t,{x:r}=e;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const t=yB({inputs:{input:r},backend:n}),e=xj({inputs:{x:t},backend:n}),a=RW({inputs:{input:r},backend:n}),s=xj({inputs:{x:a},backend:n}),o=gB({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return jU({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const kj={kernelName:Px,backendName:"cpu",kernelFunc:xj};const Sj={kernelName:Fw,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const e=yB({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=RW({inputs:{input:a},backend:r}),o=xj({inputs:{x:s},backend:r}),i=gB({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return jU({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function Ij(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return EU({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Yb(s,t.shape,"All tensors passed to stack must have matching shapes"),Jb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=_W({inputs:e.map((t=>{const e=EU({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}const Nj={kernelName:Dw,backendName:"cpu",kernelFunc:Ij};const Cj={kernelName:Ow,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;HP(a,"pad");const i=s.map(((t,e)=>t[0]+a.shape[e]+t[1])),l=s.map((t=>t[0])),c=n.data.get(a.dataId).values,u=Qb(a.shape),h=a.shape.length,d=my(a.shape),p=Qb(i),f=i.length,g=my(i),m=iy(a.dtype,p);0!==o&&m.fill(o);for(let b=0;b<u;b++){m[Sy(Iy(b,h,d).map(((t,e)=>t+l[e])),f,g)]=c[b]}return{dataId:n.write(m,i,a.dtype),shape:i,dtype:a.dtype}}},Ej=rB(((t,e)=>Math.pow(t,e))),Tj=SB(zw,Ej),Aj={kernelName:zw,backendName:"cpu",kernelFunc:Tj};function Rj(t,e,n,r){const[a,s]=CC(t,r),o=Kk(e,"int32"),i=wy(Qb(a),o),l=Qb(s);for(let c=0;c<i.length;++c){const t=c*l;let e=1;for(let r=0;r<l;++r)e*=n[t+r];i[c]=e}return{outVals:i,outShape:a,outDtype:o}}const Fj={kernelName:Mw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;HP(a,"prod");const i=a.shape.length,l=sy(s,a.shape),c=AC(l,i);let u=l,h=a;const d=[];null!=c&&(h=VB({inputs:{x:a},backend:n,attrs:{perm:c}}),d.push(h),u=FC(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=Rj(h.shape,h.dtype,p,u);let b=g;return o&&(b=EC(g,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(b,m,f)}};function _j(t,e,n,r){const a=[];let s=0;const o=e.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const r=t[n],a=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const t=e[c+1];for(let e=1;e<l+1;++e)i[c].push(e*t)}for(let c=0;c<t.length;++c){let r=t[c],o=t[c]+1;for(let t=0;t<n.length;++t){const a=n[t],s=t+e.length-1;if(s>=0){const t=i[s],e=t[t.length-1]-a[r];for(let n=r;n<o;++n)i[s].push(a[n+1]+e)}r=a[r],o=a[o]}o!==r&&(a.push([r,o]),s+=o-r)}return{outSplits:i,valueSlices:a,numValues:s}}function Dj(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function Oj(t,e,n,r,a){const s=e.slice();s[0]=a;const o=ly(n,Qb(s)),i=t.length;return function(t,e,n,r,a,s){const o=Dj(e,2)[1],i=Dj(s,2)[1];let l=0;for(const c of n)for(let e=c[0];e<c[1];++e){for(let n=0;n<r;++n)a[l*i+n]=t[e*o+n];++l}}(t,e,r,0===i?0:i/e[0],o,s),[o,s]}function zj(t,e,n,r,a,s,o,i){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,r)=>{if(t<0||t>=n){const a=Iy(r,e.length,my(e)).join(",");throw new Error("indices[".concat(a,"] = ").concat(t," is not in [0, ").concat(n,")"))}}))}(s,o,e[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:u,numValues:h}=_j(s,o,t,l),d=function(t){const e=[];for(let n=0;n<t.length;++n){const r=ly("int32",t[n].length);e.push(r),t[n].forEach(((t,e)=>r[e]=t))}return e}(c),p=Oj(n,r,a,u,h);return[d,p[0],p[1]]}const Lj={kernelName:Pw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.data.get(t.dataId).values)),c=a.map((t=>t.shape)),u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,[d,p,f]=zj(l,c,u,s.shape,s.dtype,h,o.shape),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}},Mj=2147483647;function Pj(t,e,n,r,a,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=0===e.length,l=0===a.length,c=0===o.length,u=[];i||u.push(e[0]),l||u.push(a[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=ly("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const e=i?t[0]:t[g],n=l?r[0]:r[g],a=c?s[0]:s[g];if(0===a)throw new Error("Requires delta != 0");let o;if(a>0&&n<e||a<0&&n>e)o=0;else if(o=Math.ceil(Math.abs((n-e)/a)),o>Mj)throw new Error("Requires ((limit - start) / delta) <= ".concat(Mj));d[g+1]=d[g]+o}const p=ly(n,d[h]);let f=0;for(let g=0;g<h;++g){const e=d[g+1]-d[g];let n=i?t[0]:t[g];const r=c?s[0]:s[g];for(let t=0;t<e;++t)p[f++]=n,n+=r}return[d,p]}const Bj={kernelName:Bw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=Pj(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};var Wj=FT;class Uj{constructor(t,e,n,r,a,s,o,i,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=DT(c),this.raggedRank=OT(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Wj.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Wj.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Wj.VALUE_ROWIDS:return Uj.getMaxWidthValueRowID(e);case Wj.ROW_SPLITS:return Uj.getMaxWidthRowSplit(e);default:throw new Error("Cannot handle partition type ".concat(Wj[this.getRowPartitionTypeByDimension(t-1)]))}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let r=0;r<e-1;++r){const e=t[r+1]-t[r];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,r=t[0],a=0;for(let s=1;s<e;++s){const e=t[s];e!==r&&(r=e,a=Math.max(s-n,a),n=s)}return Math.max(e-n,a)}tensorShapeFromTensor(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return jj(t,n)}calculateOutputSize(t){const e=this.valuesShape;zT(this.defaultValueShape,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=_T(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(t,e,n){const r=Math.min(t,n),a=[];let s=0;for(let o=0;o<r;++o,s+=e)a.push(s);for(let o=r;o<t;++o)a.push(-1);return Jb(a.length===t,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(t,e,n,r){const a=t.length,s=[];for(let o=0;o<a-1;++o){const a=t[o+1]-t[o];let i=Math.min(r,a),l=e[o];-1===l&&(i=0);for(let t=0;t<i;++t)s.push(l),l+=n;for(let t=0;t<a-i;++t)s.push(-1)}if(a>0&&s.length!==t[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,r){const a=t.length,s=[];if(0===a)return[];let o=0,i=t[0];if(i>=e.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(e.length));let l=e[i];s.push(l);for(let c=1;c<a;++c){const a=t[c];if(a===i)l>=0&&(++o,o<r?l+=n:l=-1);else{if(o=0,i=a,a>=e.length)throw new Error("Got nextValueRowId=".concat(a," which is not less than ").concat(e.length));l=e[a]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,r){const a=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case Wj.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,e,n,r);case Wj.ROW_SPLITS:if(a.length-1>e.length)throw new Error("Row partition size is greater than output size: ".concat(a.length-1," > ").concat(e.length));return this.calculateOutputIndexRowSplit(a,e,n,r);default:throw new Error("Unsupported partition type: ".concat(Wj[s]))}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Wj.FIRST_DIM_SIZE:return t[0];case Wj.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Wj.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(Wj[e]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*e[s+1];const r=jj(e,!1),a=ly(this.valuesDType,Qb(r));if(n[0]*e[0]>0){let s=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t){s=this.calculateOutputIndex(t-1,s,n[t],e[t])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(t,e,n,r){if(0===n.length)return;const a=this.values,s=n;let o=r.slice();o=o.slice(t+1);const i=Qb(o),l=e.length;let c=this.defaultValue;if(c.length!==i&&1!==c.length){const t=this.defaultValueShape;SS((()=>{const e=BN(c,t),n=KN(e,o);c=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=l;++p){let t=p<l?e[p]:-1;if(t!==d){if(h<d){const t=a.subarray(u*i);Vj(s.subarray(h*i),t,(d-h)*i)}if(p>=l){const e=n.length;t=Math.floor(e/i)}if(t>d)if(1===this.defaultValue.length)s.subarray(d*i,t*i).fill(this.defaultValue[0]),d=t;else for(;t>d;){Vj(s.slice(d*i),c,i),++d}t<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function Vj(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function jj(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error("Dimension ".concat(r," must be >= 0"));if(r<-1)throw new Error("Dimension ".concat(r," must be >= -1"));r=-1}n.push(r)}return n}function Gj(t,e,n,r,a,s,o,i,l,c){return new Uj(t,e,n,r,a,s,o,i,l,c).compute()}const Hj={kernelName:Ww,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=i.map((t=>n.data.get(t.dataId).values)),p=i.map((t=>t.shape)),[f,g]=Gj(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}};function Kj(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return wy(0,r);const a=wy(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const qj={kernelName:Uw,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,dtype:s,step:o}=n,i=Kj(r,a,o,s);return e.makeTensorInfo([i.length],s,i)}},Xj=JP(jw,(t=>1/t)),Jj={kernelName:jw,backendName:"cpu",kernelFunc:Xj};const Yj={kernelName:Xw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;HP(a,"resizeBilinear");const l=my(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(Qb([h,c,u,f])),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u];let v=0;const w=b[0]/y[0],x=b[1]/y[1];for(let k=0;k<h;k++)for(let t=0;t<c;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,a=Math.min(d-1,Math.ceil(e)),s=k*l[0]+n*l[1],i=k*l[0]+a*l[1];for(let t=0;t<u;t++){let e;e=o?x*(t+.5)-.5:x*t;const n=Math.max(0,Math.floor(e)),a=e-n,c=Math.min(p-1,Math.ceil(e)),u=s+n*l[2],h=i+n*l[2],d=s+c*l[2],b=i+c*l[2];for(let t=0;t<f;t++){const e=g[u+t],n=g[h+t],s=e+(g[d+t]-e)*a,o=s+(n+(g[b+t]-n)*a-s)*r;m[v++]=o}}}return n.makeTensorInfo([h,c,u,f],"float32",m)}};const Zj={kernelName:Jw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;HP([s,a],"resizeBilinearGrad");const i=my(a.shape),[l,c,u,h]=a.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),g=[o&&d>1?c-1:c,o&&p>1?u-1:u],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],b=g[0]/m[0],y=g[1]/m[1],v=n.data.get(s.dataId).values;let w=0;for(let x=0;x<l;x++){const t=x*i[0];for(let e=0;e<d;e++){const n=e*b,r=Math.floor(n),a=Math.min(Math.ceil(n),c-1),s=t+r*i[1],o=t+a*i[1],l=n-r,d=1-l;for(let t=0;t<p;t++){const e=t*y,n=Math.floor(e),r=Math.min(Math.ceil(e),u-1),a=e-n,c=1-a,p=s+n*i[2],g=s+r*i[2],m=o+n*i[2],b=o+r*i[2],x=d*c,k=d*a,S=l*c,I=l*a;for(let t=0;t<h;t++){const e=v[w++];f[p+t]+=e*x,f[g+t]+=e*k,f[m+t]+=e*S,f[b+t]+=e*I}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}};const Qj={kernelName:Kw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r;HP(a,"resizeNearestNeighbor");const l=my(a.shape),[c,u]=i,[h,d,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(h*c*u*f),b=[s&&c>1?d-1:d,s&&u>1?p-1:p],y=[s&&c>1?c-1:c,s&&u>1?u-1:u],v=b[0]/y[0],w=b[1]/y[1];let x=0;for(let k=0;k<h;k++){const t=k*l[0];for(let e=0;e<c;e++){const n=o?v*(e+.5):v*e;let r=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));const a=t+r*l[1];for(let t=0;t<u;t++){const e=o?w*(t+.5):w*t;let n=Math.min(p-1,s?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const r=a+n*l[2];for(let t=0;t<f;t++){const e=g[r+t];m[x++]=e}}}}return n.makeTensorInfo([h,c,u,f],a.dtype,m)}};const $j={kernelName:qw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r;HP([s,a],"resizeNearestNeighborGrad");const i=my(a.shape),l=my(s.shape),[c,u,h,d]=a.shape,[,p,f]=s.shape,g=new Float32Array(c*u*h*d),m=n.data.get(s.dataId).values,b=[o&&p>1?u-1:u,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=b[0]/y[0],w=b[1]/y[1],x=1/v,k=1/w,S=2*Math.ceil(x)+2,I=2*Math.ceil(k)+2;for(let N=0;N<c;N++){const t=N*i[0];for(let e=0;e<u;e++){const n=t+e*i[1],r=Math.floor(e*x),a=Math.floor(r-S/2);for(let s=0;s<h;s++){const r=n+s*i[2],c=Math.floor(s*k),b=Math.floor(c-I/2);for(let n=0;n<d;n++){let i=0;for(let r=0;r<S;r++){const c=r+a;if(c<0||c>=p)continue;const d=t+c*l[1],g=c*v;if(e===Math.min(u-1,o?Math.round(g):Math.floor(g)))for(let t=0;t<I;t++){const e=t+b;if(e<0||e>=f)continue;const r=d+e*l[2],a=e*w;s===Math.min(h-1,o?Math.round(a):Math.floor(a))&&(i+=m[r+n])}}g[r+n]=i}}}}return n.makeTensorInfo(a.shape,a.dtype,g)}};const tG={kernelName:Zw,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r;HP(a,"reverse");const o=a.shape.length,i=sy(s,a.shape);if(0===o)return $P({inputs:{x:a},backend:n});const l=new Dk(a.shape,a.dtype),c=n.bufferSync(a);for(let u=0;u<l.size;u++){const t=l.indexToLoc(u),e=t.slice();i.forEach((t=>e[t]=a.shape[t]-1-e[t])),l.set(c.get(...e),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},eG={kernelName:Ux,backendName:"cpu",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=iy(a.dtype,Qb(a.shape)),[u,h,d,p]=a.shape,[f,g]=PT(i,h,d),m=Math.sin(s),b=Math.cos(s),y=l.data.get(a.dataId).values;for(let v=0;v<u;v++){const t=v*d*h*p;for(let e=0;e<h;e++){const n=e*(d*p);for(let r=0;r<d;r++){const a=r*p;for(let s=0;s<p;s++){const i=[u,e,r,s],l=i[2],v=i[1];let w=(l-f)*b-(v-g)*m,x=(l-f)*m+(v-g)*b;w=Math.round(w+f),x=Math.round(x+g);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),w>=0&&w<d&&x>=0&&x<h){k=y[t+x*(d*p)+w*p+s]}c[t+n+a+s]=k}}}}return{dataId:l.write(c,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},nG=JP(Qw,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1})),rG={kernelName:Qw,backendName:"cpu",kernelFunc:nG},aG=XP((t=>1/Math.sqrt(t))),sG=YP($w,aG),oG={kernelName:$w,backendName:"cpu",kernelFunc:sG};function iG(t,e,n,r,a,s,o,i,l,c){const u=[r/a,a],h=t.values,d=e.values;if(0===r)return fI(n,e.dtype);const p=l instanceof Dk?l:fI(u,e.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const t=[];let s=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),s+=n*i[e]}if(s<0||s>=r/a)throw new Error("Invalid indices: ".concat(t," does not index into ").concat(n));for(let n=0;n<a;n++)c?p.values[s*a+n]+=d[f*a+n]:p.values[s*a+n]=0===e.rank?d[0]:d[f*a+n]}return p}const lG={kernelName:tx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qT(0,a,o),d=iG(n.bufferSync(a),n.bufferSync(s),o,h,c,l,i,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};function cG(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<e?n=a+1:r=a;return r}function uG(t,e){let n=0,r=t.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),t[a]<=e?n=a+1:r=a;return r}const hG={kernelName:nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=function(t,e,n,r,a,s){const o=ly("int32",n*a);for(let i=0;i<n;++i){const n=t.slice(i*r,(i+1)*r),l=i*a;for(let t=0;t<a;++t)o[l+t]="left"===s?cG(n,e[t+l]):uG(n,e[t+l])}return o}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};const dG={kernelName:rx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e;HP([r,a,s],"select");const o=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=Kk(a.dtype,s.dtype),h=wy(Qb(a.shape),u);let d=0;const p=0===o||o>1||1===a.shape.length?1:Qb(a.shape.slice(1));for(let f=0;f<i.length;f++)for(let t=0;t<p;t++)1===i[f]?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(a.shape,u,h)}},pG=XT,fG=JT,gG=JP(ax,(t=>t>=0?fG*t:pG*(Math.exp(t)-1))),mG={kernelName:ax,backendName:"cpu",kernelFunc:gG},bG=JP(lx,(t=>t<0?-1:t>0?1:0)),yG={kernelName:lx,backendName:"cpu",kernelFunc:bG},vG=JP(ox,(t=>Math.sin(t))),wG={kernelName:ox,backendName:"cpu",kernelFunc:vG},xG=JP(ix,(t=>Math.sinh(t))),kG={kernelName:ix,backendName:"cpu",kernelFunc:xG},SG=Math.log(1.1920928955078125e-7)+2,IG=JP(ux,(t=>{const e=t>-SG,n=t<SG,r=Math.exp(t);let a;return a=n?r:e?t:Math.log(1+r),a})),NG={kernelName:ux,backendName:"cpu",kernelFunc:IG};const CG={kernelName:px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;HP([a],"spaceToBatchND");const i=Qb(s),l=[[0,0]];l.push(...o);for(let m=1+s.length;m<a.shape.length;++m)l.push([0,0]);const c=Cj.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=BT(c.shape,s,i,!1),h=WT(u.length,s.length,!1),d=UT(c.shape,s,i,!1),p=AB({inputs:{x:c},backend:n,attrs:{shape:u}}),f=VB({inputs:{x:p},backend:n,attrs:{perm:h}}),g=AB({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function EG(t,e,n,r,a,s,o){const i=e[0],l=s[0],c=new Array(l),u=new Array(i),h=e[1];if(0===l){if(0!==i)throw new Error(xA(i));return[ly(n,0),[0,h],ly(a,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<i;++m){const e=t[m*h];if(e<0)throw new Error(kA(m,e));if(e>=l)throw new Error(SA(m,e,l));++f[e],d=d&&e>=p,p=e}let g=!0;for(let m=0;m<l;++m){const t=0===f[m];c[m]=t,g=g&&!t,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const e=t,n=r;for(let t=0;t<i;++t)u[t]=t;return[e,[i,h],n,c,u]}{const e=f[l-1],s=ly(n,e*h),d=ly(a,e),p=new Array(l).fill(0);for(let n=0;n<i;++n){const e=t[n*h],a=p[e],o=(0===e?0:f[e-1])+a;p[e]++;for(let r=0;r<h;++r)s[o*h+r]=t[n*h+r];d[o]=r[n],u[n]=o}for(let t=0;t<l;++t){if(0===p[t]){const e=0===t?0:f[t-1];s[e*h+0]=t;for(let t=1;t<h;++t)s[e*h+t]=0;d[e]=o}}return[s,[e,h],d,c,u]}}const TG={kernelName:mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,g]=EG(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function AG(t,e,n,r,a){const s=Qb(r),o=e[0],i=a.length,l=[];let c=1,u=-1;for(let g=0;g<i;++g){const t=a[g];if(-1===t){if(-1!==u)throw new Error(IA(u,g));u=g,l.push(1)}else{if(t<0)throw new Error(NA(g,t));c*=t,l.push(t)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(s/c);if(c*t!==s)throw new Error(EA(r,l));l[u]=t}if(Qb(l)!==s)throw new Error(TA(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t)d[t]=d[t+1]*r[t+1]}const p=[];if(i>0){p[i-1]=1;for(let t=i-2;t>=0;--t)p[t]=p[t+1]*l[t+1]}const f=ly(n,o*i);for(let g=0;g<o;++g){let e=0;for(let n=0;n<h;++n)e+=t[g*h+n]*d[n];for(let t=0;t<i;++t)f[g*i+t]=Math.trunc(e/p[t]),e%=p[t]}return[f,[o,i],l]}const RG={kernelName:bx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.data.get(a.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=AG(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function FG(t,e,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=r.length,l=[e[0],t.length/e[0]],c=l[1],u=i>0?a[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=u;const d=ly(n,h.reduce(((t,e)=>t*e),1));if(0===i)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=a[p];for(;;){let e=0;if(f<i){if(e=a[f],m===e){++f;continue}if(m>=e)throw new Error("segment ids are not increasing")}if(m<0||m>=u)throw new Error(FA(m,u));m>g&&d.fill(o,g*c,m*c);for(let n=p;n<f;++n){const e=r[n];if(e<0||e>=l[0])throw new Error(_A(n,r[n],l[0]));for(let n=0;n<c;n++)d[m*c+n]+=t[e*c+n]}if(s)for(let t=0;t<c;t++)d[m*c+t]/=f-p;if(p=f,++f,g=m+1,m=e,f>i)break}return g<u&&d.fill(o,g*c,u*c),[d,h]}const _G={kernelName:yx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=FG(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const DG={kernelName:vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=FG(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const OG={kernelName:wx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=qT(0,a,i),p=!1,f=n.bufferSync(a);let g;switch(s.dtype){case"bool":g=iG(f,n.bufferSync(s),i,d,u,c,l,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":g=iG(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"int32":g=iG(f,n.bufferSync(s),i,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"string":g=iG(f,n.bufferSync(s),i,d,u,c,l,h,vk(n.data.get(o.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(s.dtype))}return n.makeTensorInfo(i,g.dtype,g.values)}};const zG={kernelName:fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=sy(o,a.shape)[0],l=wA(a,s,i),c=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map((t=>{const e=[...u];e[i]=t;const r=fW({inputs:{x:a},backend:n,attrs:{begin:c,size:e}});return c[i]+=t,r}))}},LG=XP((t=>Math.sqrt(t))),MG=JP(hx,(t=>Math.sqrt(t))),PG={kernelName:hx,backendName:"cpu",kernelFunc:MG},BG={kernelName:kx,backendName:"cpu",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{x:r}=e,a=n;HP(r,"square");const s=a.data.get(r.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const t=s[i];o[i]=t*t}return{dataId:a.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},WG=rB(((t,e)=>{const n=t-e;return n*n})),UG=SB(xx,WG),VG={kernelName:xx,backendName:"cpu",kernelFunc:UG},jG=XP(((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=e;return t.replace(new RegExp(n,r?"g":""),a)})),GG=YP(Sx,jG),HG={kernelName:Sx,backendName:"cpu",kernelFunc:GG},KG=JP(Bx,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),qG={kernelName:Bx,backendName:"cpu",kernelFunc:KG};function XG(t,e,n,r){const a=fI(t,e.dtype);for(let s=0;s<a.size;s++){const t=a.indexToLoc(s),o=new Array(t.length);for(let e=0;e<o.length;e++)o[e]=t[e]*n[e]+r[e];a.set(e.get(...o),...t)}return a}const JG={kernelName:Ix,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;HP(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=vN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=AB({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Jb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=oN(y,v,w),e=fW({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=AB({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{const t=XG(p,n.bufferSync(a),w,y);x=n.makeTensorInfo(f,t.dtype,t.values)}return x}};class YG{constructor(t,e,n,r,a,s){this.separator=yk(t),this.nGramWidths=e,this.leftPad=yk(n),this.rightPad=yk(r),this.padWidth=a,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),l=Math.max(0,i-o),c=Math.max(0,i-(a-(o+1))),u=s-(l+c),h=e+(l>0?0:o-i);let d=0;d+=l*this.leftPad.length;for(let e=0;e<u;++e)d+=t[h+e].length;d+=c*this.rightPad.length;d+=(l+c+u-1)*this.separator.length,n[r+o]=new Uint8Array(d);const p=n[r+o];let f=0;const g=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)g(this.leftPad),g(this.separator);for(let e=0;e<u-1;++e)g(t[h+e]),g(this.separator);if(u>0){g(t[h+u-1]);for(let t=0;t<c;++t)g(this.separator),g(this.rightPad)}else{for(let t=0;t<c-1;++t)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error("First split value must be 0, got ".concat(t));for(let a=1;a<r;++a){let r=e[a]>=t;if(r=r&&e[a]<=n,!r)throw new Error("Invalid split value ".concat(e[a],", must be in [").concat(t,", ").concat(n,"]"));t=e[a]}if(t!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(t))}const a=r-1,s=ly("int32",r);if(0===n||0===r){const t=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[t,s]}s[0]=0;for(let i=1;i<=a;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach((e=>{n+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[a]);for(let i=0;i<a;++i){const n=e[i];let r=s[i];if(this.nGramWidths.forEach((a=>{const s=e[i+1]-e[i],l=this.getNumNGrams(s,a);this.createNGrams(t,n,o,r,l,a),r+=l})),this.preserveShort&&r===s[i]){const a=e[i+1]-e[i];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(t,n,o,r,l,s)}}return[o,s]}}function ZG(t,e,n,r,a,s,o,i){return new YG(n,r,a,s,o,i).compute(t,e)}const QG={kernelName:Nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,g]=ZG(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};function $G(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const a=e[0];let s=t.indexOf(a);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(a)}return void(n&&0===t.length||r.push(t))}let a=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(a,s);n&&0===e.length||r.push(e),a=s+1}}function tH(t,e,n){const r=t.length,a=[];let s=0,o=0;const i=new Array(r);for(let d=0;d<r;++d){const r=a.length;$G(t[d],e,n,a);const l=a.length-r;i[d]=l,s+=l,o=Math.max(o,l)}const l=ly("int32",2*s),c=new Array(s),u=[r,o];let h=0;for(let d=0;d<r;++d)for(let t=0;t<i[d];++t)l[2*h]=d,l[2*h+1]=t,c[h]=a[h],++h;return[l,c,u]}const eH={kernelName:Cx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[c,u,h]=tH(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function nH(t,e){const n=ly("int32",t.length);for(let r=0;r<t.length;++r)n[r]=fk(t[r]).modulo(e).getLowBitsUnsigned();return n}const rH={kernelName:Ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=nH(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",o)}},aH=JP(Ax,(t=>Math.tan(t))),sH={kernelName:Ax,backendName:"cpu",kernelFunc:aH},oH=JP(Rx,(t=>Math.tanh(t)));const iH={kernelName:ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{tensor:r,indices:a,updates:s}=e,{sliceRank:o,numUpdates:i,sliceSize:l,strides:c,outputSize:u}=qT(0,a,r.shape),h=n.bufferSync(a),d=n.bufferSync(s),p=n.bufferSync(r),f=iG(h,d,r.shape,u,l,i,o,c,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function lH(t,e){const n=new Array(t.rank);for(let a=0;a<n.length;a++)n[a]=t.shape[a]*e[a];const r=fI(n,t.dtype);for(let a=0;a<r.values.length;++a){const e=r.indexToLoc(a),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const s=t.locToIndex(n);r.values[a]=t.values[s]}return r}const cH={kernelName:Fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;HP(a,"tile");const o=lH(n.bufferSync(a),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},uH=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function hH(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=e-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2);hH(t,e,Math.max(n,Math.floor(e-s*i/a+l)),Math.min(r,Math.floor(e+(a-s)*i/a+l)))}const a=t[e];let s=n,o=r;for(Xb(t,n,e),uH(t[r],a)>0&&Xb(t,n,r);s<o;){for(Xb(t,s,o),s++,o--;uH(t[s],a)<0;)s+=1;for(;uH(t[o],a)>0;)o-=1}0===uH(t[n],a)?Xb(t,n,o):(o+=1,Xb(t,o,r)),o<=e&&(n=o+1),e<=o&&(r=o-1)}}function dH(t,e,n,r,a){const s=e[e.length-1],[o,i]=[t.length/s,s],l=iy(n,o*r),c=iy("int32",o*r);for(let h=0;h<o;h++){const e=h*i,n=t.subarray(e,e+i);let s=new Array(n.length);n.forEach(((t,e)=>s[e]={value:t,index:e})),r<s.length&&(hH(s,r),s=s.slice(0,r)),a&&s.sort(uH);const o=h*r,u=l.subarray(o,o+r),d=c.subarray(o,o+r);for(let t=0;t<r;t++)u[t]=s[t].value,d[t]=s[t].index}const u=e.slice();return u[u.length-1]=r,[fI(u,n,l),fI(u,"int32",c)]}const pH={kernelName:_x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r;HP(a,"topk");const i=n.data.get(a.dataId).values,[l,c]=dH(i,a.shape,a.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const fH={kernelName:Dx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=n,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=[u,f,g,p],b=my(a.shape),y=b[0],v=b[1],w=b[2],x=my(m),k=x[0],S=x[1],I=x[2],N=iy(a.dtype,Qb(m));N.fill(l);const C=r.data.get(a.dataId).values,E=r.data.get(s.dataId).values;for(let T=0;T<u;++T){const t=1===s.shape[0]?E:E.subarray(8*T,8*T+8);for(let e=0;e<f;++e)for(let n=0;n<g;++n)for(let r=0;r<p;++r){let a;const s=t[6]*n+t[7]*e+1;if(0===s)continue;const c=(t[0]*n+t[1]*e+t[2])/s,u=(t[3]*n+t[4]*e+t[5])/s,p=gH(c,d,i),f=gH(u,h,i);switch(o){case"nearest":a=bH(C,h,d,y,v,w,T,f,p,r,l);break;case"bilinear":a=yH(C,h,d,y,v,w,T,f,p,r,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}N[T*k+e*S+n*I+r]=a}return r.makeTensorInfo(m,a.dtype,N)}return{dataId:r.write(N,m,a.dtype),shape:a.shape,dtype:a.dtype}}};function gH(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return Kb(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return Kb(0,n,e-1)}(t,e);case"nearest":return function(t,e){return Kb(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function mH(t,e,n,r,a,s,o,i,l,c,u){return 0<=i&&i<e&&0<=l&&l<n?t[o*r+i*a+l*s+c]:u}function bH(t,e,n,r,a,s,o,i,l,c,u){return mH(t,e,n,r,a,s,o,Math.round(i),Math.round(l),c,u)}function yH(t,e,n,r,a,s,o,i,l,c,u){const h=Math.floor(i),d=Math.floor(l),p=h+1,f=d+1;return(p-i)*((f-l)*mH(t,e,n,r,a,s,o,h,d,c,u)+(l-d)*mH(t,e,n,r,a,s,o,h,f,c,u))+(i-h)*((f-l)*mH(t,e,n,r,a,s,o,p,d,c,u)+(l-d)*mH(t,e,n,r,a,s,o,p,f,c,u))}function vH(t,e,n,r){const a=sy(e,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const o=new Map,i=new Int32Array(n[a]),l=new Dk(s,r,t),c=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let e;if(u)e=t[f].toString();else{const t=[];for(let e=0;e<s[0];e++)for(let n=0;n<s[2];n++)t.push(l.get(e,f,n));e=t.join(",")}const n=o.get(e);if(null!=n)i[f]=n;else{const t=o.size;o.set(e,t),i[f]=t,c.push(f)}}const h=s.slice();h[1]=o.size;const d=new Dk(h,r);c.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,t,r),n,e,r)}));const p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const wH={kernelName:zx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;HP(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:c}=vH(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const xH={kernelName:Lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape.length,i=a.shape[s],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=a.shape[p]);const u=new Array(o).fill(0),h=a.shape.slice();h[s]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[s]=p;const t=fW({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});d[p]=AB({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}};const kH={kernelName:Mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r;HP(a,"unsortedSegmentSum");const i=[],l=[],c=a.shape.length-s.shape.length;let u=s;for(let d=0;d<c;++d){const t=EU({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=t,l.push(t)}for(let d=0;d<o;++d){const t=gk(d,"int32"),e=n.makeTensorInfo([],"int32",t),r=fU({inputs:{a:e,b:u},backend:n}),s=xB({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=iU({inputs:{a:s,b:a},backend:n}),c=cU({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(c),l.push(e),l.push(r),l.push(s),l.push(o),l.push(c)}const h=Ij({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},SH=[DB,zB,MB,BB,TB,WB,GB,HB,KB,qB,JB,ZB,$B,nW,aW,lW,cW,uW,hW,_B,dW,mW,vW,xW,kW,kB,NW,EW,mB,TW,DW,zW,LW,MW,PW,BW,WW,VW,GW,HW,KW,qW,XW,JW,ZW,QW,$W,tU,eU,nU,rU,aU,hU,QP,dU,gU,SU,CU,TU,FU,VU,GU,HU,XU,ZU,QU,$U,eV,rV,oV,cV,tB,uV,FW,dV,fV,mV,nB,vV,kV,IV,EV,AV,_V,OV,MV,PV,BV,VV,HV,KV,qV,XV,JV,YV,ZV,QV,ej,nj,sj,lj,lU,uj,dj,fj,mj,vj,wj,Sj,Nj,Cj,Aj,oB,Fj,Lj,Bj,Hj,qj,vB,OU,Jj,lB,uB,RB,Yj,Zj,Qj,$j,tG,eG,rG,oG,lG,hG,dG,mG,pB,yG,wG,kG,gW,ij,NG,CG,TG,RG,_G,DG,OG,zG,PG,BG,VG,HG,qG,JG,QG,eH,rH,PU,uU,sH,{kernelName:Rx,backendName:"cpu",kernelFunc:oH},iH,cH,pH,fH,jB,wH,xH,kH,kj];for(const n of SH)Qx(n);const IH={},NH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function CH(t,e){if(!(t in IH)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if(Ay().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==t){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(t):e;n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete IH[t]}),!1),Ay().getBool("SOFTWARE_WEBGL_ENABLED")&&(NH.failIfMajorPerformanceCaveat=!1);if(1===t)return n.getContext("webgl",NH)||n.getContext("experimental-webgl",NH);return n.getContext("webgl2",NH)}(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;IH[t]=n}const n=IH[t];return null==n||n.isContextLost()?(delete IH[t],CH(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),IH[t])}var EH,TH,AH;function RH(t,e){return[e,t]}function FH(t){const e=Qb(t);return ey(Math.ceil(e/4))}function _H(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function DH(t,e){const n=t;let r,a,s,o,i,l,c,u,h,d;return 2===Ay().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,a=t.RGBA,s=t.RGBA,o=n.RGBA,i=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function OH(t,e){const n=e();return Ay().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(e)}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(EH||(EH={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(TH||(TH={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(AH||(AH={}));function zH(t){return!!(Ay().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function LH(t,e){return HH(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}const MH=/ERROR: [0-9]+:([0-9]+):/g;function PH(t,e){const n=MH.exec(e);if(null==n)return console.log("Couldn't parse line number in error: ".concat(e)),void console.log(t);const r=+n[1],a=t.split("\n"),s=a.length.toString().length+2,o=a.map(((t,e)=>ny((e+1).toString(),s)+t));let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c ".concat(ny(c[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function BH(t,e){if(OH(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function WH(t,e,n,r,a,s,o){const i=t.getAttribLocation(e,n);return-1!==i&&(OH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),OH(t,(()=>t.vertexAttribPointer(i,a,t.FLOAT,!1,s,o))),OH(t,(()=>t.enableVertexAttribArray(i))),!0)}function UH(t,e,n,r){OH(t,(()=>function(t,e,n){KH(t,n),OH(t,(()=>t.activeTexture(t.TEXTURE0+n))),OH(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),OH(t,(()=>t.uniform1i(n,r)))}function VH(t,e,n){OH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),OH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function jH(t,e){OH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),OH(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function GH(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(e)}}(t,e))}function HH(t,e,n){const r=OH(t,(()=>e()));if(null==r)throw new Error(n);return r}function KH(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const t="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(t,"."))}}function qH(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Qb(t.slice(0,t.length-e))}function XH(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function JH(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[qH(t),...XH(t)]),e}function YH(t){return t%2===0}function ZH(t,e){if($b(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r)return!0;if(YH(n)&&YH(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&YH(t[0])&&YH(e[0])}let QH,$H;function tK(t,e){return null!=t.getExtension(e)}function eK(t){try{if(null!=CH(t))return!0}catch(v1){return console.log("Error when getting WebGL context: ",v1),!1}return!1}function nK(t){if(0===t)return!1;const e=CH(t);if(1!==t){if(tK(e,"EXT_color_buffer_float"))return rK(e);const t="EXT_color_buffer_half_float";if(tK(e,t)){const n=e.getExtension(t);return function(t,e){const n=DH(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);const a=1,s=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),i}(e,n)}return!1}if(!tK(e,"OES_texture_float"))return!1;if(!tK(e,"WEBGL_color_buffer_float"))return!1;return rK(e)}function rK(t){const e=DH(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),a}function aK(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Jb("complex64"!==t.dtype,(()=>"".concat(e," does not support complex64 tensors ")+"in the WebGL backend."))}))}const sK=Ay();function oK(){let t,e,n,r,a,s,o,i,l,c;return 2===Ay().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=Ay().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:c}}function iK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=my(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(e),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(e):"index -= ".concat(t[a]," * ").concat(e);return"".concat(s,"; ").concat(o,";")})).join("")}function lK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=my(e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / outShapeStrides[").concat(a,"]"),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * outShapeStrides[").concat(a,"]"):"index -= ".concat(t[a]," * outShapeStrides[").concat(a,"]");return"".concat(s,"; ").concat(o,";")})).join("")}function cK(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(t,e){const n=t.length,r=t.map((t=>"".concat(e,"[").concat(t,"]"))),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]="(".concat(a[s+1]," * ").concat(r[s+1],")");return a}(t.map(((t,e)=>e)),e);return r.map(((e,a)=>{const s="int ".concat(t[a]," = ").concat(n," / ").concat(r[a]),o=a===r.length-1?"int ".concat(t[a+1]," = ").concat(n," - ").concat(t[a]," * ").concat(r[a]):"index -= ".concat(t[a]," * ").concat(r[a]);return"".concat(s,"; ").concat(o,";")})).join("")}function uK(t){const e=my(t).map((t=>t.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(e[0]," + coords.y * ").concat(e[1]," + coords.z;\n  }\n")}sK.registerFlag("HAS_WEBGL",(()=>sK.getNumber("WEBGL_VERSION")>0)),sK.registerFlag("WEBGL_VERSION",(()=>eK(2)?2:eK(1)?1:0)),sK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),sK.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===sK.get("WEBGL_VERSION"))),sK.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),sK.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),sK.registerFlag("WEBGL_PACK",(()=>sK.getBool("HAS_WEBGL"))),sK.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_CLIP",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_REDUCE",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_LAZILY_UNPACK",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_CONV_IM2COL",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>sK.getBool("WEBGL_PACK"))),sK.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==QH){const e=CH(t);QH=e.getParameter(e.MAX_TEXTURE_SIZE)}return QH}(sK.getNumber("WEBGL_VERSION")))),sK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==$H){const e=CH(t);$H=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$H)}(sK.getNumber("WEBGL_VERSION")))),sK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=sK.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=CH(t);return e=tK(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:tK(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),sK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>sK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!iS())),sK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=CH(t);if(1===t){if(!tK(e,"OES_texture_float"))return!1}else if(!tK(e,"EXT_color_buffer_float"))return!1;return rK(e)}(sK.getNumber("WEBGL_VERSION")))),sK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!sK.getBool("WEBGL_FORCE_F16_TEXTURES")&&sK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),sK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>nK(sK.getNumber("WEBGL_VERSION")))),sK.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=sK.getNumber("WEBGL_VERSION"))&&null!=CH(t).fenceSync;var t})),sK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>sK.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),sK.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(t,"."))})),sK.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>iS()?1:-1),(t=>{if("number"!==typeof t)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(t,"."));if(t<0&&-1!==t)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(t,"."))})),sK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),sK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),sK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),sK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),sK.registerFlag("WEBGL_EXP_CONV",(()=>!1)),sK.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>sK.getBool("IS_TEST"))),sK.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),sK.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),sK.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),sK.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const hK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:dK}=r;function pK(t,e,n){const r=[];if(t.forEach((t=>{const e=Qb(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push("uniform float ".concat(t.name).concat(e>1?"[".concat(e,"]"):"",";")):(r.push("uniform sampler2D ".concat(t.name,";")),r.push("uniform int offset".concat(t.name,";"))),n.enableShapeUniforms){const{uniformShape:e}=SK(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push("uniform int ".concat(t.name,"Shape;"));break;case 2:r.push("uniform ivec2 ".concat(t.name,"Shape;"));break;case 3:r.push("uniform ivec3 ".concat(t.name,"Shape;"));break;case 4:r.push("uniform ivec4 ".concat(t.name,"Shape;"))}r.push("uniform ivec2 ".concat(t.name,"TexShape;"))}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{r.push("uniform ".concat(t.type," ").concat(t.name).concat(t.arrayIndex?"[".concat(t.arrayIndex,"]"):"",";"))}));const a=r.join("\n"),s=t.map((t=>function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?gK(t,r):fK(t,r);const s=t.shapeInfo.logicalShape,o=e.logicalShape;s.length<=o.length&&(a+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=dK(t.shapeInfo.logicalShape,e.logicalShape),l=kK(o),c=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((t=>"coords.".concat(h[t+c]," = 0;"))).join("\n");let d="";d=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(h[e+c]))).join(", ");let p="return outputValue;";const f=1===Qb(t.shapeInfo.logicalShape),g=Qb(e.logicalShape),m=1===g;if(1!==s||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const t=s-2,e=s-1;i.indexOf(t)>-1&&i.indexOf(e)>-1?p="return vec4(outputValue.x);":i.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(a,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(r,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.texShape,o=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&null==t.shapeInfo.flatOffset&&$b(o,s))return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const c=kK(l),u=dK(t.shapeInfo.logicalShape,e.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":l<2&&u.length>=1?"coords = 0;":u.map((t=>"coords.".concat(p[t+h]," = 0;"))).join("\n");let f="";f=l<2&&i>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>"coords.".concat(p[e+h]))).join(", ");return"\n    float ".concat(a,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(r,"(").concat(f,");\n    }\n  ")}(t,e));return a}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=e.texShape,i=oK(),l=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(t.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let c,u,h=function(t){const e="".concat(t.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(t.varyingFs," vec2 resultUV;\n    ").concat(t.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(t.defineSpecialNaN,"\n    ").concat(t.defineSpecialInf,"\n    ").concat(t.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(mK,"\n    ").concat(bK,"\n    ").concat(yK,"\n  ");return e}(i);e.isPacked?(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1],".0);\n      }\n    ");if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      return 2 * (resTexRC.x * ").concat(r[1]," + resTexRC.y);\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if($b(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0],", ").concat(r[1],"));\n      }\n    ");const a=Math.ceil(t[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[2]/2),s=a*Math.ceil(t[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],a=Math.ceil(t[t.length-1]/2),s=a*Math.ceil(t[t.length-2]/2);let o=s,i="",l="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],i="\n      int b".concat(c," = index / ").concat(o,";\n      index -= b").concat(c," * ").concat(o,";\n    ")+i,l="b".concat(c,", ")+l;return"\n    ivec".concat(t.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(t.length,"(").concat(l,");\n    }\n  ")}(t,e,n)}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(vec4 val) {\n      ".concat(t.output," = val;\n    }\n  ")}(i)):(c=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){if(1===e[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(e[1],".0);\n      }\n    ");if(1===e[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(e[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      return resTexRC.x * ").concat(e[1]," + resTexRC.y;\n    }\n  ")}(0,e,n);case 2:return function(t,e,n){if($b(t,e))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(e[0],", ").concat(e[1],"));\n      }\n    ");if(1===t[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===t[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      int r = index / ").concat(t[1],";\n      int c = index - r * ").concat(t[1],";\n      return ivec2(r, c);\n    }\n  ")}(t,e,n);case 3:return function(t,e,n){if(n){const e=lK(["r","c","d"],t);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(e,"\n    return ivec3(r, c, d);\n  }\n")}const r=iK(["r","c","d"],t);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,e,n);case 4:return function(t,e,n){if(n){const e=lK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(e,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const r=iK(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(t,e,n);case 5:return function(t,e){const n=iK(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(e[0],",\n                             ").concat(e[1],"));\n\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(t,e);case 6:return function(t,e){const n=iK(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(t,e);default:throw new Error("".concat(t.length,"-D output sampling is not yet supported"))}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return"\n    void setOutput(float val) {\n      ".concat(t.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=vK);return[h,l,u,a,c,s,n.userCode].join("\n")}function fK(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"float ".concat(r,"() {return ").concat(n,";}");const[a,s]=t.shapeInfo.texShape;if(1===a&&1===s)return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=wK(n);if(e)return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,l]=t.shapeInfo.texShape;return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(l,", ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int index) {\n        ").concat(xK(t),"\n      }\n    ");const a=t.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return"\n      float ".concat(r,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=wK(n);if(1===o)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===s)return e?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(e)return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&$b(n,s)){if(e)return"\n      float ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const t=s[0],n=s[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(t,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}const{newShape:o,keptDims:i}=oy(n),l=o;if(l.length<n.length){const n=IK(t,l),r=["row","col"];return"\n      ".concat(fK(n,e),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(NK(r,i),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(xK(t),"\n      }\n    ");const c=s[0],u=s[1],h=wK(r);if(1===u)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r,"TexShape[0]));\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(c,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(1===c)return e?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(e)return"\n      float ".concat(a,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(c,", ").concat(u,", index);\n    return sampleTexture(").concat(r,", uv);\n  }\n")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:l}=oy(n),c=i;if(c.length<n.length){const n=IK(t,c),r=["row","col","depth"];return"\n        ".concat(fK(n,e),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(NK(r,l),");\n        }\n      ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(o,", 1)));\n        ").concat(xK(t),"\n      }\n    ");const u=t.shapeInfo.texShape,h=u[0],d=u[1],p=t.shapeInfo.flatOffset;if(d===s&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        int stride1 = ").concat(r,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(r,", uv);\n        }\n      ");if(d===o&&null==p)return e?"\n      float ".concat(a,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");const f=wK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r,"Shape[1] * ").concat(r,"Shape[2];\n      int stride1 = ").concat(r,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n      return sampleTexture(").concat(r,", uv);\n    }\n    ");return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(o," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(r,", uv);\n      }\n  ")}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:l,keptDims:c}=oy(n);if(l.length<n.length){const n=IK(t,l),r=["row","col","depth","depth2"];return"\n      ".concat(fK(n,e),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(NK(r,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(o,", ").concat(s,", 1)));\n        ").concat(xK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(r,"Shape[3];"),g="int stride1 = ".concat(r,"Shape[2] * stride2;"),m="int stride0 = ".concat(r,"Shape[1] * stride1;");if(p===i&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");if(p===s&&null==u)return e?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r,"Shape[1] * ").concat(r,"Shape[2], ").concat(r,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const b=wK(r);if(e)return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(g,"\n      ").concat(m,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e[4],s=e[3]*a,o=e[2]*s,i=e[1]*o,{newShape:l,keptDims:c}=oy(e);if(l.length<e.length){const e=IK(t,l),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(fK(e),"\n      float ").concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r,"(").concat(NK(n,c),");\n      }\n    ")}if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(o,", ").concat(s,", ").concat(a,")) +\n          depth3;\n        ").concat(xK(t),"\n      }\n    ");const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(s,", ").concat(a,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===a&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3],",\n               ").concat(e[2]*e[3],", ").concat(e[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=wK(n);return"\n    float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," + depth * ").concat(s," +\n          depth2 * ").concat(a," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=oy(e);if(a.length<e.length){const e=IK(t,a),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(fK(e),"\n      float ").concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r,"(").concat(NK(n,s),");\n      }\n    ")}const o=e[5],i=e[4]*o,l=e[3]*i,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(c,", ").concat(l,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(xK(t),"\n      }\n    ");const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(c,", ").concat(l,", ").concat(i,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===o&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(e[1]*e[2]*e[3]*e[4],",\n               ").concat(e[2]*e[3]*e[4],",\n               ").concat(e[3]*e[4],",\n               ").concat(e[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=wK(n);return"\n    float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(c," + depth * ").concat(l," +\n          depth2 * ").concat(i," + depth3 * ").concat(o," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(t);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function gK(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=oK();return"\n    vec4 ".concat(n,"() {\n      return ").concat(r.texture2D,"(").concat(e,", halfCR);\n    }\n  ")}(t);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t.shapeInfo.texShape,s=oK();if(e)return"\n    vec4 ".concat(r,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(r,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0],", ").concat(o[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],i=s[1],l=oK();if(null!=s&&$b(n,s))return e?"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    "):"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(o,".0);\n\n        return ").concat(l.texture2D,"(").concat(r,", uv);\n      }\n    ");if(e)return"\n    vec4 ".concat(a,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ");const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(c[0],", ").concat(c[1],", row, col);\n      return ").concat(l.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=IK(t,n.slice(1)),o=["b","row","col"];return"\n        ".concat(gK(s,e),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(NK(o,r),");\n        }\n      ")}const i=oK();if(e)return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ");const l=o[0],c=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l,", ").concat(c,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(r,", uv);\n    }\n  ")}(t,e);default:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=oK();if(e)return"\n    vec4 ".concat(r,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=t.shapeInfo.logicalShape,o=s.length,i=t.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let g=2;g<o-1;g++)p="int b".concat(g,", ")+p,d*=s[o-g-1],f="b".concat(g," * ").concat(d," + ")+f;return"\n    vec4 ".concat(r,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(c,");\n      return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ")}(t,e)}}const mK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",bK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function wK(t){return"offset".concat(t)}function xK(t){const e=t.name,n=Qb(t.shapeInfo.logicalShape);return n<2?"return ".concat(e,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(e,"[i];\n      }\n    }\n  ")}function kK(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank ".concat(t," is not yet supported"))}function SK(t,e,n){const{newShape:r,keptDims:a}=oy(e),s=e.length,o=t&&3===s&&1===e[0],i=o?e.slice(1):r,l=!t&&s>1&&!$b(e,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:a}}function IK(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function NK(t,e){return e.map((e=>t[e])).join(", ")}function CK(t,e,n,r){const a=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=a.map((t=>t.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=pK(a,o,e),l=function(t,e){const n=HH(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(OH(t,(()=>t.shaderSource(n,e))),OH(t,(()=>t.compileShader(n))),Ay().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw PH(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,i),c=t.createProgram(l);return Ay().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:i,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},EK(t,e,c)))}function EK(t,e,n){const r=[],a=[];let s,o,i,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),1===Ay().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const a={name:h,uniform:t.getUniformLocation(n,h,u),offset:t.getUniformLocation(n,"offset".concat(h),u)};e.enableShapeUniforms&&(a.shape=t.getUniformLocation(n,"".concat(h,"Shape"),u),a.texShape=t.getUniformLocation(n,"".concat(h,"TexShape"),u)),r.push(a)}if(e.enableShapeUniforms&&(s=t.getUniformLocation(n,"outShape",u),i=t.getUniformLocation(n,"outShapeStrides",u),o=t.getUniformLocation(n,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)a.push(t.getUniformLocation(n,h.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}}function TK(t,e){if(t.length!==e.length)throw Error("Binary was compiled with ".concat(t.length," inputs, but ")+"was executed with ".concat(e.length," inputs"));t.forEach(((t,n)=>{const r=t.logicalShape,a=e[n],s=a.shape;if(!$b(r,s))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(r," and ").concat(s," must match"));if(t.isUniform&&a.isUniform)return;const o=t.texShape,i=a.isUniform?null:a.texData.texShape;if(!$b(o,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(i," must match"))}))}function AK(t){return Ay().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class RK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=EH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=oK();this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?lK(["r","c","d"],t):iK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class FK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=EH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=oK();this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?lK(["r","c","d"],t):iK(["r","c","d"],t),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}class _K{constructor(t){this.variableNames=["A"],this.outTexUsage=TH.DOWNLOAD;const e=oK();this.outputShape=t,this.userCode="\n      ".concat(hK,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}class DK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TH.DOWNLOAD;const e=oK();this.outputShape=t,this.userCode="\n      ".concat(hK,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(e.output," = encode_float(x);\n      }\n    ")}}const OK={R:0,G:1,B:2,A:3};class zK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=oK();this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length);let a="result";e&&(a="floor(result * 255. + 0.5)");let s="";for(let o=0;o<n.length;o++){const t=n[o];s+="\n          if(offset == ".concat(o,") {\n            result = values[").concat(OK[t],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":uK(t),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(r.texture2D,"(A, uv);\n          ").concat(s,"\n        }\n        ").concat(r.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class LK{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=oK();this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length);let r="",a="result";e&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let e=0;e<=1;e++){const a=2*s+e;r+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(e," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(t[2]),") {\n          localCoords[2] += ").concat(e,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(t[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(a,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(a,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(a,"] = values[2];\n            } else {\n              result[").concat(a,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":uK(t),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(r,"\n\n          ").concat(n.output," = ").concat(a,";\n        }\n    ")}}function MK(t){const e=oK();return function(t,e){const n=HH(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(OH(t,(()=>t.shaderSource(n,e))),OH(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,"".concat(e.version,"\n    precision highp float;\n    ").concat(e.attribute," vec3 clipSpacePos;\n    ").concat(e.attribute," vec2 uv;\n    ").concat(e.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function PK(t){return function(t,e){const n=HH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return OH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),OH(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function BK(t){return function(t,e){const n=HH(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return OH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),OH(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}function WK(t,e,n,r,a,s){!function(t,e){const n=Ay().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const n="[".concat(t,"x").concat(e,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(t>n||e>n){const r="[".concat(t,"x").concat(e,"]"),a="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}(e,n);const o=function(t){return HH(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),i=t.TEXTURE_2D;return OH(t,(()=>t.bindTexture(i,o))),OH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),OH(t,(()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),OH(t,(()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST))),OH(t,(()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Ay().getNumber("WEBGL_VERSION")?OH(t,(()=>t.texImage2D(i,0,r,e,n,0,a,s,null))):OH(t,(()=>t.texStorage2D(i,1,r,e,n))),OH(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:o,texShape:[n,e]}}function UK(t){return t.internalFormatFloat}function VK(t){return t.internalFormatHalfFloat}function jK(t){return t.downloadTextureFormat}function GK(t){return t.internalFormatPackedFloat}function HK(t){return t.internalFormatPackedHalfFloat}function KK(t,e,n,r,a,s,o,i){const l=t,c=new Float32Array(function(t,e){const[n,r]=_H(t,e);return n*r*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}class qK{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Ay().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function(t,e){IH[t]=e}(e,t)):this.gl=CH(e),t=this.gl,2===Ay().getNumber("WEBGL_VERSION")){const e=t;this.createVertexArray=()=>OH(e,(()=>e.createVertexArray())),this.bindVertexArray=t=>OH(e,(()=>e.bindVertexArray(t))),this.deleteVertexArray=t=>OH(e,(()=>e.deleteVertexArray(t))),this.getVertexArray=()=>OH(e,(()=>e.getParameter(e.VERTEX_ARRAY_BINDING)))}else if(null!=t){const e=t.getExtension("OES_vertex_array_object");if(null==e)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>OH(t,(()=>e.createVertexArrayOES())),this.bindVertexArray=n=>OH(t,(()=>e.bindVertexArrayOES(n))),this.deleteVertexArray=n=>OH(t,(()=>e.deleteVertexArrayOES(n))),this.getVertexArray=()=>OH(t,(()=>t.getParameter(e.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ay().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=LH(this.gl,t),tK(this.gl,e))this.textureHalfFloatExtension=LH(this.gl,e);else if(Ay().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),tK(this.gl,r))this.colorBufferHalfFloatExtension=LH(this.gl,r);else if(Ay().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",tK(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!tK(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=PK(this.gl),this.indexBuffer=BK(this.gl),this.framebuffer=function(t){return HH(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=DH(this.gl,this.textureHalfFloatExtension)}get debug(){return Ay().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;OH(t,(()=>t.finish())),OH(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),OH(t,(()=>t.deleteFramebuffer(this.framebuffer))),OH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),OH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),OH(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=RH(e,n);return WK(t,a,s,UK(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=RH(e,n);return WK(t,a,s,VK(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=RH(e,n);return WK(t,a,s,jK(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){OH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Ay().getNumber("WEBGL_VERSION")?OH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):OH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Ay().getNumber("WEBGL_VERSION")?OH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):OH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),OH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,a,s){let o,i,l;OH(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),i=t.FLOAT,l=s.internalFormatPackedFloat),o.set(a),2===Ay().getNumber("WEBGL_VERSION")?OH(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,i,o))):OH(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,i,o))),OH(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=_H(e,n);return WK(t,a,s,HK(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[a,s]=_H(e,n);return WK(t,a,s,GK(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(jH(this.gl,this.framebuffer),this.outputTexture=null),OH(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[a,s]=RH(e,n),o=new Uint8Array(e*n*4);return OH(t,(()=>t.readPixels(0,0,a,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,a,s){return KK(this.gl,t,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const a=t.createBuffer();OH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,a)));const s=16*e*n;return OH(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),OH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),OH(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),a}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Ay().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(a,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=a}else Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return OH(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=MK(e));const n=function(t){return HH(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);OH(e,(()=>e.attachShader(n,this.vertexShader))),OH(e,(()=>e.attachShader(n,t))),function(t,e){if(OH(t,(()=>t.linkProgram(e))),!Ay().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&BH(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;OH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(t,e,n){OH(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),WH(t,e,"clipSpacePos",n,3,20,0)&&WH(t,e,"uv",n,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(OH(this.gl,(()=>this.gl.deleteProgram(t))),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&BH(this.gl,this.program),OH(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(t,e,n){return HH(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),OH(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),UH(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,a]=_H(e,n);this.setOutputMatrixTextureDriver(t,r,a)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&BH(this.gl,this.program),GH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}OH(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),OH(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=LH(this.gl,2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await ry((()=>this.disposed||this.isQueryAvailable(t,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ay().platform&&(n=Ay().platform.setTimeoutCustom.bind(Ay().platform)),ry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),VH(this.gl,t,this.framebuffer),this.debug&&GH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(VH(this.gl,this.outputTexture,this.framebuffer),this.debug&&GH(this.gl)):jH(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;VH(r,t,this.framebuffer),this.debug&&GH(r),this.outputTexture=t,OH(r,(()=>r.viewport(0,0,e,n))),OH(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),OH(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:XK,bincountImpl:JK,bincountReduceImpl:YK,bitwiseAndImpl:ZK,castImpl:QK,ceilImpl:$K,concatImpl:tq,equalImpl:eq,expImpl:nq,expm1Impl:rq,floorImpl:aq,gatherNdImpl:sq,gatherV2Impl:oq,greaterImpl:iq,greaterEqualImpl:lq,lessImpl:cq,lessEqualImpl:uq,linSpaceImpl:hq,logImpl:dq,maxImpl:pq,maximumImpl:fq,minimumImpl:gq,multiplyImpl:mq,negImpl:bq,notEqualImpl:yq,prodImpl:vq,raggedGatherImpl:wq,raggedRangeImpl:xq,raggedTensorToTensorImpl:kq,rangeImpl:Sq,rsqrtImpl:Iq,scatterImpl:Nq,sigmoidImpl:Cq,simpleAbsImpl:Eq,sliceImpl:Tq,sparseFillEmptyRowsImpl:Aq,sparseReshapeImpl:Rq,sparseSegmentReductionImpl:Fq,sqrtImpl:_q,staticRegexReplaceImpl:Dq,stridedSliceImpl:Oq,stringNGramsImpl:zq,stringSplitImpl:Lq,stringToHashBucketFastImpl:Mq,subImpl:Pq,tileImpl:Bq,topKImpl:Wq,transposeImpl:Uq,uniqueImpl:Vq}=a;function jq(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>"".concat(t,".").concat(e)))}function Gq(t,e){return 1===e?[t]:jq(t,e)}class Hq{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=AK(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=Gq("rc",this.rank),e=kK(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode="\n        void main() {\n          ".concat(e," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(a,"));\n          }\n        }\n      ")}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a="".concat(0===n?"r":"rp1",", ").concat(0===r?"c":"cp1");for(let e=2;e<this.rank;e++)a="".concat(t[t.length-1-e],",")+a;e.push(a)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let e="";for(let n=this.rank-2;n<this.rank;n++)e+="".concat(t[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],r=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(e[0],";\n      int c = ").concat(e[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(r,";\n    ")}getOutput(t){const e=this.getSourceCoordsArr(t);if(1===this.rank){const t=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(t," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(e[0],"),\n            cEdge ? 0. : getA(").concat(e[1],"),\n            rEdge ? 0. : getA(").concat(e[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(e[3],")")}}class Kq{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length);let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2===1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+="\n        ".concat(t,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(t,e){const n=e?cK(["r","c","d"],"inputShape"):iK(["r","c","d"],t);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":uK(t),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":t[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":t[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class qq{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const r=Jq(e,n),a=Yq(t,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=Xq(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[a].pop();return this.usedTextures[a].push(t),t}let o;return r===AH.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===AH.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===AH.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===AH.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===AH.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const a=Jq(n,r),s=Yq(e,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=Xq(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=Ay().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l&&l.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(t,")"));const e=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*e),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Xq(t,e,n,r,a){const s=function(t,e){switch(t){case AH.PACKED_2X2_FLOAT32:return GK(e);case AH.PACKED_2X2_FLOAT16:return HK(e);case AH.UNPACKED_FLOAT32:return UK(e);case AH.UNPACKED_FLOAT16:return VK(e);case AH.PACKED_4X1_UNSIGNED_BYTE:return jK(e);default:throw new Error("Unknown physical texture type ".concat(t))}}(e,r);let o;if(a){const[e,n]=_H(t[0],t[1]);o=e*n}else{const[e,n]=RH(t[0],t[1]);o=e*n}const i=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(e))}(n,s);return o*i}function Jq(t,e){if(t===TH.UPLOAD)return AH.PACKED_2X2_FLOAT32;if(t===TH.RENDER||null==t)return function(t){return Ay().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?AH.PACKED_2X2_FLOAT32:AH.UNPACKED_FLOAT32:t?AH.PACKED_2X2_FLOAT16:AH.UNPACKED_FLOAT16}(e);if(t===TH.DOWNLOAD||t===TH.PIXELS)return AH.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(t))}function Yq(t,e,n){return"".concat(t[0],"_").concat(t[1],"_").concat(e,"_").concat(n)}class Zq{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const Qq="if (isnan(x)) return x;",$q="return x;",tX="return abs(x);";const eX="return (x >= 0.0) ? x : (exp(x) - 1.0);",nX=Qq+"\n  return (x < 0.0) ? 0.0 : x;\n",rX=Qq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",aX="return x;",sX="return 1.0 / (1.0 + exp(-1.0 * x));",oX="return x;",iX="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",lX="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cX="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",uX="return 1.0 / (1.0 + exp(-1.0 * x));";class hX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class dX{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length);const e=t.length,n=Gq("rc",e),r=kK(e),a=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(a,");\n\n        setOutput(getChannel(packedInput, ").concat(o,"));\n      }\n    ")}}const pX=PA,fX={};const gX=Ay().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class mX extends jb{nextDataId(){return mX.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ay().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(null!=t){if(t instanceof qK)e=t;else{const n=CH(Ay().getNumber("WEBGL_VERSION"),t);e=new qK(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=CH(Ay().getNumber("WEBGL_VERSION"));e=new qK(t),this.binaryCache=((n=Ay().getNumber("WEBGL_VERSION"))in fX||(fX[n]={}),fX[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new qq(this.gpgpu),this.numMBBeforeWarning=null==Ay().global.screen?1024:Ay().global.screen.height*Ay().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Vb(this,xS())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,n,r,a,s){const o=this.makeTensorInfo(e,n),i=this.texData.get(o.dataId);i.isPacked=!1,i.texture={texture:t,texShape:[r,a]},i.texShape=[r,a];const l=JH(e),c=new zK(l,!1,s),u=this.runWebGLProgram(c,[o],n,[[r,a]]);return u.shape=e,i.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(t,e,n){if((Ay().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ay().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:TH.UPLOAD,refCount:1}),r}refCount(t){if(this.texData.has(t)){return this.texData.get(t).refCount}return 0}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,r,a){if(Ay().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:TH.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=e;if(null!=s){let e;e=i?new hX(o,aX):new Zq(o,aX);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=bk()),"complex64"===r){u=nA(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else u=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=bk()-c),this.convertAndCacheOnCPU(t,u)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=e;if(null!=a){let e;e=i?new hX(r,aX):new Zq(r,aX);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(t);if(Ay().getBool("DEBUG")&&!Ay().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ay().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==s&&Ay().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(e.texture.texture,...FH(r))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=nA(t[0],t[1])}else if(null==u)c=this.getValuesFromTexture(t);else{const t=Qb(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const t=this.gpgpu.gl;OH(t,(()=>t.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(t,c),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&xS().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new hX(a,aX):new Zq(a,aX);const r=this.runWebGLProgram(n,[{dataId:t,shape:a,dtype:o}],o),s=this.readToGPU(r,e);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,e.customTexShape),u=xS().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>vk(t)));return fI(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return fI(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!zH(n)){if(Ay().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),a=Qb(e);if(Ay().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...FH(e)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=Ay().getBool("WEBGL_PACK")&&!0===r,o=s?JH(e):e,i=s?new DK(o):new _K(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const a=xk(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=xk(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(a);o.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),o.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>"".concat(t.name,": ").concat(t.ms))).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:bk(),endMs:null}}endTimer(t){return Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=bk(),t)}async getQueryTime(t){if(Ay().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(t),i=o&&o.origDataId||t,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,a,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:gX;return Ay().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&Qb(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){Hx("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return pX(t.shape,e)}packedUnaryOp(t,e,n){const r=new hX(t.shape,e),a=this.compileAndRun(r,[t],n);return xS().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=Eq(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,tX,t.dtype);const e=new Zq(t.shape,tX),n=this.compileAndRun(e,[t]);return xS().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&hy(n[0])){const a=n.map((t=>yk(t)));r=this.write(a,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return xS().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new dX(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Hq(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[qH(t.shape),...XH(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},a=[qH(e),...XH(e)],s=new Kq(a,n),o=[n],i=this.runWebGLProgram(s,[r],t.dtype,o,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:a,dtype:s}=n;if(null!=e){Jb(Qb(a)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=JH(a);let i;i=r?new FK(o):new RK(o);const l=[null!=e?e:FH(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:t}],s,l,!0,e).dataId}}runWebGLProgram(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(t.outputShape,n),i=this.texData.get(o.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===EH.DENSE){const e=null!=s?s:FH(t.outputShape);i.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(i.usage=t.outTexUsage),0===Qb(o.shape))return i.values=iy(o.dtype,0),o;const l=[],c=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&Qb(e.shape)<=Ay().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!==!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!ZH(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((e=>{const a=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const s=e.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:l}=SK(t.packedInputs,e.shape,s);let c="",u="",h="";if(1===i.length&&t.packedInputs){const t=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c="".concat(t[0]>1,"_").concat(t[1]>1)}else if(2!==i.length||t.packedInputs){if(i.length>2&&!t.packedInputs){const t=my(i);h="".concat(t[0]===s[1],"_").concat(t[t.length-1]===s[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=e.shape.length,p=2===i.length&&$b(e.shape,s),f=1===Qb(e.shape),g=BI(e.shape,n.shape),m=!t.packedInputs&&d===n.shape.length&&$b(s,n.texData.texShape),b=t.packedInputs||i.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);r+="".concat(d,"_").concat(m,"_").concat(o?l:"","_").concat(i.length,"_").concat(f,"_").concat(g,"_").concat(p,"_").concat(c,"_").concat(u,"_").concat(h,"_").concat(b,"_").concat(a)}else{const t=e.isUniform?"uniform":e.texData.texShape;r+="".concat(e.shape,"_").concat(t,"_").concat(a)}}));const a=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+a+"".concat(Ay().getNumber("WEBGL_VERSION")),s}(t,c,u),d=this.getAndSaveBinary(h,(()=>CK(this.gpgpu,t,c,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Ay().get("ENGINE_COMPILE_ONLY")||function(t,e,n,r,a){e.program.enableShapeUniforms||(TK(e.inShapeInfos,n),TK([e.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),1===Ay().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:o,texShape:i}=e.variablesLocations[l];if(o){const{uniformShape:n}=SK(e.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:t.gl.uniform1iv(o,new Int32Array(n));break;case 2:t.gl.uniform2iv(o,new Int32Array(n));break;case 3:t.gl.uniform3iv(o,new Int32Array(n));break;case 4:t.gl.uniform4iv(o,new Int32Array(n))}}if(i&&t.gl.uniform2i(i,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Qb(r.shape)<2)t.gl.uniform1f(a,r.uniformValues[0]);else{let e=r.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=r.texData.slice&&null!=s&&t.gl.uniform1i(s,r.texData.slice.flatOffset),t.setInputMatrixTexture(r.texData.texture.texture,a,l)}const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:t.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(i,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=my(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&a)for(let l=0;l<e.program.customUniforms.length;++l){const n=e.program.customUniforms[l],r=e.customUniformLocations[l],s=a[l];if("float"===n.type)t.gl.uniform1fv(r,s);else if("vec2"===n.type)t.gl.uniform2fv(r,s);else if("vec3"===n.type)t.gl.uniform3fv(r,s);else if("vec4"===n.type)t.gl.uniform4fv(r,s);else if("int"===n.type)t.gl.uniform1iv(r,s);else if("ivec2"===n.type)t.gl.uniform2iv(r,s);else if("ivec3"===n.type)t.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));t.gl.uniform4iv(r,s)}}t.executeProgram()}(this.gpgpu,d,c,u,r),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const g=Ay().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const t=bk();t-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Ay().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===a){const t=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),t}return o}compileAndRun(t,e,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||e[0].dtype;return this.runWebGLProgram(t,e,n,r,a)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Ay().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=SS((()=>{if(!Ay().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ay().getBool("DEBUG");Ay().set("DEBUG",!1);const e=this.abs(NI(1e-8)).dataSync()[0];if(Ay().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=e;if(null!=s)return;const l=null!=this.activeTimers;let c;l&&(c=bk());let u=e.texShape;if(null==u&&(u=function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Ay().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ay().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Ay().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n*=2,r*=2,1===(t=t.map(((e,n)=>n>=t.length-2?qb(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=oy(t);t=e.newShape}let a=Qb(t),s=null;t.length<=1&&a<=n?s=[1,a]:2===t.length&&t[0]<=n&&t[1]<=n?s=t:3===t.length&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(null==s||o)if(e){const e=qH(t);let n=2,r=2;t.length&&([n,r]=XH(t)),a=e*(n/2)*(r/2),s=ey(a).map((t=>2*t))}else s=ey(a);return s}(n,i),e.texShape=u),null!=a){const t=JH(n);let s,o=u[1],h=u[0];const d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!i&&d||([o,h]=_H(u[0],u[1])),s=i?new LK(t,d):new zK(t,d);const p=d?[h,o]:u,f=this.makeTensorInfo(p,r),g=this.texData.get(f.dataId);g.usage=d?TH.PIXELS:TH.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,h,a);const m=[[h,o]],b=!0,y=this.runWebGLProgram(s,[f],r,m,b),v=this.texData.get(y.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Ay().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=bk()-c)}else{const t=this.acquireTexture(u,o,r,i);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype ".concat(e))}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(t," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*uy(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(n){throw n}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await TT(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw PH(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}=EK(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=a,t.outShapeLocation=s,t.outShapeStridesLocation=o,t.outTexShapeLocation=i}}createTensorFromGPUData(t,e,n){t.channels=t.channels||"RGBA";const{texture:r,height:a,width:s,channels:o}=t,i=xS().backend;if(!i.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=i.writeTexture(r,e,n,a,s,o);return xS().makeTensorFromDataId(l,e,n,i)}}mX.nextDataId=0;lS()&&CS("webgl",(()=>new mX),2);const bX="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class yX{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=UI(e,n),this.enableShapeUniforms=AK(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const vX="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class wX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=UI(e,n);const a=this.outputShape.length;this.enableShapeUniforms=AK(a);let s="";if(r)if(0===a||1===Qb(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const t=kK(a);if(s="\n          ".concat(t," coords = getOutputCoords();\n        "),1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const t=Gq("coords",a);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= outShape[").concat(a," - 2];\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= outShape[").concat(a," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(t[a-2]," + 1) >= ").concat(this.outputShape[a-2],";\n            bool nextColOutOfBounds =\n              (").concat(t[a-1]," + 1) >= ").concat(this.outputShape[a-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}}function xX(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const kX={kernelName:Jv,backendName:"webgl",kernelFunc:xX};function SX(t){const{inputs:e,backend:n}=t,{real:r,imag:a}=e,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=xX({inputs:{x:r},backend:n}),l=xX({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:l},s}const IX={kernelName:ov,backendName:"webgl",kernelFunc:SX},NX="return (a < 0.) ? b * a : a;",CX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const EX={kernelName:ew,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{alpha:s}=r,o=n.makeTensorInfo([],"float32",gk(s,"float32")),i=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wX(CX,a.shape,o.shape):new yX(NX,a.shape,o.shape),l=n.runWebGLProgram(i,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},TX="return (a < 0.) ? b * a : a;",AX="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const RX={kernelName:Lw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wX(AX,r.shape,a.shape):new yX(TX,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},FX="if (isnan(x)) return x;";function _X(t){let{opSnippet:e,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=t;return t=>{let{inputs:s,backend:o}=t;const{x:i}=s,l=o,c=a||i.dtype;if(l.shouldExecuteOnCPU([i])&&null!=r){const t=l.texData.get(i.dataId),e=r(t.values,c);return l.makeTensorInfo(i.shape,c,e)}let u;return u=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new hX(i.shape,n):new Zq(i.shape,e),l.runWebGLProgram(u,[i],c)}}function DX(t){let{opSnippet:e,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:o}=t;return t=>{let{inputs:i,backend:l}=t;const{a:c,b:u}=i,h=l;if(a&&"complex64"===c.dtype){const t=h.texData.get(c.dataId),n=h.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:c.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},o=new yX(e,c.shape,u.shape);return h.runWebGLProgram(o,[a,s],Kk(n.dtype,r.dtype))})),s=SX({inputs:{real:r,imag:a},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(a),s}const d=o||Kk(c.dtype,u.dtype);if(("string"===c.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([c,u]))&&null!=s){const t=h.texData.get(c.dataId).values,e=h.texData.get(u.dataId).values,n="string"===c.dtype?LA(t):t,r="string"===c.dtype?LA(e):e,[a,o]=s(c.shape,u.shape,n,r,d),i=h.makeTensorInfo(o,d);return h.texData.get(i.dataId).values=a,i}let p;return p=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new wX(n,c.shape,u.shape,r):new yX(e,c.shape,u.shape),h.runWebGLProgram(p,[c,u],d)}}function OX(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===t)return e?oX:$q;if("relu"===t)return e?lX:nX;if("elu"===t)return e?iX:eX;if("relu6"===t)return e?cX:rX;if("prelu"===t)return e?AX:TX;if("leakyrelu"===t)return e?CX:NX;if("sigmoid"===t)return e?uX:sX;throw new Error("Activation ".concat(t," has not been implemented for the WebGL backend."))}class zX{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=AK(this.outputShape.length);const c=r?t[1]:t[2],u=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";o&&(g=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(o,"\n        }"):l?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(o,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(o,"\n        }"),m="result = activation(result);");const b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y="imod(rc.x, ".concat(t[0],")"):e[0]<t[0]&&(v="imod(rc.x, ".concat(e[0],")")),this.userCode="\n      ".concat(g,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(m,"\n\n        setOutput(result);\n      }\n    ")}}const LX={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class MX{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=UI(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const PX="return a * b;";function BX(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Kk(r.dtype,a.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),s=new MX(LX.REAL,r.shape,a.shape),o=new MX(LX.IMAG,r.shape,a.shape),i=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,i,"float32"),c=n.runWebGLProgram(o,i,"float32"),u=SX({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([r,a])){const t=n.texData.get(r.dataId),e=n.texData.get(a.dataId),[o,i]=mq(r.shape,a.shape,t.values,e.values,s),l=n.makeTensorInfo(i,s);return n.texData.get(l.dataId).values=o,l}let o;return o=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wX(PX,r.shape,a.shape):new yX(PX,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const WX={kernelName:Nw,backendName:"webgl",kernelFunc:BX};function UX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{shape:s}=r,o=n,i=Qb(a.shape),l=ay(s,i),c=Qb(l);Jb(i===c,(()=>"The new shape (".concat(l,") has ").concat(c," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=o.texData.get(a.dataId);return!u.isPacked||ZH(a.shape,l)||null!==u.texture&&ZH(u.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(t,e,n){const r=[qH(t.shape),...XH(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[qH(e),...XH(e)],o=new Kq(s,r),i=[r],l=n.runWebGLProgram(o,[a],t.dtype,i,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(a,l,o)}const VX={kernelName:Hw,backendName:"webgl",kernelFunc:UX};class jX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l="sumValue += dot(values * ".concat(ty(t)?t.toPrecision(2):t,", ones);")}let c="";a%n>0&&(c="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class GX{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=t;this.outputShape=[r,s];let o="0.0",i="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",i="min"):"max"===e&&(o="-1.0 / 1e-20",i="max");let l="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===e,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===e,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===e," || ").concat("max"===e,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";a%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(o,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(o,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(l,");\n      }\n    ")}}function HX(t,e,n,r){const a=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=MT(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let s=t;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:l,outSize:c}=a[o];let u,h;u="mean"===n?0===o?new jX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},i):new jX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c}):new GX({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:c},n),h=s,s=r.runWebGLProgram(u,[s],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return s}class KX{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;const r=kK(this.rank),a=function(t){const e=t.length;if(e>6)throw Error("Transpose for rank ".concat(e," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let a=0;a<t.length;a++)r[t[a]]=n[a];return r.join()}(e);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(a,"));\n    }\n    ")}}class qX{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const r=kK(this.rank),a=jq("rc",this.rank),s=new Array(this.rank);for(let c=0;c<e.length;c++)s[e[c]]=a[c];const o="vec2(".concat(s.slice(-2).join(),")"),i="++".concat(a[this.rank-1]," < ").concat(n[this.rank-1]),l="getChannel(getA(".concat(s.join(),"), ").concat(o,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l,";\n      if(").concat(i,") {\n        result[1] = ").concat(l,";\n      }\n      --").concat(a[this.rank-1],";\n      if(++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(l,";\n        if(").concat(i,") {\n          result[3] = ").concat(l,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function XX(t,e,n){const r=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qX(t.shape,e):new KX(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function JX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r;return function(t,e,n,r){const a=e,s=t.shape.length,o=sy(a,t.shape);let i=o;const l=AC(i,s),c=null!=l;let u=t;c&&(u=XX(t,l,r),i=FC(i.length,s)),TC("sum",i,s);const[h,d]=CC(u.shape,i);let p=h;n&&(p=EC(h,o));const f=Qb(d),g=UX({inputs:{x:u},attrs:{shape:[Qb(t.shape)/f,f]},backend:r}),m=HX(g,qk(t.dtype),"sum",r),b=UX({inputs:{x:m},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(m),c&&r.disposeIntermediateTensorInfo(u),b}(a,s,o,n)}const YX={kernelName:dx,backendName:"webgl",kernelFunc:JX};function ZX(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{perm:s}=r,o=n,i=a.shape.length,l=new Array(i);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let c;if(o.shouldExecuteOnCPU([a])){const t=o.texData.get(a.dataId).values,e=Uq(t,a.shape,a.dtype,s,l);c=o.makeTensorInfo(l,a.dtype);o.texData.get(c.dataId).values=e}else c=XX(a,s,o);return c}const QX={kernelName:Ox,backendName:"webgl",kernelFunc:ZX},$X=1e3;function tJ(t){let{a:e,b:n,transposeA:r,transposeB:a,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:c=null}=t;const u=e.shape.length,h=n.shape.length,d=r?e.shape[u-2]:e.shape[u-1],p=a?n.shape[h-1]:n.shape[h-2],f=r?e.shape[u-1]:e.shape[u-2],g=a?n.shape[h-2]:n.shape[h-1],m=e.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Qb(m),v=Qb(b),w=UI(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);Jb(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(e.shape," and ")+"".concat(n.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const x=r?[y,d,f]:[y,f,d],k=a?[v,g,p]:[v,p,g],S=UX({inputs:{x:e},backend:s,attrs:{shape:x}}),I=UX({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],C=Math.max(y,v),E=r?S.shape[1]:S.shape[2],T=null!=o,A=null!=i,R="leakyrelu"===c,F=null!=c?OX(c,!0):null;let _;if((1===f||1===g)&&E>$X&&!1===(T||A||R||null!=F)){let t=S,e=I;r&&(t=ZX({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(t)),a&&(e=ZX({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e));const n=1===g;let o=t;1!==g&&(o=UX({inputs:{x:t},backend:s,attrs:{shape:[C,E,1]}}),N.push(o));const i=1===g?2:1;let l=e;n&&(l=UX({inputs:{x:e},backend:s,attrs:{shape:[C,1,E]}}),N.push(l));const c=BX({inputs:{a:o,b:l},backend:s});_=JX({inputs:{x:c},backend:s,attrs:{axis:i,keepDims:!0}}),N.push(c)}else{const t=Kk(e.dtype,n.dtype),c=new zX(x,k,[C,f,g],r,a,T,F,A,R),u=[S,I];if(null!=o&&u.push(o),A&&u.push(i),R){const t=s.makeTensorInfo([],"float32",gk(l,"float32"));u.push(t),N.push(t)}_=s.runWebGLProgram(c,u,t)}const D=UX({inputs:{x:_},backend:s,attrs:{shape:w}});N.push(_);for(const O of N)s.disposeIntermediateTensorInfo(O);return D}const eJ={kernelName:Vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s,bias:o,preluActivationWeights:i}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return tJ({a:a,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},nJ="return abs(x);";const rJ={kernelName:Oy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const t=n.texData.get(r.dataId),e=Eq(t.values);return n.makeTensorInfo(r.shape,r.dtype,e)}let a;return a=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new hX(r.shape,nJ):new Zq(r.shape,nJ),n.runWebGLProgram(a,[r],r.dtype)}},aJ=_X({opSnippet:Qq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),sJ={kernelName:zy,backendName:"webgl",kernelFunc:aJ},oJ=_X({opSnippet:Qq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),iJ={kernelName:Ly,backendName:"webgl",kernelFunc:oJ},lJ="return a + b;",cJ=DX({opSnippet:lJ,packedOpSnippet:lJ,supportsComplex:!0,cpuKernelImpl:XK}),uJ={kernelName:My,backendName:"webgl",kernelFunc:cJ};class hJ{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("float v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}class dJ{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>"T".concat(e)));const n=[];this.variableNames.forEach((t=>{n.push("vec4 v".concat(t," = get").concat(t,"AtOutCoords();"))}));const r=this.variableNames.map((t=>"v".concat(t))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}const pJ={kernelName:Py,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,a=n;if(1===a.length)return xX({inputs:{x:a[0]},backend:r});if(a.length>Ay().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(a.length/2),n=t({inputs:a.slice(0,e),backend:r}),s=t({inputs:a.slice(e),backend:r});return t({inputs:[n,s],backend:r})}const s=a.map((t=>t.dtype)).reduce(((t,e)=>Kk(t,e))),o=a.map((t=>t.shape)),i=Ay().getBool("WEBGL_PACK")?new dJ(a[0].shape,o):new hJ(a[0].shape,o);return r.runWebGLProgram(i,a,s)}};const fJ={kernelName:By,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=AC(c,i);let h=a;null!=u&&(h=ZX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=FC(c.length,i)),TC("all",c,i);const[d,p]=CC(h.shape,c),f=UX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=HX(f,f.dtype,"all",n);let m;if(o){m=UX({inputs:{x:g},backend:n,attrs:{shape:EC(d,l)}})}else m=UX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};const gJ={kernelName:Wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=AC(c,i);let h=a;null!=u&&(h=ZX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=FC(c.length,i)),TC("any",c,i);const[d,p]=CC(h.shape,c),f=UX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=HX(f,f.dtype,"any",n);let m;if(o){m=UX({inputs:{x:g},backend:n,attrs:{shape:EC(d,l)}})}else m=UX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}};class mJ{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===e?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(o," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class bJ{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Jb(t.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const a=t[t.length-1],s=Math.ceil(a/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=kK(i),c=Gq("coords",i);let u,h;if(1===s){h=i+1;const t=kK(h);u="\n        ".concat(t," sourceLocR = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-1],";\n        ").concat(t," sourceLocG = ").concat(t,"(").concat(c.join(),", 0);\n        ++").concat(c[i-2],";\n        ").concat(t," sourceLocA = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-1],";\n        ").concat(t," sourceLocB = ").concat(t,"(").concat(c.join(),", 0);\n        --").concat(c[i-2],";")}else h=i,u="\n        ".concat(l," sourceLocR = coords;\n        ++").concat(c[i-1],";\n        ").concat(l," sourceLocG = coords;\n        ++").concat(c[i-2],";\n        ").concat(l," sourceLocA = coords;\n        --").concat(c[i-1],";\n        ").concat(l," sourceLocB = coords;\n        --").concat(c[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((t=>"int "+t)),g=Gq("sourceLocR",h-1).concat("inIdx.r"),m=Gq("sourceLocG",h-1).concat("inIdx.g"),b=Gq("sourceLocB",h-1).concat("inIdx.b"),y=Gq("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",w=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),x="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(m.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=r?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(l," coords = getOutputCoords();\n        bool hasNextCol = ").concat(c[i-1]," < ").concat(o[i-1]-1,";\n        bool hasNextRow = ").concat(c[i-2]," < ").concat(o[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(e,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(x,";\n\n        for (int i = 0; i < ").concat(e,"; i++) {\n          inIdx = srcIdx;\n          ").concat(w,"\n          vec4 candidate = ").concat(x,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function yJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=e.shape[0],s=e.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=MT(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},l=new mJ(i,n,null==r),c=[e];null!=r&&c.push(r);const u=t.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=yJ(t,e,n,u);return t.disposeIntermediateTensorInfo(u),h}function vJ(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:e.shape,s=MT(a[a.length-1]),o=new bJ(a,s,n,null==r),i=null==r?[e]:[e,r],l=t.runWebGLProgram(o,i,"int32");if(l.shape.length===e.shape.length){const r=vJ(t,e,n,l);return t.disposeIntermediateTensorInfo(l),r}return l}function wJ(t,e,n,r){const a=[n];if(TC("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,e.shape.length),!Ay().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],s=t.texData.get(e.dataId);let o=e;null!==s&&s.isPacked&&(o=t.unpackTensor(e),n.push(o));const[i,l]=CC(o.shape,a),c=Qb(l),u=UX({inputs:{x:o},backend:t,attrs:{shape:[-1,c]}});n.push(u);const h=yJ(t,u,r);n.push(h);const d=UX({inputs:{x:h},backend:t,attrs:{shape:i}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),d}return vJ(t,e,r)}const xJ={kernelName:Uy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=sy(s,a.shape);const i=AC(o,a.shape.length);let l=a;const c=[];null!=i&&(l=ZX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=FC(o.length,l.shape.length)),TC("argMax",[o[0]],l.shape.length);const u=wJ(n,l,o[0],"max");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}};const kJ={kernelName:Vy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s}=r;let o=sy(s,a.shape);const i=AC(o,a.shape.length);let l=a;const c=[];null!=i&&(l=ZX({inputs:{x:a},backend:n,attrs:{perm:i}}),c.push(l),o=FC(o.length,l.shape.length)),TC("argMin",[o[0]],l.shape.length);const u=wJ(n,l,o[0],"min");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}},SJ=_X({opSnippet:Qq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),IJ={kernelName:jy,backendName:"webgl",kernelFunc:SJ},NJ=_X({opSnippet:Qq+"return log(x + sqrt(x * x + 1.0));"}),CJ={kernelName:Gy,backendName:"webgl",kernelFunc:NJ},EJ=_X({opSnippet:Qq+"\n  return atan(x);\n"}),TJ={kernelName:Hy,backendName:"webgl",kernelFunc:EJ},AJ=DX({opSnippet:bX+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vX+"\n  return result;\n"}),RJ={kernelName:qy,backendName:"webgl",kernelFunc:AJ},FJ=_X({opSnippet:Qq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),_J={kernelName:Ky,backendName:"webgl",kernelFunc:FJ};class DJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,g="((batch  * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + d"),m="(xR * ".concat(t.inWidth," + xC) * ").concat(t.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(c,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(e," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?a?g:m:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(y="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),w=s%4,x="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(l,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(c,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              getValue(batch, xR, xC + 3 * ").concat(c,", d)\n            );\n\n            ").concat(x,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(2===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(x,"\n          } else if (").concat(3===w,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              initializationValue\n            );\n\n            ").concat(x,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class OJ{constructor(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,i=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=t.padInfo.front,m=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(c,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(e," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?a?"(((batch * ".concat(t.inDepth," + xD) * ").concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"((xD * ".concat(t.inHeight," + xR) * ").concat(t.inWidth," + xC) * ").concat(t.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let w="".concat(e,"(").concat(e,"(").concat(e,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(s/4),k=s%4,S="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(o,", ").concat(i,", ").concat(l,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(t.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(c,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(x,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(x,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(w,");\n      }\n    ")}}const zJ={kernelName:Xy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;aK(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(zN(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=NN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))return xX({inputs:{x:a},backend:n});const u=new DJ(c,"avg",!1);return n.runWebGLProgram(u,[a],"float32")}};const LJ={kernelName:Yy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:c}=r,u=CN(a.shape,s,o,[1,1,1],i,l,c),h=new OJ(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}};class MJ{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=i-1-t.padInfo.top,u=l-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(l,";\n            wC+= ").concat(o,") {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PJ{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=u-1-t.padInfo.front,f=h-1-t.padInfo.top,g=d-1-t.padInfo.left,m=1/(e*n*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(g,");\n      const float avgMultiplier = float(").concat(m,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(a,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(l,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const BJ={kernelName:Zy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=CN(o.shape,i,l,[1,1,1],c,u),d=new PJ(h);return n.runWebGLProgram(d,[a],o.dtype)}};const WJ={kernelName:Jy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s;aK([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:c}=r,u=NN(o.shape,i,l,1,c),h=new MJ(u);return n.runWebGLProgram(h,[a],o.dtype)}};const UJ={kernelName:Qy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:a,b:s}=e,{transposeA:o,transposeB:i}=r;return tJ({a:a,b:s,transposeA:o,transposeB:i,backend:n})}};class VJ{constructor(t,e,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],UI(t,e),UI(t,n);let o="0.0";null!=r&&(UI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(UI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class jJ{constructor(t,e,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],UI(t,e),UI(t,n);let o="vec4(0.0)";null!=r&&(UI(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(UI(t,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const GJ={kernelName:Gv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a,mean:s,variance:o,offset:i,scale:l}=e;Jb(s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Jb(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Jb(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=[a,s,o];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=l&&(d=l.shape,u.push(l));const p=Ay().getBool("WEBGL_PACK_NORMALIZATION")?new jJ(a.shape,s.shape,o.shape,h,d,c):new VJ(a.shape,s.shape,o.shape,h,d,c);return n.runWebGLProgram(p,u,u[0].dtype)}};class HJ{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=kK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return KJ.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error("Slicing for rank ".concat(t," is not yet supported"))}(this.rank);let r;const a=t.map(((t,e)=>"sourceLoc.".concat(KJ[e]," = start[").concat(e,"] + coords.").concat(KJ[e],";")));r="\n        ".concat(e," sourceLoc;\n        ").concat(e," coords = getOutputCoords();\n        ").concat(a.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(r,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const KJ=["x","y","z","w","u","v"];class qJ{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=kK(this.rank),n=Gq("coords",this.rank),r=Gq("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),s="getChannel(getSource(".concat(r.join(),"), ").concat(a,")"),o="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(r[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(t[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(t[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),l=this.rank<=4?"sourceLoc = coords +\n            ".concat(e,"(").concat(t.map(((t,e)=>"start[".concat(e,"]"))).join(),");"):t.map(((t,e)=>"".concat(r[e]," = ").concat(n[e]," + start[").concat(e,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(e," coords = getOutputCoords();\n        ").concat(e," sourceLoc;\n        ").concat(l,"\n        vec4 result = vec4(0.);\n        ").concat(o,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function XJ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,size:o}=r,[i,l]=yN(a,s,o);if(aN(a,i,l),0===Qb(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const t=n.texData.get(a.dataId),e=Tq(t.values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,e)}const{isPacked:c}=n.texData.get(a.dataId),u=mN(a.shape,i,l);if(c||!u){const t=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qJ(l):new HJ(l),e=[i];return n.runWebGLProgram(t,[a],a.dtype,e)}return n.uploadToGPU(a.dataId),function(t,e,n,r){const a=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=t.dtype;let i=bN(e,my(t.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||t.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}(a,i,l,n)}const JJ={kernelName:sx,backendName:"webgl",kernelFunc:XJ},YJ={kernelName:$y,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,crops:o}=r;Jb(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=BT(a.shape,s,i),c=WT(l.length,s.length),u=UT(a.shape,s,i),h=VT(o,s.length),d=jT(u,o,s.length),p=[],f=UX({inputs:{x:a},backend:n,attrs:{shape:l}}),g=ZX({inputs:{x:f},backend:n,attrs:{perm:c}}),m=UX({inputs:{x:g},backend:n,attrs:{shape:u}}),b=XJ({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}};const ZJ={kernelName:tv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o}=r,i=n.readSync(a.dataId),l=n.readSync(s.dataId),c=JK(i,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}};const QJ={kernelName:ev,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{a:r,b:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ay().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===o){const t=n.texData.get(r.dataId).values,e=n.texData.get(a.dataId).values,[s,o]=ZK(r.shape,a.shape,t,e,r.dtype),i=n.makeTensorInfo(o,r.dtype);return n.texData.get(i.dataId).values=s,i}let i;return i=s?new wX("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new yX("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(i,[r,a],r.dtype)}};const $J={kernelName:nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:a}=e,s=n.readSync(r.dataId),o=n.readSync(a.dataId),i=UI(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},tY=DX({opSnippet:"return float(a != b);",cpuKernelImpl:yq,dtype:"bool"}),eY={kernelName:Ew,backendName:"webgl",kernelFunc:tY};function nY(t){const{inputs:e,backend:n}=t,{input:r}=e;return xX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const rY={kernelName:Vw,backendName:"webgl",kernelFunc:nY},aY="return float(int(x));";const sY={kernelName:rv,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return xX({inputs:{x:s},backend:r});const e=GC(s.shape),n=t({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=SX({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const e=nY({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),n}if(!cy(s.dtype,o)){const t=xX({inputs:{x:s},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:o}}if(r.shouldExecuteOnCPU([s])){const t=r.texData.get(s.dataId).values,[e,n,a]=QK(t,s.shape,s.dtype,o);return r.makeTensorInfo(e,n,a)}if("int32"===o)return function(t,e){const n=new Zq(t.shape,aY),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const t=r.makeTensorInfo([],"bool",iy("bool",1)),e=tY({inputs:{a:s,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(o))}},oY="return ceil(x);",iY=_X({opSnippet:oY,packedOpSnippet:oY,cpuKernelImpl:$K}),lY={kernelName:av,backendName:"webgl",kernelFunc:iY};class cY{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class uY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const hY={kernelName:sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{clipValueMin:s,clipValueMax:o}=r;let i;i=Ay().getBool("WEBGL_PACK_CLIP")?new uY(a.shape):new cY(a.shape);const l=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,l)}};class dY{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function pY(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const fY={kernelName:iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=n.texData.get(r.dataId),s=new dY(r.shape),o=[pY(r,a.complexTensorInfos.real),pY(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class gY{constructor(t){this.outputShape=[],this.outputShape=RT(t,1),this.variableNames=t.map(((t,e)=>"T".concat(e)));const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=["if (yC < ".concat(e[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<e.length;s++){const t=e[s-1];n.push("else if (yC < ".concat(e[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(t,"));"))}const r=e.length,a=e[e.length-1];n.push("else setOutput(getT".concat(r,"(yR, yC-").concat(a,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class mY{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=RT(t,e);const n=this.outputShape,r=n.length,a=kK(r),s=Gq("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>"T".concat(e)));const i=new Array(t.length-1);i[0]=t[0][e];for(let f=1;f<i.length;f++)i[f]=i[f-1]+t[f][e];const l=o[e],c=o.slice(-2),u=o.join();let h="if (".concat(l," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(c.join(),"));\n        }");for(let f=1;f<i.length;f++){const t=i[f-1];h+="\n        if (".concat(l," < ").concat(i[f],"  && ").concat(l," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(bY(o,l,t),"),\n            vec2(").concat(bY(c,l,t),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(bY(o,l,p),"),\n          vec2(").concat(bY(c,l,p),"));"),this.userCode="\n      float getValue(".concat(o.map((t=>"int "+t)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(a," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," + 1;\n        if (").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-2]," = ").concat(s[r-2]," + 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[r-1]," = ").concat(s[r-1]," - 1;\n        if (").concat(s[r-2]," < ").concat(n[r-2]," &&\n            ").concat(s[r-1]," < ").concat(n[r-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}function bY(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?"".concat(t," - ").concat(n):t)).join()}function yY(t){const{inputs:e,backend:n}=t,{input:r}=e;return xX({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const vY={kernelName:Zv,backendName:"webgl",kernelFunc:yY};function wY(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>nY({inputs:{input:t},backend:n}))),a=t.map((t=>yY({inputs:{input:t},backend:n}))),s=wY(r,e,n),o=wY(a,e,n),i=SX({inputs:{real:s,imag:o},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),a.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(t);if("string"===r&&(a=!0),a){const a=t.map((t=>{const r=Qb(t.shape.slice(e));return UX({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),o=RT(a.map((t=>t.shape)),1),i=1===a[0].shape[0],l=tq(s,o,r,i),c=RT(t.map((t=>t.shape)),e),u=n.makeTensorInfo(c,r,l);return a.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}const s=t.filter((t=>Qb(t.shape)>0)),o=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const e=o?new Zq(t[0].shape,aX):new hX(t[0].shape,aX);return n.runWebGLProgram(e,t,r)}const i=Ay().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){const t=[];for(let a=0;a<s.length;a+=i){const r=s.slice(a,a+i);t.push(wY(r,e,n))}const r=wY(t,e,n);for(const e of t)n.disposeIntermediateTensorInfo(e);return r}if(o){const t=new mY(s.map((t=>t.shape)),e);return n.runWebGLProgram(t,s,r)}const{tensors2D:l,outShape:c}=function(t,e,n){const r=RT(t.map((t=>t.shape)),e),a=t.map((t=>UX({inputs:{x:t},attrs:{shape:[-1,Qb(t.shape.slice(e))]},backend:n})));return{tensors2D:a,outShape:r}}(s,e,n),u=new gY(l.map((t=>t.shape))),h=n.runWebGLProgram(u,l,r);l.forEach((t=>n.disposeIntermediateTensorInfo(t)));const d=UX({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function xY(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r,s=sy(a,e[0].shape)[0];AT(e.map((t=>t.shape)),s);const o=RT(e.map((t=>t.shape)),s);if(0===Qb(o))return n.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter((t=>Qb(t.shape)>0));return 1===i.length?xX({inputs:{x:i[0]},backend:n}):wY(i,s,n)}const kY={kernelName:lv,backendName:"webgl",kernelFunc:xY};class SY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,o=t.padInfo.left,i=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,g="channelsLast"===t.dataFormat,m=g?1:2,b=g?2:3,y=g?3:1;let v="",w="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),w="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(l,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(c,";\n\n          if (xR < 0 || xR >= ").concat(t.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(t.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(x,"\n        ").concat(w,"\n        setOutput(result);\n      }\n    ")}}class IY{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(a,", ").concat(s,", ").concat(o,");\n      const ivec3 pads = ivec3(").concat(e,", ").concat(n,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(t.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(l,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(c,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class NY{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=AK(this.outputShape.length);const s=t.padInfo.left,o=t.strideWidth,i=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,u=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+="\n           vec4 xTexelC".concat(2*g,";\n           int xTexelC").concat(2*g,"Ready;\n           vec4 xTexelC").concat(2*g+1,";\n           int xTexelC").concat(2*g+1,"Ready;\n           vec4 xC").concat(g,";");h+="\n     for (int r = 0; r < ".concat(l,"; r++) {\n      for (int d1 = 0; d1 < ").concat(t.inChannels,"; d1 += 2) {\n       ");for(let g=0;g<c;g++)h+="\n           xTexelC".concat(2*g," = vec4(0.0);\n           xTexelC").concat(2*g,"Ready = 0;\n           xTexelC").concat(2*g+1," = vec4(0.0);\n           xTexelC").concat(2*g+1,"Ready = 0;\n           xC").concat(g," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const e=2*g;if(h+="\n           xC = xCCorner + ".concat(e*i,";\n           "),1===o){if(e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n               "),h+=1===i&&e>0?"\n                 xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                   } else {\n                     xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xC").concat(e," = xTexelC").concat(e,";\n                 "),e+1<c)){const t=s%2===0?qb(i):i;i%2===0&&s%2===1||i%2!==0&&s%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                     xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(e+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(e+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                     } else {\n                      xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                     }\n                     "):"\n                     xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                     ")):h+=1===t?"\n                     xC".concat(e+1," = xTexelC").concat(e,";\n                     "):"\n                     xCOffset = xC + ".concat(t,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                       xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(e+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(e+1,"Ready = 1;\n                     }\n\n                     xC").concat(e+1," = xTexelC").concat(e+1,";\n                     ")}}else e<c&&(s%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n               "),e+1<c&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                   xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(e,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(e,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                   xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(e+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(e+1,"Ready = 1;\n                 }\n\n                 xC").concat(e," = vec4(\n                   xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n               "),e+1<c&&(h+="\n                   xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                 "))));e<c&&(h+="\n             wTexel = getW(r, ".concat(e,", d1, d2);\n             dotProd += xC").concat(e,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(t.inChannels,") {\n               dotProd += xC").concat(e,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),e+1<c&&(h+="\n               wTexel = getW(r, ".concat(e+1,", d1, d2);\n               dotProd += xC").concat(e+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(t.inChannels,") {\n                 dotProd += xC").concat(e+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):a?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class CY{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=AK(this.outputShape.length);const{dataFormat:n}=e,r=oK(),a="channelsLast"===n,s=a?1:2,o=a?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(t[2]," && pos < ").concat(t[1],") {");let l="";for(let c=0;c<=1;c++)for(let t=0;t<=1;t++)l+="\n          blockIndex = rc.z + ".concat(t,";\n          pos = rc.y + ").concat(c,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(o,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(a,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*c+t,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(l,"\n\n        ").concat(r.output," = result;\n      }\n    ")}}function EY(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function TY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const c=e.shape,u=a.texData.get(e.dataId),h=r.inChannels,d=c[0]*c[1]*c[2],p=r.outChannels,f="channelsLast"===r.dataFormat;let g;const m=[];if(null!=o){const t=EY(o.shape,f);null!=t&&(o=UX({inputs:{x:o},backend:a,attrs:{shape:t}}),m.push(o))}if(null!=s){const t=EY(s.shape,f);null!=t&&(s=UX({inputs:{x:s},backend:a,attrs:{shape:t}}),m.push(s))}if(!((1===d||1===p)&&h>$X)&&u.isPacked&&f&&null!=u.texture&&c[2]%2!==0&&$b(u.shape.slice(-3),c.slice(-3))){const t=c[0]*c[1]*(c[2]+1),h={dataId:e.dataId,shape:[1,t,r.inChannels],dtype:e.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Jb(ZH(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=UX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});m.push(p);const f=tJ({a:h,b:p,backend:a,transposeA:false,transposeB:false,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i}),b=a.texData.get(f.dataId);Jb(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,b.shape=r.outShape,g=xX({inputs:{x:f},backend:a}),g.shape=r.outShape,m.push(f)}else{const t=r.outHeight*r.outWidth,c=UX({inputs:{x:e},backend:a,attrs:{shape:f?[r.batchSize,t,r.inChannels]:[r.batchSize,r.inChannels,t]}}),u=UX({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=tJ({a:f?c:u,b:f?u:c,transposeA:!f,transposeB:false,backend:a,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:i});g=UX({inputs:{x:h},backend:a,attrs:{shape:r.outShape}}),m.push(c),m.push(u),m.push(h)}for(const b of m)a.disposeIntermediateTensorInfo(b);return g}function AY(t){let{x:e,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}=t;const{filterWidth:c,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,g="channelsLast"===f,m=c*u*h,b=p*d,y=[r.batchSize,m,b],v=[];if(null!=o){const t=EY(o.shape,g);null!=t&&(o=UX({inputs:{x:o},backend:a,attrs:{shape:t}}),v.push(o))}if(null!=s){const t=EY(s.shape,g);null!=t&&(s=UX({inputs:{x:s},backend:a,attrs:{shape:t}}),v.push(s))}const w=UX({inputs:{x:n},backend:a,attrs:{shape:[1,m,Qb(n.shape)/m]}});v.push(w);const x=new CY(y,r),k=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(x,[e],"float32",k),I=UX({inputs:{x:S},backend:a,attrs:{shape:y}});v.push(S),v.push(I);const N=null!=s,C=null!=o,E="leakyrelu"===l,T=l?OX(l,!0):null,A=new zX(g?I.shape:w.shape,g?w.shape:I.shape,g?[r.batchSize,b,r.outChannels]:[r.batchSize,r.outChannels,b],!0,!1,N,T,C,E),R=g?[I,w]:[w,I];if(s&&R.push(s),C&&R.push(o),E){const t=a.makeTensorInfo([],"float32",gk(i,"float32"));R.push(t),v.push(t)}const F=a.runWebGLProgram(A,R,"float32"),_=UX({inputs:{x:F},backend:a,attrs:{shape:r.outShape}});v.push(F);for(const D of v)a.disposeIntermediateTensorInfo(D);return _}const RY={kernelName:cv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=MN(l),d=EN(a.shape,s.shape,o,c,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Ay().getBool("WEBGL_EXP_CONV")){const t=new NY(d),e=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(t,[a,s],"float32",e)}else if(Ay().getBool("WEBGL_CONV_IM2COL"))p=AY({x:a,filter:s,convInfo:d,backend:n});else{const t=new SY(d);p=n.runWebGLProgram(t,[a,s],"float32")}else p=TY({x:a,filter:s,convInfo:d,backend:n});const f=UX({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class FY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              ").concat(s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class _Y{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s="channelsLast"===t.dataFormat,o=e-1-t.padInfo.top,i=n-1-t.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(l,"], coords[").concat(c,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class DY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.padInfo.front,s=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(t.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(e," - ").concat(a,";\n\n            if (xF < 0 || xF >= ").concat(t.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(t.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(o,";\n\n                if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class OY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,a=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(l,", ").concat(c,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(e,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(a,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(t.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(e," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const zY={kernelName:uv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=MN(l),d=EN(a.shape,u,o,1,i,c,!1,h),p=new FY(d);return n.runWebGLProgram(p,[a,s],"float32")}};class LY{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=AK(this.outputShape.length);const e=t.filterHeight,n=t.filterWidth,r=e-1-t.padInfo.top,a=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(a,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(t.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(t.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const MY={kernelName:hv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{inputShape:o,strides:i,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=MN(c),d=EN(o,s.shape,i,1,l,u,!1,h);if(Ay().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const t=[[d.strideHeight,d.strideWidth]],e=new LY(d);return n.runWebGLProgram(e,[a,s],"float32",t)}{const t=new _Y(d);return n.runWebGLProgram(t,[a,s],"float32")}}};const PY={kernelName:dv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=TN(a.shape,s.shape,o,l,i),u=new IY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const BY={kernelName:pv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,pad:i,filterShape:l}=r,c=TN(a.shape,l,o,1,i),u=new DY(c);return n.runWebGLProgram(u,[a,s],"float32")}};const WY={kernelName:fv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{pad:o,strides:i,inputShape:l}=r,c=TN(l,s.shape,i,1,o),u=new OY(c);return n.runWebGLProgram(u,[a,s],"float32")}},UY=_X({opSnippet:FX+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(vX,"\n  return result;\n")}),VY={kernelName:gv,backendName:"webgl",kernelFunc:UY},jY=_X({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),GY={kernelName:mv,backendName:"webgl",kernelFunc:jY};class HY{constructor(t,e,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===r?1:0,[p,f]=["".concat(o-1,".0"),"".concat(i-1,".0")],[g,m,b]=u>1?["".concat((o-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,w]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(g,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(m,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n        float in_x = ").concat(w,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const KY={kernelName:vv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{image:a,boxes:s,boxInd:o}=e,{cropSize:i,method:l,extrapolationValue:c}=r,u=new HY(a.shape,s.shape,i,l,c);return n.runWebGLProgram(u,[a,s,o],"float32")}};var qY;!function(t){t.Prod="*",t.Sum="+"}(qY||(qY={}));class XY{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===qY.Prod?"1.0":"0.0",o=n?s:"getX(".concat(JY(a,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=r?"end != ".concat(i-1):"end != 0",c=r?"end + 1":"end - 1"):(l=r?"end + pow2 < ".concat(i):"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(kK(a)," coords = getOutputCoords();\n        int end = ").concat(YY(a,"coords",this.op),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(l,") {\n          int idx = ").concat(c,";\n          ").concat(YY(a,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(JY(a,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function JY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".x, ").concat(e,".y");if(3===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z");if(4===t)return"".concat(e,".x, ").concat(e,".y, ").concat(e,".z, ").concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function YY(t,e,n){if(1===t)return"".concat(e);if(2===t)return"".concat(e,".y");if(3===t)return"".concat(e,".z");if(4===t)return"".concat(e,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(t," is not yet supported"))}function ZY(t,e,n,r,a,s){const o=e.shape.length,i=AC([r],o);let l=e;null!=i&&(l=ZX({inputs:{x:e},backend:n,attrs:{perm:i}}));const c=FC(1,o)[0];if(c!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(e.shape.length-1," ")+"but got axis=".concat(r));const u=l.shape[c];let h=xX({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const e=new XY(t,l.shape,!1,s),r=[[d]],a=h;h=n.runWebGLProgram(e,[h],h.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const e=new XY(t,l.shape,a,s),r=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=i){const t=ZX({inputs:{x:h},backend:n,attrs:{perm:RC(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}const QY={kernelName:bv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return ZY(qY.Prod,a,n,s,o,i)}};const $Y={kernelName:yv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,exclusive:o,reverse:i}=r;return ZY(qY.Sum,a,n,s,o,i)}};const tZ={kernelName:wv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,weights:s}=e,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const t=n.readSync(a.dataId),e=n.readSync(s.dataId),r=JK(t,e,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const t=n.bufferSync(a),e=n.bufferSync(s),r=YK(t,e,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};class eZ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(e,";\n      int offset_h = imod(h, ").concat(e,");\n      int in_w = w / ").concat(e,";\n      int offset_w = imod(w, ").concat(e,");\n      int offset_d = (offset_h * ").concat(e," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const nZ={kernelName:xv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,c=("NHWC"===o?a.shape[2]:a.shape[3])*s,u=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),h=new eZ("NHWC"===o?[i,l,c,u]:[i,u,l,c],s,o);return n.runWebGLProgram(h,[a],a.dtype)}};class rZ{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=AK(this.outputShape.length);const s=t.filterHeight,o=t.filterWidth,i=t.outChannels/t.inChannels;let l="",c="";n&&(l=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),c="result = activation(result);");const u=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(l,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")}}class aZ{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=AK(this.outputShape.length);const s=t.outChannels/t.inChannels,o=t.padInfo.left,i=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+="\n          vec4 xTexelC".concat(2*m,";\n          int xTexelC").concat(2*m,"Ready;\n          vec4 xTexelC").concat(2*m+1,";\n          int xTexelC").concat(2*m+1,"Ready;\n          vec4 xC").concat(m,";");d+="\n    for (int r = 0; r < ".concat(c,"; r++) {\n      ");for(let m=0;m<u;m++)d+="\n          xTexelC".concat(2*m," = vec4(0.0);\n          xTexelC").concat(2*m,"Ready = 0;\n          xTexelC").concat(2*m+1," = vec4(0.0);\n          xTexelC").concat(2*m+1,"Ready = 0;\n          xC").concat(m," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const t=2*m;if(d+="\n          xC = xCCorner + ".concat(t*l,";\n          "),1===i){if(t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n              "),d+=1===l&&t>0?"\n                xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                  } else {\n                    xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xC").concat(t," = xTexelC").concat(t,";\n                "),t+1<u)){const e=o%2===0?qb(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                    xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(t+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(t+1,"Ready = 1;\n                  }\n                  "),d+=l>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                    } else {\n                     xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                    }\n                    "):"\n                    xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                    ")):d+=1===e?"\n                    xC".concat(t+1," = xTexelC").concat(t,";\n                    "):"\n                    xCOffset = xC + ".concat(e,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                      xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(t+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(t+1,"Ready = 1;\n                    }\n\n                    xC").concat(t+1," = xTexelC").concat(t+1,";\n                    ")}}else t<u&&(o%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n              "),t+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                  xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(t,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(t,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                  xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(t+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(t+1,"Ready = 1;\n                }\n\n                xC").concat(t," = vec4(\n                  xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n              "),t+1<u&&(d+="\n                  xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                "))));t<u&&(d+="\n            wTexel = getW(r, ".concat(t,", d1, q);\n            dotProd += xC").concat(t," * vec4(wTexel.xz, wTexel.xz);\n          "),t+1<u&&(d+="\n              wTexel = getW(r, ".concat(t+1,", d1, q);\n              dotProd += xC").concat(t+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const sZ={kernelName:kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),Jb(zN(o,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(u,"'")));const h=EN(a.shape,s.shape,o,u,i,c,!0);let d;d=Ay().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new aZ(h):new rZ(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}};class oZ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,a=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(t.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(e," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class iZ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,a=t.strideWidth,s=e-1-t.padInfo.top,o=n-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(e,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(e," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const lZ={kernelName:Sv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,dy:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,filterShape:u}=r,h=EN(a.shape,u,o,i,l,c,!0),d=new oZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};const cZ={kernelName:Iv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,filter:s}=e,{strides:o,dilations:i,pad:l,dimRoundingMode:c,inputShape:u}=r,h=EN(u,s.shape,o,i,l,c,!0),d=new iZ(h);return n.runWebGLProgram(d,[a,s],"float32")}};class uZ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const hZ={kernelName:Nv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,a=[...r.shape,...r.shape],s=Qb(r.shape),o=UX({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new uZ(s),l=n.runWebGLProgram(i,[o],o.dtype),c=UX({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}};class dZ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:l,dilationWidth:c}=t,{top:u,left:h}=r;this.userCode="\n      const ivec2 strides = ivec2(".concat(a,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(o,"; h++) {\n          int hIn = hBeg + h * ").concat(l,";\n\n          if (hIn >= 0 && hIn < ").concat(e,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(c,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const pZ={kernelName:Cv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s}=e,{strides:o,pad:i,dilations:l}=r,c=IN(a.shape,s.shape,o,i,"NHWC",l);let u;const h=new dZ(c);u=n.runWebGLProgram(h,[a,s],"float32");const d=UX({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const fZ={kernelName:Fv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:a}=r,s=e,{allDims:o,summedDims:i,idDims:l}=fA(a,s.length);mA(o.length,l,s);const{path:c,steps:u}=bA(i,l),h=u.length;let d=null,p=o.length;const f=[];for(let g=0;g<h;++g){for(const t of u[g]){const{permutationIndices:e,expandDims:r}=gA(p,l[t]);let a;yA(e)?a=s[t]:(a=ZX({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let t=0;t<r.length;++t)o.splice(r[t],0,1);$b(a.shape,o)||(a=UX({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===d?d=a:(d=BX({inputs:{a:a,b:d},backend:n}),f.push(d))}g<h-1&&(c[g]>=0&&(d=JX({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},gZ=_X({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),mZ={kernelName:_v,backendName:"webgl",kernelFunc:gZ},bZ={kernelName:Dv,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:r,y:a}=e,s=Ay().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wX("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new yX("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},yZ=DX({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:eq}),vZ={kernelName:zv,backendName:"webgl",kernelFunc:yZ},wZ=_X({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(YT,";\n  float a1 = ").concat(ZT,";\n  float a2 = ").concat(QT,";\n  float a3 = ").concat($T,";\n  float a4 = ").concat(tA,";\n  float a5 = ").concat(eA,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),xZ={kernelName:Ov,backendName:"webgl",kernelFunc:wZ},kZ=_X({opSnippet:FX+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:nq,dtype:"float32"}),SZ={kernelName:Lv,backendName:"webgl",kernelFunc:kZ};function IZ(t){const{inputs:e,attrs:n,backend:r}=t,{dim:a}=n,{input:s}=e,o=s.shape.length,i=s.shape.slice();let l=a;return a<0&&(Jb(-(o+1)<=a,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),l=o+a+1),i.splice(l,0,1),UX({inputs:{x:s},backend:r,attrs:{shape:i}})}const NZ={kernelName:Mv,backendName:"webgl",kernelFunc:IZ},CZ="return exp(x) - 1.0;",EZ=_X({opSnippet:CZ,packedOpSnippet:CZ,cpuKernelImpl:rq}),TZ={kernelName:Pv,backendName:"webgl",kernelFunc:EZ};class AZ{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const a=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(r,".0"):"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error('FFT component must be either "real" or "imag", got '.concat(t,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(a,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function RZ(t,e,n){const r=n.texData.get(t.dataId),a=Qb(t.shape),s=t.shape[t.shape.length-1],o=UX({inputs:{x:t},backend:n,attrs:{shape:[a/s,s]}}),i=o.shape,l=new AZ("real",i,e),c=new AZ("imag",i,e),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(l,u,"float32"),d=n.runWebGLProgram(c,u,"float32"),p=SX({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=UX({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const FZ={kernelName:Bv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return RZ(r,!1,n)}};class _Z{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function DZ(t){const{backend:e,attrs:n}=t,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||py(a),"string"===s){const t=ly(s,Qb(r));return t.fill(a),e.makeTensorInfo(r,s,t)}{const t=new _Z(r,a),n=[[a]];return e.runWebGLProgram(t,[],s,n)}}const OZ={kernelName:Wv,backendName:"webgl",kernelFunc:DZ};class zZ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(e," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(e,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const LZ={kernelName:Uv,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n}=t;const{image:r}=e,a=n,s=new zZ(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},MZ="return floor(x);",PZ=_X({opSnippet:MZ,packedOpSnippet:MZ,cpuKernelImpl:aq}),BZ={kernelName:Vv,backendName:"webgl",kernelFunc:PZ},WZ=DX({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),UZ={kernelName:jv,backendName:"webgl",kernelFunc:WZ};class VZ{constructor(t){this.variableNames=["A"];const e=oK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(e.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class jZ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=oK(),[n,r]=t;this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(n,".0);\n            vec4 values = ").concat(e.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(e.output," = result;\n      }\n    ")}}const GZ={kernelName:Wx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:a}=e;const{numChannels:s}=r,o="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,c]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[c,l],h=[c,l,s];if(i||o){const t=Ay().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=HZ&&t===KZ||(KZ=t,HZ=document.createElement("canvas").getContext("2d",{willReadFrequently:KZ})),HZ.canvas.width=l,HZ.canvas.height=c,HZ.drawImage(a,0,0,l,c),a=HZ.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=TH.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);const p=Ay().getBool("WEBGL_PACK")?new jZ(h):new VZ(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let HZ,KZ=Ay().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const qZ={kernelName:jx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,g=MN(u),m=EN(a.shape,s.shape,l,h,c,d,!1,g);let b;const y=[],v=null!=o,w=null!=i,x="leakyrelu"===p,k=()=>{const t=[a,s],e=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=UX({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return y.push(e),e}return t};if(v&&t.push(e(o,u)),w&&t.push(e(i,u)),x){const e=n.makeTensorInfo([],"float32",gk(f,"float32"));t.push(e),y.push(e)}return t};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&Ay().getBool("WEBGL_EXP_CONV")){const t=p?OX(p,!0):null,e=new NY(m,v,t,w,x),r=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],a=k();b=n.runWebGLProgram(e,a,"float32",r)}else if(Ay().getBool("WEBGL_CONV_IM2COL"))b=AY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const t=p?OX(p,!1):null,e=new SY(m,v,t,w,x),r=k();b=n.runWebGLProgram(e,r,"float32")}else b=TY({x:a,filter:s,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=UX({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return y.push(b),y.forEach((t=>n.disposeIntermediateTensorInfo(t))),S}};const XZ={kernelName:Gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,filter:s,bias:o,preluActivationWeights:i}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let g=u;null==g&&(g=[1,1]),Jb(zN(l,g),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(l," and dilations '").concat(g,"'")));const m=EN(a.shape,s.shape,l,g,c,h,!0),b=Ay().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,y=d?OX(d,b):null,v=[a,s],w=null!=o,x=null!=i,k="leakyrelu"===d;if(w&&v.push(o),x&&v.push(i),k){const t=n.makeTensorInfo([],"float32",gk(p,"float32"));v.push(t),f.push(t)}let S;S=b?new aZ(m,w,y,x,k):new rZ(m,w,y,x,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((t=>n.disposeIntermediateTensorInfo(t))),N}};class JZ{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=kK(n.length);let s="\n    int index;";for(let o=0;o<this.sliceDim;o++)s+="\n          index = round(getIndices(coords[0], ".concat(o,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[o],";\n          flattenIndex += index * ").concat(this.strides[o],";");this.userCode="\n         void main() {\n          ".concat(a," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const YZ={kernelName:Kv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:a}=e,s=a.shape,o=s[s.length-1],i=Qb(r.shape),[l,c,u,h]=GT(r,a),d=UX({inputs:{x:a},backend:n,attrs:{shape:[c,o]}}),p=UX({inputs:{x:r},backend:n,attrs:{shape:[Qb(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const t=n.readSync(a.dataId),e=n.bufferSync(r),s=sq(t,e,r.dtype,c,o,u,h,r.shape,i);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new JZ(o,h,[c,u],r.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=UX({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class ZZ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=kK(this.rank),r=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<t.length;a++)2===a?r.push("index"):r.push("".concat(n[a]));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(t[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(r,"));\n      }\n    ")}}function QZ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,indices:s}=e,{axis:o,batchDims:i}=r,l=sy(o,a.shape)[0];if(Ay().get("DEBUG")){const t=n.readSync(s.dataId),e=a.shape[l];for(let n=0;n<t.length;++n){const r=t[n];Jb(r<=e-1&&r>=0,(()=>"GatherV2: the index value ".concat(r," is not in [0, ").concat(e-1,"]")))}}const c=zA(a,s,l,i),u=Qb(s.shape),h=[],d=UX({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=UX({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const t=n.bufferSync(p),e=n.bufferSync(d),r=oq(e,t,f);return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const g=new ZZ(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=UX({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}const $Z={kernelName:Hv,backendName:"webgl",kernelFunc:QZ},tQ=DX({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:iq,dtype:"bool"}),eQ={kernelName:qv,backendName:"webgl",kernelFunc:tQ},nQ=DX({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:lq}),rQ={kernelName:Xv,backendName:"webgl",kernelFunc:nQ};const aQ={kernelName:Yv,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return RZ(r,!0,n)}},sQ=_X({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),oQ={kernelName:Qv,backendName:"webgl",kernelFunc:sQ},iQ=_X({opSnippet:"return float(isinf(x));",dtype:"bool"}),lQ={kernelName:$v,backendName:"webgl",kernelFunc:iQ},cQ=_X({opSnippet:"return float(isnan(x));",dtype:"bool"}),uQ={kernelName:tw,backendName:"webgl",kernelFunc:cQ},hQ=DX({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:cq,dtype:"bool"}),dQ={kernelName:nw,backendName:"webgl",kernelFunc:hQ},pQ=DX({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:uq,dtype:"bool"}),fQ={kernelName:rw,backendName:"webgl",kernelFunc:pQ};const gQ={kernelName:aw,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:a,num:s}=n,o=hq(r,a,s);return e.makeTensorInfo([o.length],"float32",o)}},mQ=_X({opSnippet:FX+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:dq}),bQ={kernelName:sw,backendName:"webgl",kernelFunc:mQ},yQ=_X({opSnippet:FX+"\n  return log(1.0 + x);\n"}),vQ={kernelName:ow,backendName:"webgl",kernelFunc:yQ},wQ=DX({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),xQ={kernelName:iw,backendName:"webgl",kernelFunc:wQ},kQ=_X({opSnippet:"return float(!(x >= 1.0));"}),SQ={kernelName:lw,backendName:"webgl",kernelFunc:kQ},IQ=DX({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),NQ={kernelName:cw,backendName:"webgl",kernelFunc:IQ};class CQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(o,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class EQ{constructor(t,e,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let i;this.outputShape=t;const l="float(".concat(n,") + float(").concat(r,") * sum");i=.5===a?"inversesqrt(".concat(l,")"):1===a?"1.0/(".concat(l,")"):"exp(log(".concat(l,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(o,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const TQ={kernelName:uw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{depthRadius:s,bias:o,alpha:i,beta:l}=r,c=Ay().getBool("WEBGL_PACK_NORMALIZATION")?new EQ(a.shape,s,o,i,l):new CQ(a.shape,s,o,i,l);return n.runWebGLProgram(c,[a],a.dtype)}};class AQ{constructor(t,e,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(e,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(e," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(a,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(a,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const RQ={kernelName:hw,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a,y:s,dy:o}=e,{depthRadius:i,bias:l,alpha:c,beta:u}=r,h=new AQ(a.shape,i,l,c,u);return n.runWebGLProgram(h,[a,s,o],a.dtype)}};function FQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=AC(c,i),h=null!=u,d=n.shouldExecuteOnCPU([a]);let p=a;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(i);for(let n=0;n<e.length;n++)e[n]=a.shape[u[n]];const r=Uq(t,a.shape,a.dtype,u,e);p=n.makeTensorInfo(e,a.dtype);n.texData.get(p.dataId).values=r}else p=XX(a,u,n);c=FC(c.length,i)}TC("max",c,i);const[f,g]=CC(p.shape,c);let m,b=f;if(o&&(b=EC(f,l)),d){const t=n.texData.get(p.dataId).values,e=pq(t,Qb(g),b,a.dtype);m=n.makeTensorInfo(b,a.dtype);n.texData.get(m.dataId).values=e}else m=function(t,e,n,r){const a=Qb(e),s=UX({inputs:{x:t},attrs:{shape:[Qb(t.shape)/a,a]},backend:r}),o=HX(s,t.dtype,"max",r),i=UX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const _Q={kernelName:dw,backendName:"webgl",kernelFunc:FQ},DQ=DX({opSnippet:bX+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vX+"\n  return result;\n",cpuKernelImpl:fq}),OQ={kernelName:pw,backendName:"webgl",kernelFunc:DQ};const zQ={kernelName:fw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;aK(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;Jb(zN(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const c=NN(a.shape,s,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&$b(c.inShape,c.outShape))return xX({inputs:{x:a},backend:n});const u=new DJ(c,"max",!1);return n.runWebGLProgram(u,[a],a.dtype)}};const LQ={kernelName:mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{filterSize:s,strides:o,pad:i,dataFormat:l,dimRoundingMode:c}=r,u=CN(a.shape,s,o,[1,1,1],i,c,l),h=new OJ(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}};class MQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,a=t.effectiveFilterHeight,s=t.effectiveFilterWidth,o=a-1-t.padInfo.top,i=s-1-t.padInfo.left,l=a*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(a,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(e,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(l," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,a=t.dilationDepth,s=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=i-1-t.padInfo.front,h=l-1-t.padInfo.top,d=c-1-t.padInfo.left,p=i*l*c-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(a,") {\n          float dyD = float(dyDCorner + wD) / ").concat(e,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(c,";\n                wC += ").concat(o,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(l," * ").concat(c," +\n                  wR * ").concat(c," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const BQ={kernelName:bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s}=e,o=s,{filterSize:i,strides:l,pad:c,dimRoundingMode:u}=r,h=CN(o.shape,i,l,[1,1,1],c,u),d=new OJ(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new PQ(h),g=n.runWebGLProgram(f,[a,p],o.dtype);return n.disposeIntermediateTensorInfo(p),g}};const WQ={kernelName:gw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:a,input:s,output:o}=e,i=s;aK([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=NN(i.shape,l,c,1,u,h),p=new DJ(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),g=new MQ(d),m=n.runWebGLProgram(g,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),m}};const UQ={kernelName:yw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:l}=n,c=r;Jb(4===a.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length,".")));const u=[1,1];Jb(zN(o,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(u,"'")));const h=NN(a.shape,s,o,u,i),[d,p]=function(t,e,n,r){let a=new DJ(n,"max",!1);const s=r.runWebGLProgram(a,[t],"float32");return a=new DJ(n,"max",!0,!0,e),[s,r.runWebGLProgram(a,[t],"float32")]}(a,l,h,c);return[d,p]}};const VQ={kernelName:vw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,{keepDims:s,axis:o}=n,i=r,l=a.shape.length,c=sy(o,a.shape);let u=c;const h=AC(u,l),d=null!=h,p=i.shouldExecuteOnCPU([a]),f=[];let g=a;if(d){if(p){const t=i.texData.get(g.dataId).values,e=new Array(l);for(let r=0;r<e.length;r++)e[r]=a.shape[h[r]];const n=Uq(t,a.shape,a.dtype,h,e);g=i.makeTensorInfo(e,a.dtype);i.texData.get(g.dataId).values=n}else g=XX(a,h,i);f.push(g),u=FC(u.length,l)}TC("sum",u,l);const[m,b]=CC(g.shape,u);let y=m;s&&(y=EC(m,c));const v=function(t,e,n,r){const a=Qb(e),s=UX({inputs:{x:t},attrs:{shape:[Qb(t.shape)/a,a]},backend:r}),o=HX(s,"float32","mean",r),i=UX({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(g,b,y,i);for(const w of f)i.disposeIntermediateTensorInfo(w);return v}};const jQ={kernelName:ww,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=sy(s,a.shape);let c=l;const u=AC(c,i);let h=a;null!=u&&(h=ZX({inputs:{x:a},backend:n,attrs:{perm:u}}),c=FC(c.length,a.shape.length)),TC("min",c,i);const[d,p]=CC(h.shape,c),f=UX({inputs:{x:h},backend:n,attrs:{shape:[-1,Qb(p)]}}),g=HX(f,f.dtype,"min",n);let m;if(o){m=UX({inputs:{x:g},backend:n,attrs:{shape:EC(d,l)}})}else m=UX({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),m}},GQ=DX({opSnippet:bX+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vX+"\n  return result;\n",cpuKernelImpl:gq}),HQ={kernelName:xw,backendName:"webgl",kernelFunc:GQ};class KQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=kK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l,";\n          }\n        }\n        ").concat(a," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class qQ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=kK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Gq("rc",r),l=Gq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===r){const t="\n        ".concat(a," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ")}else{const t="\n        ".concat(a," source = rc;\n        ").concat(a," lt = ").concat(a,"(lessThan(source, start));\n        ").concat(a," gte = ").concat(a,"(greaterThanEqual(source, end));\n        ").concat(a," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(t,"\n        result[0] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        ").concat(i[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(t,"\n          result[1] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[r-2]," += 1;\n        if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(t,"\n          result[2] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          ").concat(i[r-1]," += 1;\n          if(").concat(c,") {\n            ").concat(t,"\n            result[3] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const XQ={kernelName:kw,backendName:"webgl",kernelFunc:t=>{let{inputs:e,backend:n,attrs:r}=t;const{x:a}=e,{paddings:s,mode:o}=r,i=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qQ(a.shape,s,o):new KQ(a.shape,s,o);return n.runWebGLProgram(i,[a],a.dtype)}},JQ=DX({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+vX+"\n  return result;\n"}),YQ={kernelName:Sw,backendName:"webgl",kernelFunc:JQ};class ZQ{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(e-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(e-1,"));\n      }\n    ")}}const QQ=DX({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),$Q={kernelName:Rv,backendName:"webgl",kernelFunc:QQ},t$="return a - b;",e$=DX({opSnippet:t$,packedOpSnippet:t$,supportsComplex:!0,cpuKernelImpl:Pq}),n$={kernelName:Tx,backendName:"webgl",kernelFunc:e$};function r$(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{dim:s}=r,o=sy([s],a.shape),i=FQ({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=EC(i.shape,o),c=UX({inputs:{x:i},backend:n,attrs:{shape:l}}),u=e$({inputs:{a:a,b:c},backend:n}),h=kZ({inputs:{x:u},backend:n}),d=JX({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=UX({inputs:{x:d},backend:n,attrs:{shape:l}}),f=QQ({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const a$={kernelName:gx,backendName:"webgl",kernelFunc:r$};const s$={kernelName:Iw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:a}=e,{numSamples:s,seed:o,normalized:i}=r,l=i?a:r$({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new ZQ(c,u,s),d=[[o]],p=n.runWebGLProgram(h,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),p}},o$=Qq+"\n  return -x;\n";const i$={kernelName:Cw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const t=n.texData.get(r.dataId),[e,a]=bq(t.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,e)}let a;return a=Ay().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new hX(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Zq(r.shape,o$),n.runWebGLProgram(a,[r],r.dtype)}},l$=YE;const c$={kernelName:Tw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=l$(c,u,o,i,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},u$=ZE;const h$={kernelName:Aw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=u$(u,h,o,i,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},d$=QE;const p$={kernelName:Rw,backendName:"webgl",kernelFunc:function(t){Hx("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:a,scores:s}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),d=o,p=i,f=l,g=c,{selectedIndices:m,selectedScores:b}=d$(u,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class f${constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const g$={kernelName:_w,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:a}=e,{dtype:s,depth:o,onValue:i,offValue:l}=r,c=Qb(a.shape),u=new f$(c,o,i,l),h=UX({inputs:{x:a},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const p=UX({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function m$(t){const{inputs:e,backend:n}=t,{x:r}=e;if("complex64"===r.dtype){const t=nY({inputs:{input:r},backend:n}),e=m$({inputs:{x:t},backend:n}),a=yY({inputs:{input:r},backend:n}),s=m$({inputs:{x:a},backend:n}),o=SX({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return DZ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const b$={kernelName:Px,backendName:"webgl",kernelFunc:m$};const y$={kernelName:Fw,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const e=nY({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r}),s=yY({inputs:{input:a},backend:r}),o=m$({inputs:{x:s},backend:r}),i=SX({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return DZ({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const v$={kernelName:Dw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:a}=r;if(1===e.length)return IZ({inputs:{input:e[0]},backend:n,attrs:{dim:a}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{Yb(s,t.shape,"All tensors passed to stack must have matching shapes"),Jb(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=xY({inputs:e.map((t=>{const e=IZ({inputs:{input:t},backend:n,attrs:{dim:a}});return i.push(e),e})),backend:n,attrs:{axis:a}});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}};class w${constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=kK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(s,");\n      ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(a," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class x${constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,a=kK(r),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),i=Gq("rc",r),l=Gq("source",r),c="".concat(i[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(l.slice(-2).join(),")"),h=["".concat(a," rc = outputLoc;"),"".concat(i[r-1]," += 1;\n       if(").concat(c,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(i[r-2]," += 1;\n       if(").concat(i[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(i[r-1]," += 1;\n         if(").concat(c,") {")],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===r?2:4;f<g;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(a," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(l.join(),"), ").concat(u,");\n        }\n      ");p+=1===r?"} ":"}}",this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(s,");\n      const ").concat(a," end = ").concat(a,"(").concat(o,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const k$=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{paddings:s,constantValue:o}=r;if(0===Qb(a.shape)){const t=s.map(((t,e)=>t[0]+a.shape[e]+t[1]));return DZ({backend:n,attrs:{shape:t,value:o,dtype:a.dtype}})}const i=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x$(a.shape,s,o):new w$(a.shape,s,o),l=[[o]];return n.runWebGLProgram(i,[a],a.dtype,l)},S$={kernelName:Ow,backendName:"webgl",kernelFunc:k$},I$=DX({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+vX+"\n  return result;\n"}),N$={kernelName:zw,backendName:"webgl",kernelFunc:I$};const C$={kernelName:Mw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{axis:s,keepDims:o}=r,i=a.shape.length,l=[],c=sy(s,a.shape);let u=c;const h=AC(u,i);let d,p=a;if(null!=h&&(p=ZX({inputs:{x:a},backend:n,attrs:{perm:h}}),u=FC(u.length,i),l.push(p)),TC("prod",u,i),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:r,outDtype:a}=vq(p.shape,p.dtype,t,u);d=n.makeTensorInfo(r,a,e)}else{const[t,e]=CC(p.shape,u),r=Qb(e),s=UX({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),o=HX(s,qk(a.dtype),"prod",n);d=UX({inputs:{x:o},backend:n,attrs:{shape:t}}),l.push(s),l.push(o)}if(o){l.push(d);const t=EC(d.shape,c);d=UX({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),d}};const E$={kernelName:Pw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:i}=r,l=a.map((t=>n.readSync(t.dataId))),c=a.map((t=>t.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=wq(l,c,u,s.shape,s.dtype,h,o.shape,i),g=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(f,s.dtype,p);return g.concat([m])}};const T$={kernelName:Bw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:a,deltas:s}=e,o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=xq(o,r.shape,r.dtype,i,a.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],r.dtype,u)]}};const A$={kernelName:Ww,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i.map((t=>n.readSync(t.dataId))),p=i.map((t=>t.shape)),[f,g]=kq(c,a.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,g)}},R$=t=>{const{backend:e,attrs:n}=t,{start:r,stop:a,step:s,dtype:o}=n,i=Sq(r,a,s,o);return e.makeTensorInfo([i.length],o,i)},F$={kernelName:Uw,backendName:"webgl",kernelFunc:R$},_$=_X({opSnippet:"return 1.0 / x;"}),D$={kernelName:jw,backendName:"webgl",kernelFunc:_$},O$=_X({opSnippet:Qq+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),z$={kernelName:Gw,backendName:"webgl",kernelFunc:O$},L$=_X({opSnippet:Qq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),M$={kernelName:Yw,backendName:"webgl",kernelFunc:L$};class P${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class B${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const W$={kernelName:Xw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ay().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new B$(a.shape,l,c,s,o):new P$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],"float32")}};class U${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(a-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const V$={kernelName:Jw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new U$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class j${constructor(t,e,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class G${constructor(t,e,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=t;this.outputShape=[s,e,n,l];const c=[r&&e>1?o-1:o,r&&n>1?i-1:i],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/u[0],",\n          ").concat(c[1]/u[1],",\n          ").concat(c[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const H$={kernelName:Kw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a}=e,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,c]=i,u=Ay().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new G$(a.shape,l,c,s,o):new j$(a.shape,l,c,s,o);return n.runWebGLProgram(u,[a],a.dtype)}};class K${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,s,o]=t,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=i[0]/l[0],u=i[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(l[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(l[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const q$={kernelName:qw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:a,dy:s}=e,{alignCorners:o}=r,i=new K$(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class X${constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=t,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(t[0]," - coord - 1));\n        }\n      "));const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(r))).join(","),a=kK(n);this.userCode="\n      void main() {\n        ".concat(a," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}}class J${constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=t;const r=Gq("rc",n),a="".concat(r[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(r[n-2]," + 1 < ").concat(this.outputShape[n-2]),o=kK(n);function i(n){const r=t.map(((r,a)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?"".concat(t[n]," - ").concat(r[n]," - 1"):"".concat(r[n])}(a,n))),a=r.join(","),s=r.slice(-2).join(",");return"getChannel(getX(".concat(a,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(t[0]," - rc - 1),\n            ").concat(t[0]," - rc - 1);\n          if(").concat(a,"){\n              result.g = getChannel(getX(").concat(t[0]," - (rc  + 1) - 1),\n                ").concat(t[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(o," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(t){return i(t)}(r.slice()),";\n          if(").concat(a,"){\n            result.g = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",i(t)}(r.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(t){return t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            if(").concat(a,") {\n              result.a = ").concat(function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const Y$={kernelName:Zw,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{dims:s}=r,o=a.shape.length,i=sy(s,a.shape);if(0===o)return xX({inputs:{x:a},backend:n});const l=Ay().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new J$(a.shape,i):new X$(a.shape,i);return n.runWebGLProgram(l,[a],a.dtype)}};class Z${constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let a="";a="number"===typeof e?"float outputValue = ".concat(e.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(e.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(a,"\n          if(coordX >= 0 && coordX < ").concat(r," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const Q$={kernelName:Ux,backendName:"webgl",kernelFunc:t=>{let{inputs:e,attrs:n,backend:r}=t;const{image:a}=e,{radians:s,fillValue:o,center:i}=n,l=r,c=new Z$(a.shape,o),[u,h]=PT(i,a.shape[1],a.shape[2]),d=[[u,h,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(c,[a],a.dtype,d)}},$$=_X({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),t0={kernelName:Qw,backendName:"webgl",kernelFunc:$$},e0=_X({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Iq}),n0={kernelName:$w,backendName:"webgl",kernelFunc:e0};class r0{constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=kK(a.length),l=kK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(t,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(e,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(g,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class a0{constructor(t,e,n,r,a,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const i=kK(a.length),l=kK(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=e>1?"strides[j]":"strides",m=e>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(a,");\n\n        void main() {\n          ").concat(l," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(t,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(e,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(g,";\n              if (j + 1 < ").concat(e,") {\n                flattenedIndex += index.yw * ").concat(m,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const s0={kernelName:tx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:a,updates:s}=e,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qT(0,a,o),d=[h/c,c];if(0===h)return n.makeTensorInfo(o,a.dtype);const p=UX({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),f=UX({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=Ay().getBool("WEBGL_PACK")?new a0(l,i,p.shape.length,f.shape.length,u,d):new r0(l,i,p.shape.length,f.shape.length,u,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),y=UX({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class o0{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const a="for (int i = 0; i < ".concat(Math.ceil(Math.log2(e+1)),"; ++i) { if (left >= right) break;"),s=2===Ay().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const i0={kernelName:nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:a,values:s}=e,{side:o}=r,i=new o0(a.shape[0],a.shape[1],s.shape[1],o),l=[[a.shape[1]]];return n.runWebGLProgram(i,[a,s],"int32",l)}};class l0{constructor(t,e,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<e.length;r++)o.push("".concat(n[r])),r<t&&s.push("".concat(n[r]));r=s.join(),a=o.join()}const s=kK(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(a,"));\n        } else {\n          setOutput(getB(").concat(a,"));\n        }\n      }\n    ")}}const c0={kernelName:rx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:a,e:s}=e,o=new l0(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],Kk(a.dtype,s.dtype))}},u0=_X({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(XT,";\n  float scale = ").concat(JT,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),h0={kernelName:ax,backendName:"webgl",kernelFunc:u0},d0=_X({opSnippet:FX+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Cq}),p0={kernelName:cx,backendName:"webgl",kernelFunc:d0},f0=_X({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),g0={kernelName:lx,backendName:"webgl",kernelFunc:f0},m0=_X({opSnippet:FX+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(vX,"\n  return result;\n")}),b0={kernelName:ox,backendName:"webgl",kernelFunc:m0},y0=_X({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),v0={kernelName:ix,backendName:"webgl",kernelFunc:y0},w0=_X({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),x0={kernelName:ux,backendName:"webgl",kernelFunc:w0},k0={kernelName:px,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{blockShape:s,paddings:o}=r;Jb(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...o);for(let b=1+s.length;b<a.shape.length;++b)l.push([0,0]);const c=[],u=k$({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=BT(u.shape,s,i,!1),d=WT(h.length,s.length,!1),p=UT(u.shape,s,i,!1),f=UX({inputs:{x:u},backend:n,attrs:{shape:h}}),g=ZX({inputs:{x:f},backend:n,attrs:{perm:d}}),m=UX({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(g),c.forEach((t=>n.disposeIntermediateTensorInfo(t))),m}};const S0={kernelName:mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:a,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,g]=Aq(i,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const I0={kernelName:bx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:a,newShape:s}=e;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(a.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=Rq(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};const N0={kernelName:yx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Fq(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(u,r.dtype,c)}};const C0={kernelName:vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:a,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Fq(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(u,r.dtype,c)}};const E0={kernelName:wx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:a,sparseValues:s,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=qT(0,a,i);if("string"===s.dtype){const t=n.bufferSync(a),e=n.bufferSync(s),r=vk(n.readSync(o.dataId)[0]),p=Nq(t,e,i,d,u,c,l,h,r,false);return n.makeTensorInfo(i,p.dtype,p.values)}const p=new r0(c,l,a.shape.length,s.shape.length,h,[d,1],false),f=n.runWebGLProgram(p,[s,a,o],s.dtype),g=UX({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),g}};const T0={kernelName:fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{numOrSizeSplits:s,axis:o}=r,i=sy(o,a.shape)[0],l=wA(a,s,i),c=a.shape.length,u=new Array(c).fill(0),h=a.shape.slice();return l.map((t=>{const e=[...h];e[i]=t;const r=XJ({inputs:{x:a},backend:n,attrs:{begin:u,size:e}});return u[i]+=t,r}))}},A0="return sqrt(x);",R0=_X({opSnippet:A0,packedOpSnippet:A0,cpuKernelImpl:_q}),F0={kernelName:hx,backendName:"webgl",kernelFunc:R0},_0={kernelName:kx,backendName:"webgl",kernelFunc:_X({opSnippet:"return x * x;"})},D0="return (a - b) * (a - b);",O0=DX({opSnippet:D0,packedOpSnippet:D0}),z0={kernelName:xx,backendName:"webgl",kernelFunc:O0};const L0={kernelName:Sx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=LA(n.readSync(a.dataId)),o=Dq(s,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};const M0={kernelName:Bx,backendName:"webgl",kernelFunc:function(t){let{inputs:e,attrs:n,backend:r}=t;const{x:a}=e,s=Qq+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),o=new Zq(a.shape,s);return r.runWebGLProgram(o,[a],a.dtype)}};class P0{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=kK(n.length),s=kK(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map(((e,r)=>(t++,1===n.length?"coords * strides[".concat(r,"] + begin[").concat(r,"]"):"coords[".concat(t-1,"] * strides[").concat(r,"] + begin[").concat(r,"]")))).join(",")}this.userCode="\n      ".concat(a," begin = ").concat(a,"(").concat(t,");\n      ").concat(a," strides = ").concat(a,"(").concat(e,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(o,"));\n      }\n    ")}}const B0={kernelName:Ix,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{begin:s,end:o,strides:i,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:v,strides:w}=vN(a.shape,s,o,i,l,c,u,h,d);let x;if(g)x=UX({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||b){Jb(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const t=oN(y,v,w),e=XJ({inputs:{x:a},backend:n,attrs:{begin:y,size:t}});x=UX({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{if(n.shouldExecuteOnCPU([a])){const t=n.readSync(a.dataId),e=fI(a.shape,a.dtype,t),r=Oq(p,e,w,y);x=n.makeTensorInfo(f,a.dtype,r.values)}else{const t=new P0(y,w,p);x=n.runWebGLProgram(t,[a],a.dtype)}}const k=UX({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),k}};const W0={kernelName:Nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,g]=zq(d,p,a,s,o,i,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};const U0={kernelName:Cx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:a}=r,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,h]=Lq(i,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const V0={kernelName:Ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:a}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=Mq(o,a);return n.makeTensorInfo(s.shape,"int32",i)}},j0=_X({opSnippet:"return tan(x);"}),G0={kernelName:Ax,backendName:"webgl",kernelFunc:j0},H0=_X({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),K0={kernelName:Rx,backendName:"webgl",kernelFunc:H0};const q0={kernelName:ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:a,indices:s,updates:o}=e,{}=r,{sliceRank:i,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=qT(0,s,a.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,s.dtype);const p=UX({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),f=UX({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),g=UX({inputs:{x:a},backend:n,attrs:{shape:d}}),m=new r0(l,i,p.shape.length,f.shape.length,u,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),y=UX({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class X0{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;const r=kK(this.rank),a=function(t){const e=t.length;if(e>5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"imod(resRC, ".concat(t[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<t.length;a++)r.push("imod(".concat(n[a],", ").concat(t[a],")"));return r.join()}(t);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(a,"));\n      }\n    ")}}function J0(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const t=n.readSync(a.dataId),e="string"===a.dtype?t.map((t=>vk(t))):t,r=fI(a.shape,a.dtype,e),o=Bq(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new X0(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}const Y0={kernelName:Fx,backendName:"webgl",kernelFunc:J0};class Z0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Q0{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function $0(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function t1(t){let e=1;for(;e<t;)e*=2;return e}const e1={kernelName:_x,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a}=e,{k:s,sorted:o}=r,i=Ay().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ay().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([a])||u<i||s>l){const t=n.readSync(a.dataId),[e,r]=Wq(t,c,a.dtype,s,o);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[a,DZ({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(a.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(a):a,f=Qb(c)/u,g=UX({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&$0(n,p);const m=t1(s),b=t1(u);let y=null;const v=()=>null===y?[g,g]:[g,y],w=(t,e,r)=>{const a=v(),s=new Z0(r),o=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],i=y;y=n.runWebGLProgram(s,a,"int32",o),$0(n,i)};for(let N=1;N<m;N*=2){const t=2*N;for(let e=N;e>=1;e/=2)w(t,e,[f,b])}for(let N=b;N>m;N/=2){const t=v(),e=new Q0([f,N/2]),r=[[u],[null===y?1:0],[m]],a=y;y=n.runWebGLProgram(e,t,"int32",r),$0(n,a);const s=m/2,o=2*s;for(let n=s;n>=1;n/=2)w(o,n,y.shape)}let x=y;y=XJ({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),$0(n,x);let k=QZ({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});$0(n,g);const S=c.slice(0,-1);S.push(s),x=y,y=UX({inputs:{x:y},attrs:{shape:S},backend:n}),$0(n,x);const I=k;return k=UX({inputs:{x:k},attrs:{shape:S},backend:n}),$0(n,I),[k,y]}};class n1{constructor(t,e,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(t," && 0 <= coordX && coordX < ").concat(e,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(a,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(a,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(e,"));\n                float mapY = mapCoord(inY, float(").concat(t,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const r1={kernelName:Dx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:a,transforms:s}=e,{interpolation:o,fillMode:i,fillValue:l,outputShape:c}=r,[u,h,d,p]=a.shape,[f,g]=null!=c?c:[h,d],m=new n1(h,d,o,i,l,[u,f,g,p]);return n.runWebGLProgram(m,[a,s],"float32")}};const a1={kernelName:zx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:a}=n,{x:s}=e;aK(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:l,indices:c}=Vq(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}};const s1={kernelName:Lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:a}=e;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,l=a.shape[s],c=new Array(i-1);let u=0;for(let g=0;g<i;g++)g!==s&&(c[u++]=o.shape[g]);const h=[],d=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[s]=g;const t=XJ({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),e=UX({inputs:{x:t},backend:n,attrs:{shape:c}});f[g]=e,h.push(t)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};class o1{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,a=t.inSize,s=t.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";a%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      "));let h="";a%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(c,"\n        } else if (").concat(2===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(c,"\n        } else if (").concat(3===l,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(c,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const i1={kernelName:Mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:a,segmentIds:s}=e,{numSegments:o}=r,i=a.shape.length,l=[];let c=0;const u=AC([c],i);let h=a;null!=u&&(h=ZX({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(h),c=FC(1,i)[0]);const d=OA(h.shape,c,o),p=Qb([h.shape[c]]),f=UX({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=qk(a.dtype),m=(t,e,r,a,s)=>{const o=t.shape[0],i=t.shape[1],c=DA(i,s),u=new o1({windowSize:c,inSize:i,batchSize:o,numSegments:s},e),h=n.compileAndRun(u,[t,r],a);if(l.push(h),h.shape[1]===s)return h;const d=R$({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=J0({inputs:{x:d},backend:n,attrs:{reps:[i/c]}});l.push(d),l.push(p);return m(h,e,p,a,s)},b=UX({inputs:{x:m(f,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:d}});let y=b;if(null!=u){l.push(b);const t=RC(u);y=ZX({inputs:{x:y},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}},l1=[eJ,rJ,sJ,iJ,uJ,pJ,fJ,gJ,xJ,kJ,IJ,CJ,TJ,RJ,_J,zJ,LJ,BJ,WJ,UJ,GJ,YJ,ZJ,QJ,$J,sY,lY,hY,IX,fY,kY,RY,zY,MY,PY,BY,WY,VY,GY,KY,QY,$Y,tZ,nZ,sZ,lZ,cZ,hZ,pZ,fZ,mZ,bZ,vZ,xZ,SZ,NZ,TZ,FZ,OZ,LZ,BZ,UZ,GZ,qZ,XZ,YZ,$Z,eQ,rQ,kX,aQ,vY,oQ,lQ,uQ,EX,dQ,fQ,gQ,bQ,vQ,xQ,SQ,NQ,TQ,RQ,_Q,OQ,zQ,LQ,BQ,WQ,UQ,VQ,jQ,HQ,XQ,YQ,s$,WX,i$,c$,h$,p$,eY,g$,y$,v$,S$,N$,RX,C$,E$,T$,A$,F$,rY,$Q,D$,z$,M$,VX,W$,V$,H$,q$,Y$,Q$,t0,n0,s0,i0,c0,h0,p0,g0,b0,v0,JJ,a$,x0,k0,S0,I0,N0,C0,E0,T0,F0,_0,z0,L0,M0,B0,W0,U0,V0,n$,YX,G0,K0,q0,Y0,e1,r1,QX,a1,s1,i1,b$];for(const n of l1)Qx(n);const c1=function(){const[t,e]=(0,o.useState)(null),[n,r]=(0,o.useState)(null),[a,s]=(0,o.useState)(null),i=window.innerWidth;new Xz(l);var l,c=360;i>=360&&(c=720),i>720&&(c=1280);var u=.55*c,h=c/2,d=(u+240)/2;const p=Math.floor(201*Math.random())-100,f=Math.floor(201*Math.random())-100,[g,m]=(0,o.useState)(!1),[b,y]=(0,o.useState)(h),[v,w]=(0,o.useState)(d);function x(t){return t.map(((t,e)=>[t,e])).reduce(((t,e)=>e[0]>t[0]?e:t))[1]}(0,o.useEffect)((()=>{k();const t=setInterval((()=>{g&&(b>=0&&b<=c&&v>=240&&v<=u?(y(b+p),w(v+f)):(y(h),w(d)))}),1e3);return()=>clearInterval(t)}),[b,v,g]);const k=async()=>{const t=function(t,e,n,r){if(ae(null==n&&null==r||null!=n&&null!=r,(function(){return"customModelURL and customMetadataURL must be both provided or both not provided."})),null!=n&&ae(null==e,(function(){return"vocabulary name must be null or undefined when modelURL is provided."})),"BROWSER_FFT"===t)return new Bb(e,n,r);throw"SOFT_FFT"===t?new Error("SOFT_FFT SpeechCommandRecognizer has not been implemented yet."):new Error("Invalid fftType: '"+t+"'")}("BROWSER_FFT",void 0);console.log("Model Loaded"),await t.ensureModelLoaded(),console.log(t.wordLabels()),s(t.wordLabels()),e(t)},S=async()=>{console.log("listening. . . .. "),t.listen((t=>{console.log(a[x(Object.values(t.scores))]),"go"==a[x(Object.values(t.scores))]?(m(!0),console.log("----------------GO---------------------------"),console.log(n)):"stop"==a[x(Object.values(t.scores))]&&(m(!1),console.log("----------------STOP---------------------------"),console.log(n))}),{includeSpectrogram:!0,probabilityThreshold:.75})};return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsx)("div",{className:"img-container",children:(0,Ht.jsx)("img",{src:"/supercircle/images/white-bear-img.png",alt:"white-bear",className:"img-component",style:{position:"absolute",left:"".concat(b,"px"),top:"".concat(v,"px")}})}),(0,Ht.jsxs)("div",{className:"btn-container",children:[(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STARTED. . ."),S()},children:"Start Listening"})}),(0,Ht.jsx)(Tt,{children:(0,Ht.jsx)("div",{className:"moving-btn",onClick:()=>{console.log("STOPPED"),t.stopListening()},children:"Stop Listening"})})]})]})};const u1=function(){return(0,Ht.jsxs)(Ht.Fragment,{children:[(0,Ht.jsxs)("div",{style:{"text-align":"center"},children:[(0,Ht.jsx)("h1",{children:"Press the start button to start"}),(0,Ht.jsx)("h2",{children:'Control the bear by saying "GO" and "STOP"'})]}),(0,Ht.jsx)(c1,{})]})},h1=()=>{const[t,e]=(0,o.useState)(null),[n,r]=(0,o.useState)(null),[a,s]=(0,o.useState)(""),[i,l]=(0,o.useState)("");return(0,o.useEffect)((()=>{(async()=>{const t=await qz("https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json"),n=await fetch("https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json").then((t=>t.json()));e(t),r(n),console.log("Model Loaded")})()}),[]),(0,Ht.jsxs)("div",{className:"app-header",children:[(0,Ht.jsx)("h1",{children:"Sentiment Analysis"}),null==t?(0,Ht.jsx)("div",{children:"Model Loading . .. ."}):(0,Ht.jsxs)("div",{className:"body-container",children:[(0,Ht.jsx)("div",{className:"result",children:(0,Ht.jsx)("div",{className:"icon",children:"positive"==i?"\ud83d\ude42":"negative"==i?"\ud83d\ude1e":"\ud83d\ude10"})}),(0,Ht.jsxs)("div",{className:"input",children:[(0,Ht.jsx)("input",{type:"text",value:a,onChange:t=>s(t.target.value),placeholder:"Enter text here"}),(0,Ht.jsx)("button",{onClick:async()=>{if(null!==t){console.log("analysing sentiment. . .");const e=a.trim().toLowerCase().replace(/(\.|\,|\!)/g,"").split(" "),r=fI([1,n.max_len],"float32");e.forEach(((t,e)=>r.set(n.word_index[t]+n.index_from,0,e)));const s=r.toTensor(),o=await t.predict(s),c=o.dataSync()[0];o.dispose(),l(c>.5?"positive":"negative"),console.log(i)}},children:"submit"})]})]})]})};const d1=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(h1,{})})};function p1(t){return Wt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M64.264 44.704c-88.765 25.213-39.73 158.676-2.108 161.887-8.506 42.218-13.32 84.645-12.642 127.824.355 22.67 51.374 58.424 105.35 86.035C186.48 466.787 238.98 466.876 256 467.296c17.02-.42 69.52-.51 101.137-46.846 53.975-27.61 104.994-63.364 105.35-86.035.677-43.179-4.137-85.606-12.643-127.824 37.623-3.211 86.657-136.674-2.108-161.887-28.433 1.462-55.606 16.152-82.172 37.223C317.64 62.233 293.164 61.296 256 61.296c-37.163 0-61.639.937-109.564 20.63-26.566-21.07-53.739-35.76-82.172-37.222zm4.927 49.928c6.057-.096 17.237 5.625 26.809 14.664 3.362 3.175-22.916 51.05-26.818 50.158-4.59-1.05-14.985-48.285-3.725-63.318.745-.994 2.039-1.477 3.734-1.504zm373.618 0c1.695.027 2.99.51 3.734 1.504 11.26 15.033.865 62.268-3.725 63.318-3.902.893-30.18-46.983-26.818-50.158 9.572-9.04 20.752-14.76 26.809-14.664zm-260.85 82.088c17.457-.304 30.686 24.445 42.041 44.576-53.57 15.878-82.575-17.11-57.752-37.777 5.603-4.665 10.823-6.714 15.711-6.8zm148.082 0c4.888.085 10.108 2.134 15.711 6.799 24.823 20.667-4.181 53.655-57.752 37.777 11.355-20.13 24.584-44.88 42.041-44.576zM256 251.548c17.32.223 36.826 9.567 30.197 36.517-1.444 5.872-12.516 8.617-21.197 9.7v8.972c99.884 41.126 79.565 138.559-9 138.559s-108.884-97.433-9-138.559v-8.972c-8.68-1.083-19.753-3.828-21.197-9.7-6.629-26.95 12.877-36.294 30.197-36.517z"},child:[]}]})(t)}function f1(t){return Wt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M10.5199 19.8634C10.5955 18.6615 10.8833 17.5172 11.3463 16.4676C9.81124 16.3252 8.41864 15.6867 7.33309 14.7151L8.66691 13.2248C9.55217 14.0172 10.7188 14.4978 12 14.4978C12.1763 14.4978 12.3501 14.4887 12.5211 14.471C14.227 12.2169 16.8661 10.7083 19.8634 10.5199C19.1692 6.80877 15.9126 4 12 4C7.58172 4 4 7.58172 4 12C4 15.9126 6.80877 19.1692 10.5199 19.8634ZM19.0233 12.636C15.7891 13.2396 13.2396 15.7891 12.636 19.0233L19.0233 12.636ZM22 12C22 12.1677 21.9959 12.3344 21.9877 12.5L12.5 21.9877C12.3344 21.9959 12.1677 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM10 10C10 10.8284 9.32843 11.5 8.5 11.5C7.67157 11.5 7 10.8284 7 10C7 9.17157 7.67157 8.5 8.5 8.5C9.32843 8.5 10 9.17157 10 10ZM17 10C17 10.8284 16.3284 11.5 15.5 11.5C14.6716 11.5 14 10.8284 14 10C14 9.17157 14.6716 8.5 15.5 8.5C16.3284 8.5 17 9.17157 17 10Z"},child:[]}]})(t)}const g1=function(){return(0,Ht.jsxs)("div",{className:"projects-page",children:[(0,Ht.jsx)(Tt,{to:"/project1",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(p1,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Project: NLP"})]})}),(0,Ht.jsx)(Tt,{to:"/project2",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(f1,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Sentiment Analysis"})]})}),(0,Ht.jsx)(Tt,{to:"/No-project",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(Xt,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Underconstruction"})]})}),(0,Ht.jsx)(Tt,{to:"/No-project",children:(0,Ht.jsxs)("div",{className:"projects-container",children:[(0,Ht.jsx)(Xt,{className:"project-icon"}),(0,Ht.jsx)("p",{className:"project-des",children:"Underconstruction"})]})})]})};const m1=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)(g1,{})})};const b1=function(){return(0,Ht.jsx)(Ht.Fragment,{children:(0,Ht.jsx)("div",{style:{"background-color":"rgb(28, 27, 27)",width:"100vw",height:"80vh",display:"flex"},children:(0,Ht.jsx)("h1",{style:{"text-align":"center",color:"white",width:"100vw"},children:"Underconstruction . . . . . . . . . . . . ."})})})};const y1=function(){return(0,Ht.jsx)("div",{className:"App",children:(0,Ht.jsxs)(Nt,{children:[(0,Ht.jsx)(Kt,{}),(0,Ht.jsxs)(vt,{children:[(0,Ht.jsx)(bt,{path:"/supercircle",exact:!0,element:(0,Ht.jsx)($t,{})}),(0,Ht.jsx)(bt,{path:"/",exact:!0,element:(0,Ht.jsx)($t,{})}),(0,Ht.jsx)(bt,{path:"/projects",exact:!0,element:(0,Ht.jsx)(m1,{})}),(0,Ht.jsx)(bt,{path:"/contact",exact:!0,element:(0,Ht.jsx)(Yt,{})}),(0,Ht.jsx)(bt,{path:"/project1",exact:!0,element:(0,Ht.jsx)(u1,{})}),(0,Ht.jsx)(bt,{path:"/project2",exact:!0,element:(0,Ht.jsx)(d1,{})}),(0,Ht.jsx)(bt,{path:"/no-project",exact:!0,element:(0,Ht.jsx)(b1,{})})]})]})})};l.createRoot(document.getElementById("root")).render((0,Ht.jsx)(o.StrictMode,{children:(0,Ht.jsx)(y1,{})}))})()})();
//# sourceMappingURL=main.2ea2cab4.js.map